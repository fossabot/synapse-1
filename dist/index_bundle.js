/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 162);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(43));
__export(__webpack_require__(44));
__export(__webpack_require__(29));
__export(__webpack_require__(90));
__export(__webpack_require__(91));
__export(__webpack_require__(92));
__export(__webpack_require__(93));
__export(__webpack_require__(45));
__export(__webpack_require__(94));
__export(__webpack_require__(46));
__export(__webpack_require__(95));
__export(__webpack_require__(96));
__export(__webpack_require__(98));
__export(__webpack_require__(99));
__export(__webpack_require__(100));

//# sourceMappingURL=index.js.map


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var util_3 = __webpack_require__(0);
var util_4 = __webpack_require__(0);
var util_5 = __webpack_require__(0);
var util_6 = __webpack_require__(0);
var storage_1 = __webpack_require__(18);
var util_7 = __webpack_require__(0);
/**
 * Returns a locally-unique ID (generated by just incrementing up from 0 each time its called).
 * @type {function(): number} Generated ID.
 */
exports.LUIDGenerator = (function () {
    var id = 1;
    return function () {
        return id++;
    };
})();
/**
 * Sha1 hash of the input string
 * @param {!string} str The string to hash
 * @return {!string} The resulting hash
 */
exports.sha1 = function (str) {
    var utf8Bytes = util_5.stringToByteArray(str);
    var sha1 = new util_4.Sha1();
    sha1.update(utf8Bytes);
    var sha1Bytes = sha1.digest();
    return util_3.base64.encodeByteArray(sha1Bytes);
};
/**
 * @param {...*} var_args
 * @return {string}
 * @private
 */
var buildLogMessage_ = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = '';
    for (var i = 0; i < var_args.length; i++) {
        if (Array.isArray(var_args[i]) ||
            (var_args[i] &&
                typeof var_args[i] === 'object' &&
                typeof var_args[i].length === 'number')) {
            message += buildLogMessage_.apply(null, var_args[i]);
        }
        else if (typeof var_args[i] === 'object') {
            message += util_6.stringify(var_args[i]);
        }
        else {
            message += var_args[i];
        }
        message += ' ';
    }
    return message;
};
/**
 * Use this for all debug messages in Firebase.
 * @type {?function(string)}
 */
exports.logger = null;
/**
 * Flag to check for log availability on first log message
 * @type {boolean}
 * @private
 */
var firstLog_ = true;
/**
 * The implementation of Firebase.enableLogging (defined here to break dependencies)
 * @param {boolean|?function(string)} logger_ A flag to turn on logging, or a custom logger
 * @param {boolean=} persistent Whether or not to persist logging settings across refreshes
 */
exports.enableLogging = function (logger_, persistent) {
    util_1.assert(!persistent || (logger_ === true || logger_ === false), "Can't turn on custom loggers persistently.");
    if (logger_ === true) {
        if (typeof console !== 'undefined') {
            if (typeof console.log === 'function') {
                exports.logger = console.log.bind(console);
            }
            else if (typeof console.log === 'object') {
                // IE does this.
                exports.logger = function (message) {
                    console.log(message);
                };
            }
        }
        if (persistent)
            storage_1.SessionStorage.set('logging_enabled', true);
    }
    else if (typeof logger_ === 'function') {
        exports.logger = logger_;
    }
    else {
        exports.logger = null;
        storage_1.SessionStorage.remove('logging_enabled');
    }
};
/**
 *
 * @param {...(string|Arguments)} var_args
 */
exports.log = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (firstLog_ === true) {
        firstLog_ = false;
        if (exports.logger === null && storage_1.SessionStorage.get('logging_enabled') === true)
            exports.enableLogging(true);
    }
    if (exports.logger) {
        var message = buildLogMessage_.apply(null, var_args);
        exports.logger(message);
    }
};
/**
 * @param {!string} prefix
 * @return {function(...[*])}
 */
exports.logWrapper = function (prefix) {
    return function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        exports.log.apply(void 0, [prefix].concat(var_args));
    };
};
/**
 * @param {...string} var_args
 */
exports.error = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE INTERNAL ERROR: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.error !== 'undefined') {
            console.error(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * @param {...string} var_args
 */
exports.fatal = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var message = buildLogMessage_.apply(void 0, var_args);
    throw new Error('FIREBASE FATAL ERROR: ' + message);
};
/**
 * @param {...*} var_args
 */
exports.warn = function () {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    if (typeof console !== 'undefined') {
        var message = 'FIREBASE WARNING: ' + buildLogMessage_.apply(void 0, var_args);
        if (typeof console.warn !== 'undefined') {
            console.warn(message);
        }
        else {
            console.log(message);
        }
    }
};
/**
 * Logs a warning if the containing page uses https. Called when a call to new Firebase
 * does not use https.
 */
exports.warnIfPageIsSecure = function () {
    // Be very careful accessing browser globals. Who knows what may or may not exist.
    if (typeof window !== 'undefined' &&
        window.location &&
        window.location.protocol &&
        window.location.protocol.indexOf('https:') !== -1) {
        exports.warn('Insecure Firebase access from a secure page. ' +
            'Please use https in calls to new Firebase().');
    }
};
/**
 * @param {!String} methodName
 */
exports.warnAboutUnsupportedMethod = function (methodName) {
    exports.warn(methodName +
        ' is unsupported and will likely change soon.  ' +
        'Please do not use.');
};
/**
 * Returns true if data is NaN, or +/- Infinity.
 * @param {*} data
 * @return {boolean}
 */
exports.isInvalidJSONNumber = function (data) {
    return (typeof data === 'number' &&
        (data != data || // NaN
            data == Number.POSITIVE_INFINITY ||
            data == Number.NEGATIVE_INFINITY));
};
/**
 * @param {function()} fn
 */
exports.executeWhenDOMReady = function (fn) {
    if (util_7.isNodeSdk() || document.readyState === 'complete') {
        fn();
    }
    else {
        // Modeled after jQuery. Try DOMContentLoaded and onreadystatechange (which
        // fire before onload), but fall back to onload.
        var called_1 = false;
        var wrappedFn_1 = function () {
            if (!document.body) {
                setTimeout(wrappedFn_1, Math.floor(10));
                return;
            }
            if (!called_1) {
                called_1 = true;
                fn();
            }
        };
        if (document.addEventListener) {
            document.addEventListener('DOMContentLoaded', wrappedFn_1, false);
            // fallback to onload.
            window.addEventListener('load', wrappedFn_1, false);
        }
        else if (document.attachEvent) {
            // IE.
            document.attachEvent('onreadystatechange', function () {
                if (document.readyState === 'complete')
                    wrappedFn_1();
            });
            // fallback to onload.
            window.attachEvent('onload', wrappedFn_1);
            // jQuery has an extra hack for IE that we could employ (based on
            // http://javascript.nwbox.com/IEContentLoaded/) But it looks really old.
            // I'm hoping we don't need it.
        }
    }
};
/**
 * Minimum key name. Invalid for actual data, used as a marker to sort before any valid names
 * @type {!string}
 */
exports.MIN_NAME = '[MIN_NAME]';
/**
 * Maximum key name. Invalid for actual data, used as a marker to sort above any valid names
 * @type {!string}
 */
exports.MAX_NAME = '[MAX_NAME]';
/**
 * Compares valid Firebase key names, plus min and max name
 * @param {!string} a
 * @param {!string} b
 * @return {!number}
 */
exports.nameCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a === exports.MIN_NAME || b === exports.MAX_NAME) {
        return -1;
    }
    else if (b === exports.MIN_NAME || a === exports.MAX_NAME) {
        return 1;
    }
    else {
        var aAsInt = exports.tryParseInt(a), bAsInt = exports.tryParseInt(b);
        if (aAsInt !== null) {
            if (bAsInt !== null) {
                return aAsInt - bAsInt == 0 ? a.length - b.length : aAsInt - bAsInt;
            }
            else {
                return -1;
            }
        }
        else if (bAsInt !== null) {
            return 1;
        }
        else {
            return a < b ? -1 : 1;
        }
    }
};
/**
 * @param {!string} a
 * @param {!string} b
 * @return {!number} comparison result.
 */
exports.stringCompare = function (a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
};
/**
 * @param {string} key
 * @param {Object} obj
 * @return {*}
 */
exports.requireKey = function (key, obj) {
    if (obj && key in obj) {
        return obj[key];
    }
    else {
        throw new Error('Missing required key (' + key + ') in object: ' + util_6.stringify(obj));
    }
};
/**
 * @param {*} obj
 * @return {string}
 */
exports.ObjectToUniqueKey = function (obj) {
    if (typeof obj !== 'object' || obj === null)
        return util_6.stringify(obj);
    var keys = [];
    for (var k in obj) {
        keys.push(k);
    }
    // Export as json, but with the keys sorted.
    keys.sort();
    var key = '{';
    for (var i = 0; i < keys.length; i++) {
        if (i !== 0)
            key += ',';
        key += util_6.stringify(keys[i]);
        key += ':';
        key += exports.ObjectToUniqueKey(obj[keys[i]]);
    }
    key += '}';
    return key;
};
/**
 * Splits a string into a number of smaller segments of maximum size
 * @param {!string} str The string
 * @param {!number} segsize The maximum number of chars in the string.
 * @return {Array.<string>} The string, split into appropriately-sized chunks
 */
exports.splitStringBySize = function (str, segsize) {
    var len = str.length;
    if (len <= segsize) {
        return [str];
    }
    var dataSegs = [];
    for (var c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
            dataSegs.push(str.substring(c, len));
        }
        else {
            dataSegs.push(str.substring(c, c + segsize));
        }
    }
    return dataSegs;
};
/**
 * Apply a function to each (key, value) pair in an object or
 * apply a function to each (index, value) pair in an array
 * @param {!(Object|Array)} obj The object or array to iterate over
 * @param {function(?, ?)} fn The function to apply
 */
exports.each = function (obj, fn) {
    if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; ++i) {
            fn(i, obj[i]);
        }
    }
    else {
        /**
         * in the conversion of code we removed the goog.object.forEach
         * function which did a value,key callback. We standardized on
         * a single impl that does a key, value callback. So we invert
         * to not have to touch the `each` code points
         */
        util_2.forEach(obj, function (key, val) { return fn(val, key); });
    }
};
/**
 * Like goog.bind, but doesn't bother to create a closure if opt_context is null/undefined.
 * @param {function(*)} callback Callback function.
 * @param {?Object=} context Optional context to bind to.
 * @return {function(*)}
 */
exports.bindCallback = function (callback, context) {
    return context ? callback.bind(context) : callback;
};
/**
 * Borrowed from http://hg.secondlife.com/llsd/src/tip/js/typedarray.js (MIT License)
 * I made one modification at the end and removed the NaN / Infinity
 * handling (since it seemed broken [caused an overflow] and we don't need it).  See MJL comments.
 * @param {!number} v A double
 * @return {string}
 */
exports.doubleToIEEE754String = function (v) {
    util_1.assert(!exports.isInvalidJSONNumber(v), 'Invalid JSON number'); // MJL
    var ebits = 11, fbits = 52;
    var bias = (1 << (ebits - 1)) - 1, s, e, f, ln, i, bits, str;
    // Compute sign, exponent, fraction
    // Skip NaN / Infinity handling --MJL.
    if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
    }
    else {
        s = v < 0;
        v = Math.abs(v);
        if (v >= Math.pow(2, 1 - bias)) {
            // Normalized
            ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
            e = ln + bias;
            f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        }
        else {
            // Denormalized
            e = 0;
            f = Math.round(v / Math.pow(2, 1 - bias - fbits));
        }
    }
    // Pack sign, exponent, fraction
    bits = [];
    for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
    }
    for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
    }
    bits.push(s ? 1 : 0);
    bits.reverse();
    str = bits.join('');
    // Return the data as a hex string. --MJL
    var hexByteString = '';
    for (i = 0; i < 64; i += 8) {
        var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1)
            hexByte = '0' + hexByte;
        hexByteString = hexByteString + hexByte;
    }
    return hexByteString.toLowerCase();
};
/**
 * Used to detect if we're in a Chrome content script (which executes in an
 * isolated environment where long-polling doesn't work).
 * @return {boolean}
 */
exports.isChromeExtensionContentScript = function () {
    return !!(typeof window === 'object' &&
        window['chrome'] &&
        window['chrome']['extension'] &&
        !/^chrome/.test(window.location.href));
};
/**
 * Used to detect if we're in a Windows 8 Store app.
 * @return {boolean}
 */
exports.isWindowsStoreApp = function () {
    // Check for the presence of a couple WinRT globals
    return typeof Windows === 'object' && typeof Windows.UI === 'object';
};
/**
 * Converts a server error code to a Javascript Error
 * @param {!string} code
 * @param {!Query} query
 * @return {Error}
 */
exports.errorForServerCode = function (code, query) {
    var reason = 'Unknown Error';
    if (code === 'too_big') {
        reason =
            'The data requested exceeds the maximum size ' +
                'that can be accessed with a single request.';
    }
    else if (code == 'permission_denied') {
        reason = "Client doesn't have permission to access the desired data.";
    }
    else if (code == 'unavailable') {
        reason = 'The service is unavailable';
    }
    var error = new Error(code + ' at ' + query.path.toString() + ': ' + reason);
    error.code = code.toUpperCase();
    return error;
};
/**
 * Used to test for integer-looking strings
 * @type {RegExp}
 * @private
 */
exports.INTEGER_REGEXP_ = new RegExp('^-?\\d{1,10}$');
/**
 * If the string contains a 32-bit integer, return it.  Else return null.
 * @param {!string} str
 * @return {?number}
 */
exports.tryParseInt = function (str) {
    if (exports.INTEGER_REGEXP_.test(str)) {
        var intVal = Number(str);
        if (intVal >= -2147483648 && intVal <= 2147483647) {
            return intVal;
        }
    }
    return null;
};
/**
 * Helper to run some code but catch any exceptions and re-throw them later.
 * Useful for preventing user callbacks from breaking internal code.
 *
 * Re-throwing the exception from a setTimeout is a little evil, but it's very
 * convenient (we don't have to try to figure out when is a safe point to
 * re-throw it), and the behavior seems reasonable:
 *
 * * If you aren't pausing on exceptions, you get an error in the console with
 *   the correct stack trace.
 * * If you're pausing on all exceptions, the debugger will pause on your
 *   exception and then again when we rethrow it.
 * * If you're only pausing on uncaught exceptions, the debugger will only pause
 *   on us re-throwing it.
 *
 * @param {!function()} fn The code to guard.
 */
exports.exceptionGuard = function (fn) {
    try {
        fn();
    }
    catch (e) {
        // Re-throw exception when it's safe.
        setTimeout(function () {
            // It used to be that "throw e" would result in a good console error with
            // relevant context, but as of Chrome 39, you just get the firebase.js
            // file/line number where we re-throw it, which is useless. So we log
            // e.stack explicitly.
            var stack = e.stack || '';
            exports.warn('Exception was thrown by user callback.', stack);
            throw e;
        }, Math.floor(0));
    }
};
/**
 * Helper function to safely call opt_callback with the specified arguments.  It:
 * 1. Turns into a no-op if opt_callback is null or undefined.
 * 2. Wraps the call inside exceptionGuard to prevent exceptions from breaking our state.
 *
 * @param {?Function=} callback Optional onComplete callback.
 * @param {...*} var_args Arbitrary args to be passed to opt_onComplete
 */
exports.callUserCallback = function (callback) {
    var var_args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        var_args[_i - 1] = arguments[_i];
    }
    if (typeof callback === 'function') {
        exports.exceptionGuard(function () {
            callback.apply(void 0, var_args);
        });
    }
};
/**
 * @return {boolean} true if we think we're currently being crawled.
 */
exports.beingCrawled = function () {
    var userAgent = (typeof window === 'object' &&
        window['navigator'] &&
        window['navigator']['userAgent']) ||
        '';
    // For now we whitelist the most popular crawlers.  We should refine this to be the set of crawlers we
    // believe to support JavaScript/AJAX rendering.
    // NOTE: Google Webmaster Tools doesn't really belong, but their "This is how a visitor to your website
    // would have seen the page" is flaky if we don't treat it as a crawler.
    return (userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0);
};
/**
 * Export a property of an object using a getter function.
 *
 * @param {!Object} object
 * @param {string} name
 * @param {!function(): *} fnGet
 */
exports.exportPropGetter = function (object, name, fnGet) {
    Object.defineProperty(object, name, { get: fnGet });
};
/**
 * Same as setTimeout() except on Node.JS it will /not/ prevent the process from exiting.
 *
 * It is removed with clearTimeout() as normal.
 *
 * @param {Function} fn Function to run.
 * @param {number} time Milliseconds to wait before running.
 * @return {number|Object} The setTimeout() return value.
 */
exports.setTimeoutNonBlocking = function (fn, time) {
    var timeout = setTimeout(fn, time);
    if (typeof timeout === 'object' && timeout['unref']) {
        timeout['unref']();
    }
    return timeout;
};

//# sourceMappingURL=util.js.map


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
var util_2 = __webpack_require__(0);
/**
 * An immutable object representing a parsed path.  It's immutable so that you
 * can pass them around to other functions without worrying about them changing
 * it.
 */
var Path = /** @class */ (function () {
    /**
     * @param {string|Array.<string>} pathOrString Path string to parse,
     *      or another path, or the raw tokens array
     * @param {number=} pieceNum
     */
    function Path(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
            this.pieces_ = pathOrString.split('/');
            // Remove empty pieces.
            var copyTo = 0;
            for (var i = 0; i < this.pieces_.length; i++) {
                if (this.pieces_[i].length > 0) {
                    this.pieces_[copyTo] = this.pieces_[i];
                    copyTo++;
                }
            }
            this.pieces_.length = copyTo;
            this.pieceNum_ = 0;
        }
        else {
            this.pieces_ = pathOrString;
            this.pieceNum_ = pieceNum;
        }
    }
    Object.defineProperty(Path, "Empty", {
        /**
         * Singleton to represent an empty path
         *
         * @const
         */
        get: function () {
            return new Path('');
        },
        enumerable: true,
        configurable: true
    });
    Path.prototype.getFront = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        return this.pieces_[this.pieceNum_];
    };
    /**
     * @return {number} The number of segments in this path
     */
    Path.prototype.getLength = function () {
        return this.pieces_.length - this.pieceNum_;
    };
    /**
     * @return {!Path}
     */
    Path.prototype.popFront = function () {
        var pieceNum = this.pieceNum_;
        if (pieceNum < this.pieces_.length) {
            pieceNum++;
        }
        return new Path(this.pieces_, pieceNum);
    };
    /**
     * @return {?string}
     */
    Path.prototype.getBack = function () {
        if (this.pieceNum_ < this.pieces_.length)
            return this.pieces_[this.pieces_.length - 1];
        return null;
    };
    Path.prototype.toString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + this.pieces_[i];
        }
        return pathString || '/';
    };
    Path.prototype.toUrlEncodedString = function () {
        var pathString = '';
        for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
            if (this.pieces_[i] !== '')
                pathString += '/' + encodeURIComponent(String(this.pieces_[i]));
        }
        return pathString || '/';
    };
    /**
     * Shallow copy of the parts of the path.
     *
     * @param {number=} begin
     * @return {!Array<string>}
     */
    Path.prototype.slice = function (begin) {
        if (begin === void 0) { begin = 0; }
        return this.pieces_.slice(this.pieceNum_ + begin);
    };
    /**
     * @return {?Path}
     */
    Path.prototype.parent = function () {
        if (this.pieceNum_ >= this.pieces_.length)
            return null;
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length - 1; i++)
            pieces.push(this.pieces_[i]);
        return new Path(pieces, 0);
    };
    /**
     * @param {string|!Path} childPathObj
     * @return {!Path}
     */
    Path.prototype.child = function (childPathObj) {
        var pieces = [];
        for (var i = this.pieceNum_; i < this.pieces_.length; i++)
            pieces.push(this.pieces_[i]);
        if (childPathObj instanceof Path) {
            for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
                pieces.push(childPathObj.pieces_[i]);
            }
        }
        else {
            var childPieces = childPathObj.split('/');
            for (var i = 0; i < childPieces.length; i++) {
                if (childPieces[i].length > 0)
                    pieces.push(childPieces[i]);
            }
        }
        return new Path(pieces, 0);
    };
    /**
     * @return {boolean} True if there are no segments in this path
     */
    Path.prototype.isEmpty = function () {
        return this.pieceNum_ >= this.pieces_.length;
    };
    /**
     * @param {!Path} outerPath
     * @param {!Path} innerPath
     * @return {!Path} The path from outerPath to innerPath
     */
    Path.relativePath = function (outerPath, innerPath) {
        var outer = outerPath.getFront(), inner = innerPath.getFront();
        if (outer === null) {
            return innerPath;
        }
        else if (outer === inner) {
            return Path.relativePath(outerPath.popFront(), innerPath.popFront());
        }
        else {
            throw new Error('INTERNAL ERROR: innerPath (' +
                innerPath +
                ') is not within ' +
                'outerPath (' +
                outerPath +
                ')');
        }
    };
    /**
     * @param {!Path} left
     * @param {!Path} right
     * @return {number} -1, 0, 1 if left is less, equal, or greater than the right.
     */
    Path.comparePaths = function (left, right) {
        var leftKeys = left.slice();
        var rightKeys = right.slice();
        for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
            var cmp = util_1.nameCompare(leftKeys[i], rightKeys[i]);
            if (cmp !== 0)
                return cmp;
        }
        if (leftKeys.length === rightKeys.length)
            return 0;
        return leftKeys.length < rightKeys.length ? -1 : 1;
    };
    /**
     *
     * @param {Path} other
     * @return {boolean} true if paths are the same.
     */
    Path.prototype.equals = function (other) {
        if (this.getLength() !== other.getLength()) {
            return false;
        }
        for (var i = this.pieceNum_, j = other.pieceNum_; i <= this.pieces_.length; i++, j++) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
        }
        return true;
    };
    /**
     *
     * @param {!Path} other
     * @return {boolean} True if this path is a parent (or the same as) other
     */
    Path.prototype.contains = function (other) {
        var i = this.pieceNum_;
        var j = other.pieceNum_;
        if (this.getLength() > other.getLength()) {
            return false;
        }
        while (i < this.pieces_.length) {
            if (this.pieces_[i] !== other.pieces_[j]) {
                return false;
            }
            ++i;
            ++j;
        }
        return true;
    };
    return Path;
}()); // end Path
exports.Path = Path;
/**
 * Dynamic (mutable) path used to count path lengths.
 *
 * This class is used to efficiently check paths for valid
 * length (in UTF8 bytes) and depth (used in path validation).
 *
 * Throws Error exception if path is ever invalid.
 *
 * The definition of a path always begins with '/'.
 */
var ValidationPath = /** @class */ (function () {
    /**
     * @param {!Path} path Initial Path.
     * @param {string} errorPrefix_ Prefix for any error messages.
     */
    function ValidationPath(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        /** @type {!Array<string>} */
        this.parts_ = path.slice();
        /** @type {number} Initialize to number of '/' chars needed in path. */
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (var i = 0; i < this.parts_.length; i++) {
            this.byteLength_ += util_2.stringLength(this.parts_[i]);
        }
        this.checkValid_();
    }
    Object.defineProperty(ValidationPath, "MAX_PATH_DEPTH", {
        /** @const {number} Maximum key depth. */
        get: function () {
            return 32;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ValidationPath, "MAX_PATH_LENGTH_BYTES", {
        /** @const {number} Maximum number of (UTF8) bytes in a Firebase path. */
        get: function () {
            return 768;
        },
        enumerable: true,
        configurable: true
    });
    /** @param {string} child */
    ValidationPath.prototype.push = function (child) {
        // Count the needed '/'
        if (this.parts_.length > 0) {
            this.byteLength_ += 1;
        }
        this.parts_.push(child);
        this.byteLength_ += util_2.stringLength(child);
        this.checkValid_();
    };
    ValidationPath.prototype.pop = function () {
        var last = this.parts_.pop();
        this.byteLength_ -= util_2.stringLength(last);
        // Un-count the previous '/'
        if (this.parts_.length > 0) {
            this.byteLength_ -= 1;
        }
    };
    ValidationPath.prototype.checkValid_ = function () {
        if (this.byteLength_ > ValidationPath.MAX_PATH_LENGTH_BYTES) {
            throw new Error(this.errorPrefix_ +
                'has a key path longer than ' +
                ValidationPath.MAX_PATH_LENGTH_BYTES +
                ' bytes (' +
                this.byteLength_ +
                ').');
        }
        if (this.parts_.length > ValidationPath.MAX_PATH_DEPTH) {
            throw new Error(this.errorPrefix_ +
                'path specified exceeds the maximum depth that can be written (' +
                ValidationPath.MAX_PATH_DEPTH +
                ') or object contains a cycle ' +
                this.toErrorString());
        }
    };
    /**
     * String for use in error messages - uses '.' notation for path.
     *
     * @return {string}
     */
    ValidationPath.prototype.toErrorString = function () {
        if (this.parts_.length == 0) {
            return '';
        }
        return "in property '" + this.parts_.join('.') + "'";
    };
    return ValidationPath;
}());
exports.ValidationPath = ValidationPath;

//# sourceMappingURL=Path.js.map


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = __webpack_require__(20);
var util_1 = __webpack_require__(1);
var Node_1 = __webpack_require__(5);
var LeafNode_1 = __webpack_require__(21);
var nodeFromJSON;
var MAX_NODE;
function setNodeFromJSON(val) {
    nodeFromJSON = val;
}
exports.setNodeFromJSON = setNodeFromJSON;
function setMaxNode(val) {
    MAX_NODE = val;
}
exports.setMaxNode = setMaxNode;
/**
 * @constructor
 * @extends {Index}
 * @private
 */
var PriorityIndex = /** @class */ (function (_super) {
    __extends(PriorityIndex, _super);
    function PriorityIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.compare = function (a, b) {
        var aPriority = a.node.getPriority();
        var bPriority = b.node.getPriority();
        var indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
            return util_1.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.isDefinedOn = function (node) {
        return !node.getPriority().isEmpty();
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    PriorityIndex.prototype.maxPost = function () {
        return new Node_1.NamedNode(util_1.MAX_NAME, new LeafNode_1.LeafNode('[PRIORITY-POST]', MAX_NODE));
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    PriorityIndex.prototype.makePost = function (indexValue, name) {
        var priorityNode = nodeFromJSON(indexValue);
        return new Node_1.NamedNode(name, new LeafNode_1.LeafNode('[PRIORITY-POST]', priorityNode));
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    PriorityIndex.prototype.toString = function () {
        return '.priority';
    };
    return PriorityIndex;
}(Index_1.Index));
exports.PriorityIndex = PriorityIndex;
exports.PRIORITY_INDEX = new PriorityIndex();

//# sourceMappingURL=PriorityIndex.js.map


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var SortedMap_1 = __webpack_require__(22);
var Node_1 = __webpack_require__(5);
var snap_1 = __webpack_require__(52);
var PriorityIndex_1 = __webpack_require__(3);
var KeyIndex_1 = __webpack_require__(14);
var IndexMap_1 = __webpack_require__(54);
var LeafNode_1 = __webpack_require__(21);
var comparators_1 = __webpack_require__(56);
// TODO: For memory savings, don't store priorityNode_ if it's empty.
var EMPTY_NODE;
/**
 * ChildrenNode is a class for storing internal nodes in a DataSnapshot
 * (i.e. nodes with children).  It implements Node and stores the
 * list of children in the children property, sorted by child name.
 *
 * @constructor
 * @implements {Node}
 */
var ChildrenNode = /** @class */ (function () {
    /**
     *
     * @param {!SortedMap.<string, !Node>} children_ List of children
     * of this node..
     * @param {?Node} priorityNode_ The priority of this node (as a snapshot node).
     * @param {!IndexMap} indexMap_
     */
    function ChildrenNode(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        /**
         * Note: The only reason we allow null priority is for EMPTY_NODE, since we can't use
         * EMPTY_NODE as the priority of EMPTY_NODE.  We might want to consider making EMPTY_NODE its own
         * class instead of an empty ChildrenNode.
         */
        if (this.priorityNode_) {
            snap_1.validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
            util_1.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), 'An empty node cannot have a priority');
        }
    }
    Object.defineProperty(ChildrenNode, "EMPTY_NODE", {
        get: function () {
            return (EMPTY_NODE ||
                (EMPTY_NODE = new ChildrenNode(new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), null, IndexMap_1.IndexMap.Default)));
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    ChildrenNode.prototype.isLeafNode = function () {
        return false;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPriority = function () {
        return this.priorityNode_ || EMPTY_NODE;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updatePriority = function (newPriorityNode) {
        if (this.children_.isEmpty()) {
            // Don't allow priorities on empty nodes
            return this;
        }
        else {
            return new ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.getPriority();
        }
        else {
            var child = this.children_.get(childName);
            return child === null ? EMPTY_NODE : child;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getChild = function (path) {
        var front = path.getFront();
        if (front === null)
            return this;
        return this.getImmediateChild(front).getChild(path.popFront());
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hasChild = function (childName) {
        return this.children_.get(childName) !== null;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        util_1.assert(newChildNode, 'We should always be passing snapshot nodes');
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else {
            var namedNode = new Node_1.NamedNode(childName, newChildNode);
            var newChildren = void 0, newIndexMap = void 0, newPriority = void 0;
            if (newChildNode.isEmpty()) {
                newChildren = this.children_.remove(childName);
                newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
            }
            else {
                newChildren = this.children_.insert(childName, newChildNode);
                newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
            }
            newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
            return new ChildrenNode(newChildren, newPriority, newIndexMap);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else {
            util_1.assert(path.getFront() !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            var newImmediateChild = this.getImmediateChild(front).updateChild(path.popFront(), newChildNode);
            return this.updateImmediateChild(front, newImmediateChild);
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.isEmpty = function () {
        return this.children_.isEmpty();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.numChildren = function () {
        return this.children_.count();
    };
    /** @inheritDoc */
    ChildrenNode.prototype.val = function (exportFormat) {
        if (this.isEmpty())
            return null;
        var obj = {};
        var numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
            obj[key] = childNode.val(exportFormat);
            numKeys++;
            if (allIntegerKeys && ChildrenNode.INTEGER_REGEXP_.test(key)) {
                maxKey = Math.max(maxKey, Number(key));
            }
            else {
                allIntegerKeys = false;
            }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
            // convert to array.
            var array = [];
            for (var key in obj)
                array[key] = obj[key];
            return array;
        }
        else {
            if (exportFormat && !this.getPriority().isEmpty()) {
                obj['.priority'] = this.getPriority().val();
            }
            return obj;
        }
    };
    /** @inheritDoc */
    ChildrenNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash_1 = '';
            if (!this.getPriority().isEmpty())
                toHash_1 +=
                    'priority:' +
                        snap_1.priorityHashText(this.getPriority().val()) +
                        ':';
            this.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                var childHash = childNode.hash();
                if (childHash !== '')
                    toHash_1 += ':' + key + ':' + childHash;
            });
            this.lazyHash_ = toHash_1 === '' ? '' : util_2.sha1(toHash_1);
        }
        return this.lazyHash_;
    };
    /** @inheritDoc */
    ChildrenNode.prototype.getPredecessorChildName = function (childName, childNode, index) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            var predecessor = idx.getPredecessorKey(new Node_1.NamedNode(childName, childNode));
            return predecessor ? predecessor.name : null;
        }
        else {
            return this.children_.getPredecessorKey(childName);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getFirstChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var minKey = idx.minKey();
            return minKey && minKey.name;
        }
        else {
            return this.children_.minKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getFirstChild = function (indexDefinition) {
        var minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
            return new Node_1.NamedNode(minKey, this.children_.get(minKey));
        }
        else {
            return null;
        }
    };
    /**
     * Given an index, return the key name of the largest value we have, according to that index
     * @param {!Index} indexDefinition
     * @return {?string}
     */
    ChildrenNode.prototype.getLastChildName = function (indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            var maxKey = idx.maxKey();
            return maxKey && maxKey.name;
        }
        else {
            return this.children_.maxKey();
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {?NamedNode}
     */
    ChildrenNode.prototype.getLastChild = function (indexDefinition) {
        var maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
            return new Node_1.NamedNode(maxKey, this.children_.get(maxKey));
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.forEachChild = function (index, action) {
        var idx = this.resolveIndex_(index);
        if (idx) {
            return idx.inorderTraversal(function (wrappedNode) {
                return action(wrappedNode.name, wrappedNode.node);
            });
        }
        else {
            return this.children_.inorderTraversal(action);
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {SortedMapIterator}
     */
    ChildrenNode.prototype.getIterator = function (indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    /**
     *
     * @param {!NamedNode} startPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getIteratorFrom = function (startPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getIteratorFrom(startPost, function (key) { return key; });
        }
        else {
            var iterator = this.children_.getIteratorFrom(startPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, startPost) < 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIterator = function (indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    /**
     * @param {!NamedNode} endPost
     * @param {!Index} indexDefinition
     * @return {!SortedMapIterator}
     */
    ChildrenNode.prototype.getReverseIteratorFrom = function (endPost, indexDefinition) {
        var idx = this.resolveIndex_(indexDefinition);
        if (idx) {
            return idx.getReverseIteratorFrom(endPost, function (key) {
                return key;
            });
        }
        else {
            var iterator = this.children_.getReverseIteratorFrom(endPost.name, Node_1.NamedNode.Wrap);
            var next = iterator.peek();
            while (next != null && indexDefinition.compare(next, endPost) > 0) {
                iterator.getNext();
                next = iterator.peek();
            }
            return iterator;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.compareTo = function (other) {
        if (this.isEmpty()) {
            if (other.isEmpty()) {
                return 0;
            }
            else {
                return -1;
            }
        }
        else if (other.isLeafNode() || other.isEmpty()) {
            return 1;
        }
        else if (other === exports.MAX_NODE) {
            return -1;
        }
        else {
            // Must be another node with children.
            return 0;
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.withIndex = function (indexDefinition) {
        if (indexDefinition === KeyIndex_1.KEY_INDEX ||
            this.indexMap_.hasIndex(indexDefinition)) {
            return this;
        }
        else {
            var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
            return new ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.isIndexed = function (index) {
        return index === KeyIndex_1.KEY_INDEX || this.indexMap_.hasIndex(index);
    };
    /**
     * @inheritDoc
     */
    ChildrenNode.prototype.equals = function (other) {
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            return false;
        }
        else {
            var otherChildrenNode = other;
            if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
                return false;
            }
            else if (this.children_.count() === otherChildrenNode.children_.count()) {
                var thisIter = this.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var otherIter = otherChildrenNode.getIterator(PriorityIndex_1.PRIORITY_INDEX);
                var thisCurrent = thisIter.getNext();
                var otherCurrent = otherIter.getNext();
                while (thisCurrent && otherCurrent) {
                    if (thisCurrent.name !== otherCurrent.name ||
                        !thisCurrent.node.equals(otherCurrent.node)) {
                        return false;
                    }
                    thisCurrent = thisIter.getNext();
                    otherCurrent = otherIter.getNext();
                }
                return thisCurrent === null && otherCurrent === null;
            }
            else {
                return false;
            }
        }
    };
    /**
     * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
     * instead.
     *
     * @private
     * @param {!Index} indexDefinition
     * @return {?SortedMap.<NamedNode, Node>}
     */
    ChildrenNode.prototype.resolveIndex_ = function (indexDefinition) {
        if (indexDefinition === KeyIndex_1.KEY_INDEX) {
            return null;
        }
        else {
            return this.indexMap_.get(indexDefinition.toString());
        }
    };
    /**
     * @private
     * @type {RegExp}
     */
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode;
}());
exports.ChildrenNode = ChildrenNode;
/**
 * @constructor
 * @extends {ChildrenNode}
 * @private
 */
var MaxNode = /** @class */ (function (_super) {
    __extends(MaxNode, _super);
    function MaxNode() {
        return _super.call(this, new SortedMap_1.SortedMap(comparators_1.NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap_1.IndexMap.Default) || this;
    }
    MaxNode.prototype.compareTo = function (other) {
        if (other === this) {
            return 0;
        }
        else {
            return 1;
        }
    };
    MaxNode.prototype.equals = function (other) {
        // Not that we every compare it, but MAX_NODE is only ever equal to itself
        return other === this;
    };
    MaxNode.prototype.getPriority = function () {
        return this;
    };
    MaxNode.prototype.getImmediateChild = function (childName) {
        return ChildrenNode.EMPTY_NODE;
    };
    MaxNode.prototype.isEmpty = function () {
        return false;
    };
    return MaxNode;
}(ChildrenNode));
exports.MaxNode = MaxNode;
/**
 * Marker that will sort higher than any other snapshot.
 * @type {!MAX_NODE}
 * @const
 */
exports.MAX_NODE = new MaxNode();
Object.defineProperties(Node_1.NamedNode, {
    MIN: {
        value: new Node_1.NamedNode(util_2.MIN_NAME, ChildrenNode.EMPTY_NODE)
    },
    MAX: {
        value: new Node_1.NamedNode(util_2.MAX_NAME, exports.MAX_NODE)
    }
});
/**
 * Reference Extensions
 */
KeyIndex_1.KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode_1.LeafNode.__childrenNodeConstructor = ChildrenNode;
snap_1.setMaxNode(exports.MAX_NODE);
PriorityIndex_1.setMaxNode(exports.MAX_NODE);

//# sourceMappingURL=ChildrenNode.js.map


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 *
 * @param {!string} name
 * @param {!Node} node
 * @constructor
 * @struct
 */
var NamedNode = /** @class */ (function () {
    function NamedNode(name, node) {
        this.name = name;
        this.node = node;
    }
    /**
     *
     * @param {!string} name
     * @param {!Node} node
     * @return {NamedNode}
     */
    NamedNode.Wrap = function (name, node) {
        return new NamedNode(name, node);
    };
    return NamedNode;
}());
exports.NamedNode = NamedNode;

//# sourceMappingURL=Node.js.map


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = isDef;
/* harmony export (immutable) */ __webpack_exports__["c"] = isJustDef;
/* harmony export (immutable) */ __webpack_exports__["b"] = isFunction;
/* harmony export (immutable) */ __webpack_exports__["i"] = isObject;
/* harmony export (immutable) */ __webpack_exports__["g"] = isNonNullObject;
/* harmony export (immutable) */ __webpack_exports__["f"] = isNonArrayObject;
/* harmony export (immutable) */ __webpack_exports__["j"] = isString;
/* harmony export (immutable) */ __webpack_exports__["h"] = isNumber;
/* harmony export (immutable) */ __webpack_exports__["d"] = isNativeBlob;
/* harmony export (immutable) */ __webpack_exports__["e"] = isNativeBlobDefined;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @return False if the object is undefined or null, true otherwise.
 */
function isDef(p) {
    return p != null;
}
function isJustDef(p) {
    return p !== void 0;
}
function isFunction(p) {
    return typeof p === 'function';
}
function isObject(p) {
    return typeof p === 'object';
}
function isNonNullObject(p) {
    return isObject(p) && p !== null;
}
function isNonArrayObject(p) {
    return isObject(p) && !Array.isArray(p);
}
function isString(p) {
    return typeof p === 'string' || p instanceof String;
}
function isNumber(p) {
    return typeof p === 'number' || p instanceof Number;
}
function isNativeBlob(p) {
    return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() {
    return typeof Blob !== 'undefined';
}

//# sourceMappingURL=type.js.map


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export FirebaseStorageError */
/* unused harmony export errors */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Code; });
/* unused harmony export prependCode */
/* harmony export (immutable) */ __webpack_exports__["s"] = unknown;
/* harmony export (immutable) */ __webpack_exports__["m"] = objectNotFound;
/* unused harmony export bucketNotFound */
/* unused harmony export projectNotFound */
/* harmony export (immutable) */ __webpack_exports__["n"] = quotaExceeded;
/* harmony export (immutable) */ __webpack_exports__["q"] = unauthenticated;
/* harmony export (immutable) */ __webpack_exports__["r"] = unauthorized;
/* harmony export (immutable) */ __webpack_exports__["o"] = retryLimitExceeded;
/* unused harmony export invalidChecksum */
/* harmony export (immutable) */ __webpack_exports__["c"] = canceled;
/* unused harmony export invalidEventName */
/* harmony export (immutable) */ __webpack_exports__["k"] = invalidUrl;
/* harmony export (immutable) */ __webpack_exports__["h"] = invalidDefaultBucket;
/* unused harmony export noDefaultBucket */
/* harmony export (immutable) */ __webpack_exports__["d"] = cannotSliceBlob;
/* harmony export (immutable) */ __webpack_exports__["p"] = serverFileWrongSize;
/* harmony export (immutable) */ __webpack_exports__["l"] = noDownloadURL;
/* harmony export (immutable) */ __webpack_exports__["f"] = invalidArgument;
/* harmony export (immutable) */ __webpack_exports__["g"] = invalidArgumentCount;
/* harmony export (immutable) */ __webpack_exports__["b"] = appDeleted;
/* harmony export (immutable) */ __webpack_exports__["j"] = invalidRootOperation;
/* harmony export (immutable) */ __webpack_exports__["i"] = invalidFormat;
/* harmony export (immutable) */ __webpack_exports__["e"] = internalError;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(26);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FirebaseStorageError = /** @class */ (function () {
    function FirebaseStorageError(code, message) {
        this.code_ = prependCode(code);
        this.message_ = 'Firebase Storage: ' + message;
        this.serverResponse_ = null;
        this.name_ = 'FirebaseError';
    }
    FirebaseStorageError.prototype.codeProp = function () {
        return this.code;
    };
    FirebaseStorageError.prototype.codeEquals = function (code) {
        return prependCode(code) === this.codeProp();
    };
    FirebaseStorageError.prototype.serverResponseProp = function () {
        return this.serverResponse_;
    };
    FirebaseStorageError.prototype.setServerResponseProp = function (serverResponse) {
        this.serverResponse_ = serverResponse;
    };
    Object.defineProperty(FirebaseStorageError.prototype, "name", {
        get: function () {
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "code", {
        get: function () {
            return this.code_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "message", {
        get: function () {
            return this.message_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseStorageError.prototype, "serverResponse", {
        get: function () {
            return this.serverResponse_;
        },
        enumerable: true,
        configurable: true
    });
    return FirebaseStorageError;
}());

var errors = {};
var Code = {
    // Shared between all platforms
    UNKNOWN: 'unknown',
    OBJECT_NOT_FOUND: 'object-not-found',
    BUCKET_NOT_FOUND: 'bucket-not-found',
    PROJECT_NOT_FOUND: 'project-not-found',
    QUOTA_EXCEEDED: 'quota-exceeded',
    UNAUTHENTICATED: 'unauthenticated',
    UNAUTHORIZED: 'unauthorized',
    RETRY_LIMIT_EXCEEDED: 'retry-limit-exceeded',
    INVALID_CHECKSUM: 'invalid-checksum',
    CANCELED: 'canceled',
    // JS specific
    INVALID_EVENT_NAME: 'invalid-event-name',
    INVALID_URL: 'invalid-url',
    INVALID_DEFAULT_BUCKET: 'invalid-default-bucket',
    NO_DEFAULT_BUCKET: 'no-default-bucket',
    CANNOT_SLICE_BLOB: 'cannot-slice-blob',
    SERVER_FILE_WRONG_SIZE: 'server-file-wrong-size',
    NO_DOWNLOAD_URL: 'no-download-url',
    INVALID_ARGUMENT: 'invalid-argument',
    INVALID_ARGUMENT_COUNT: 'invalid-argument-count',
    APP_DELETED: 'app-deleted',
    INVALID_ROOT_OPERATION: 'invalid-root-operation',
    INVALID_FORMAT: 'invalid-format',
    INTERNAL_ERROR: 'internal-error'
};
function prependCode(code) {
    return 'storage/' + code;
}
function unknown() {
    var message = 'An unknown error occurred, please check the error payload for ' +
        'server response.';
    return new FirebaseStorageError(Code.UNKNOWN, message);
}
function objectNotFound(path) {
    return new FirebaseStorageError(Code.OBJECT_NOT_FOUND, "Object '" + path + "' does not exist.");
}
function bucketNotFound(bucket) {
    return new FirebaseStorageError(Code.BUCKET_NOT_FOUND, "Bucket '" + bucket + "' does not exist.");
}
function projectNotFound(project) {
    return new FirebaseStorageError(Code.PROJECT_NOT_FOUND, "Project '" + project + "' does not exist.");
}
function quotaExceeded(bucket) {
    return new FirebaseStorageError(Code.QUOTA_EXCEEDED, "Quota for bucket '" +
        bucket +
        "' exceeded, please view quota on " +
        'https://firebase.google.com/pricing/.');
}
function unauthenticated() {
    var message = 'User is not authenticated, please authenticate using Firebase ' +
        'Authentication and try again.';
    return new FirebaseStorageError(Code.UNAUTHENTICATED, message);
}
function unauthorized(path) {
    return new FirebaseStorageError(Code.UNAUTHORIZED, "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
    return new FirebaseStorageError(Code.RETRY_LIMIT_EXCEEDED, 'Max retry time for operation exceeded, please try again.');
}
function invalidChecksum(path, checksum, calculated) {
    return new FirebaseStorageError(Code.INVALID_CHECKSUM, "Uploaded/downloaded object '" +
        path +
        "' has checksum '" +
        checksum +
        "' which does not match '" +
        calculated +
        "'. Please retry the upload/download.");
}
function canceled() {
    return new FirebaseStorageError(Code.CANCELED, 'User canceled the upload/download.');
}
function invalidEventName(name) {
    return new FirebaseStorageError(Code.INVALID_EVENT_NAME, "Invalid event name '" + name + "'.");
}
function invalidUrl(url) {
    return new FirebaseStorageError(Code.INVALID_URL, "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
    return new FirebaseStorageError(Code.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
    return new FirebaseStorageError(Code.NO_DEFAULT_BUCKET, 'No default bucket ' +
        "found. Did you set the '" +
        __WEBPACK_IMPORTED_MODULE_0__constants__["c" /* configOption */] +
        "' property when initializing the app?");
}
function cannotSliceBlob() {
    return new FirebaseStorageError(Code.CANNOT_SLICE_BLOB, 'Cannot slice blob for upload. Please retry the upload.');
}
function serverFileWrongSize() {
    return new FirebaseStorageError(Code.SERVER_FILE_WRONG_SIZE, 'Server recorded incorrect upload file size, please retry the upload.');
}
function noDownloadURL() {
    return new FirebaseStorageError(Code.NO_DOWNLOAD_URL, 'The given file does not have any download URLs.');
}
function invalidArgument(index, fnName, message) {
    return new FirebaseStorageError(Code.INVALID_ARGUMENT, 'Invalid argument in `' + fnName + '` at index ' + index + ': ' + message);
}
function invalidArgumentCount(argMin, argMax, fnName, real) {
    var countPart;
    var plural;
    if (argMin === argMax) {
        countPart = argMin;
        plural = argMin === 1 ? 'argument' : 'arguments';
    }
    else {
        countPart = 'between ' + argMin + ' and ' + argMax;
        plural = 'arguments';
    }
    return new FirebaseStorageError(Code.INVALID_ARGUMENT_COUNT, 'Invalid argument count in `' +
        fnName +
        '`: Expected ' +
        countPart +
        ' ' +
        plural +
        ', received ' +
        real +
        '.');
}
function appDeleted() {
    return new FirebaseStorageError(Code.APP_DELETED, 'The Firebase app was deleted.');
}
/**
 * @param name The name of the operation that was invalid.
 */
function invalidRootOperation(name) {
    return new FirebaseStorageError(Code.INVALID_ROOT_OPERATION, "The operation '" +
        name +
        "' cannot be performed on a root reference, create a non-root " +
        "reference using child, such as .child('file.png').");
}
/**
 * @param format The format that was not valid.
 * @param message A message describing the format violation.
 */
function invalidFormat(format, message) {
    return new FirebaseStorageError(Code.INVALID_FORMAT, "String does not match format '" + format + "': " + message);
}
/**
 * @param message A message describing the internal error.
 */
function internalError(message) {
    throw new FirebaseStorageError(Code.INTERNAL_ERROR, 'Internal error: ' + message);
}

//# sourceMappingURL=error.js.map


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "firebase", function() { return firebase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_firebaseApp__ = __webpack_require__(89);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var firebase = Object(__WEBPACK_IMPORTED_MODULE_0__src_firebaseApp__["a" /* createFirebaseNamespace */])();
/* harmony default export */ __webpack_exports__["default"] = (firebase);


//# sourceMappingURL=index.js.map


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = __webpack_require__(2);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var util_3 = __webpack_require__(0);
var util_4 = __webpack_require__(0);
/**
 * True for invalid Firebase keys
 * @type {RegExp}
 * @private
 */
exports.INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
/**
 * True for invalid Firebase paths.
 * Allows '/' in paths.
 * @type {RegExp}
 * @private
 */
exports.INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
/**
 * Maximum number of characters to allow in leaf value
 * @type {number}
 * @private
 */
exports.MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
/**
 * @param {*} key
 * @return {boolean}
 */
exports.isValidKey = function (key) {
    return (typeof key === 'string' && key.length !== 0 && !exports.INVALID_KEY_REGEX_.test(key));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
exports.isValidPathString = function (pathString) {
    return (typeof pathString === 'string' &&
        pathString.length !== 0 &&
        !exports.INVALID_PATH_REGEX_.test(pathString));
};
/**
 * @param {string} pathString
 * @return {boolean}
 */
exports.isValidRootPathString = function (pathString) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    return exports.isValidPathString(pathString);
};
/**
 * @param {*} priority
 * @return {boolean}
 */
exports.isValidPriority = function (priority) {
    return (priority === null ||
        typeof priority === 'string' ||
        (typeof priority === 'number' && !util_2.isInvalidJSONNumber(priority)) ||
        (priority && typeof priority === 'object' && util_1.contains(priority, '.sv')));
};
/**
 * Pre-validate a datum passed as an argument to Firebase function.
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
exports.validateFirebaseDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    exports.validateFirebaseData(util_3.errorPrefix(fnName, argumentNumber, optional), data, path);
};
/**
 * Validate a data object client-side before sending to server.
 *
 * @param {string} errorPrefix
 * @param {*} data
 * @param {!Path|!ValidationPath} path_
 */
exports.validateFirebaseData = function (errorPrefix, data, path_) {
    var path = path_ instanceof Path_1.Path ? new Path_1.ValidationPath(path_, errorPrefix) : path_;
    if (data === undefined) {
        throw new Error(errorPrefix + 'contains undefined ' + path.toErrorString());
    }
    if (typeof data === 'function') {
        throw new Error(errorPrefix +
            'contains a function ' +
            path.toErrorString() +
            ' with contents = ' +
            data.toString());
    }
    if (util_2.isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix + 'contains ' + data.toString() + ' ' + path.toErrorString());
    }
    // Check max leaf size, but try to avoid the utf8 conversion if we can.
    if (typeof data === 'string' &&
        data.length > exports.MAX_LEAF_SIZE_ / 3 &&
        util_4.stringLength(data) > exports.MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix +
            'contains a string greater than ' +
            exports.MAX_LEAF_SIZE_ +
            ' utf8 bytes ' +
            path.toErrorString() +
            " ('" +
            data.substring(0, 50) +
            "...')");
    }
    // TODO = Perf = Consider combining the recursive validation of keys into NodeFromJSON
    // to save extra walking of large objects.
    if (data && typeof data === 'object') {
        var hasDotValue_1 = false, hasActualChild_1 = false;
        util_1.forEach(data, function (key, value) {
            if (key === '.value') {
                hasDotValue_1 = true;
            }
            else if (key !== '.priority' && key !== '.sv') {
                hasActualChild_1 = true;
                if (!exports.isValidKey(key)) {
                    throw new Error(errorPrefix +
                        ' contains an invalid key (' +
                        key +
                        ') ' +
                        path.toErrorString() +
                        '.  Keys must be non-empty strings ' +
                        'and can\'t contain ".", "#", "$", "/", "[", or "]"');
                }
            }
            path.push(key);
            exports.validateFirebaseData(errorPrefix, value, path);
            path.pop();
        });
        if (hasDotValue_1 && hasActualChild_1) {
            throw new Error(errorPrefix +
                ' contains ".value" child ' +
                path.toErrorString() +
                ' in addition to actual children.');
        }
    }
};
/**
 * Pre-validate paths passed in the firebase function.
 *
 * @param {string} errorPrefix
 * @param {Array<!Path>} mergePaths
 */
exports.validateFirebaseMergePaths = function (errorPrefix, mergePaths) {
    var i, curPath;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        var keys = curPath.slice();
        for (var j = 0; j < keys.length; j++) {
            if (keys[j] === '.priority' && j === keys.length - 1) {
                // .priority is OK
            }
            else if (!exports.isValidKey(keys[j])) {
                throw new Error(errorPrefix +
                    'contains an invalid key (' +
                    keys[j] +
                    ') in path ' +
                    curPath.toString() +
                    '. Keys must be non-empty strings ' +
                    'and can\'t contain ".", "#", "$", "/", "[", or "]"');
            }
        }
    }
    // Check that update keys are not descendants of each other.
    // We rely on the property that sorting guarantees that ancestors come
    // right before descendants.
    mergePaths.sort(Path_1.Path.comparePaths);
    var prevPath = null;
    for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && prevPath.contains(curPath)) {
            throw new Error(errorPrefix +
                'contains a path ' +
                prevPath.toString() +
                ' that is ancestor of another path ' +
                curPath.toString());
        }
        prevPath = curPath;
    }
};
/**
 * pre-validate an object passed as an argument to firebase function (
 * must be an object - e.g. for firebase.update()).
 *
 * @param {string} fnName
 * @param {number} argumentNumber
 * @param {*} data
 * @param {!Path} path
 * @param {boolean} optional
 */
exports.validateFirebaseMergeDataArg = function (fnName, argumentNumber, data, path, optional) {
    if (optional && data === undefined)
        return;
    var errorPrefix = util_3.errorPrefix(fnName, argumentNumber, optional);
    if (!(data && typeof data === 'object') || Array.isArray(data)) {
        throw new Error(errorPrefix + ' must be an object containing the children to replace.');
    }
    var mergePaths = [];
    util_1.forEach(data, function (key, value) {
        var curPath = new Path_1.Path(key);
        exports.validateFirebaseData(errorPrefix, value, path.child(curPath));
        if (curPath.getBack() === '.priority') {
            if (!exports.isValidPriority(value)) {
                throw new Error(errorPrefix +
                    "contains an invalid value for '" +
                    curPath.toString() +
                    "', which must be a valid " +
                    'Firebase priority (a string, finite number, server value, or null).');
            }
        }
        mergePaths.push(curPath);
    });
    exports.validateFirebaseMergePaths(errorPrefix, mergePaths);
};
exports.validatePriority = function (fnName, argumentNumber, priority, optional) {
    if (optional && priority === undefined)
        return;
    if (util_2.isInvalidJSONNumber(priority))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'is ' +
            priority.toString() +
            ', but must be a valid Firebase priority (a string, finite number, ' +
            'server value, or null).');
    // Special case to allow importing data with a .sv.
    if (!exports.isValidPriority(priority))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid Firebase priority ' +
            '(a string, finite number, server value, or null).');
};
exports.validateEventType = function (fnName, argumentNumber, eventType, optional) {
    if (optional && eventType === undefined)
        return;
    switch (eventType) {
        case 'value':
        case 'child_added':
        case 'child_removed':
        case 'child_changed':
        case 'child_moved':
            break;
        default:
            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                'must be a valid event type = "value", "child_added", "child_removed", ' +
                '"child_changed", or "child_moved".');
    }
};
exports.validateKey = function (fnName, argumentNumber, key, optional) {
    if (optional && key === undefined)
        return;
    if (!exports.isValidKey(key))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'was an invalid key = "' +
            key +
            '".  Firebase keys must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "/", "[", or "]").');
};
exports.validatePathString = function (fnName, argumentNumber, pathString, optional) {
    if (optional && pathString === undefined)
        return;
    if (!exports.isValidPathString(pathString))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'was an invalid path = "' +
            pathString +
            '". Paths must be non-empty strings and ' +
            'can\'t contain ".", "#", "$", "[", or "]"');
};
exports.validateRootPathString = function (fnName, argumentNumber, pathString, optional) {
    if (pathString) {
        // Allow '/.info/' at the beginning.
        pathString = pathString.replace(/^\/*\.info(\/|$)/, '/');
    }
    exports.validatePathString(fnName, argumentNumber, pathString, optional);
};
exports.validateWritablePath = function (fnName, path) {
    if (path.getFront() === '.info') {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
    }
};
exports.validateUrl = function (fnName, argumentNumber, parsedUrl) {
    // TODO = Validate server better.
    var pathString = parsedUrl.path.toString();
    if (!(typeof parsedUrl.repoInfo.host === 'string') ||
        parsedUrl.repoInfo.host.length === 0 ||
        !exports.isValidKey(parsedUrl.repoInfo.namespace) ||
        (pathString.length !== 0 && !exports.isValidRootPathString(pathString))) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, false) +
            'must be a valid firebase URL and ' +
            'the path can\'t contain ".", "#", "$", "[", or "]".');
    }
};
exports.validateCredential = function (fnName, argumentNumber, cred, optional) {
    if (optional && cred === undefined)
        return;
    if (!(typeof cred === 'string'))
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid credential (a string).');
};
exports.validateBoolean = function (fnName, argumentNumber, bool, optional) {
    if (optional && bool === undefined)
        return;
    if (typeof bool !== 'boolean')
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) + 'must be a boolean.');
};
exports.validateString = function (fnName, argumentNumber, string, optional) {
    if (optional && string === undefined)
        return;
    if (!(typeof string === 'string')) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid string.');
    }
};
exports.validateObject = function (fnName, argumentNumber, obj, optional) {
    if (optional && obj === undefined)
        return;
    if (!(obj && typeof obj === 'object') || obj === null) {
        throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid object.');
    }
};
exports.validateObjectContainsKey = function (fnName, argumentNumber, obj, key, optional, opt_type) {
    var objectContainsKey = obj && typeof obj === 'object' && util_1.contains(obj, key);
    if (!objectContainsKey) {
        if (optional) {
            return;
        }
        else {
            throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                'must contain the key "' +
                key +
                '"');
        }
    }
    if (opt_type) {
        var val = util_1.safeGet(obj, key);
        if ((opt_type === 'number' && !(typeof val === 'number')) ||
            (opt_type === 'string' && !(typeof val === 'string')) ||
            (opt_type === 'boolean' && !(typeof val === 'boolean')) ||
            (opt_type === 'function' && !(typeof val === 'function')) ||
            (opt_type === 'object' && !(typeof val === 'object') && val)) {
            if (optional) {
                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                    'contains invalid value for key "' +
                    key +
                    '" (must be of type "' +
                    opt_type +
                    '")');
            }
            else {
                throw new Error(util_3.errorPrefix(fnName, argumentNumber, optional) +
                    'must contain the key "' +
                    key +
                    '" with type "' +
                    opt_type +
                    '"');
            }
        }
    }
};

//# sourceMappingURL=validation.js.map


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 *
 * @enum
 */
var OperationType;
(function (OperationType) {
    OperationType[OperationType["OVERWRITE"] = 0] = "OVERWRITE";
    OperationType[OperationType["MERGE"] = 1] = "MERGE";
    OperationType[OperationType["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
    OperationType[OperationType["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType = exports.OperationType || (exports.OperationType = {}));
/**
 * @param {boolean} fromUser
 * @param {boolean} fromServer
 * @param {?string} queryId
 * @param {boolean} tagged
 * @constructor
 */
var OperationSource = /** @class */ (function () {
    function OperationSource(fromUser, fromServer, queryId, tagged) {
        this.fromUser = fromUser;
        this.fromServer = fromServer;
        this.queryId = queryId;
        this.tagged = tagged;
        util_1.assert(!tagged || fromServer, 'Tagged queries must be from server.');
    }
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.User = new OperationSource(
    /*fromUser=*/ true, false, null, 
    /*tagged=*/ false);
    /**
     * @const
     * @type {!OperationSource}
     */
    OperationSource.Server = new OperationSource(false, 
    /*fromServer=*/ true, null, 
    /*tagged=*/ false);
    /**
     * @param {string} queryId
     * @return {!OperationSource}
     */
    OperationSource.forServerTaggedQuery = function (queryId) {
        return new OperationSource(false, 
        /*fromServer=*/ true, queryId, 
        /*tagged=*/ true);
    };
    return OperationSource;
}());
exports.OperationSource = OperationSource;

//# sourceMappingURL=Operation.js.map


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = make;
/* harmony export (immutable) */ __webpack_exports__["c"] = resolve;
/* harmony export (immutable) */ __webpack_exports__["b"] = reject;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Implements the promise abstraction interface for external
 * (public SDK) packaging, which just passes through to the firebase-app impl.
 */
/**
 * @template T
 * @param {function((function(T): void),
 *                  (function(!Error): void))} resolver
 */
function make(resolver) {
    return new Promise(resolver);
}
/**
 * @template T
 */
function resolve(value) {
    return Promise.resolve(value);
}
function reject(error) {
    return Promise.reject(error);
}

//# sourceMappingURL=promise_external.js.map


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @constructor
 * @struct
 * @param {!string} type The event type
 * @param {!Node} snapshotNode The data
 * @param {string=} childName The name for this child, if it's a child event
 * @param {Node=} oldSnap Used for intermediate processing of child changed events
 * @param {string=} prevName The name for the previous child, if applicable
 */
var Change = /** @class */ (function () {
    function Change(type, snapshotNode, childName, oldSnap, prevName) {
        this.type = type;
        this.snapshotNode = snapshotNode;
        this.childName = childName;
        this.oldSnap = oldSnap;
        this.prevName = prevName;
    }
    /**
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.valueChange = function (snapshot) {
        return new Change(Change.VALUE, snapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childAddedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_ADDED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childRemovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_REMOVED, snapshot, childKey);
    };
    /**
     * @param {string} childKey
     * @param {!Node} newSnapshot
     * @param {!Node} oldSnapshot
     * @return {!Change}
     */
    Change.childChangedChange = function (childKey, newSnapshot, oldSnapshot) {
        return new Change(Change.CHILD_CHANGED, newSnapshot, childKey, oldSnapshot);
    };
    /**
     * @param {string} childKey
     * @param {!Node} snapshot
     * @return {!Change}
     */
    Change.childMovedChange = function (childKey, snapshot) {
        return new Change(Change.CHILD_MOVED, snapshot, childKey);
    };
    //event types
    /** Event type for a child added */
    Change.CHILD_ADDED = 'child_added';
    /** Event type for a child removed */
    Change.CHILD_REMOVED = 'child_removed';
    /** Event type for a child changed */
    Change.CHILD_CHANGED = 'child_changed';
    /** Event type for a child moved */
    Change.CHILD_MOVED = 'child_moved';
    /** Event type for a value change */
    Change.VALUE = 'value';
    return Change;
}());
exports.Change = Change;

//# sourceMappingURL=Change.js.map


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export contains */
/* harmony export (immutable) */ __webpack_exports__["b"] = forEach;
/* harmony export (immutable) */ __webpack_exports__["a"] = clone;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Contains methods for working with objects.
 */
function contains(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
function forEach(obj, f) {
    for (var key in obj) {
        if (contains(obj, key)) {
            f(key, obj[key]);
        }
    }
}
function clone(obj) {
    if (obj == null) {
        return {};
    }
    var c = {};
    forEach(obj, function (key, val) {
        c[key] = val;
    });
    return c;
}

//# sourceMappingURL=object.js.map


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = __webpack_require__(20);
var Node_1 = __webpack_require__(5);
var util_1 = __webpack_require__(1);
var util_2 = __webpack_require__(0);
var __EMPTY_NODE;
var KeyIndex = /** @class */ (function (_super) {
    __extends(KeyIndex, _super);
    function KeyIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex, "__EMPTY_NODE", {
        get: function () {
            return __EMPTY_NODE;
        },
        set: function (val) {
            __EMPTY_NODE = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.compare = function (a, b) {
        return util_1.nameCompare(a.name, b.name);
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.isDefinedOn = function (node) {
        // We could probably return true here (since every node has a key), but it's never called
        // so just leaving unimplemented for now.
        throw util_2.assertionError('KeyIndex.isDefinedOn not expected to be called.');
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return false; // The key for a node never changes.
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    KeyIndex.prototype.maxPost = function () {
        // TODO: This should really be created once and cached in a static property, but
        // NamedNode isn't defined yet, so I can't use it in a static.  Bleh.
        return new Node_1.NamedNode(util_1.MAX_NAME, __EMPTY_NODE);
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    KeyIndex.prototype.makePost = function (indexValue, name) {
        util_2.assert(typeof indexValue === 'string', 'KeyIndex indexValue must always be a string.');
        // We just use empty node, but it'll never be compared, since our comparator only looks at name.
        return new Node_1.NamedNode(indexValue, __EMPTY_NODE);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    KeyIndex.prototype.toString = function () {
        return '.key';
    };
    return KeyIndex;
}(Index_1.Index));
exports.KeyIndex = KeyIndex;
exports.KEY_INDEX = new KeyIndex();

//# sourceMappingURL=KeyIndex.js.map


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = __webpack_require__(4);
var LeafNode_1 = __webpack_require__(21);
var Node_1 = __webpack_require__(5);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var childSet_1 = __webpack_require__(55);
var comparators_1 = __webpack_require__(56);
var IndexMap_1 = __webpack_require__(54);
var PriorityIndex_1 = __webpack_require__(3);
var USE_HINZE = true;
/**
 * Constructs a snapshot node representing the passed JSON and returns it.
 * @param {*} json JSON to create a node for.
 * @param {?string|?number=} priority Optional priority to use.  This will be ignored if the
 * passed JSON contains a .priority property.
 * @return {!Node}
 */
function nodeFromJSON(json, priority) {
    if (priority === void 0) { priority = null; }
    if (json === null) {
        return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
    }
    if (typeof json === 'object' && '.priority' in json) {
        priority = json['.priority'];
    }
    util_2.assert(priority === null ||
        typeof priority === 'string' ||
        typeof priority === 'number' ||
        (typeof priority === 'object' && '.sv' in priority), 'Invalid priority type found: ' + typeof priority);
    if (typeof json === 'object' && '.value' in json && json['.value'] !== null) {
        json = json['.value'];
    }
    // Valid leaf nodes include non-objects or server-value wrapper objects
    if (typeof json !== 'object' || '.sv' in json) {
        var jsonLeaf = json;
        return new LeafNode_1.LeafNode(jsonLeaf, nodeFromJSON(priority));
    }
    if (!(json instanceof Array) && USE_HINZE) {
        var children_1 = [];
        var childrenHavePriority_1 = false;
        var hinzeJsonObj_1 = json;
        util_1.forEach(hinzeJsonObj_1, function (key, child) {
            if (typeof key !== 'string' || key.substring(0, 1) !== '.') {
                // Ignore metadata nodes
                var childNode = nodeFromJSON(hinzeJsonObj_1[key]);
                if (!childNode.isEmpty()) {
                    childrenHavePriority_1 =
                        childrenHavePriority_1 || !childNode.getPriority().isEmpty();
                    children_1.push(new Node_1.NamedNode(key, childNode));
                }
            }
        });
        if (children_1.length == 0) {
            return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        var childSet = childSet_1.buildChildSet(children_1, comparators_1.NAME_ONLY_COMPARATOR, function (namedNode) { return namedNode.name; }, comparators_1.NAME_COMPARATOR);
        if (childrenHavePriority_1) {
            var sortedChildSet = childSet_1.buildChildSet(children_1, PriorityIndex_1.PRIORITY_INDEX.getCompare());
            return new ChildrenNode_1.ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap_1.IndexMap({ '.priority': sortedChildSet }, { '.priority': PriorityIndex_1.PRIORITY_INDEX }));
        }
        else {
            return new ChildrenNode_1.ChildrenNode(childSet, nodeFromJSON(priority), IndexMap_1.IndexMap.Default);
        }
    }
    else {
        var node_1 = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        var jsonObj_1 = json;
        util_1.forEach(jsonObj_1, function (key, childData) {
            if (util_1.contains(jsonObj_1, key)) {
                if (key.substring(0, 1) !== '.') {
                    // ignore metadata nodes.
                    var childNode = nodeFromJSON(childData);
                    if (childNode.isLeafNode() || !childNode.isEmpty())
                        node_1 = node_1.updateImmediateChild(key, childNode);
                }
            }
        });
        return node_1.updatePriority(nodeFromJSON(priority));
    }
}
exports.nodeFromJSON = nodeFromJSON;
PriorityIndex_1.setNodeFromJSON(nodeFromJSON);

//# sourceMappingURL=nodeFromJSON.js.map


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StringFormat; });
/* harmony export (immutable) */ __webpack_exports__["c"] = formatValidator;
/* unused harmony export StringData */
/* harmony export (immutable) */ __webpack_exports__["b"] = dataFromString;
/* unused harmony export utf8Bytes_ */
/* unused harmony export percentEncodedBytes_ */
/* unused harmony export base64Bytes_ */
/* unused harmony export dataURLBytes_ */
/* unused harmony export dataURLContentType_ */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__error__ = __webpack_require__(7);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var StringFormat = {
    RAW: 'raw',
    BASE64: 'base64',
    BASE64URL: 'base64url',
    DATA_URL: 'data_url'
};
function formatValidator(stringFormat) {
    switch (stringFormat) {
        case StringFormat.RAW:
        case StringFormat.BASE64:
        case StringFormat.BASE64URL:
        case StringFormat.DATA_URL:
            return;
        default:
            throw 'Expected one of the event types: [' +
                StringFormat.RAW +
                ', ' +
                StringFormat.BASE64 +
                ', ' +
                StringFormat.BASE64URL +
                ', ' +
                StringFormat.DATA_URL +
                '].';
    }
}
/**
 * @struct
 */
var StringData = /** @class */ (function () {
    function StringData(data, opt_contentType) {
        this.data = data;
        this.contentType = opt_contentType || null;
    }
    return StringData;
}());

function dataFromString(format, string) {
    switch (format) {
        case StringFormat.RAW:
            return new StringData(utf8Bytes_(string));
        case StringFormat.BASE64:
        case StringFormat.BASE64URL:
            return new StringData(base64Bytes_(format, string));
        case StringFormat.DATA_URL:
            return new StringData(dataURLBytes_(string), dataURLContentType_(string));
    }
    // assert(false);
    throw __WEBPACK_IMPORTED_MODULE_0__error__["s" /* unknown */]();
}
function utf8Bytes_(string) {
    var b = [];
    for (var i = 0; i < string.length; i++) {
        var c = string.charCodeAt(i);
        if (c <= 127) {
            b.push(c);
        }
        else {
            if (c <= 2047) {
                b.push(192 | (c >> 6), 128 | (c & 63));
            }
            else {
                if ((c & 64512) == 55296) {
                    // The start of a surrogate pair.
                    var valid = i < string.length - 1 &&
                        (string.charCodeAt(i + 1) & 64512) == 56320;
                    if (!valid) {
                        // The second surrogate wasn't there.
                        b.push(239, 191, 189);
                    }
                    else {
                        var hi = c;
                        var lo = string.charCodeAt(++i);
                        c = 65536 | ((hi & 1023) << 10) | (lo & 1023);
                        b.push(240 | (c >> 18), 128 | ((c >> 12) & 63), 128 | ((c >> 6) & 63), 128 | (c & 63));
                    }
                }
                else {
                    if ((c & 64512) == 56320) {
                        // Invalid low surrogate.
                        b.push(239, 191, 189);
                    }
                    else {
                        b.push(224 | (c >> 12), 128 | ((c >> 6) & 63), 128 | (c & 63));
                    }
                }
            }
        }
    }
    return new Uint8Array(b);
}
function percentEncodedBytes_(string) {
    var decoded;
    try {
        decoded = decodeURIComponent(string);
    }
    catch (e) {
        throw __WEBPACK_IMPORTED_MODULE_0__error__["i" /* invalidFormat */](StringFormat.DATA_URL, 'Malformed data URL.');
    }
    return utf8Bytes_(decoded);
}
function base64Bytes_(format, string) {
    switch (format) {
        case StringFormat.BASE64: {
            var hasMinus = string.indexOf('-') !== -1;
            var hasUnder = string.indexOf('_') !== -1;
            if (hasMinus || hasUnder) {
                var invalidChar = hasMinus ? '-' : '_';
                throw __WEBPACK_IMPORTED_MODULE_0__error__["i" /* invalidFormat */](format, "Invalid character '" +
                    invalidChar +
                    "' found: is it base64url encoded?");
            }
            break;
        }
        case StringFormat.BASE64URL: {
            var hasPlus = string.indexOf('+') !== -1;
            var hasSlash = string.indexOf('/') !== -1;
            if (hasPlus || hasSlash) {
                var invalidChar = hasPlus ? '+' : '/';
                throw __WEBPACK_IMPORTED_MODULE_0__error__["i" /* invalidFormat */](format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
            }
            string = string.replace(/-/g, '+').replace(/_/g, '/');
            break;
        }
    }
    var bytes;
    try {
        bytes = atob(string);
    }
    catch (e) {
        throw __WEBPACK_IMPORTED_MODULE_0__error__["i" /* invalidFormat */](format, 'Invalid character found');
    }
    var array = new Uint8Array(bytes.length);
    for (var i = 0; i < bytes.length; i++) {
        array[i] = bytes.charCodeAt(i);
    }
    return array;
}
/**
 * @struct
 */
var DataURLParts = /** @class */ (function () {
    function DataURLParts(dataURL) {
        this.base64 = false;
        this.contentType = null;
        var matches = dataURL.match(/^data:([^,]+)?,/);
        if (matches === null) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["i" /* invalidFormat */](StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
        }
        var middle = matches[1] || null;
        if (middle != null) {
            this.base64 = endsWith(middle, ';base64');
            this.contentType = this.base64
                ? middle.substring(0, middle.length - ';base64'.length)
                : middle;
        }
        this.rest = dataURL.substring(dataURL.indexOf(',') + 1);
    }
    return DataURLParts;
}());
function dataURLBytes_(string) {
    var parts = new DataURLParts(string);
    if (parts.base64) {
        return base64Bytes_(StringFormat.BASE64, parts.rest);
    }
    else {
        return percentEncodedBytes_(parts.rest);
    }
}
function dataURLContentType_(string) {
    var parts = new DataURLParts(string);
    return parts.contentType;
}
function endsWith(s, end) {
    var longEnough = s.length >= end.length;
    if (!longEnough) {
        return false;
    }
    return s.substring(s.length - end.length) === end;
}

//# sourceMappingURL=string.js.map


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TaskEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InternalTaskState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return TaskState; });
/* harmony export (immutable) */ __webpack_exports__["d"] = taskStateFromInternalTaskState;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var TaskEvent = {
    /** Triggered whenever the task changes or progress is updated. */
    STATE_CHANGED: 'state_changed'
};
var InternalTaskState = {
    RUNNING: 'running',
    PAUSING: 'pausing',
    PAUSED: 'paused',
    SUCCESS: 'success',
    CANCELING: 'canceling',
    CANCELED: 'canceled',
    ERROR: 'error'
};
var TaskState = {
    /** The task is currently transferring data. */
    RUNNING: 'running',
    /** The task was paused by the user. */
    PAUSED: 'paused',
    /** The task completed successfully. */
    SUCCESS: 'success',
    /** The task was canceled. */
    CANCELED: 'canceled',
    /** The task failed with an error. */
    ERROR: 'error'
};
function taskStateFromInternalTaskState(state) {
    switch (state) {
        case InternalTaskState.RUNNING:
        case InternalTaskState.PAUSING:
        case InternalTaskState.CANCELING:
            return TaskState.RUNNING;
        case InternalTaskState.PAUSED:
            return TaskState.PAUSED;
        case InternalTaskState.SUCCESS:
            return TaskState.SUCCESS;
        case InternalTaskState.CANCELED:
            return TaskState.CANCELED;
        case InternalTaskState.ERROR:
            return TaskState.ERROR;
        default:
            // TODO(andysoto): assert(false);
            return TaskState.ERROR;
    }
}

//# sourceMappingURL=taskenums.js.map


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DOMStorageWrapper_1 = __webpack_require__(103);
var MemoryStorage_1 = __webpack_require__(104);
/**
 * Helper to create a DOMStorageWrapper or else fall back to MemoryStorage.
 * TODO: Once MemoryStorage and DOMStorageWrapper have a shared interface this method annotation should change
 * to reflect this type
 *
 * @param {string} domStorageName Name of the underlying storage object
 *   (e.g. 'localStorage' or 'sessionStorage').
 * @return {?} Turning off type information until a common interface is defined.
 */
var createStoragefor = function (domStorageName) {
    try {
        // NOTE: just accessing "localStorage" or "window['localStorage']" may throw a security exception,
        // so it must be inside the try/catch.
        if (typeof window !== 'undefined' &&
            typeof window[domStorageName] !== 'undefined') {
            // Need to test cache. Just because it's here doesn't mean it works
            var domStorage = window[domStorageName];
            domStorage.setItem('firebase:sentinel', 'cache');
            domStorage.removeItem('firebase:sentinel');
            return new DOMStorageWrapper_1.DOMStorageWrapper(domStorage);
        }
    }
    catch (e) { }
    // Failed to create wrapper.  Just return in-memory storage.
    // TODO: log?
    return new MemoryStorage_1.MemoryStorage();
};
/** A storage object that lasts across sessions */
exports.PersistentStorage = createStoragefor('localStorage');
/** A storage object that only lasts one session */
exports.SessionStorage = createStoragefor('sessionStorage');

//# sourceMappingURL=storage.js.map


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PROTOCOL_VERSION = '5';
exports.VERSION_PARAM = 'v';
exports.TRANSPORT_SESSION_PARAM = 's';
exports.REFERER_PARAM = 'r';
exports.FORGE_REF = 'f';
exports.FORGE_DOMAIN = 'firebaseio.com';
exports.LAST_SESSION_PARAM = 'ls';
exports.WEBSOCKET = 'websocket';
exports.LONG_POLLING = 'long_polling';

//# sourceMappingURL=Constants.js.map


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Node_1 = __webpack_require__(5);
var util_1 = __webpack_require__(1);
/**
 *
 * @constructor
 */
var Index = /** @class */ (function () {
    function Index() {
    }
    /**
     * @return {function(!NamedNode, !NamedNode):number} A standalone comparison function for
     * this index
     */
    Index.prototype.getCompare = function () {
        return this.compare.bind(this);
    };
    /**
     * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
     * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
     *
     * @param {!Node} oldNode
     * @param {!Node} newNode
     * @return {boolean} True if the portion of the snapshot being indexed changed between oldNode and newNode
     */
    Index.prototype.indexedValueChanged = function (oldNode, newNode) {
        var oldWrapped = new Node_1.NamedNode(util_1.MIN_NAME, oldNode);
        var newWrapped = new Node_1.NamedNode(util_1.MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
    };
    /**
     * @return {!NamedNode} a node wrapper that will sort equal to or less than
     * any other node wrapper, using this index
     */
    Index.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    return Index;
}());
exports.Index = Index;

//# sourceMappingURL=Index.js.map


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var snap_1 = __webpack_require__(52);
var __childrenNodeConstructor;
/**
 * LeafNode is a class for storing leaf nodes in a DataSnapshot.  It
 * implements Node and stores the value of the node (a string,
 * number, or boolean) accessible via getValue().
 */
var LeafNode = /** @class */ (function () {
    /**
     * @implements {Node}
     * @param {!(string|number|boolean|Object)} value_ The value to store in this leaf node.
     *                                         The object type is possible in the event of a deferred value
     * @param {!Node=} priorityNode_ The priority of this node.
     */
    function LeafNode(value_, priorityNode_) {
        if (priorityNode_ === void 0) { priorityNode_ = LeafNode.__childrenNodeConstructor.EMPTY_NODE; }
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        util_1.assert(this.value_ !== undefined && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        snap_1.validatePriorityNode(this.priorityNode_);
    }
    Object.defineProperty(LeafNode, "__childrenNodeConstructor", {
        get: function () {
            return __childrenNodeConstructor;
        },
        set: function (val) {
            __childrenNodeConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /** @inheritDoc */
    LeafNode.prototype.isLeafNode = function () {
        return true;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPriority = function () {
        return this.priorityNode_;
    };
    /** @inheritDoc */
    LeafNode.prototype.updatePriority = function (newPriorityNode) {
        return new LeafNode(this.value_, newPriorityNode);
    };
    /** @inheritDoc */
    LeafNode.prototype.getImmediateChild = function (childName) {
        // Hack to treat priority as a regular child
        if (childName === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.getChild = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else if (path.getFront() === '.priority') {
            return this.priorityNode_;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.hasChild = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.getPredecessorChildName = function (childName, childNode) {
        return null;
    };
    /** @inheritDoc */
    LeafNode.prototype.updateImmediateChild = function (childName, newChildNode) {
        if (childName === '.priority') {
            return this.updatePriority(newChildNode);
        }
        else if (newChildNode.isEmpty() && childName !== '.priority') {
            return this;
        }
        else {
            return LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.updateChild = function (path, newChildNode) {
        var front = path.getFront();
        if (front === null) {
            return newChildNode;
        }
        else if (newChildNode.isEmpty() && front !== '.priority') {
            return this;
        }
        else {
            util_1.assert(front !== '.priority' || path.getLength() === 1, '.priority must be the last token in a path');
            return this.updateImmediateChild(front, LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(path.popFront(), newChildNode));
        }
    };
    /** @inheritDoc */
    LeafNode.prototype.isEmpty = function () {
        return false;
    };
    /** @inheritDoc */
    LeafNode.prototype.numChildren = function () {
        return 0;
    };
    /** @inheritDoc */
    LeafNode.prototype.forEachChild = function (index, action) {
        return false;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.val = function (exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty())
            return {
                '.value': this.getValue(),
                '.priority': this.getPriority().val()
            };
        else
            return this.getValue();
    };
    /** @inheritDoc */
    LeafNode.prototype.hash = function () {
        if (this.lazyHash_ === null) {
            var toHash = '';
            if (!this.priorityNode_.isEmpty())
                toHash +=
                    'priority:' +
                        snap_1.priorityHashText(this.priorityNode_.val()) +
                        ':';
            var type = typeof this.value_;
            toHash += type + ':';
            if (type === 'number') {
                toHash += util_2.doubleToIEEE754String(this.value_);
            }
            else {
                toHash += this.value_;
            }
            this.lazyHash_ = util_2.sha1(toHash);
        }
        return this.lazyHash_;
    };
    /**
     * Returns the value of the leaf node.
     * @return {Object|string|number|boolean} The value of the node.
     */
    LeafNode.prototype.getValue = function () {
        return this.value_;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.compareTo = function (other) {
        if (other === LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
            return 1;
        }
        else if (other instanceof LeafNode.__childrenNodeConstructor) {
            return -1;
        }
        else {
            util_1.assert(other.isLeafNode(), 'Unknown node type');
            return this.compareToLeafNode_(other);
        }
    };
    /**
     * Comparison specifically for two leaf nodes
     * @param {!LeafNode} otherLeaf
     * @return {!number}
     * @private
     */
    LeafNode.prototype.compareToLeafNode_ = function (otherLeaf) {
        var otherLeafType = typeof otherLeaf.value_;
        var thisLeafType = typeof this.value_;
        var otherIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        var thisIndex = LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        util_1.assert(otherIndex >= 0, 'Unknown leaf type: ' + otherLeafType);
        util_1.assert(thisIndex >= 0, 'Unknown leaf type: ' + thisLeafType);
        if (otherIndex === thisIndex) {
            // Same type, compare values
            if (thisLeafType === 'object') {
                // Deferred value nodes are all equal, but we should also never get to this point...
                return 0;
            }
            else {
                // Note that this works because true > false, all others are number or string comparisons
                if (this.value_ < otherLeaf.value_) {
                    return -1;
                }
                else if (this.value_ === otherLeaf.value_) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
        }
        else {
            return thisIndex - otherIndex;
        }
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.withIndex = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.isIndexed = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LeafNode.prototype.equals = function (other) {
        /**
         * @inheritDoc
         */
        if (other === this) {
            return true;
        }
        else if (other.isLeafNode()) {
            var otherLeaf = other;
            return (this.value_ === otherLeaf.value_ &&
                this.priorityNode_.equals(otherLeaf.priorityNode_));
        }
        else {
            return false;
        }
    };
    /**
     * The sort order for comparing leaf nodes of different types. If two leaf nodes have
     * the same type, the comparison falls back to their value
     * @type {Array.<!string>}
     * @const
     */
    LeafNode.VALUE_TYPE_ORDER = ['object', 'boolean', 'number', 'string'];
    return LeafNode;
}());
exports.LeafNode = LeafNode;

//# sourceMappingURL=LeafNode.js.map


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An iterator over an LLRBNode.
 */
var SortedMapIterator = /** @class */ (function () {
    /**
     * @template K, V, T
     * @param {LLRBNode|LLRBEmptyNode} node Node to iterate.
     * @param {?K} startKey
     * @param {function(K, K): number} comparator
     * @param {boolean} isReverse_ Whether or not to iterate in reverse
     * @param {(function(K, V):T)=} resultGenerator_
     */
    function SortedMapIterator(node, startKey, comparator, isReverse_, resultGenerator_) {
        if (resultGenerator_ === void 0) { resultGenerator_ = null; }
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        /** @private
         * @type {Array.<!LLRBNode>}
         */
        this.nodeStack_ = [];
        var cmp = 1;
        while (!node.isEmpty()) {
            node = node;
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse_)
                cmp *= -1;
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse_) {
                    node = node.left;
                }
                else {
                    node = node.right;
                }
            }
            else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack, but stop iterating;
                this.nodeStack_.push(node);
                break;
            }
            else {
                // This node is greater than our start key, add it to the stack and move to the next one
                this.nodeStack_.push(node);
                if (this.isReverse_) {
                    node = node.right;
                }
                else {
                    node = node.left;
                }
            }
        }
    }
    SortedMapIterator.prototype.getNext = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_.pop();
        var result;
        if (this.resultGenerator_)
            result = this.resultGenerator_(node.key, node.value);
        else
            result = { key: node.key, value: node.value };
        if (this.isReverse_) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.right;
            }
        }
        else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack_.push(node);
                node = node.left;
            }
        }
        return result;
    };
    SortedMapIterator.prototype.hasNext = function () {
        return this.nodeStack_.length > 0;
    };
    SortedMapIterator.prototype.peek = function () {
        if (this.nodeStack_.length === 0)
            return null;
        var node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
            return this.resultGenerator_(node.key, node.value);
        }
        else {
            return { key: node.key, value: node.value };
        }
    };
    return SortedMapIterator;
}());
exports.SortedMapIterator = SortedMapIterator;
/**
 * Represents a node in a Left-leaning Red-Black tree.
 */
var LLRBNode = /** @class */ (function () {
    /**
     * @template K, V
     * @param {!K} key Key associated with this node.
     * @param {!V} value Value associated with this node.
     * @param {?boolean} color Whether this node is red.
     * @param {?(LLRBNode|LLRBEmptyNode)=} left Left child.
     * @param {?(LLRBNode|LLRBEmptyNode)=} right Right child.
     */
    function LLRBNode(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left =
            left != null ? left : SortedMap.EMPTY_NODE;
        this.right =
            right != null ? right : SortedMap.EMPTY_NODE;
    }
    /**
     * Returns a copy of the current node, optionally replacing pieces of it.
     *
     * @param {?K} key New key for the node, or null.
     * @param {?V} value New value for the node, or null.
     * @param {?boolean} color New color for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} left New left child for the node, or null.
     * @param {?LLRBNode|LLRBEmptyNode} right New right child for the node, or null.
     * @return {!LLRBNode} The node copy.
     */
    LLRBNode.prototype.copy = function (key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBNode.prototype.count = function () {
        return this.left.count() + 1 + this.right.count();
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBNode.prototype.isEmpty = function () {
        return false;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     *   node.  If it returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    LLRBNode.prototype.inorderTraversal = function (action) {
        return (this.left.inorderTraversal(action) ||
            action(this.key, this.value) ||
            this.right.inorderTraversal(action));
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!Object, !Object)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {*} True if traversal was aborted.
     */
    LLRBNode.prototype.reverseTraversal = function (action) {
        return (this.right.reverseTraversal(action) ||
            action(this.key, this.value) ||
            this.left.reverseTraversal(action));
    };
    /**
     * @return {!Object} The minimum node in the tree.
     * @private
     */
    LLRBNode.prototype.min_ = function () {
        if (this.left.isEmpty()) {
            return this;
        }
        else {
            return this.left.min_();
        }
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.minKey = function () {
        return this.min_().key;
    };
    /**
     * @return {!K} The maximum key in the tree.
     */
    LLRBNode.prototype.maxKey = function () {
        if (this.right.isEmpty()) {
            return this.key;
        }
        else {
            return this.right.maxKey();
        }
    };
    /**
     *
     * @param {!Object} key Key to insert.
     * @param {!Object} value Value to insert.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with the key/value added.
     */
    LLRBNode.prototype.insert = function (key, value, comparator) {
        var cmp, n;
        n = this;
        cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        }
        else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        }
        else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the minimum key removed.
     */
    LLRBNode.prototype.removeMin_ = function () {
        if (this.left.isEmpty()) {
            return SortedMap.EMPTY_NODE;
        }
        var n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_())
            n = n.moveRedLeft_();
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
    };
    /**
     * @param {!Object} key The key of the item to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode|LLRBEmptyNode} New tree, with the specified item removed.
     */
    LLRBNode.prototype.remove = function (key, comparator) {
        var n, smallest;
        n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
                n = n.moveRedLeft_();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        }
        else {
            if (n.left.isRed_())
                n = n.rotateRight_();
            if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
                n = n.moveRedRight_();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return SortedMap.EMPTY_NODE;
                }
                else {
                    smallest = n.right.min_();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp_();
    };
    /**
     * @private
     * @return {boolean} Whether this is a RED node.
     */
    LLRBNode.prototype.isRed_ = function () {
        return this.color;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree after performing any needed rotations.
     */
    LLRBNode.prototype.fixUp_ = function () {
        var n = this;
        if (n.right.isRed_() && !n.left.isRed_())
            n = n.rotateLeft_();
        if (n.left.isRed_() && n.left.left.isRed_())
            n = n.rotateRight_();
        if (n.left.isRed_() && n.right.isRed_())
            n = n.colorFlip_();
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedLeft.
     */
    LLRBNode.prototype.moveRedLeft_ = function () {
        var n = this.colorFlip_();
        if (n.right.left.isRed_()) {
            n = n.copy(null, null, null, null, n.right.rotateRight_());
            n = n.rotateLeft_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after moveRedRight.
     */
    LLRBNode.prototype.moveRedRight_ = function () {
        var n = this.colorFlip_();
        if (n.left.left.isRed_()) {
            n = n.rotateRight_();
            n = n.colorFlip_();
        }
        return n;
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateLeft.
     */
    LLRBNode.prototype.rotateLeft_ = function () {
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after rotateRight.
     */
    LLRBNode.prototype.rotateRight_ = function () {
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    };
    /**
     * @private
     * @return {!LLRBNode} New tree, after colorFlip.
     */
    LLRBNode.prototype.colorFlip_ = function () {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    };
    /**
     * For testing.
     *
     * @private
     * @return {boolean} True if all is well.
     */
    LLRBNode.prototype.checkMaxDepth_ = function () {
        var blackDepth = this.check_();
        return Math.pow(2.0, blackDepth) <= this.count() + 1;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBNode.prototype.check_ = function () {
        var blackDepth;
        if (this.isRed_() && this.left.isRed_()) {
            throw new Error('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed_()) {
            throw new Error('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
            throw new Error('Black depths differ');
        }
        else {
            return blackDepth + (this.isRed_() ? 0 : 1);
        }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
}());
exports.LLRBNode = LLRBNode;
/**
 * Represents an empty node (a leaf node in the Red-Black Tree).
 */
var LLRBEmptyNode = /** @class */ (function () {
    function LLRBEmptyNode() {
    }
    /**
     * Returns a copy of the current node.
     *
     * @return {!LLRBEmptyNode} The node copy.
     */
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
        return this;
    };
    /**
     * Returns a copy of the tree, with the specified key/value added.
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBNode} New tree, with item added.
     */
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
        return new LLRBNode(key, value, null);
    };
    /**
     * Returns a copy of the tree, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @param {Comparator} comparator Comparator.
     * @return {!LLRBEmptyNode} New tree, with item removed.
     */
    LLRBEmptyNode.prototype.remove = function (key, comparator) {
        return this;
    };
    /**
     * @return {number} The total number of nodes in the tree.
     */
    LLRBEmptyNode.prototype.count = function () {
        return 0;
    };
    /**
     * @return {boolean} True if the tree is empty.
     */
    LLRBEmptyNode.prototype.isEmpty = function () {
        return true;
    };
    /**
     * Traverses the tree in key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V):*} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.inorderTraversal = function (action) {
        return false;
    };
    /**
     * Traverses the tree in reverse key order and calls the specified action function
     * for each node.
     *
     * @param {function(!K, !V)} action Callback function to be called for each
     * node.  If it returns true, traversal is aborted.
     * @return {boolean} True if traversal was aborted.
     */
    LLRBEmptyNode.prototype.reverseTraversal = function (action) {
        return false;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.minKey = function () {
        return null;
    };
    /**
     * @return {null}
     */
    LLRBEmptyNode.prototype.maxKey = function () {
        return null;
    };
    /**
     * @private
     * @return {number} Not sure what this returns exactly. :-).
     */
    LLRBEmptyNode.prototype.check_ = function () {
        return 0;
    };
    /**
     * @private
     * @return {boolean} Whether this node is red.
     */
    LLRBEmptyNode.prototype.isRed_ = function () {
        return false;
    };
    return LLRBEmptyNode;
}());
exports.LLRBEmptyNode = LLRBEmptyNode;
/**
 * An immutable sorted map implementation, based on a Left-leaning Red-Black
 * tree.
 */
var SortedMap = /** @class */ (function () {
    /**
     * @template K, V
     * @param {function(K, K):number} comparator_ Key comparator.
     * @param {LLRBNode=} root_ (Optional) Root node for the map.
     */
    function SortedMap(comparator_, root_) {
        if (root_ === void 0) { root_ = SortedMap.EMPTY_NODE; }
        this.comparator_ = comparator_;
        this.root_ = root_;
    }
    /**
     * Returns a copy of the map, with the specified key/value added or replaced.
     * (TODO: We should perhaps rename this method to 'put')
     *
     * @param {!K} key Key to be added.
     * @param {!V} value Value to be added.
     * @return {!SortedMap.<K, V>} New map, with item added.
     */
    SortedMap.prototype.insert = function (key, value) {
        return new SortedMap(this.comparator_, this.root_
            .insert(key, value, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns a copy of the map, with the specified key removed.
     *
     * @param {!K} key The key to remove.
     * @return {!SortedMap.<K, V>} New map, with item removed.
     */
    SortedMap.prototype.remove = function (key) {
        return new SortedMap(this.comparator_, this.root_
            .remove(key, this.comparator_)
            .copy(null, null, LLRBNode.BLACK, null, null));
    };
    /**
     * Returns the value of the node with the given key, or null.
     *
     * @param {!K} key The key to look up.
     * @return {?V} The value of the node with the given key, or null if the
     * key doesn't exist.
     */
    SortedMap.prototype.get = function (key) {
        var cmp;
        var node = this.root_;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                return node.value;
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    };
    /**
     * Returns the key of the item *before* the specified key, or null if key is the first item.
     * @param {K} key The key to find the predecessor of
     * @return {?K} The predecessor key.
     */
    SortedMap.prototype.getPredecessorKey = function (key) {
        var cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
            cmp = this.comparator_(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty())
                        node = node.right;
                    return node.key;
                }
                else if (rightParent) {
                    return rightParent.key;
                }
                else {
                    return null; // first item.
                }
            }
            else if (cmp < 0) {
                node = node.left;
            }
            else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw new Error('Attempted to find predecessor key for a nonexistent key.  What gives?');
    };
    /**
     * @return {boolean} True if the map is empty.
     */
    SortedMap.prototype.isEmpty = function () {
        return this.root_.isEmpty();
    };
    /**
     * @return {number} The total number of nodes in the map.
     */
    SortedMap.prototype.count = function () {
        return this.root_.count();
    };
    /**
     * @return {?K} The minimum key in the map.
     */
    SortedMap.prototype.minKey = function () {
        return this.root_.minKey();
    };
    /**
     * @return {?K} The maximum key in the map.
     */
    SortedMap.prototype.maxKey = function () {
        return this.root_.maxKey();
    };
    /**
     * Traverses the map in key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!K, !V):*} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} The first truthy value returned by action, or the last falsey
     *   value returned by action
     */
    SortedMap.prototype.inorderTraversal = function (action) {
        return this.root_.inorderTraversal(action);
    };
    /**
     * Traverses the map in reverse key order and calls the specified action function
     * for each key/value pair.
     *
     * @param {function(!Object, !Object)} action Callback function to be called
     * for each key/value pair.  If action returns true, traversal is aborted.
     * @return {*} True if the traversal was aborted.
     */
    SortedMap.prototype.reverseTraversal = function (action) {
        return this.root_.reverseTraversal(action);
    };
    /**
     * Returns an iterator over the SortedMap.
     * @template T
     * @param {(function(K, V):T)=} resultGenerator
     * @return {SortedMapIterator.<K, V, T>} The iterator.
     */
    SortedMap.prototype.getIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {
        return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap.prototype.getReverseIterator = function (resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    /**
     * Always use the same empty node, to reduce memory.
     * @const
     */
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap;
}());
exports.SortedMap = SortedMap;

//# sourceMappingURL=SortedMap.js.map


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ServerValues_1 = __webpack_require__(58);
var nodeFromJSON_1 = __webpack_require__(15);
var Path_1 = __webpack_require__(2);
var SparseSnapshotTree_1 = __webpack_require__(59);
var SyncTree_1 = __webpack_require__(109);
var SnapshotHolder_1 = __webpack_require__(120);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var util_3 = __webpack_require__(0);
var AuthTokenProvider_1 = __webpack_require__(121);
var StatsManager_1 = __webpack_require__(34);
var StatsReporter_1 = __webpack_require__(123);
var StatsListener_1 = __webpack_require__(64);
var EventQueue_1 = __webpack_require__(124);
var PersistentConnection_1 = __webpack_require__(65);
var ReadonlyRestClient_1 = __webpack_require__(129);
var Database_1 = __webpack_require__(47);
var INTERRUPT_REASON = 'repo_interrupt';
/**
 * A connection to a single data repository.
 */
var Repo = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo_
     * @param {boolean} forceRestClient
     * @param {!FirebaseApp} app
     */
    function Repo(repoInfo_, forceRestClient, app) {
        var _this = this;
        this.repoInfo_ = repoInfo_;
        this.app = app;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue_1.EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        // A list of data pieces and paths to be set when this client disconnects.
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        /**
         * TODO: This should be @private but it's used by test_access.js and internal.js
         * @type {?PersistentConnection}
         */
        this.persistentConnection_ = null;
        /** @type {!AuthTokenProvider} */
        var authTokenProvider = new AuthTokenProvider_1.AuthTokenProvider(app);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo_);
        if (forceRestClient || util_2.beingCrawled()) {
            this.server_ = new ReadonlyRestClient_1.ReadonlyRestClient(this.repoInfo_, this.onDataUpdate_.bind(this), authTokenProvider);
            // Minor hack: Fire onConnect immediately, since there's no actual connection.
            setTimeout(this.onConnectStatus_.bind(this, true), 0);
        }
        else {
            var authOverride = app.options['databaseAuthVariableOverride'];
            // Validate authOverride
            if (typeof authOverride !== 'undefined' && authOverride !== null) {
                if (typeof authOverride !== 'object') {
                    throw new Error('Only objects are supported for option databaseAuthVariableOverride');
                }
                try {
                    util_1.stringify(authOverride);
                }
                catch (e) {
                    throw new Error('Invalid authOverride provided: ' + e);
                }
            }
            this.persistentConnection_ = new PersistentConnection_1.PersistentConnection(this.repoInfo_, this.onDataUpdate_.bind(this), this.onConnectStatus_.bind(this), this.onServerInfoUpdate_.bind(this), authTokenProvider, authOverride);
            this.server_ = this.persistentConnection_;
        }
        authTokenProvider.addTokenChangeListener(function (token) {
            _this.server_.refreshAuthToken(token);
        });
        // In the case of multiple Repos for the same repoInfo (i.e. there are multiple Firebase.Contexts being used),
        // we only want to create one StatsReporter.  As such, we'll report stats over the first Repo created.
        this.statsReporter_ = StatsManager_1.StatsManager.getOrCreateReporter(repoInfo_, function () { return new StatsReporter_1.StatsReporter(_this.stats_, _this.server_); });
        this.transactions_init_();
        // Used for .info.
        this.infoData_ = new SnapshotHolder_1.SnapshotHolder();
        this.infoSyncTree_ = new SyncTree_1.SyncTree({
            startListening: function (query, tag, currentHashFn, onComplete) {
                var infoEvents = [];
                var node = _this.infoData_.getNode(query.path);
                // This is possibly a hack, but we have different semantics for .info endpoints. We don't raise null events
                // on initial data...
                if (!node.isEmpty()) {
                    infoEvents = _this.infoSyncTree_.applyServerOverwrite(query.path, node);
                    setTimeout(function () {
                        onComplete('ok');
                    }, 0);
                }
                return infoEvents;
            },
            stopListening: function () { }
        });
        this.updateInfo_('connected', false);
        this.serverSyncTree_ = new SyncTree_1.SyncTree({
            startListening: function (query, tag, currentHashFn, onComplete) {
                _this.server_.listen(query, currentHashFn, tag, function (status, data) {
                    var events = onComplete(status, data);
                    _this.eventQueue_.raiseEventsForChangedPath(query.path, events);
                });
                // No synchronous events for network-backed sync trees
                return [];
            },
            stopListening: function (query, tag) {
                _this.server_.unlisten(query, tag);
            }
        });
    }
    /**
     * @return {string}  The URL corresponding to the root of this Firebase.
     */
    Repo.prototype.toString = function () {
        return ((this.repoInfo_.secure ? 'https://' : 'http://') + this.repoInfo_.host);
    };
    /**
     * @return {!string} The namespace represented by the repo.
     */
    Repo.prototype.name = function () {
        return this.repoInfo_.namespace;
    };
    /**
     * @return {!number} The time in milliseconds, taking the server offset into account if we have one.
     */
    Repo.prototype.serverTime = function () {
        var offsetNode = this.infoData_.getNode(new Path_1.Path('.info/serverTimeOffset'));
        var offset = offsetNode.val() || 0;
        return new Date().getTime() + offset;
    };
    /**
     * Generate ServerValues using some variables from the repo object.
     * @return {!Object}
     */
    Repo.prototype.generateServerValues = function () {
        return ServerValues_1.generateWithValues({
            timestamp: this.serverTime()
        });
    };
    /**
     * Called by realtime when we get new messages from the server.
     *
     * @private
     * @param {string} pathString
     * @param {*} data
     * @param {boolean} isMerge
     * @param {?number} tag
     */
    Repo.prototype.onDataUpdate_ = function (pathString, data, isMerge, tag) {
        // For testing.
        this.dataUpdateCount++;
        var path = new Path_1.Path(pathString);
        data = this.interceptServerDataCallback_
            ? this.interceptServerDataCallback_(pathString, data)
            : data;
        var events = [];
        if (tag) {
            if (isMerge) {
                var taggedChildren = util_3.map(data, function (raw) {
                    return nodeFromJSON_1.nodeFromJSON(raw);
                });
                events = this.serverSyncTree_.applyTaggedQueryMerge(path, taggedChildren, tag);
            }
            else {
                var taggedSnap = nodeFromJSON_1.nodeFromJSON(data);
                events = this.serverSyncTree_.applyTaggedQueryOverwrite(path, taggedSnap, tag);
            }
        }
        else if (isMerge) {
            var changedChildren = util_3.map(data, function (raw) {
                return nodeFromJSON_1.nodeFromJSON(raw);
            });
            events = this.serverSyncTree_.applyServerMerge(path, changedChildren);
        }
        else {
            var snap = nodeFromJSON_1.nodeFromJSON(data);
            events = this.serverSyncTree_.applyServerOverwrite(path, snap);
        }
        var affectedPath = path;
        if (events.length > 0) {
            // Since we have a listener outstanding for each transaction, receiving any events
            // is a proxy for some change having occurred.
            affectedPath = this.rerunTransactions_(path);
        }
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, events);
    };
    /**
     * TODO: This should be @private but it's used by test_access.js and internal.js
     * @param {?function(!string, *):*} callback
     * @private
     */
    Repo.prototype.interceptServerData_ = function (callback) {
        this.interceptServerDataCallback_ = callback;
    };
    /**
     * @param {!boolean} connectStatus
     * @private
     */
    Repo.prototype.onConnectStatus_ = function (connectStatus) {
        this.updateInfo_('connected', connectStatus);
        if (connectStatus === false) {
            this.runOnDisconnectEvents_();
        }
    };
    /**
     * @param {!Object} updates
     * @private
     */
    Repo.prototype.onServerInfoUpdate_ = function (updates) {
        var _this = this;
        util_2.each(updates, function (value, key) {
            _this.updateInfo_(key, value);
        });
    };
    /**
     *
     * @param {!string} pathString
     * @param {*} value
     * @private
     */
    Repo.prototype.updateInfo_ = function (pathString, value) {
        var path = new Path_1.Path('/.info/' + pathString);
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.infoData_.updateSnapshot(path, newNode);
        var events = this.infoSyncTree_.applyServerOverwrite(path, newNode);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
    };
    /**
     * @return {!number}
     * @private
     */
    Repo.prototype.getNextWriteId_ = function () {
        return this.nextWriteId_++;
    };
    /**
     * @param {!Path} path
     * @param {*} newVal
     * @param {number|string|null} newPriority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.setWithPriority = function (path, newVal, newPriority, onComplete) {
        var _this = this;
        this.log_('set', {
            path: path.toString(),
            value: newVal,
            priority: newPriority
        });
        // TODO: Optimize this behavior to either (a) store flag to skip resolving where possible and / or
        // (b) store unresolved paths on JSON parse
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, newPriority);
        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        var writeId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, writeId, true);
        this.eventQueue_.queueEvents(events);
        this.server_.put(path.toString(), newNodeUnresolved.val(/*export=*/ true), function (status, errorReason) {
            var success = status === 'ok';
            if (!success) {
                util_2.warn('set at ' + path + ' failed: ' + status);
            }
            var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId, !success);
            _this.eventQueue_.raiseEventsForChangedPath(path, clearEvents);
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
        var affectedPath = this.abortTransactions_(path);
        this.rerunTransactions_(affectedPath);
        // We queued the events above, so just flush the queue here
        this.eventQueue_.raiseEventsForChangedPath(affectedPath, []);
    };
    /**
     * @param {!Path} path
     * @param {!Object} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.update = function (path, childrenToMerge, onComplete) {
        var _this = this;
        this.log_('update', { path: path.toString(), value: childrenToMerge });
        // Start with our existing data and merge each child into it.
        var empty = true;
        var serverValues = this.generateServerValues();
        var changedChildren = {};
        util_3.forEach(childrenToMerge, function (changedKey, changedValue) {
            empty = false;
            var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(changedValue);
            changedChildren[changedKey] = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        });
        if (!empty) {
            var writeId_1 = this.getNextWriteId_();
            var events = this.serverSyncTree_.applyUserMerge(path, changedChildren, writeId_1);
            this.eventQueue_.queueEvents(events);
            this.server_.merge(path.toString(), childrenToMerge, function (status, errorReason) {
                var success = status === 'ok';
                if (!success) {
                    util_2.warn('update at ' + path + ' failed: ' + status);
                }
                var clearEvents = _this.serverSyncTree_.ackUserWrite(writeId_1, !success);
                var affectedPath = clearEvents.length > 0 ? _this.rerunTransactions_(path) : path;
                _this.eventQueue_.raiseEventsForChangedPath(affectedPath, clearEvents);
                _this.callOnCompleteCallback(onComplete, status, errorReason);
            });
            util_3.forEach(childrenToMerge, function (changedPath) {
                var affectedPath = _this.abortTransactions_(path.child(changedPath));
                _this.rerunTransactions_(affectedPath);
            });
            // We queued the events above, so just flush the queue here
            this.eventQueue_.raiseEventsForChangedPath(path, []);
        }
        else {
            util_2.log("update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
        }
    };
    /**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     * @private
     */
    Repo.prototype.runOnDisconnectEvents_ = function () {
        var _this = this;
        this.log_('onDisconnectEvents');
        var serverValues = this.generateServerValues();
        var resolvedOnDisconnectTree = ServerValues_1.resolveDeferredValueTree(this.onDisconnect_, serverValues);
        var events = [];
        resolvedOnDisconnectTree.forEachTree(Path_1.Path.Empty, function (path, snap) {
            events = events.concat(_this.serverSyncTree_.applyServerOverwrite(path, snap));
            var affectedPath = _this.abortTransactions_(path);
            _this.rerunTransactions_(affectedPath);
        });
        this.onDisconnect_ = new SparseSnapshotTree_1.SparseSnapshotTree();
        this.eventQueue_.raiseEventsForChangedPath(Path_1.Path.Empty, events);
    };
    /**
     * @param {!Path} path
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectCancel = function (path, onComplete) {
        var _this = this;
        this.server_.onDisconnectCancel(path.toString(), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.forget(path);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSet = function (path, value, onComplete) {
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} value
     * @param {*} priority
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectSetWithPriority = function (path, value, priority, onComplete) {
        var _this = this;
        var newNode = nodeFromJSON_1.nodeFromJSON(value, priority);
        this.server_.onDisconnectPut(path.toString(), newNode.val(/*export=*/ true), function (status, errorReason) {
            if (status === 'ok') {
                _this.onDisconnect_.remember(path, newNode);
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Path} path
     * @param {*} childrenToMerge
     * @param {?function(?Error, *=)} onComplete
     */
    Repo.prototype.onDisconnectUpdate = function (path, childrenToMerge, onComplete) {
        var _this = this;
        if (util_3.isEmpty(childrenToMerge)) {
            util_2.log("onDisconnect().update() called with empty data.  Don't do anything.");
            this.callOnCompleteCallback(onComplete, 'ok');
            return;
        }
        this.server_.onDisconnectMerge(path.toString(), childrenToMerge, function (status, errorReason) {
            if (status === 'ok') {
                util_3.forEach(childrenToMerge, function (childName, childNode) {
                    var newChildNode = nodeFromJSON_1.nodeFromJSON(childNode);
                    _this.onDisconnect_.remember(path.child(childName), newChildNode);
                });
            }
            _this.callOnCompleteCallback(onComplete, status, errorReason);
        });
    };
    /**
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     */
    Repo.prototype.addEventCallbackForQuery = function (query, eventRegistration) {
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.addEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.addEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    /**
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration
     */
    Repo.prototype.removeEventCallbackForQuery = function (query, eventRegistration) {
        // These are guaranteed not to raise events, since we're not passing in a cancelError. However, we can future-proof
        // a little bit by handling the return values anyways.
        var events;
        if (query.path.getFront() === '.info') {
            events = this.infoSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        else {
            events = this.serverSyncTree_.removeEventRegistration(query, eventRegistration);
        }
        this.eventQueue_.raiseEventsAtPath(query.path, events);
    };
    Repo.prototype.interrupt = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.interrupt(INTERRUPT_REASON);
        }
    };
    Repo.prototype.resume = function () {
        if (this.persistentConnection_) {
            this.persistentConnection_.resume(INTERRUPT_REASON);
        }
    };
    Repo.prototype.stats = function (showDelta) {
        if (showDelta === void 0) { showDelta = false; }
        if (typeof console === 'undefined')
            return;
        var stats;
        if (showDelta) {
            if (!this.statsListener_)
                this.statsListener_ = new StatsListener_1.StatsListener(this.stats_);
            stats = this.statsListener_.get();
        }
        else {
            stats = this.stats_.get();
        }
        var longestName = Object.keys(stats).reduce(function (previousValue, currentValue) {
            return Math.max(currentValue.length, previousValue);
        }, 0);
        util_3.forEach(stats, function (stat, value) {
            // pad stat names to be the same length (plus 2 extra spaces).
            for (var i = stat.length; i < longestName + 2; i++)
                stat += ' ';
            console.log(stat + value);
        });
    };
    Repo.prototype.statsIncrementCounter = function (metric) {
        this.stats_.incrementCounter(metric);
        this.statsReporter_.includeStat(metric);
    };
    /**
     * @param {...*} var_args
     * @private
     */
    Repo.prototype.log_ = function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        var prefix = '';
        if (this.persistentConnection_) {
            prefix = this.persistentConnection_.id + ':';
        }
        util_2.log.apply(void 0, [prefix].concat(var_args));
    };
    /**
     * @param {?function(?Error, *=)} callback
     * @param {!string} status
     * @param {?string=} errorReason
     */
    Repo.prototype.callOnCompleteCallback = function (callback, status, errorReason) {
        if (callback) {
            util_2.exceptionGuard(function () {
                if (status == 'ok') {
                    callback(null);
                }
                else {
                    var code = (status || 'error').toUpperCase();
                    var message = code;
                    if (errorReason)
                        message += ': ' + errorReason;
                    var error = new Error(message);
                    error.code = code;
                    callback(error);
                }
            });
        }
    };
    Object.defineProperty(Repo.prototype, "database", {
        get: function () {
            return this.__database || (this.__database = new Database_1.Database(this));
        },
        enumerable: true,
        configurable: true
    });
    return Repo;
}());
exports.Repo = Repo;

//# sourceMappingURL=Repo.js.map


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A cache node only stores complete children. Additionally it holds a flag whether the node can be considered fully
 * initialized in the sense that we know at one point in time this represented a valid state of the world, e.g.
 * initialized with data from the server, or a complete overwrite by the client. The filtered flag also tracks
 * whether a node potentially had children removed due to a filter.
 */
var CacheNode = /** @class */ (function () {
    /**
     * @param {!Node} node_
     * @param {boolean} fullyInitialized_
     * @param {boolean} filtered_
     */
    function CacheNode(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
    }
    /**
     * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
     * @return {boolean}
     */
    CacheNode.prototype.isFullyInitialized = function () {
        return this.fullyInitialized_;
    };
    /**
     * Returns whether this node is potentially missing children due to a filter applied to the node
     * @return {boolean}
     */
    CacheNode.prototype.isFiltered = function () {
        return this.filtered_;
    };
    /**
     * @param {!Path} path
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForPath = function (path) {
        if (path.isEmpty()) {
            return this.isFullyInitialized() && !this.filtered_;
        }
        var childKey = path.getFront();
        return this.isCompleteForChild(childKey);
    };
    /**
     * @param {!string} key
     * @return {boolean}
     */
    CacheNode.prototype.isCompleteForChild = function (key) {
        return ((this.isFullyInitialized() && !this.filtered_) || this.node_.hasChild(key));
    };
    /**
     * @return {!Node}
     */
    CacheNode.prototype.getNode = function () {
        return this.node_;
    };
    return CacheNode;
}());
exports.CacheNode = CacheNode;

//# sourceMappingURL=CacheNode.js.map


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var CODES = {
    AVAILABLE_IN_WINDOW: 'only-available-in-window',
    AVAILABLE_IN_SW: 'only-available-in-sw',
    SHOULD_BE_INHERITED: 'should-be-overriden',
    BAD_SENDER_ID: 'bad-sender-id',
    INCORRECT_GCM_SENDER_ID: 'incorrect-gcm-sender-id',
    PERMISSION_DEFAULT: 'permission-default',
    PERMISSION_BLOCKED: 'permission-blocked',
    UNSUPPORTED_BROWSER: 'unsupported-browser',
    NOTIFICATIONS_BLOCKED: 'notifications-blocked',
    FAILED_DEFAULT_REGISTRATION: 'failed-serviceworker-registration',
    SW_REGISTRATION_EXPECTED: 'sw-registration-expected',
    GET_SUBSCRIPTION_FAILED: 'get-subscription-failed',
    INVALID_SAVED_TOKEN: 'invalid-saved-token',
    SW_REG_REDUNDANT: 'sw-reg-redundant',
    TOKEN_SUBSCRIBE_FAILED: 'token-subscribe-failed',
    TOKEN_SUBSCRIBE_NO_TOKEN: 'token-subscribe-no-token',
    TOKEN_SUBSCRIBE_NO_PUSH_SET: 'token-subscribe-no-push-set',
    USE_SW_BEFORE_GET_TOKEN: 'use-sw-before-get-token',
    INVALID_DELETE_TOKEN: 'invalid-delete-token',
    DELETE_TOKEN_NOT_FOUND: 'delete-token-not-found',
    DELETE_SCOPE_NOT_FOUND: 'delete-scope-not-found',
    BG_HANDLER_FUNCTION_EXPECTED: 'bg-handler-function-expected',
    NO_WINDOW_CLIENT_TO_MSG: 'no-window-client-to-msg',
    UNABLE_TO_RESUBSCRIBE: 'unable-to-resubscribe',
    NO_FCM_TOKEN_FOR_RESUBSCRIBE: 'no-fcm-token-for-resubscribe',
    FAILED_TO_DELETE_TOKEN: 'failed-to-delete-token',
    NO_SW_IN_REG: 'no-sw-in-reg',
    BAD_SCOPE: 'bad-scope',
    BAD_VAPID_KEY: 'bad-vapid-key',
    BAD_SUBSCRIPTION: 'bad-subscription',
    BAD_TOKEN: 'bad-token',
    BAD_PUSH_SET: 'bad-push-set',
    FAILED_DELETE_VAPID_KEY: 'failed-delete-vapid-key'
};
var ERROR_MAP = (_a = {},
    _a[CODES.AVAILABLE_IN_WINDOW] = 'This method is available in a Window context.',
    _a[CODES.AVAILABLE_IN_SW] = 'This method is available in a service worker ' + 'context.',
    _a[CODES.SHOULD_BE_INHERITED] = 'This method should be overriden by ' + 'extended classes.',
    _a[CODES.BAD_SENDER_ID] = "Please ensure that 'messagingSenderId' is set " +
        'correctly in the options passed into firebase.initializeApp().',
    _a[CODES.PERMISSION_DEFAULT] = 'The required permissions were not granted and ' + 'dismissed instead.',
    _a[CODES.PERMISSION_BLOCKED] = 'The required permissions were not granted and ' + 'blocked instead.',
    _a[CODES.UNSUPPORTED_BROWSER] = "This browser doesn't support the API's " +
        'required to use the firebase SDK.',
    _a[CODES.NOTIFICATIONS_BLOCKED] = 'Notifications have been blocked.',
    _a[CODES.FAILED_DEFAULT_REGISTRATION] = 'We are unable to register the ' +
        'default service worker. {$browserErrorMessage}',
    _a[CODES.SW_REGISTRATION_EXPECTED] = 'A service worker registration was the ' + 'expected input.',
    _a[CODES.GET_SUBSCRIPTION_FAILED] = 'There was an error when trying to get ' +
        'any existing Push Subscriptions.',
    _a[CODES.INVALID_SAVED_TOKEN] = 'Unable to access details of the saved token.',
    _a[CODES.SW_REG_REDUNDANT] = 'The service worker being used for push was made ' + 'redundant.',
    _a[CODES.TOKEN_SUBSCRIBE_FAILED] = 'A problem occured while subscribing the ' + 'user to FCM: {$message}',
    _a[CODES.TOKEN_SUBSCRIBE_NO_TOKEN] = 'FCM returned no token when subscribing ' + 'the user to push.',
    _a[CODES.TOKEN_SUBSCRIBE_NO_PUSH_SET] = 'FCM returned an invalid response ' + 'when getting an FCM token.',
    _a[CODES.USE_SW_BEFORE_GET_TOKEN] = 'You must call useServiceWorker() before ' +
        'calling getToken() to ensure your service worker is used.',
    _a[CODES.INVALID_DELETE_TOKEN] = 'You must pass a valid token into ' +
        'deleteToken(), i.e. the token from getToken().',
    _a[CODES.DELETE_TOKEN_NOT_FOUND] = 'The deletion attempt for token could not ' +
        'be performed as the token was not found.',
    _a[CODES.DELETE_SCOPE_NOT_FOUND] = 'The deletion attempt for service worker ' +
        'scope could not be performed as the scope was not found.',
    _a[CODES.BG_HANDLER_FUNCTION_EXPECTED] = 'The input to ' + 'setBackgroundMessageHandler() must be a function.',
    _a[CODES.NO_WINDOW_CLIENT_TO_MSG] = 'An attempt was made to message a ' + 'non-existant window client.',
    _a[CODES.UNABLE_TO_RESUBSCRIBE] = 'There was an error while re-subscribing ' +
        'the FCM token for push messaging. Will have to resubscribe the ' +
        'user on next visit. {$message}',
    _a[CODES.NO_FCM_TOKEN_FOR_RESUBSCRIBE] = 'Could not find an FCM token ' +
        'and as a result, unable to resubscribe. Will have to resubscribe the ' +
        'user on next visit.',
    _a[CODES.FAILED_TO_DELETE_TOKEN] = 'Unable to delete the currently saved token.',
    _a[CODES.NO_SW_IN_REG] = 'Even though the service worker registration was ' +
        'successful, there was a problem accessing the service worker itself.',
    _a[CODES.INCORRECT_GCM_SENDER_ID] = "Please change your web app manifest's " +
        "'gcm_sender_id' value to '103953800507' to use Firebase messaging.",
    _a[CODES.BAD_SCOPE] = 'The service worker scope must be a string with at ' +
        'least one character.',
    _a[CODES.BAD_VAPID_KEY] = 'The public VAPID key must be a string with at ' + 'least one character.',
    _a[CODES.BAD_SUBSCRIPTION] = 'The subscription must be a valid ' + 'PushSubscription.',
    _a[CODES.BAD_TOKEN] = 'The FCM Token used for storage / lookup was not ' +
        'a valid token string.',
    _a[CODES.BAD_PUSH_SET] = 'The FCM push set used for storage / lookup was not ' +
        'not a valid push set string.',
    _a[CODES.FAILED_DELETE_VAPID_KEY] = 'The VAPID key could not be deleted.',
    _a);
/* harmony default export */ __webpack_exports__["a"] = ({
    codes: CODES,
    map: ERROR_MAP
});
var _a;

//# sourceMappingURL=errors.js.map


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return domainBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return downloadBase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return apiBaseUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return apiUploadBaseUrl; });
/* unused harmony export setDomainBase */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return configOption; });
/* unused harmony export shortMaxOperationRetryTime */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultMaxOperationRetryTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return defaultMaxUploadRetryTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return minSafeInteger; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Constants used in the Firebase Storage library.
 */
/**
 * Domain and scheme for API calls.
 */
var domainBase = 'https://firebasestorage.googleapis.com';
/**
 * Domain and scheme for object downloads.
 */
var downloadBase = 'https://firebasestorage.googleapis.com';
/**
 * Base URL for non-upload calls to the API.
 */
var apiBaseUrl = '/v0';
/**
 * Base URL for upload calls to the API.
 */
var apiUploadBaseUrl = '/v0';
function setDomainBase(domainBase) {
    domainBase = domainBase;
}
var configOption = 'storageBucket';
/**
 * 1 minute
 */
var shortMaxOperationRetryTime = 1 * 60 * 1000;
/**
 * 2 minutes
 */
var defaultMaxOperationRetryTime = 2 * 60 * 1000;
/**
 * 10 minutes
 */
var defaultMaxUploadRetryTime = 10 * 60 * 100;
/**
 * This is the value of Number.MIN_SAFE_INTEGER, which is not well supported
 * enough for us to use it directly.
 */
var minSafeInteger = -9007199254740991;

//# sourceMappingURL=constants.js.map


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Location; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__error__ = __webpack_require__(7);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Functionality related to the parsing/composition of bucket/
 * object location.
 */

/**
 * @struct
 */
var Location = /** @class */ (function () {
    function Location(bucket, path) {
        this.bucket = bucket;
        this.path_ = path;
    }
    Object.defineProperty(Location.prototype, "path", {
        get: function () {
            return this.path_;
        },
        enumerable: true,
        configurable: true
    });
    Location.prototype.fullServerUrl = function () {
        var encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o/' + encode(this.path);
    };
    Location.prototype.bucketOnlyServerUrl = function () {
        var encode = encodeURIComponent;
        return '/b/' + encode(this.bucket) + '/o';
    };
    Location.makeFromBucketSpec = function (bucketString) {
        var bucketLocation;
        try {
            bucketLocation = Location.makeFromUrl(bucketString);
        }
        catch (e) {
            // Not valid URL, use as-is. This lets you put bare bucket names in
            // config.
            return new Location(bucketString, '');
        }
        if (bucketLocation.path === '') {
            return bucketLocation;
        }
        else {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["h" /* invalidDefaultBucket */](bucketString);
        }
    };
    Location.makeFromUrl = function (url) {
        var location = null;
        var bucketDomain = '([A-Za-z0-9.\\-]+)';
        function gsModify(loc) {
            if (loc.path.charAt(loc.path.length - 1) === '/') {
                loc.path_ = loc.path_.slice(0, -1);
            }
        }
        var gsPath = '(/(.*))?$';
        var path = '(/([^?#]*).*)?$';
        var gsRegex = new RegExp('^gs://' + bucketDomain + gsPath, 'i');
        var gsIndices = { bucket: 1, path: 3 };
        function httpModify(loc) {
            loc.path_ = decodeURIComponent(loc.path);
        }
        var version = 'v[A-Za-z0-9_]+';
        var httpRegex = new RegExp('^https?://firebasestorage\\.googleapis\\.com/' +
            version +
            '/b/' +
            bucketDomain +
            '/o' +
            path, 'i');
        var httpIndices = { bucket: 1, path: 3 };
        var groups = [
            { regex: gsRegex, indices: gsIndices, postModify: gsModify },
            { regex: httpRegex, indices: httpIndices, postModify: httpModify }
        ];
        for (var i = 0; i < groups.length; i++) {
            var group = groups[i];
            var captures = group.regex.exec(url);
            if (captures) {
                var bucketValue = captures[group.indices.bucket];
                var pathValue = captures[group.indices.path];
                if (!pathValue) {
                    pathValue = '';
                }
                location = new Location(bucketValue, pathValue);
                group.postModify(location);
                break;
            }
        }
        if (location == null) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["k" /* invalidUrl */](url);
        }
        return location;
    };
    return Location;
}());


//# sourceMappingURL=location.js.map


/***/ }),
/* 28 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
exports.CONSTANTS = {
    /**
     * @define {boolean} Whether this is the client Node.js SDK.
     */
    NODE_CLIENT: false,
    /**
     * @define {boolean} Whether this is the Admin Node.js SDK.
     */
    NODE_ADMIN: false,
    /**
     * Firebase SDK Version
     */
    SDK_VERSION: '${JSCORE_VERSION}'
};

//# sourceMappingURL=constants.js.map


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var onDisconnect_1 = __webpack_require__(50);
var TransactionResult_1 = __webpack_require__(105);
var util_1 = __webpack_require__(1);
var NextPushId_1 = __webpack_require__(106);
var Query_1 = __webpack_require__(51);
var Repo_1 = __webpack_require__(23);
var Path_1 = __webpack_require__(2);
var QueryParams_1 = __webpack_require__(130);
var validation_1 = __webpack_require__(9);
var util_2 = __webpack_require__(0);
var util_3 = __webpack_require__(0);
var SyncPoint_1 = __webpack_require__(62);
var Reference = /** @class */ (function (_super) {
    __extends(Reference, _super);
    /**
     * Call options:
     *   new Reference(Repo, Path) or
     *   new Reference(url: string, string|RepoManager)
     *
     * Externally - this is the firebase.database.Reference type.
     *
     * @param {!Repo} repo
     * @param {(!Path)} path
     * @extends {Query}
     */
    function Reference(repo, path) {
        var _this = this;
        if (!(repo instanceof Repo_1.Repo)) {
            throw new Error('new Reference() no longer supported - use app.database().');
        }
        // call Query's constructor, passing in the repo and path.
        _this = _super.call(this, repo, path, QueryParams_1.QueryParams.DEFAULT, false) || this;
        return _this;
    }
    /** @return {?string} */
    Reference.prototype.getKey = function () {
        util_2.validateArgCount('Reference.key', 0, 0, arguments.length);
        if (this.path.isEmpty())
            return null;
        else
            return this.path.getBack();
    };
    /**
     * @param {!(string|Path)} pathString
     * @return {!Reference}
     */
    Reference.prototype.child = function (pathString) {
        util_2.validateArgCount('Reference.child', 1, 1, arguments.length);
        if (typeof pathString === 'number') {
            pathString = String(pathString);
        }
        else if (!(pathString instanceof Path_1.Path)) {
            if (this.path.getFront() === null)
                validation_1.validateRootPathString('Reference.child', 1, pathString, false);
            else
                validation_1.validatePathString('Reference.child', 1, pathString, false);
        }
        return new Reference(this.repo, this.path.child(pathString));
    };
    /** @return {?Reference} */
    Reference.prototype.getParent = function () {
        util_2.validateArgCount('Reference.parent', 0, 0, arguments.length);
        var parentPath = this.path.parent();
        return parentPath === null ? null : new Reference(this.repo, parentPath);
    };
    /** @return {!Reference} */
    Reference.prototype.getRoot = function () {
        util_2.validateArgCount('Reference.root', 0, 0, arguments.length);
        var ref = this;
        while (ref.getParent() !== null) {
            ref = ref.getParent();
        }
        return ref;
    };
    /** @return {!Database} */
    Reference.prototype.databaseProp = function () {
        return this.repo.database;
    };
    /**
     * @param {*} newVal
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.set = function (newVal, onComplete) {
        util_2.validateArgCount('Reference.set', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.set', this.path);
        validation_1.validateFirebaseDataArg('Reference.set', 1, newVal, this.path, false);
        util_2.validateCallback('Reference.set', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path, newVal, 
        /*priority=*/ null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.update = function (objectToMerge, onComplete) {
        util_2.validateArgCount('Reference.update', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.update', this.path);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            util_1.warn('Passing an Array to Firebase.update() is deprecated. ' +
                'Use set() if you want to overwrite the existing data, or ' +
                'an Object with integer keys if you really do want to ' +
                'only update some of the children.');
        }
        validation_1.validateFirebaseMergeDataArg('Reference.update', 1, objectToMerge, this.path, false);
        util_2.validateCallback('Reference.update', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.update(this.path, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} newVal
     * @param {string|number|null} newPriority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setWithPriority = function (newVal, newPriority, onComplete) {
        util_2.validateArgCount('Reference.setWithPriority', 2, 3, arguments.length);
        validation_1.validateWritablePath('Reference.setWithPriority', this.path);
        validation_1.validateFirebaseDataArg('Reference.setWithPriority', 1, newVal, this.path, false);
        validation_1.validatePriority('Reference.setWithPriority', 2, newPriority, false);
        util_2.validateCallback('Reference.setWithPriority', 3, onComplete, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.setWithPriority failed: ' +
                this.getKey() +
                ' is a read-only object.';
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path, newVal, newPriority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.remove = function (onComplete) {
        util_2.validateArgCount('Reference.remove', 0, 1, arguments.length);
        validation_1.validateWritablePath('Reference.remove', this.path);
        util_2.validateCallback('Reference.remove', 1, onComplete, true);
        return this.set(null, onComplete);
    };
    /**
     * @param {function(*):*} transactionUpdate
     * @param {(function(?Error, boolean, ?DataSnapshot))=} onComplete
     * @param {boolean=} applyLocally
     * @return {!Promise}
     */
    Reference.prototype.transaction = function (transactionUpdate, onComplete, applyLocally) {
        util_2.validateArgCount('Reference.transaction', 1, 3, arguments.length);
        validation_1.validateWritablePath('Reference.transaction', this.path);
        util_2.validateCallback('Reference.transaction', 1, transactionUpdate, false);
        util_2.validateCallback('Reference.transaction', 2, onComplete, true);
        // NOTE: applyLocally is an internal-only option for now.  We need to decide if we want to keep it and how
        // to expose it.
        validation_1.validateBoolean('Reference.transaction', 3, applyLocally, true);
        if (this.getKey() === '.length' || this.getKey() === '.keys')
            throw 'Reference.transaction failed: ' +
                this.getKey() +
                ' is a read-only object.';
        if (applyLocally === undefined)
            applyLocally = true;
        var deferred = new util_3.Deferred();
        if (typeof onComplete === 'function') {
            deferred.promise.catch(function () { });
        }
        var promiseComplete = function (error, committed, snapshot) {
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve(new TransactionResult_1.TransactionResult(committed, snapshot));
            }
            if (typeof onComplete === 'function') {
                onComplete(error, committed, snapshot);
            }
        };
        this.repo.startTransaction(this.path, transactionUpdate, promiseComplete, applyLocally);
        return deferred.promise;
    };
    /**
     * @param {string|number|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!Promise}
     */
    Reference.prototype.setPriority = function (priority, onComplete) {
        util_2.validateArgCount('Reference.setPriority', 1, 2, arguments.length);
        validation_1.validateWritablePath('Reference.setPriority', this.path);
        validation_1.validatePriority('Reference.setPriority', 1, priority, false);
        util_2.validateCallback('Reference.setPriority', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo.setWithPriority(this.path.child('.priority'), priority, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*=} value
     * @param {function(?Error)=} onComplete
     * @return {!Reference}
     */
    Reference.prototype.push = function (value, onComplete) {
        util_2.validateArgCount('Reference.push', 0, 2, arguments.length);
        validation_1.validateWritablePath('Reference.push', this.path);
        validation_1.validateFirebaseDataArg('Reference.push', 1, value, this.path, true);
        util_2.validateCallback('Reference.push', 2, onComplete, true);
        var now = this.repo.serverTime();
        var name = NextPushId_1.nextPushId(now);
        // push() returns a ThennableReference whose promise is fulfilled with a regular Reference.
        // We use child() to create handles to two different references. The first is turned into a
        // ThennableReference below by adding then() and catch() methods and is used as the
        // return value of push(). The second remains a regular Reference and is used as the fulfilled
        // value of the first ThennableReference.
        var thennablePushRef = this.child(name);
        var pushRef = this.child(name);
        var promise;
        if (value != null) {
            promise = thennablePushRef.set(value, onComplete).then(function () { return pushRef; });
        }
        else {
            promise = Promise.resolve(pushRef);
        }
        thennablePushRef.then = promise.then.bind(promise);
        thennablePushRef.catch = promise.then.bind(promise, undefined);
        if (typeof onComplete === 'function') {
            promise.catch(function () { });
        }
        return thennablePushRef;
    };
    /**
     * @return {!OnDisconnect}
     */
    Reference.prototype.onDisconnect = function () {
        validation_1.validateWritablePath('Reference.onDisconnect', this.path);
        return new onDisconnect_1.OnDisconnect(this.repo, this.path);
    };
    Object.defineProperty(Reference.prototype, "database", {
        get: function () {
            return this.databaseProp();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "key", {
        get: function () {
            return this.getKey();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "parent", {
        get: function () {
            return this.getParent();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "root", {
        get: function () {
            return this.getRoot();
        },
        enumerable: true,
        configurable: true
    });
    return Reference;
}(Query_1.Query));
exports.Reference = Reference;
/**
 * Define reference constructor in various modules
 *
 * We are doing this here to avoid several circular
 * dependency issues
 */
Query_1.Query.__referenceConstructor = Reference;
SyncPoint_1.SyncPoint.__referenceConstructor = Reference;

//# sourceMappingURL=Reference.js.map


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var validation_1 = __webpack_require__(9);
var Path_1 = __webpack_require__(2);
var PriorityIndex_1 = __webpack_require__(3);
/**
 * Class representing a firebase data snapshot.  It wraps a SnapshotNode and
 * surfaces the public methods (val, forEach, etc.) we want to expose.
 */
var DataSnapshot = /** @class */ (function () {
    /**
     * @param {!Node} node_ A SnapshotNode to wrap.
     * @param {!Reference} ref_ The ref of the location this snapshot came from.
     * @param {!Index} index_ The iteration order for this snapshot
     */
    function DataSnapshot(node_, ref_, index_) {
        this.node_ = node_;
        this.ref_ = ref_;
        this.index_ = index_;
    }
    /**
     * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is
     * empty.
     *
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.val = function () {
        util_1.validateArgCount('DataSnapshot.val', 0, 0, arguments.length);
        return this.node_.val();
    };
    /**
     * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting
     * the entire node contents.
     * @return {*} JSON representation of the DataSnapshot contents, or null if empty.
     */
    DataSnapshot.prototype.exportVal = function () {
        util_1.validateArgCount('DataSnapshot.exportVal', 0, 0, arguments.length);
        return this.node_.val(true);
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    DataSnapshot.prototype.toJSON = function () {
        // Optional spacer argument is unnecessary because we're depending on recursion rather than stringifying the content
        util_1.validateArgCount('DataSnapshot.toJSON', 0, 1, arguments.length);
        return this.exportVal();
    };
    /**
     * Returns whether the snapshot contains a non-null value.
     *
     * @return {boolean} Whether the snapshot contains a non-null value, or is empty.
     */
    DataSnapshot.prototype.exists = function () {
        util_1.validateArgCount('DataSnapshot.exists', 0, 0, arguments.length);
        return !this.node_.isEmpty();
    };
    /**
     * Returns a DataSnapshot of the specified child node's contents.
     *
     * @param {!string} childPathString Path to a child.
     * @return {!DataSnapshot} DataSnapshot for child node.
     */
    DataSnapshot.prototype.child = function (childPathString) {
        util_1.validateArgCount('DataSnapshot.child', 0, 1, arguments.length);
        // Ensure the childPath is a string (can be a number)
        childPathString = String(childPathString);
        validation_1.validatePathString('DataSnapshot.child', 1, childPathString, false);
        var childPath = new Path_1.Path(childPathString);
        var childRef = this.ref_.child(childPath);
        return new DataSnapshot(this.node_.getChild(childPath), childRef, PriorityIndex_1.PRIORITY_INDEX);
    };
    /**
     * Returns whether the snapshot contains a child at the specified path.
     *
     * @param {!string} childPathString Path to a child.
     * @return {boolean} Whether the child exists.
     */
    DataSnapshot.prototype.hasChild = function (childPathString) {
        util_1.validateArgCount('DataSnapshot.hasChild', 1, 1, arguments.length);
        validation_1.validatePathString('DataSnapshot.hasChild', 1, childPathString, false);
        var childPath = new Path_1.Path(childPathString);
        return !this.node_.getChild(childPath).isEmpty();
    };
    /**
     * Returns the priority of the object, or null if no priority was set.
     *
     * @return {string|number|null} The priority.
     */
    DataSnapshot.prototype.getPriority = function () {
        util_1.validateArgCount('DataSnapshot.getPriority', 0, 0, arguments.length);
        // typecast here because we never return deferred values or internal priorities (MAX_PRIORITY)
        return this.node_.getPriority().val();
    };
    /**
     * Iterates through child nodes and calls the specified action for each one.
     *
     * @param {function(!DataSnapshot)} action Callback function to be called
     * for each child.
     * @return {boolean} True if forEach was canceled by action returning true for
     * one of the child nodes.
     */
    DataSnapshot.prototype.forEach = function (action) {
        var _this = this;
        util_1.validateArgCount('DataSnapshot.forEach', 1, 1, arguments.length);
        util_1.validateCallback('DataSnapshot.forEach', 1, action, false);
        if (this.node_.isLeafNode())
            return false;
        var childrenNode = this.node_;
        // Sanitize the return value to a boolean. ChildrenNode.forEachChild has a weird return type...
        return !!childrenNode.forEachChild(this.index_, function (key, node) {
            return action(new DataSnapshot(node, _this.ref_.child(key), PriorityIndex_1.PRIORITY_INDEX));
        });
    };
    /**
     * Returns whether this DataSnapshot has children.
     * @return {boolean} True if the DataSnapshot contains 1 or more child nodes.
     */
    DataSnapshot.prototype.hasChildren = function () {
        util_1.validateArgCount('DataSnapshot.hasChildren', 0, 0, arguments.length);
        if (this.node_.isLeafNode())
            return false;
        else
            return !this.node_.isEmpty();
    };
    Object.defineProperty(DataSnapshot.prototype, "key", {
        get: function () {
            return this.ref_.getKey();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the number of children for this DataSnapshot.
     * @return {number} The number of children that this DataSnapshot contains.
     */
    DataSnapshot.prototype.numChildren = function () {
        util_1.validateArgCount('DataSnapshot.numChildren', 0, 0, arguments.length);
        return this.node_.numChildren();
    };
    /**
     * @return {Reference} The Firebase reference for the location this snapshot's data came from.
     */
    DataSnapshot.prototype.getRef = function () {
        util_1.validateArgCount('DataSnapshot.ref', 0, 0, arguments.length);
        return this.ref_;
    };
    Object.defineProperty(DataSnapshot.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return DataSnapshot;
}());
exports.DataSnapshot = DataSnapshot;

//# sourceMappingURL=DataSnapshot.js.map


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var SortedMap_1 = __webpack_require__(22);
var Path_1 = __webpack_require__(2);
var util_1 = __webpack_require__(1);
var util_2 = __webpack_require__(0);
var emptyChildrenSingleton;
/**
 * Singleton empty children collection.
 *
 * @const
 * @type {!SortedMap.<string, !ImmutableTree.<?>>}
 */
var EmptyChildren = function () {
    if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap_1.SortedMap(util_1.stringCompare);
    }
    return emptyChildrenSingleton;
};
/**
 * A tree with immutable elements.
 */
var ImmutableTree = /** @class */ (function () {
    /**
     * @template T
     * @param {?T} value
     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children
     */
    function ImmutableTree(value, children) {
        if (children === void 0) { children = EmptyChildren(); }
        this.value = value;
        this.children = children;
    }
    /**
     * @template T
     * @param {!Object.<string, !T>} obj
     * @return {!ImmutableTree.<!T>}
     */
    ImmutableTree.fromObject = function (obj) {
        var tree = ImmutableTree.Empty;
        util_2.forEach(obj, function (childPath, childSnap) {
            tree = tree.set(new Path_1.Path(childPath), childSnap);
        });
        return tree;
    };
    /**
     * True if the value is empty and there are no children
     * @return {boolean}
     */
    ImmutableTree.prototype.isEmpty = function () {
        return this.value === null && this.children.isEmpty();
    };
    /**
     * Given a path and predicate, return the first node and the path to that node
     * where the predicate returns true.
     *
     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects
     * on the way back out, it may be better to pass down a pathSoFar obj.
     *
     * @param {!Path} relativePath The remainder of the path
     * @param {function(T):boolean} predicate The predicate to satisfy to return a
     *   node
     * @return {?{path:!Path, value:!T}}
     */
    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
            return { path: Path_1.Path.Empty, value: this.value };
        }
        else {
            if (relativePath.isEmpty()) {
                return null;
            }
            else {
                var front = relativePath.getFront();
                var child = this.children.get(front);
                if (child !== null) {
                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);
                    if (childExistingPathAndValue != null) {
                        var fullPath = new Path_1.Path(front).child(childExistingPathAndValue.path);
                        return { path: fullPath, value: childExistingPathAndValue.value };
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     * Find, if it exists, the shortest subpath of the given path that points a defined
     * value in the tree
     * @param {!Path} relativePath
     * @return {?{path: !Path, value: !T}}
     */
    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });
    };
    /**
     * @param {!Path} relativePath
     * @return {!ImmutableTree.<T>} The subtree at the given path
     */
    ImmutableTree.prototype.subtree = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this;
        }
        else {
            var front = relativePath.getFront();
            var childTree = this.children.get(front);
            if (childTree !== null) {
                return childTree.subtree(relativePath.popFront());
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Sets a value at the specified path.
     *
     * @param {!Path} relativePath Path to set value at.
     * @param {?T} toSet Value to set.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.set = function (relativePath, toSet) {
        if (relativePath.isEmpty()) {
            return new ImmutableTree(toSet, this.children);
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.set(relativePath.popFront(), toSet);
            var newChildren = this.children.insert(front, newChild);
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Removes the value at the specified path.
     *
     * @param {!Path} relativePath Path to value to remove.
     * @return {!ImmutableTree.<T>} Resulting tree.
     */
    ImmutableTree.prototype.remove = function (relativePath) {
        if (relativePath.isEmpty()) {
            if (this.children.isEmpty()) {
                return ImmutableTree.Empty;
            }
            else {
                return new ImmutableTree(null, this.children);
            }
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                var newChild = child.remove(relativePath.popFront());
                var newChildren = void 0;
                if (newChild.isEmpty()) {
                    newChildren = this.children.remove(front);
                }
                else {
                    newChildren = this.children.insert(front, newChild);
                }
                if (this.value === null && newChildren.isEmpty()) {
                    return ImmutableTree.Empty;
                }
                else {
                    return new ImmutableTree(this.value, newChildren);
                }
            }
            else {
                return this;
            }
        }
    };
    /**
     * Gets a value from the tree.
     *
     * @param {!Path} relativePath Path to get value for.
     * @return {?T} Value at path, or null.
     */
    ImmutableTree.prototype.get = function (relativePath) {
        if (relativePath.isEmpty()) {
            return this.value;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front);
            if (child) {
                return child.get(relativePath.popFront());
            }
            else {
                return null;
            }
        }
    };
    /**
     * Replace the subtree at the specified path with the given new tree.
     *
     * @param {!Path} relativePath Path to replace subtree for.
     * @param {!ImmutableTree} newTree New tree.
     * @return {!ImmutableTree} Resulting tree.
     */
    ImmutableTree.prototype.setTree = function (relativePath, newTree) {
        if (relativePath.isEmpty()) {
            return newTree;
        }
        else {
            var front = relativePath.getFront();
            var child = this.children.get(front) || ImmutableTree.Empty;
            var newChild = child.setTree(relativePath.popFront(), newTree);
            var newChildren = void 0;
            if (newChild.isEmpty()) {
                newChildren = this.children.remove(front);
            }
            else {
                newChildren = this.children.insert(front, newChild);
            }
            return new ImmutableTree(this.value, newChildren);
        }
    };
    /**
     * Performs a depth first fold on this tree. Transforms a tree into a single
     * value, given a function that operates on the path to a node, an optional
     * current value, and a map of child names to folded subtrees
     * @template V
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     */
    ImmutableTree.prototype.fold = function (fn) {
        return this.fold_(Path_1.Path.Empty, fn);
    };
    /**
     * Recursive helper for public-facing fold() method
     * @template V
     * @param {!Path} pathSoFar
     * @param {function(Path, ?T, Object.<string, V>):V} fn
     * @return {V}
     * @private
     */
    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {
        var accum = {};
        this.children.inorderTraversal(function (childKey, childTree) {
            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
    };
    /**
     * Find the first matching value on the given path. Return the result of applying f to it.
     * @template V
     * @param {!Path} path
     * @param {!function(!Path, !T):?V} f
     * @return {?V}
     */
    ImmutableTree.prototype.findOnPath = function (path, f) {
        return this.findOnPath_(path, Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {
        var result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
            return result;
        }
        else {
            if (pathToFollow.isEmpty()) {
                return null;
            }
            else {
                var front = pathToFollow.getFront();
                var nextChild = this.children.get(front);
                if (nextChild) {
                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);
                }
                else {
                    return null;
                }
            }
        }
    };
    /**
     *
     * @param {!Path} path
     * @param {!function(!Path, !T)} f
     * @returns {!ImmutableTree.<T>}
     */
    ImmutableTree.prototype.foreachOnPath = function (path, f) {
        return this.foreachOnPath_(path, Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {
        if (pathToFollow.isEmpty()) {
            return this;
        }
        else {
            if (this.value) {
                f(currentRelativePath, this.value);
            }
            var front = pathToFollow.getFront();
            var nextChild = this.children.get(front);
            if (nextChild) {
                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);
            }
            else {
                return ImmutableTree.Empty;
            }
        }
    };
    /**
     * Calls the given function for each node in the tree that has a value.
     *
     * @param {function(!Path, !T)} f A function to be called with
     *   the path from the root of the tree to a node, and the value at that node.
     *   Called in depth-first order.
     */
    ImmutableTree.prototype.foreach = function (f) {
        this.foreach_(Path_1.Path.Empty, f);
    };
    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {
        this.children.inorderTraversal(function (childName, childTree) {
            childTree.foreach_(currentRelativePath.child(childName), f);
        });
        if (this.value) {
            f(currentRelativePath, this.value);
        }
    };
    /**
     *
     * @param {function(string, !T)} f
     */
    ImmutableTree.prototype.foreachChild = function (f) {
        this.children.inorderTraversal(function (childName, childTree) {
            if (childTree.value) {
                f(childName, childTree.value);
            }
        });
    };
    ImmutableTree.Empty = new ImmutableTree(null);
    return ImmutableTree;
}());
exports.ImmutableTree = ImmutableTree;

//# sourceMappingURL=ImmutableTree.js.map


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Change_1 = __webpack_require__(12);
var ChildrenNode_1 = __webpack_require__(4);
var PriorityIndex_1 = __webpack_require__(3);
/**
 * Doesn't really filter nodes but applies an index to the node and keeps track of any changes
 *
 * @constructor
 * @implements {NodeFilter}
 * @param {!Index} index
 */
var IndexedFilter = /** @class */ (function () {
    function IndexedFilter(index_) {
        this.index_ = index_;
    }
    IndexedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        util_1.assert(snap.isIndexed(this.index_), 'A node must be indexed if only a child is updated');
        var oldChild = snap.getImmediateChild(key);
        // Check if anything actually changed.
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
            // There's an edge case where a child can enter or leave the view because affectedPath was set to null.
            // In this case, affectedPath will appear null in both the old and new snapshots.  So we need
            // to avoid treating these cases as "nothing changed."
            if (oldChild.isEmpty() == newChild.isEmpty()) {
                // Nothing changed.
                // This assert should be valid, but it's expensive (can dominate perf testing) so don't actually do it.
                //assert(oldChild.equals(newChild), 'Old and new snapshots should be equal.');
                return snap;
            }
        }
        if (optChangeAccumulator != null) {
            if (newChild.isEmpty()) {
                if (snap.hasChild(key)) {
                    optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, oldChild));
                }
                else {
                    util_1.assert(snap.isLeafNode(), 'A child remove without an old child only makes sense on a leaf node');
                }
            }
            else if (oldChild.isEmpty()) {
                optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, newChild));
            }
            else {
                optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, newChild, oldChild));
            }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
            return snap;
        }
        else {
            // Make sure the node is indexed
            return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
            if (!oldSnap.isLeafNode()) {
                oldSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                    if (!newSnap.hasChild(key)) {
                        optChangeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(key, childNode));
                    }
                });
            }
            if (!newSnap.isLeafNode()) {
                newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                    if (oldSnap.hasChild(key)) {
                        var oldChild = oldSnap.getImmediateChild(key);
                        if (!oldChild.equals(childNode)) {
                            optChangeAccumulator.trackChildChange(Change_1.Change.childChangedChange(key, childNode, oldChild));
                        }
                    }
                    else {
                        optChangeAccumulator.trackChildChange(Change_1.Change.childAddedChange(key, childNode));
                    }
                });
            }
        }
        return newSnap.withIndex(this.index_);
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
            return ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        else {
            return oldSnap.updatePriority(newPriority);
        }
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.filtersNodes = function () {
        return false;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndexedFilter = function () {
        return this;
    };
    /**
     * @inheritDoc
     */
    IndexedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    return IndexedFilter;
}());
exports.IndexedFilter = IndexedFilter;

//# sourceMappingURL=IndexedFilter.js.map


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var StatsCollection_1 = __webpack_require__(122);
var StatsManager = /** @class */ (function () {
    function StatsManager() {
    }
    StatsManager.getCollection = function (repoInfo) {
        var hashString = repoInfo.toString();
        if (!this.collections_[hashString]) {
            this.collections_[hashString] = new StatsCollection_1.StatsCollection();
        }
        return this.collections_[hashString];
    };
    StatsManager.getOrCreateReporter = function (repoInfo, creatorFunction) {
        var hashString = repoInfo.toString();
        if (!this.reporters_[hashString]) {
            this.reporters_[hashString] = creatorFunction();
        }
        return this.reporters_[hashString];
    };
    StatsManager.collections_ = {};
    StatsManager.reporters_ = {};
    return StatsManager;
}());
exports.StatsManager = StatsManager;

//# sourceMappingURL=StatsManager.js.map


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Repo_1 = __webpack_require__(23);
var util_2 = __webpack_require__(1);
var parser_1 = __webpack_require__(48);
var validation_1 = __webpack_require__(9);
__webpack_require__(132);
/** @const {string} */
var DATABASE_URL_OPTION = 'databaseURL';
var _staticInstance;
/**
 * Creates and caches Repo instances.
 */
var RepoManager = /** @class */ (function () {
    function RepoManager() {
        /**
         * @private {!Object.<string, Object<string, !fb.core.Repo>>}
         */
        this.repos_ = {};
        /**
         * If true, new Repos will be created to use ReadonlyRestClient (for testing purposes).
         * @private {boolean}
         */
        this.useRestClient_ = false;
    }
    RepoManager.getInstance = function () {
        if (!_staticInstance) {
            _staticInstance = new RepoManager();
        }
        return _staticInstance;
    };
    // TODO(koss): Remove these functions unless used in tests?
    RepoManager.prototype.interrupt = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].interrupt();
            }
        }
    };
    RepoManager.prototype.resume = function () {
        for (var appName in this.repos_) {
            for (var dbUrl in this.repos_[appName]) {
                this.repos_[appName][dbUrl].resume();
            }
        }
    };
    /**
     * This function should only ever be called to CREATE a new database instance.
     *
     * @param {!FirebaseApp} app
     * @return {!Database}
     */
    RepoManager.prototype.databaseFromApp = function (app, url) {
        var dbUrl = url || app.options[DATABASE_URL_OPTION];
        if (dbUrl === undefined) {
            util_2.fatal("Can't determine Firebase Database URL.  Be sure to include " +
                DATABASE_URL_OPTION +
                ' option when calling firebase.intializeApp().');
        }
        var parsedUrl = parser_1.parseRepoInfo(dbUrl);
        var repoInfo = parsedUrl.repoInfo;
        validation_1.validateUrl('Invalid Firebase Database URL', 1, parsedUrl);
        if (!parsedUrl.path.isEmpty()) {
            util_2.fatal('Database URL must point to the root of a Firebase Database ' +
                '(not including a child path).');
        }
        var repo = this.createRepo(repoInfo, app);
        return repo.database;
    };
    /**
     * Remove the repo and make sure it is disconnected.
     *
     * @param {!Repo} repo
     */
    RepoManager.prototype.deleteRepo = function (repo) {
        var appRepos = util_1.safeGet(this.repos_, repo.app.name);
        // This should never happen...
        if (!appRepos || util_1.safeGet(appRepos, repo.repoInfo_.toURLString()) !== repo) {
            util_2.fatal("Database " + repo.app.name + "(" + repo.repoInfo_ + ") has already been deleted.");
        }
        repo.interrupt();
        delete appRepos[repo.repoInfo_.toURLString()];
    };
    /**
     * Ensures a repo doesn't already exist and then creates one using the
     * provided app.
     *
     * @param {!RepoInfo} repoInfo The metadata about the Repo
     * @param {!FirebaseApp} app
     * @return {!Repo} The Repo object for the specified server / repoName.
     */
    RepoManager.prototype.createRepo = function (repoInfo, app) {
        var appRepos = util_1.safeGet(this.repos_, app.name);
        if (!appRepos) {
            appRepos = {};
            this.repos_[app.name] = appRepos;
        }
        var repo = util_1.safeGet(appRepos, repoInfo.toURLString());
        if (repo) {
            util_2.fatal('Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.');
        }
        repo = new Repo_1.Repo(repoInfo, this.useRestClient_, app);
        appRepos[repoInfo.toURLString()] = repo;
        return repo;
    };
    /**
     * Forces us to use ReadonlyRestClient instead of PersistentConnection for new Repos.
     * @param {boolean} forceRestClient
     */
    RepoManager.prototype.forceRestClient = function (forceRestClient) {
        this.useRestClient_ = forceRestClient;
    };
    return RepoManager;
}());
exports.RepoManager = RepoManager;

//# sourceMappingURL=RepoManager.js.map


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["g"] = validate;
/* unused harmony export ArgSpec */
/* unused harmony export and_ */
/* harmony export (immutable) */ __webpack_exports__["e"] = stringSpec;
/* harmony export (immutable) */ __webpack_exports__["f"] = uploadDataSpec;
/* harmony export (immutable) */ __webpack_exports__["b"] = metadataSpec;
/* harmony export (immutable) */ __webpack_exports__["c"] = nonNegativeNumberSpec;
/* harmony export (immutable) */ __webpack_exports__["a"] = looseObjectSpec;
/* harmony export (immutable) */ __webpack_exports__["d"] = nullFunctionSpec;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__metadata__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__type__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param name Name of the function.
 * @param specs Argument specs.
 * @param passed The actual arguments passed to the function.
 * @throws {fbs.Error} If the arguments are invalid.
 */
function validate(name, specs, passed) {
    var minArgs = specs.length;
    var maxArgs = specs.length;
    for (var i = 0; i < specs.length; i++) {
        if (specs[i].optional) {
            minArgs = i;
            break;
        }
    }
    var validLength = minArgs <= passed.length && passed.length <= maxArgs;
    if (!validLength) {
        throw __WEBPACK_IMPORTED_MODULE_0__error__["g" /* invalidArgumentCount */](minArgs, maxArgs, name, passed.length);
    }
    for (var i = 0; i < passed.length; i++) {
        try {
            specs[i].validator(passed[i]);
        }
        catch (e) {
            if (e instanceof Error) {
                throw __WEBPACK_IMPORTED_MODULE_0__error__["f" /* invalidArgument */](i, name, e.message);
            }
            else {
                throw __WEBPACK_IMPORTED_MODULE_0__error__["f" /* invalidArgument */](i, name, e);
            }
        }
    }
}
/**
 * @struct
 */
var ArgSpec = /** @class */ (function () {
    function ArgSpec(validator, opt_optional) {
        var self = this;
        this.validator = function (p) {
            if (self.optional && !__WEBPACK_IMPORTED_MODULE_2__type__["c" /* isJustDef */](p)) {
                return;
            }
            validator(p);
        };
        this.optional = !!opt_optional;
    }
    return ArgSpec;
}());

function and_(v1, v2) {
    return function (p) {
        v1(p);
        v2(p);
    };
}
function stringSpec(opt_validator, opt_optional) {
    function stringValidator(p) {
        if (!__WEBPACK_IMPORTED_MODULE_2__type__["j" /* isString */](p)) {
            throw 'Expected string.';
        }
    }
    var validator;
    if (opt_validator) {
        validator = and_(stringValidator, opt_validator);
    }
    else {
        validator = stringValidator;
    }
    return new ArgSpec(validator, opt_optional);
}
function uploadDataSpec() {
    function validator(p) {
        var valid = p instanceof Uint8Array ||
            p instanceof ArrayBuffer ||
            (__WEBPACK_IMPORTED_MODULE_2__type__["e" /* isNativeBlobDefined */]() && p instanceof Blob);
        if (!valid) {
            throw 'Expected Blob or File.';
        }
    }
    return new ArgSpec(validator);
}
function metadataSpec(opt_optional) {
    return new ArgSpec(__WEBPACK_IMPORTED_MODULE_1__metadata__["c" /* metadataValidator */], opt_optional);
}
function nonNegativeNumberSpec() {
    function validator(p) {
        var valid = __WEBPACK_IMPORTED_MODULE_2__type__["h" /* isNumber */](p) && p >= 0;
        if (!valid) {
            throw 'Expected a number 0 or greater.';
        }
    }
    return new ArgSpec(validator);
}
function looseObjectSpec(opt_validator, opt_optional) {
    function validator(p) {
        var isLooseObject = p === null || (__WEBPACK_IMPORTED_MODULE_2__type__["a" /* isDef */](p) && p instanceof Object);
        if (!isLooseObject) {
            throw 'Expected an Object.';
        }
        if (opt_validator !== undefined && opt_validator !== null) {
            opt_validator(p);
        }
    }
    return new ArgSpec(validator, opt_optional);
}
function nullFunctionSpec(opt_optional) {
    function validator(p) {
        var valid = p === null || __WEBPACK_IMPORTED_MODULE_2__type__["b" /* isFunction */](p);
        if (!valid) {
            throw 'Expected a Function.';
        }
    }
    return new ArgSpec(validator, opt_optional);
}

//# sourceMappingURL=args.js.map


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export noXform_ */
/* unused harmony export Mapping */
/* unused harmony export xformPath */
/* harmony export (immutable) */ __webpack_exports__["b"] = getMappings;
/* unused harmony export addRef */
/* unused harmony export fromResource */
/* harmony export (immutable) */ __webpack_exports__["a"] = fromResourceString;
/* harmony export (immutable) */ __webpack_exports__["d"] = toResourceString;
/* harmony export (immutable) */ __webpack_exports__["c"] = metadataValidator;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__json__ = __webpack_require__(149);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__location__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__path__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__type__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__url__ = __webpack_require__(38);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function noXform_(metadata, value) {
    return value;
}
/**
 * @struct
 */
var Mapping = /** @class */ (function () {
    function Mapping(server, opt_local, opt_writable, opt_xform) {
        this.server = server;
        this.local = opt_local || server;
        this.writable = !!opt_writable;
        this.xform = opt_xform || noXform_;
    }
    return Mapping;
}());

var mappings_ = null;
function xformPath(fullPath) {
    var valid = __WEBPACK_IMPORTED_MODULE_3__type__["j" /* isString */](fullPath);
    if (!valid || fullPath.length < 2) {
        return fullPath;
    }
    else {
        fullPath = fullPath;
        return __WEBPACK_IMPORTED_MODULE_2__path__["b" /* lastComponent */](fullPath);
    }
}
function getMappings() {
    if (mappings_) {
        return mappings_;
    }
    var mappings = [];
    mappings.push(new Mapping('bucket'));
    mappings.push(new Mapping('generation'));
    mappings.push(new Mapping('metageneration'));
    mappings.push(new Mapping('name', 'fullPath', true));
    function mappingsXformPath(metadata, fullPath) {
        return xformPath(fullPath);
    }
    var nameMapping = new Mapping('name');
    nameMapping.xform = mappingsXformPath;
    mappings.push(nameMapping);
    /**
     * Coerces the second param to a number, if it is defined.
     */
    function xformSize(metadata, size) {
        if (__WEBPACK_IMPORTED_MODULE_3__type__["a" /* isDef */](size)) {
            return +size;
        }
        else {
            return size;
        }
    }
    var sizeMapping = new Mapping('size');
    sizeMapping.xform = xformSize;
    mappings.push(sizeMapping);
    mappings.push(new Mapping('timeCreated'));
    mappings.push(new Mapping('updated'));
    mappings.push(new Mapping('md5Hash', null, true));
    mappings.push(new Mapping('cacheControl', null, true));
    mappings.push(new Mapping('contentDisposition', null, true));
    mappings.push(new Mapping('contentEncoding', null, true));
    mappings.push(new Mapping('contentLanguage', null, true));
    mappings.push(new Mapping('contentType', null, true));
    mappings.push(new Mapping('metadata', 'customMetadata', true));
    /**
     * Transforms a comma-separated string of tokens into a list of download
     * URLs.
     */
    function xformTokens(metadata, tokens) {
        var valid = __WEBPACK_IMPORTED_MODULE_3__type__["j" /* isString */](tokens) && tokens.length > 0;
        if (!valid) {
            // This can happen if objects are uploaded through GCS and retrieved
            // through list, so we don't want to throw an Error.
            return [];
        }
        var encode = encodeURIComponent;
        var tokensList = tokens.split(',');
        var urls = tokensList.map(function (token) {
            var bucket = metadata['bucket'];
            var path = metadata['fullPath'];
            var urlPart = '/b/' + encode(bucket) + '/o/' + encode(path);
            var base = __WEBPACK_IMPORTED_MODULE_4__url__["a" /* makeDownloadUrl */](urlPart);
            var queryString = __WEBPACK_IMPORTED_MODULE_4__url__["c" /* makeQueryString */]({
                alt: 'media',
                token: token
            });
            return base + queryString;
        });
        return urls;
    }
    mappings.push(new Mapping('downloadTokens', 'downloadURLs', false, xformTokens));
    mappings_ = mappings;
    return mappings_;
}
function addRef(metadata, authWrapper) {
    function generateRef() {
        var bucket = metadata['bucket'];
        var path = metadata['fullPath'];
        var loc = new __WEBPACK_IMPORTED_MODULE_1__location__["a" /* Location */](bucket, path);
        return authWrapper.makeStorageReference(loc);
    }
    Object.defineProperty(metadata, 'ref', { get: generateRef });
}
function fromResource(authWrapper, resource, mappings) {
    var metadata = {};
    metadata['type'] = 'file';
    var len = mappings.length;
    for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
    }
    addRef(metadata, authWrapper);
    return metadata;
}
function fromResourceString(authWrapper, resourceString, mappings) {
    var obj = __WEBPACK_IMPORTED_MODULE_0__json__["a" /* jsonObjectOrNull */](resourceString);
    if (obj === null) {
        return null;
    }
    var resource = obj;
    return fromResource(authWrapper, resource, mappings);
}
function toResourceString(metadata, mappings) {
    var resource = {};
    var len = mappings.length;
    for (var i = 0; i < len; i++) {
        var mapping = mappings[i];
        if (mapping.writable) {
            resource[mapping.server] = metadata[mapping.local];
        }
    }
    return JSON.stringify(resource);
}
function metadataValidator(p) {
    var validType = p && __WEBPACK_IMPORTED_MODULE_3__type__["i" /* isObject */](p);
    if (!validType) {
        throw 'Expected Metadata object.';
    }
    for (var key in p) {
        var val = p[key];
        if (key === 'customMetadata') {
            if (!__WEBPACK_IMPORTED_MODULE_3__type__["i" /* isObject */](val)) {
                throw 'Expected object for \'customMetadata\' mapping.';
            }
        }
        else {
            if (__WEBPACK_IMPORTED_MODULE_3__type__["g" /* isNonNullObject */](val)) {
                throw "Mapping for '" + key + "' cannot be an object.";
            }
        }
    }
}

//# sourceMappingURL=metadata.js.map


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = makeNormalUrl;
/* harmony export (immutable) */ __webpack_exports__["a"] = makeDownloadUrl;
/* harmony export (immutable) */ __webpack_exports__["d"] = makeUploadUrl;
/* harmony export (immutable) */ __webpack_exports__["c"] = makeQueryString;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__object__ = __webpack_require__(13);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Functions to create and manipulate URLs for the server API.
 */


function makeNormalUrl(urlPart) {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["f" /* domainBase */] + __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* apiBaseUrl */] + urlPart;
}
function makeDownloadUrl(urlPart) {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["g" /* downloadBase */] + __WEBPACK_IMPORTED_MODULE_0__constants__["a" /* apiBaseUrl */] + urlPart;
}
function makeUploadUrl(urlPart) {
    return __WEBPACK_IMPORTED_MODULE_0__constants__["f" /* domainBase */] + __WEBPACK_IMPORTED_MODULE_0__constants__["b" /* apiUploadBaseUrl */] + urlPart;
}
function makeQueryString(params) {
    var encode = encodeURIComponent;
    var queryPart = '?';
    __WEBPACK_IMPORTED_MODULE_1__object__["b" /* forEach */](params, function (key, val) {
        var nextPart = encode(key) + '=' + encode(val);
        queryPart = queryPart + nextPart + '&';
    });
    // Chop off the extra '&' or '?' on the end
    queryPart = queryPart.slice(0, -1);
    return queryPart;
}

//# sourceMappingURL=url.js.map


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = contains;
/* harmony export (immutable) */ __webpack_exports__["a"] = clone;
/* harmony export (immutable) */ __webpack_exports__["c"] = remove;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the object is contained in the array (compared with ===).
 * @template T
 */
function contains(array, elem) {
    return array.indexOf(elem) !== -1;
}
/**
 * Returns a shallow copy of the array or array-like object (e.g. arguments).
 * @template T
 */
function clone(arraylike) {
    return Array.prototype.slice.call(arraylike);
}
/**
 * Removes the given element from the given array, if it is contained.
 * Directly modifies the passed-in array.
 * @template T
 */
function remove(array, elem) {
    var i = array.indexOf(elem);
    if (i !== -1) {
        array.splice(i, 1);
    }
}

//# sourceMappingURL=array.js.map


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(82);
module.exports = __webpack_require__(8).default;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(101);


/***/ }),
/* 42 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(29);
/**
 * Throws an error if the provided assertion is falsy
 * @param {*} assertion The assertion to be tested for falsiness
 * @param {!string} message The message to display if the check fails
 */
exports.assert = function (assertion, message) {
    if (!assertion) {
        throw exports.assertionError(message);
    }
};
/**
 * Returns an Error object suitable for throwing.
 * @param {string} message
 * @return {!Error}
 */
exports.assertionError = function (message) {
    return new Error('Firebase Database (' +
        constants_1.CONSTANTS.SDK_VERSION +
        ') INTERNAL ASSERT FAILED: ' +
        message);
};

//# sourceMappingURL=assert.js.map


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var stringToByteArray = function (str) {
    var output = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        while (c > 255) {
            output[p++] = c & 255;
            c >>= 8;
        }
        output[p++] = c;
    }
    return output;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
var byteArrayToString = function (bytes) {
    var CHUNK_SIZE = 8192;
    // Special-case the simple case for speed's sake.
    if (bytes.length < CHUNK_SIZE) {
        return String.fromCharCode.apply(null, bytes);
    }
    // The remaining logic splits conversion by chunks since
    // Function#apply() has a maximum parameter count.
    // See discussion: http://goo.gl/LrWmZ9
    var str = '';
    for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
        var chunk = bytes.slice(i, i + CHUNK_SIZE);
        str += String.fromCharCode.apply(null, chunk);
    }
    return str;
};
// Static lookup maps, lazily populated by init_()
exports.base64 = {
    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     * @type {string}
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type {boolean}
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param {boolean=} opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeByteArray: function (input, opt_webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        var byteToCharMap = opt_webSafe
            ? this.byteToCharMapWebSafe_
            : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);
            var outByte3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray(input), opt_webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param {string} input to decode.
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {string} string representing the decoded value.
     */
    decodeString: function (input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param {string} input Input to decode.
     * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
     * @return {!Array<number>} bytes representing the decoded value.
     */
    decodeStringToByteArray: function (input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe
            ? this.charToByteMapWebSafe_
            : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            var outByte1 = (byte1 << 2) | (byte2 >> 4);
            output.push(outByte1);
            if (byte3 != 64) {
                var outByte2 = ((byte2 << 4) & 0xf0) | (byte3 >> 2);
                output.push(outByte2);
                if (byte4 != 64) {
                    var outByte3 = ((byte3 << 6) & 0xc0) | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function () {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 * @param {!string} str
 * @return {!string}
 */
exports.base64Encode = function (str) {
    var utf8Bytes = stringToByteArray(str);
    return exports.base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param {string} str To be decoded
 * @return {?string} Decoded result, if possible
 */
exports.base64Decode = function (str) {
    try {
        return exports.base64.decodeString(str, true);
    }
    catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

//# sourceMappingURL=crypt.js.map


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
    return JSON.parse(str);
}
exports.jsonEval = jsonEval;
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
    return JSON.stringify(data);
}
exports.stringify = stringify;

//# sourceMappingURL=json.js.map


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
exports.contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
exports.safeGet = function (obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key))
        return obj[key];
    // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
exports.forEach = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */
exports.extend = function (objTo, objFrom) {
    exports.forEach(objFrom, function (key, value) {
        objTo[key] = value;
    });
    return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */
exports.clone = function (obj) {
    return exports.extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 *
 * @param obj {*} A potential object.
 * @returns {boolean} True if it's an object.
 */
exports.isNonNullObject = function (obj) {
    return typeof obj === 'object' && obj !== null;
};
exports.isEmpty = function (obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};
exports.getCount = function (obj) {
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};
exports.map = function (obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};
exports.findKey = function (obj, fn, opt_this) {
    for (var key in obj) {
        if (fn.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};
exports.findValue = function (obj, fn, opt_this) {
    var key = exports.findKey(obj, fn, opt_this);
    return key && obj[key];
};
exports.getAnyKey = function (obj) {
    for (var key in obj) {
        return key;
    }
};
exports.getValues = function (obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
exports.every = function (obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!fn(key, obj[key])) {
                return false;
            }
        }
    }
    return true;
};

//# sourceMappingURL=obj.js.map


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
var parser_1 = __webpack_require__(48);
var Path_1 = __webpack_require__(2);
var Reference_1 = __webpack_require__(30);
var Repo_1 = __webpack_require__(23);
var RepoManager_1 = __webpack_require__(35);
var util_2 = __webpack_require__(0);
var validation_1 = __webpack_require__(9);
/**
 * Class representing a firebase database.
 * @implements {FirebaseService}
 */
var Database = /** @class */ (function () {
    /**
     * The constructor should not be called by users of our public API.
     * @param {!Repo} repo_
     */
    function Database(repo_) {
        this.repo_ = repo_;
        if (!(repo_ instanceof Repo_1.Repo)) {
            util_1.fatal("Don't call new Database() directly - please use firebase.database().");
        }
        /** @type {Reference} */
        this.root_ = new Reference_1.Reference(repo_, Path_1.Path.Empty);
        this.INTERNAL = new DatabaseInternals(this);
    }
    Object.defineProperty(Database.prototype, "app", {
        get: function () {
            return this.repo_.app;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a reference to the root or the path specified in opt_pathString.
     * @param {string=} pathString
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.ref = function (pathString) {
        this.checkDeleted_('ref');
        util_2.validateArgCount('database.ref', 0, 1, arguments.length);
        return pathString !== undefined ? this.root_.child(pathString) : this.root_;
    };
    /**
     * Returns a reference to the root or the path specified in url.
     * We throw a exception if the url is not in the same domain as the
     * current repo.
     * @param {string} url
     * @return {!Reference} Firebase reference.
     */
    Database.prototype.refFromURL = function (url) {
        /** @const {string} */
        var apiName = 'database.refFromURL';
        this.checkDeleted_(apiName);
        util_2.validateArgCount(apiName, 1, 1, arguments.length);
        var parsedURL = parser_1.parseRepoInfo(url);
        validation_1.validateUrl(apiName, 1, parsedURL);
        var repoInfo = parsedURL.repoInfo;
        if (repoInfo.host !== this.repo_.repoInfo_.host) {
            util_1.fatal(apiName +
                ': Host name does not match the current database: ' +
                '(found ' +
                repoInfo.host +
                ' but expected ' +
                this.repo_.repoInfo_.host +
                ')');
        }
        return this.ref(parsedURL.path.toString());
    };
    /**
     * @param {string} apiName
     */
    Database.prototype.checkDeleted_ = function (apiName) {
        if (this.repo_ === null) {
            util_1.fatal('Cannot call ' + apiName + ' on a deleted database.');
        }
    };
    // Make individual repo go offline.
    Database.prototype.goOffline = function () {
        util_2.validateArgCount('database.goOffline', 0, 0, arguments.length);
        this.checkDeleted_('goOffline');
        this.repo_.interrupt();
    };
    Database.prototype.goOnline = function () {
        util_2.validateArgCount('database.goOnline', 0, 0, arguments.length);
        this.checkDeleted_('goOnline');
        this.repo_.resume();
    };
    Database.ServerValue = {
        TIMESTAMP: {
            '.sv': 'timestamp'
        }
    };
    return Database;
}());
exports.Database = Database;
var DatabaseInternals = /** @class */ (function () {
    /** @param {!Database} database */
    function DatabaseInternals(database) {
        this.database = database;
    }
    /** @return {Promise<void>} */
    DatabaseInternals.prototype.delete = function () {
        this.database.checkDeleted_('delete');
        RepoManager_1.RepoManager.getInstance().deleteRepo(this.database.repo_);
        this.database.repo_ = null;
        this.database.root_ = null;
        this.database.INTERNAL = null;
        this.database = null;
        return Promise.resolve();
    };
    return DatabaseInternals;
}());
exports.DatabaseInternals = DatabaseInternals;

//# sourceMappingURL=Database.js.map


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = __webpack_require__(2);
var RepoInfo_1 = __webpack_require__(49);
var util_1 = __webpack_require__(1);
/**
 * @param {!string} pathString
 * @return {string}
 */
function decodePath(pathString) {
    var pathStringDecoded = '';
    var pieces = pathString.split('/');
    for (var i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
            var piece = pieces[i];
            try {
                piece = decodeURIComponent(piece.replace(/\+/g, ' '));
            }
            catch (e) { }
            pathStringDecoded += '/' + piece;
        }
    }
    return pathStringDecoded;
}
/**
 *
 * @param {!string} dataURL
 * @return {{repoInfo: !RepoInfo, path: !Path}}
 */
exports.parseRepoInfo = function (dataURL) {
    var parsedUrl = exports.parseURL(dataURL), namespace = parsedUrl.subdomain;
    if (parsedUrl.domain === 'firebase') {
        util_1.fatal(parsedUrl.host +
            ' is no longer supported. ' +
            'Please use <YOUR FIREBASE>.firebaseio.com instead');
    }
    // Catch common error of uninitialized namespace value.
    if (!namespace || namespace == 'undefined') {
        util_1.fatal('Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com');
    }
    if (!parsedUrl.secure) {
        util_1.warnIfPageIsSecure();
    }
    var webSocketOnly = parsedUrl.scheme === 'ws' || parsedUrl.scheme === 'wss';
    return {
        repoInfo: new RepoInfo_1.RepoInfo(parsedUrl.host, parsedUrl.secure, namespace, webSocketOnly),
        path: new Path_1.Path(parsedUrl.pathString)
    };
};
/**
 *
 * @param {!string} dataURL
 * @return {{host: string, port: number, domain: string, subdomain: string, secure: boolean, scheme: string, pathString: string}}
 */
exports.parseURL = function (dataURL) {
    // Default to empty strings in the event of a malformed string.
    var host = '', domain = '', subdomain = '', pathString = '';
    // Always default to SSL, unless otherwise specified.
    var secure = true, scheme = 'https', port = 443;
    // Don't do any validation here. The caller is responsible for validating the result of parsing.
    if (typeof dataURL === 'string') {
        // Parse scheme.
        var colonInd = dataURL.indexOf('//');
        if (colonInd >= 0) {
            scheme = dataURL.substring(0, colonInd - 1);
            dataURL = dataURL.substring(colonInd + 2);
        }
        // Parse host and path.
        var slashInd = dataURL.indexOf('/');
        if (slashInd === -1) {
            slashInd = dataURL.length;
        }
        host = dataURL.substring(0, slashInd);
        pathString = decodePath(dataURL.substring(slashInd));
        var parts = host.split('.');
        if (parts.length === 3) {
            // Normalize namespaces to lowercase to share storage / connection.
            domain = parts[1];
            subdomain = parts[0].toLowerCase();
        }
        else if (parts.length === 2) {
            domain = parts[0];
        }
        // If we have a port, use scheme for determining if it's secure.
        colonInd = host.indexOf(':');
        if (colonInd >= 0) {
            secure = scheme === 'https' || scheme === 'wss';
            port = parseInt(host.substring(colonInd + 1), 10);
        }
    }
    return {
        host: host,
        port: port,
        domain: domain,
        subdomain: subdomain,
        secure: secure,
        scheme: scheme,
        pathString: pathString
    };
};

//# sourceMappingURL=parser.js.map


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var storage_1 = __webpack_require__(18);
var Constants_1 = __webpack_require__(19);
/**
 * A class that holds metadata about a Repo object
 *
 * @constructor
 */
var RepoInfo = /** @class */ (function () {
    /**
     * @param {string} host Hostname portion of the url for the repo
     * @param {boolean} secure Whether or not this repo is accessed over ssl
     * @param {string} namespace The namespace represented by the repo
     * @param {boolean} webSocketOnly Whether to prefer websockets over all other transports (used by Nest).
     * @param {string=} persistenceKey Override the default session persistence storage key
     */
    function RepoInfo(host, secure, namespace, webSocketOnly, persistenceKey) {
        if (persistenceKey === void 0) { persistenceKey = ''; }
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.persistenceKey = persistenceKey;
        this.host = host.toLowerCase();
        this.domain = this.host.substr(this.host.indexOf('.') + 1);
        this.internalHost = storage_1.PersistentStorage.get('host:' + host) || this.host;
    }
    RepoInfo.prototype.needsQueryParam = function () {
        return this.host !== this.internalHost;
    };
    RepoInfo.prototype.isCacheableHost = function () {
        return this.internalHost.substr(0, 2) === 's-';
    };
    RepoInfo.prototype.isDemoHost = function () {
        return this.domain === 'firebaseio-demo.com';
    };
    RepoInfo.prototype.isCustomHost = function () {
        return (this.domain !== 'firebaseio.com' && this.domain !== 'firebaseio-demo.com');
    };
    RepoInfo.prototype.updateHost = function (newHost) {
        if (newHost !== this.internalHost) {
            this.internalHost = newHost;
            if (this.isCacheableHost()) {
                storage_1.PersistentStorage.set('host:' + this.host, this.internalHost);
            }
        }
    };
    /**
     * Returns the websocket URL for this repo
     * @param {string} type of connection
     * @param {Object} params list
     * @return {string} The URL for this repo
     */
    RepoInfo.prototype.connectionURL = function (type, params) {
        util_1.assert(typeof type === 'string', 'typeof type must == string');
        util_1.assert(typeof params === 'object', 'typeof params must == object');
        var connURL;
        if (type === Constants_1.WEBSOCKET) {
            connURL =
                (this.secure ? 'wss://' : 'ws://') + this.internalHost + '/.ws?';
        }
        else if (type === Constants_1.LONG_POLLING) {
            connURL =
                (this.secure ? 'https://' : 'http://') + this.internalHost + '/.lp?';
        }
        else {
            throw new Error('Unknown connection type: ' + type);
        }
        if (this.needsQueryParam()) {
            params['ns'] = this.namespace;
        }
        var pairs = [];
        util_2.forEach(params, function (key, value) {
            pairs.push(key + '=' + value);
        });
        return connURL + pairs.join('&');
    };
    /** @return {string} */
    RepoInfo.prototype.toString = function () {
        var str = this.toURLString();
        if (this.persistenceKey) {
            str += '<' + this.persistenceKey + '>';
        }
        return str;
    };
    /** @return {string} */
    RepoInfo.prototype.toURLString = function () {
        return (this.secure ? 'https://' : 'http://') + this.host;
    };
    return RepoInfo;
}());
exports.RepoInfo = RepoInfo;

//# sourceMappingURL=RepoInfo.js.map


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var validation_1 = __webpack_require__(9);
var util_2 = __webpack_require__(1);
var util_3 = __webpack_require__(0);
/**
 * @constructor
 */
var OnDisconnect = /** @class */ (function () {
    /**
     * @param {!Repo} repo_
     * @param {!Path} path_
     */
    function OnDisconnect(repo_, path_) {
        this.repo_ = repo_;
        this.path_ = path_;
    }
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.cancel = function (onComplete) {
        util_1.validateArgCount('OnDisconnect.cancel', 0, 1, arguments.length);
        util_1.validateCallback('OnDisconnect.cancel', 1, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectCancel(this.path_, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.remove = function (onComplete) {
        util_1.validateArgCount('OnDisconnect.remove', 0, 1, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.remove', this.path_);
        util_1.validateCallback('OnDisconnect.remove', 1, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSet(this.path_, null, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.set = function (value, onComplete) {
        util_1.validateArgCount('OnDisconnect.set', 1, 2, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.set', this.path_);
        validation_1.validateFirebaseDataArg('OnDisconnect.set', 1, value, this.path_, false);
        util_1.validateCallback('OnDisconnect.set', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSet(this.path_, value, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {*} value
     * @param {number|string|null} priority
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.setWithPriority = function (value, priority, onComplete) {
        util_1.validateArgCount('OnDisconnect.setWithPriority', 2, 3, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.setWithPriority', this.path_);
        validation_1.validateFirebaseDataArg('OnDisconnect.setWithPriority', 1, value, this.path_, false);
        validation_1.validatePriority('OnDisconnect.setWithPriority', 2, priority, false);
        util_1.validateCallback('OnDisconnect.setWithPriority', 3, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectSetWithPriority(this.path_, value, priority, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    /**
     * @param {!Object} objectToMerge
     * @param {function(?Error)=} onComplete
     * @return {!firebase.Promise}
     */
    OnDisconnect.prototype.update = function (objectToMerge, onComplete) {
        util_1.validateArgCount('OnDisconnect.update', 1, 2, arguments.length);
        validation_1.validateWritablePath('OnDisconnect.update', this.path_);
        if (Array.isArray(objectToMerge)) {
            var newObjectToMerge = {};
            for (var i = 0; i < objectToMerge.length; ++i) {
                newObjectToMerge['' + i] = objectToMerge[i];
            }
            objectToMerge = newObjectToMerge;
            util_2.warn('Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the ' +
                'existing data, or an Object with integer keys if you really do want to only update some of the children.');
        }
        validation_1.validateFirebaseMergeDataArg('OnDisconnect.update', 1, objectToMerge, this.path_, false);
        util_1.validateCallback('OnDisconnect.update', 2, onComplete, true);
        var deferred = new util_3.Deferred();
        this.repo_.onDisconnectUpdate(this.path_, objectToMerge, deferred.wrapCallback(onComplete));
        return deferred.promise;
    };
    return OnDisconnect;
}());
exports.OnDisconnect = OnDisconnect;

//# sourceMappingURL=onDisconnect.js.map


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var KeyIndex_1 = __webpack_require__(14);
var PriorityIndex_1 = __webpack_require__(3);
var ValueIndex_1 = __webpack_require__(53);
var PathIndex_1 = __webpack_require__(57);
var util_2 = __webpack_require__(1);
var Path_1 = __webpack_require__(2);
var validation_1 = __webpack_require__(9);
var util_3 = __webpack_require__(0);
var EventRegistration_1 = __webpack_require__(107);
var util_4 = __webpack_require__(0);
var __referenceConstructor;
/**
 * A Query represents a filter to be applied to a firebase location.  This object purely represents the
 * query expression (and exposes our public API to build the query).  The actual query logic is in ViewBase.js.
 *
 * Since every Firebase reference is a query, Firebase inherits from this object.
 */
var Query = /** @class */ (function () {
    function Query(repo, path, queryParams_, orderByCalled_) {
        this.repo = repo;
        this.path = path;
        this.queryParams_ = queryParams_;
        this.orderByCalled_ = orderByCalled_;
    }
    Object.defineProperty(Query, "__referenceConstructor", {
        get: function () {
            util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Validates start/end values for queries.
     * @param {!QueryParams} params
     * @private
     */
    Query.validateQueryEndpoints_ = function (params) {
        var startNode = null;
        var endNode = null;
        if (params.hasStart()) {
            startNode = params.getIndexStartValue();
        }
        if (params.hasEnd()) {
            endNode = params.getIndexEndValue();
        }
        if (params.getIndex() === KeyIndex_1.KEY_INDEX) {
            var tooManyArgsError = 'Query: When ordering by key, you may only pass one argument to ' +
                'startAt(), endAt(), or equalTo().';
            var wrongArgTypeError = 'Query: When ordering by key, the argument passed to startAt(), endAt(),' +
                'or equalTo() must be a string.';
            if (params.hasStart()) {
                var startName = params.getIndexStartName();
                if (startName != util_2.MIN_NAME) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof startNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
            if (params.hasEnd()) {
                var endName = params.getIndexEndName();
                if (endName != util_2.MAX_NAME) {
                    throw new Error(tooManyArgsError);
                }
                else if (typeof endNode !== 'string') {
                    throw new Error(wrongArgTypeError);
                }
            }
        }
        else if (params.getIndex() === PriorityIndex_1.PRIORITY_INDEX) {
            if ((startNode != null && !validation_1.isValidPriority(startNode)) ||
                (endNode != null && !validation_1.isValidPriority(endNode))) {
                throw new Error('Query: When ordering by priority, the first argument passed to startAt(), ' +
                    'endAt(), or equalTo() must be a valid priority value (null, a number, or a string).');
            }
        }
        else {
            util_1.assert(params.getIndex() instanceof PathIndex_1.PathIndex ||
                params.getIndex() === ValueIndex_1.VALUE_INDEX, 'unknown index type.');
            if ((startNode != null && typeof startNode === 'object') ||
                (endNode != null && typeof endNode === 'object')) {
                throw new Error('Query: First argument passed to startAt(), endAt(), or equalTo() cannot be ' +
                    'an object.');
            }
        }
    };
    /**
     * Validates that limit* has been called with the correct combination of parameters
     * @param {!QueryParams} params
     * @private
     */
    Query.validateLimit_ = function (params) {
        if (params.hasStart() &&
            params.hasEnd() &&
            params.hasLimit() &&
            !params.hasAnchoredLimit()) {
            throw new Error("Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead.");
        }
    };
    /**
     * Validates that no other order by call has been made
     * @param {!string} fnName
     * @private
     */
    Query.prototype.validateNoPreviousOrderByCall_ = function (fnName) {
        if (this.orderByCalled_ === true) {
            throw new Error(fnName + ": You can't combine multiple orderBy calls.");
        }
    };
    /**
     * @return {!QueryParams}
     */
    Query.prototype.getQueryParams = function () {
        return this.queryParams_;
    };
    /**
     * @return {!Reference}
     */
    Query.prototype.getRef = function () {
        util_3.validateArgCount('Query.ref', 0, 0, arguments.length);
        // This is a slight hack. We cannot goog.require('fb.api.Firebase'), since Firebase requires fb.api.Query.
        // However, we will always export 'Firebase' to the global namespace, so it's guaranteed to exist by the time this
        // method gets called.
        return new Query.__referenceConstructor(this.repo, this.path);
    };
    /**
     * @param {!string} eventType
     * @param {!function(DataSnapshot, string=)} callback
     * @param {(function(Error)|Object)=} cancelCallbackOrContext
     * @param {Object=} context
     * @return {!function(DataSnapshot, string=)}
     */
    Query.prototype.on = function (eventType, callback, cancelCallbackOrContext, context) {
        util_3.validateArgCount('Query.on', 2, 4, arguments.length);
        validation_1.validateEventType('Query.on', 1, eventType, false);
        util_3.validateCallback('Query.on', 2, callback, false);
        var ret = Query.getCancelAndContextArgs_('Query.on', cancelCallbackOrContext, context);
        if (eventType === 'value') {
            this.onValueEvent(callback, ret.cancel, ret.context);
        }
        else {
            var callbacks = {};
            callbacks[eventType] = callback;
            this.onChildEvent(callbacks, ret.cancel, ret.context);
        }
        return callback;
    };
    /**
     * @param {!function(!DataSnapshot)} callback
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onValueEvent = function (callback, cancelCallback, context) {
        var container = new EventRegistration_1.ValueEventRegistration(callback, cancelCallback || null, context || null);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {!Object.<string, !function(!DataSnapshot, ?string)>} callbacks
     * @param {?function(Error)} cancelCallback
     * @param {?Object} context
     * @protected
     */
    Query.prototype.onChildEvent = function (callbacks, cancelCallback, context) {
        var container = new EventRegistration_1.ChildEventRegistration(callbacks, cancelCallback, context);
        this.repo.addEventCallbackForQuery(this, container);
    };
    /**
     * @param {string=} eventType
     * @param {(function(!DataSnapshot, ?string=))=} callback
     * @param {Object=} context
     */
    Query.prototype.off = function (eventType, callback, context) {
        util_3.validateArgCount('Query.off', 0, 3, arguments.length);
        validation_1.validateEventType('Query.off', 1, eventType, true);
        util_3.validateCallback('Query.off', 2, callback, true);
        util_3.validateContextObject('Query.off', 3, context, true);
        var container = null;
        var callbacks = null;
        if (eventType === 'value') {
            var valueCallback = callback || null;
            container = new EventRegistration_1.ValueEventRegistration(valueCallback, null, context || null);
        }
        else if (eventType) {
            if (callback) {
                callbacks = {};
                callbacks[eventType] = callback;
            }
            container = new EventRegistration_1.ChildEventRegistration(callbacks, null, context || null);
        }
        this.repo.removeEventCallbackForQuery(this, container);
    };
    /**
     * Attaches a listener, waits for the first event, and then removes the listener
     * @param {!string} eventType
     * @param {!function(!DataSnapshot, string=)} userCallback
     * @param cancelOrContext
     * @param context
     * @return {!firebase.Promise}
     */
    Query.prototype.once = function (eventType, userCallback, cancelOrContext, context) {
        var _this = this;
        util_3.validateArgCount('Query.once', 1, 4, arguments.length);
        validation_1.validateEventType('Query.once', 1, eventType, false);
        util_3.validateCallback('Query.once', 2, userCallback, true);
        var ret = Query.getCancelAndContextArgs_('Query.once', cancelOrContext, context);
        // TODO: Implement this more efficiently (in particular, use 'get' wire protocol for 'value' event)
        // TODO: consider actually wiring the callbacks into the promise. We cannot do this without a breaking change
        // because the API currently expects callbacks will be called synchronously if the data is cached, but this is
        // against the Promise specification.
        var firstCall = true;
        var deferred = new util_4.Deferred();
        // A dummy error handler in case a user wasn't expecting promises
        deferred.promise.catch(function () { });
        var onceCallback = function (snapshot) {
            // NOTE: Even though we unsubscribe, we may get called multiple times if a single action (e.g. set() with JSON)
            // triggers multiple events (e.g. child_added or child_changed).
            if (firstCall) {
                firstCall = false;
                _this.off(eventType, onceCallback);
                if (userCallback) {
                    userCallback.bind(ret.context)(snapshot);
                }
                deferred.resolve(snapshot);
            }
        };
        this.on(eventType, onceCallback, 
        /*cancel=*/ function (err) {
            _this.off(eventType, onceCallback);
            if (ret.cancel)
                ret.cancel.bind(ret.context)(err);
            deferred.reject(err);
        });
        return deferred.promise;
    };
    /**
     * Set a limit and anchor it to the start of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToFirst = function (limit) {
        util_3.validateArgCount('Query.limitToFirst', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToFirst: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToFirst: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToFirst(limit), this.orderByCalled_);
    };
    /**
     * Set a limit and anchor it to the end of the window.
     * @param {!number} limit
     * @return {!Query}
     */
    Query.prototype.limitToLast = function (limit) {
        util_3.validateArgCount('Query.limitToLast', 1, 1, arguments.length);
        if (typeof limit !== 'number' ||
            Math.floor(limit) !== limit ||
            limit <= 0) {
            throw new Error('Query.limitToLast: First argument must be a positive integer.');
        }
        if (this.queryParams_.hasLimit()) {
            throw new Error('Query.limitToLast: Limit was already set (by another call to limit, ' +
                'limitToFirst, or limitToLast).');
        }
        return new Query(this.repo, this.path, this.queryParams_.limitToLast(limit), this.orderByCalled_);
    };
    /**
     * Given a child path, return a new query ordered by the specified grandchild path.
     * @param {!string} path
     * @return {!Query}
     */
    Query.prototype.orderByChild = function (path) {
        util_3.validateArgCount('Query.orderByChild', 1, 1, arguments.length);
        if (path === '$key') {
            throw new Error('Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.');
        }
        else if (path === '$priority') {
            throw new Error('Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.');
        }
        else if (path === '$value') {
            throw new Error('Query.orderByChild: "$value" is invalid.  Use Query.orderByValue() instead.');
        }
        validation_1.validatePathString('Query.orderByChild', 1, path, false);
        this.validateNoPreviousOrderByCall_('Query.orderByChild');
        var parsedPath = new Path_1.Path(path);
        if (parsedPath.isEmpty()) {
            throw new Error('Query.orderByChild: cannot pass in empty path.  Use Query.orderByValue() instead.');
        }
        var index = new PathIndex_1.PathIndex(parsedPath);
        var newParams = this.queryParams_.orderBy(index);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the KeyIndex
     * @return {!Query}
     */
    Query.prototype.orderByKey = function () {
        util_3.validateArgCount('Query.orderByKey', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByKey');
        var newParams = this.queryParams_.orderBy(KeyIndex_1.KEY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the PriorityIndex
     * @return {!Query}
     */
    Query.prototype.orderByPriority = function () {
        util_3.validateArgCount('Query.orderByPriority', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByPriority');
        var newParams = this.queryParams_.orderBy(PriorityIndex_1.PRIORITY_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * Return a new query ordered by the ValueIndex
     * @return {!Query}
     */
    Query.prototype.orderByValue = function () {
        util_3.validateArgCount('Query.orderByValue', 0, 0, arguments.length);
        this.validateNoPreviousOrderByCall_('Query.orderByValue');
        var newParams = this.queryParams_.orderBy(ValueIndex_1.VALUE_INDEX);
        Query.validateQueryEndpoints_(newParams);
        return new Query(this.repo, this.path, newParams, /*orderByCalled=*/ true);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.startAt = function (value, name) {
        if (value === void 0) { value = null; }
        util_3.validateArgCount('Query.startAt', 0, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.startAt', 1, value, this.path, true);
        validation_1.validateKey('Query.startAt', 2, name, true);
        var newParams = this.queryParams_.startAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.startAt: Starting point was already set (by another call to startAt ' +
                'or equalTo).');
        }
        // Calling with no params tells us to start at the beginning.
        if (value === undefined) {
            value = null;
            name = null;
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * @param {number|string|boolean|null} value
     * @param {?string=} name
     * @return {!Query}
     */
    Query.prototype.endAt = function (value, name) {
        if (value === void 0) { value = null; }
        util_3.validateArgCount('Query.endAt', 0, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.endAt', 1, value, this.path, true);
        validation_1.validateKey('Query.endAt', 2, name, true);
        var newParams = this.queryParams_.endAt(value, name);
        Query.validateLimit_(newParams);
        Query.validateQueryEndpoints_(newParams);
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.endAt: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return new Query(this.repo, this.path, newParams, this.orderByCalled_);
    };
    /**
     * Load the selection of children with exactly the specified value, and, optionally,
     * the specified name.
     * @param {number|string|boolean|null} value
     * @param {string=} name
     * @return {!Query}
     */
    Query.prototype.equalTo = function (value, name) {
        util_3.validateArgCount('Query.equalTo', 1, 2, arguments.length);
        validation_1.validateFirebaseDataArg('Query.equalTo', 1, value, this.path, false);
        validation_1.validateKey('Query.equalTo', 2, name, true);
        if (this.queryParams_.hasStart()) {
            throw new Error('Query.equalTo: Starting point was already set (by another call to startAt or ' +
                'equalTo).');
        }
        if (this.queryParams_.hasEnd()) {
            throw new Error('Query.equalTo: Ending point was already set (by another call to endAt or ' +
                'equalTo).');
        }
        return this.startAt(value, name).endAt(value, name);
    };
    /**
     * @return {!string} URL for this location.
     */
    Query.prototype.toString = function () {
        util_3.validateArgCount('Query.toString', 0, 0, arguments.length);
        return this.repo.toString() + this.path.toUrlEncodedString();
    };
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users.
    Query.prototype.toJSON = function () {
        // An optional spacer argument is unnecessary for a string.
        util_3.validateArgCount('Query.toJSON', 0, 1, arguments.length);
        return this.toString();
    };
    /**
     * An object representation of the query parameters used by this Query.
     * @return {!Object}
     */
    Query.prototype.queryObject = function () {
        return this.queryParams_.getQueryObject();
    };
    /**
     * @return {!string}
     */
    Query.prototype.queryIdentifier = function () {
        var obj = this.queryObject();
        var id = util_2.ObjectToUniqueKey(obj);
        return id === '{}' ? 'default' : id;
    };
    /**
     * Return true if this query and the provided query are equivalent; otherwise, return false.
     * @param {Query} other
     * @return {boolean}
     */
    Query.prototype.isEqual = function (other) {
        util_3.validateArgCount('Query.isEqual', 1, 1, arguments.length);
        if (!(other instanceof Query)) {
            var error = 'Query.isEqual failed: First argument must be an instance of firebase.database.Query.';
            throw new Error(error);
        }
        var sameRepo = this.repo === other.repo;
        var samePath = this.path.equals(other.path);
        var sameQueryIdentifier = this.queryIdentifier() === other.queryIdentifier();
        return sameRepo && samePath && sameQueryIdentifier;
    };
    /**
     * Helper used by .on and .once to extract the context and or cancel arguments.
     * @param {!string} fnName The function name (on or once)
     * @param {(function(Error)|Object)=} cancelOrContext
     * @param {Object=} context
     * @return {{cancel: ?function(Error), context: ?Object}}
     * @private
     */
    Query.getCancelAndContextArgs_ = function (fnName, cancelOrContext, context) {
        var ret = { cancel: null, context: null };
        if (cancelOrContext && context) {
            ret.cancel = cancelOrContext;
            util_3.validateCallback(fnName, 3, ret.cancel, true);
            ret.context = context;
            util_3.validateContextObject(fnName, 4, ret.context, true);
        }
        else if (cancelOrContext) {
            // we have either a cancel callback or a context.
            if (typeof cancelOrContext === 'object' && cancelOrContext !== null) {
                // it's a context!
                ret.context = cancelOrContext;
            }
            else if (typeof cancelOrContext === 'function') {
                ret.cancel = cancelOrContext;
            }
            else {
                throw new Error(util_3.errorPrefix(fnName, 3, true) +
                    ' must either be a cancel callback or a context object.');
            }
        }
        return ret;
    };
    Object.defineProperty(Query.prototype, "ref", {
        get: function () {
            return this.getRef();
        },
        enumerable: true,
        configurable: true
    });
    return Query;
}());
exports.Query = Query;

//# sourceMappingURL=Query.js.map


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var util_3 = __webpack_require__(0);
var MAX_NODE;
function setMaxNode(val) {
    MAX_NODE = val;
}
exports.setMaxNode = setMaxNode;
/**
 * @param {(!string|!number)} priority
 * @return {!string}
 */
exports.priorityHashText = function (priority) {
    if (typeof priority === 'number')
        return 'number:' + util_2.doubleToIEEE754String(priority);
    else
        return 'string:' + priority;
};
/**
 * Validates that a priority snapshot Node is valid.
 *
 * @param {!Node} priorityNode
 */
exports.validatePriorityNode = function (priorityNode) {
    if (priorityNode.isLeafNode()) {
        var val = priorityNode.val();
        util_1.assert(typeof val === 'string' ||
            typeof val === 'number' ||
            (typeof val === 'object' && util_3.contains(val, '.sv')), 'Priority must be a string or number.');
    }
    else {
        util_1.assert(priorityNode === MAX_NODE || priorityNode.isEmpty(), 'priority of unexpected type.');
    }
    // Don't call getPriority() on MAX_NODE to avoid hitting assertion.
    util_1.assert(priorityNode === MAX_NODE || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};

//# sourceMappingURL=snap.js.map


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Index_1 = __webpack_require__(20);
var Node_1 = __webpack_require__(5);
var util_1 = __webpack_require__(1);
var nodeFromJSON_1 = __webpack_require__(15);
/**
 * @constructor
 * @extends {Index}
 * @private
 */
var ValueIndex = /** @class */ (function (_super) {
    __extends(ValueIndex, _super);
    function ValueIndex() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.compare = function (a, b) {
        var indexCmp = a.node.compareTo(b.node);
        if (indexCmp === 0) {
            return util_1.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.isDefinedOn = function (node) {
        return true;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.indexedValueChanged = function (oldNode, newNode) {
        return !oldNode.equals(newNode);
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.minPost = function () {
        return Node_1.NamedNode.MIN;
    };
    /**
     * @inheritDoc
     */
    ValueIndex.prototype.maxPost = function () {
        return Node_1.NamedNode.MAX;
    };
    /**
     * @param {*} indexValue
     * @param {string} name
     * @return {!NamedNode}
     */
    ValueIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON_1.nodeFromJSON(indexValue);
        return new Node_1.NamedNode(name, valueNode);
    };
    /**
     * @return {!string} String representation for inclusion in a query spec
     */
    ValueIndex.prototype.toString = function () {
        return '.value';
    };
    return ValueIndex;
}(Index_1.Index));
exports.ValueIndex = ValueIndex;
exports.VALUE_INDEX = new ValueIndex();

//# sourceMappingURL=ValueIndex.js.map


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var childSet_1 = __webpack_require__(55);
var util_2 = __webpack_require__(0);
var Node_1 = __webpack_require__(5);
var PriorityIndex_1 = __webpack_require__(3);
var KeyIndex_1 = __webpack_require__(14);
var _defaultIndexMap;
var fallbackObject = {};
/**
 *
 * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes
 * @param {Object.<string, Index>} indexSet
 * @constructor
 */
var IndexMap = /** @class */ (function () {
    function IndexMap(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap, "Default", {
        /**
         * The default IndexMap for nodes without a priority
         * @type {!IndexMap}
         * @const
         */
        get: function () {
            util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');
            _defaultIndexMap =
                _defaultIndexMap ||
                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PriorityIndex_1.PRIORITY_INDEX });
            return _defaultIndexMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param {!string} indexKey
     * @return {?SortedMap.<NamedNode, Node>}
     */
    IndexMap.prototype.get = function (indexKey) {
        var sortedMap = util_2.safeGet(this.indexes_, indexKey);
        if (!sortedMap)
            throw new Error('No index defined for ' + indexKey);
        if (sortedMap === fallbackObject) {
            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the
            // regular child map
            return null;
        }
        else {
            return sortedMap;
        }
    };
    /**
     * @param {!Index} indexDefinition
     * @return {boolean}
     */
    IndexMap.prototype.hasIndex = function (indexDefinition) {
        return util_2.contains(this.indexSet_, indexDefinition.toString());
    };
    /**
     * @param {!Index} indexDefinition
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {
        util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        var childList = [];
        var sawIndexedValue = false;
        var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
        var next = iter.getNext();
        while (next) {
            sawIndexedValue =
                sawIndexedValue || indexDefinition.isDefinedOn(next.node);
            childList.push(next);
            next = iter.getNext();
        }
        var newIndex;
        if (sawIndexedValue) {
            newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());
        }
        else {
            newIndex = fallbackObject;
        }
        var indexName = indexDefinition.toString();
        var newIndexSet = util_2.clone(this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        var newIndexes = util_2.clone(this.indexes_);
        newIndexes[indexName] = newIndex;
        return new IndexMap(newIndexes, newIndexSet);
    };
    /**
     * Ensure that this node is properly tracked in any indexes that we're maintaining
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {
        var _this = this;
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {
            var index = util_2.safeGet(_this.indexSet_, indexName);
            util_1.assert(index, 'Missing index implementation for ' + indexName);
            if (indexedChildren === fallbackObject) {
                // Check to see if we need to index everything
                if (index.isDefinedOn(namedNode.node)) {
                    // We need to build this index
                    var childList = [];
                    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);
                    var next = iter.getNext();
                    while (next) {
                        if (next.name != namedNode.name) {
                            childList.push(next);
                        }
                        next = iter.getNext();
                    }
                    childList.push(namedNode);
                    return childSet_1.buildChildSet(childList, index.getCompare());
                }
                else {
                    // No change, this remains a fallback
                    return fallbackObject;
                }
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                var newChildren = indexedChildren;
                if (existingSnap) {
                    newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                }
                return newChildren.insert(namedNode, namedNode.node);
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    /**
     * Create a new IndexMap instance with the given value removed
     * @param {!NamedNode} namedNode
     * @param {!SortedMap.<string, !Node>} existingChildren
     * @return {!IndexMap}
     */
    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {
        var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {
            if (indexedChildren === fallbackObject) {
                // This is the fallback. Just return it, nothing to do in this case
                return indexedChildren;
            }
            else {
                var existingSnap = existingChildren.get(namedNode.name);
                if (existingSnap) {
                    return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));
                }
                else {
                    // No record of this child
                    return indexedChildren;
                }
            }
        });
        return new IndexMap(newIndexes, this.indexSet_);
    };
    return IndexMap;
}());
exports.IndexMap = IndexMap;

//# sourceMappingURL=IndexMap.js.map


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var SortedMap_1 = __webpack_require__(22);
var SortedMap_2 = __webpack_require__(22);
var LOG_2 = Math.log(2);
/**
 * @constructor
 */
var Base12Num = /** @class */ (function () {
    /**
     * @param {number} length
     */
    function Base12Num(length) {
        var logBase2 = function (num) {
            return parseInt((Math.log(num) / LOG_2), 10);
        };
        var bitMask = function (bits) { return parseInt(Array(bits + 1).join('1'), 2); };
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        var mask = bitMask(this.count);
        this.bits_ = (length + 1) & mask;
    }
    /**
     * @return {boolean}
     */
    Base12Num.prototype.nextBitIsOne = function () {
        //noinspection JSBitwiseOperatorUsage
        var result = !(this.bits_ & (0x1 << this.current_));
        this.current_--;
        return result;
    };
    return Base12Num;
}());
/**
 * Takes a list of child nodes and constructs a SortedSet using the given comparison
 * function
 *
 * Uses the algorithm described in the paper linked here:
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.1458
 *
 * @template K, V
 * @param {Array.<!NamedNode>} childList Unsorted list of children
 * @param {function(!NamedNode, !NamedNode):number} cmp The comparison method to be used
 * @param {(function(NamedNode):K)=} keyFn An optional function to extract K from a node wrapper, if K's
 *                                                        type is not NamedNode
 * @param {(function(K, K):number)=} mapSortFn An optional override for comparator used by the generated sorted map
 * @return {SortedMap.<K, V>}
 */
exports.buildChildSet = function (childList, cmp, keyFn, mapSortFn) {
    childList.sort(cmp);
    var buildBalancedTree = function (low, high) {
        var length = high - low;
        var namedNode;
        var key;
        if (length == 0) {
            return null;
        }
        else if (length == 1) {
            namedNode = childList[low];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, null, null);
        }
        else {
            var middle = parseInt((length / 2), 10) + low;
            var left = buildBalancedTree(low, middle);
            var right = buildBalancedTree(middle + 1, high);
            namedNode = childList[middle];
            key = keyFn ? keyFn(namedNode) : namedNode;
            return new SortedMap_1.LLRBNode(key, namedNode.node, SortedMap_1.LLRBNode.BLACK, left, right);
        }
    };
    var buildFrom12Array = function (base12) {
        var node = null;
        var root = null;
        var index = childList.length;
        var buildPennant = function (chunkSize, color) {
            var low = index - chunkSize;
            var high = index;
            index -= chunkSize;
            var childTree = buildBalancedTree(low + 1, high);
            var namedNode = childList[low];
            var key = keyFn ? keyFn(namedNode) : namedNode;
            attachPennant(new SortedMap_1.LLRBNode(key, namedNode.node, color, null, childTree));
        };
        var attachPennant = function (pennant) {
            if (node) {
                node.left = pennant;
                node = pennant;
            }
            else {
                root = pennant;
                node = pennant;
            }
        };
        for (var i = 0; i < base12.count; ++i) {
            var isOne = base12.nextBitIsOne();
            // The number of nodes taken in each slice is 2^(arr.length - (i + 1))
            var chunkSize = Math.pow(2, base12.count - (i + 1));
            if (isOne) {
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
            }
            else {
                // current == 2
                buildPennant(chunkSize, SortedMap_1.LLRBNode.BLACK);
                buildPennant(chunkSize, SortedMap_1.LLRBNode.RED);
            }
        }
        return root;
    };
    var base12 = new Base12Num(childList.length);
    var root = buildFrom12Array(base12);
    return new SortedMap_2.SortedMap(mapSortFn || cmp, root);
};

//# sourceMappingURL=childSet.js.map


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
function NAME_ONLY_COMPARATOR(left, right) {
    return util_1.nameCompare(left.name, right.name);
}
exports.NAME_ONLY_COMPARATOR = NAME_ONLY_COMPARATOR;
function NAME_COMPARATOR(left, right) {
    return util_1.nameCompare(left, right);
}
exports.NAME_COMPARATOR = NAME_COMPARATOR;

//# sourceMappingURL=comparators.js.map


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var Index_1 = __webpack_require__(20);
var ChildrenNode_1 = __webpack_require__(4);
var Node_1 = __webpack_require__(5);
var nodeFromJSON_1 = __webpack_require__(15);
/**
 * @param {!Path} indexPath
 * @constructor
 * @extends {Index}
 */
var PathIndex = /** @class */ (function (_super) {
    __extends(PathIndex, _super);
    function PathIndex(indexPath_) {
        var _this = _super.call(this) || this;
        _this.indexPath_ = indexPath_;
        util_1.assert(!indexPath_.isEmpty() && indexPath_.getFront() !== '.priority', "Can't create PathIndex with empty path or .priority key");
        return _this;
    }
    /**
     * @param {!Node} snap
     * @return {!Node}
     * @protected
     */
    PathIndex.prototype.extractChild = function (snap) {
        return snap.getChild(this.indexPath_);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.isDefinedOn = function (node) {
        return !node.getChild(this.indexPath_).isEmpty();
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.compare = function (a, b) {
        var aChild = this.extractChild(a.node);
        var bChild = this.extractChild(b.node);
        var indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
            return util_2.nameCompare(a.name, b.name);
        }
        else {
            return indexCmp;
        }
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.makePost = function (indexValue, name) {
        var valueNode = nodeFromJSON_1.nodeFromJSON(indexValue);
        var node = ChildrenNode_1.ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new Node_1.NamedNode(name, node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.maxPost = function () {
        var node = ChildrenNode_1.ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, ChildrenNode_1.MAX_NODE);
        return new Node_1.NamedNode(util_2.MAX_NAME, node);
    };
    /**
     * @inheritDoc
     */
    PathIndex.prototype.toString = function () {
        return this.indexPath_.slice().join('/');
    };
    return PathIndex;
}(Index_1.Index));
exports.PathIndex = PathIndex;

//# sourceMappingURL=PathIndex.js.map


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Path_1 = __webpack_require__(2);
var SparseSnapshotTree_1 = __webpack_require__(59);
var LeafNode_1 = __webpack_require__(21);
var nodeFromJSON_1 = __webpack_require__(15);
var PriorityIndex_1 = __webpack_require__(3);
/**
 * Generate placeholders for deferred values.
 * @param {?Object} values
 * @return {!Object}
 */
exports.generateWithValues = function (values) {
    values = values || {};
    values['timestamp'] = values['timestamp'] || new Date().getTime();
    return values;
};
/**
 * Value to use when firing local events. When writing server values, fire
 * local events with an approximate value, otherwise return value as-is.
 * @param {(Object|string|number|boolean)} value
 * @param {!Object} serverValues
 * @return {!(string|number|boolean)}
 */
exports.resolveDeferredValue = function (value, serverValues) {
    if (!value || typeof value !== 'object') {
        return value;
    }
    else {
        util_1.assert('.sv' in value, 'Unexpected leaf node or priority contents');
        return serverValues[value['.sv']];
    }
};
/**
 * Recursively replace all deferred values and priorities in the tree with the
 * specified generated replacement values.
 * @param {!SparseSnapshotTree} tree
 * @param {!Object} serverValues
 * @return {!SparseSnapshotTree}
 */
exports.resolveDeferredValueTree = function (tree, serverValues) {
    var resolvedTree = new SparseSnapshotTree_1.SparseSnapshotTree();
    tree.forEachTree(new Path_1.Path(''), function (path, node) {
        resolvedTree.remember(path, exports.resolveDeferredValueSnapshot(node, serverValues));
    });
    return resolvedTree;
};
/**
 * Recursively replace all deferred values and priorities in the node with the
 * specified generated replacement values.  If there are no server values in the node,
 * it'll be returned as-is.
 * @param {!Node} node
 * @param {!Object} serverValues
 * @return {!Node}
 */
exports.resolveDeferredValueSnapshot = function (node, serverValues) {
    var rawPri = node.getPriority().val();
    var priority = exports.resolveDeferredValue(rawPri, serverValues);
    var newNode;
    if (node.isLeafNode()) {
        var leafNode = node;
        var value = exports.resolveDeferredValue(leafNode.getValue(), serverValues);
        if (value !== leafNode.getValue() ||
            priority !== leafNode.getPriority().val()) {
            return new LeafNode_1.LeafNode(value, nodeFromJSON_1.nodeFromJSON(priority));
        }
        else {
            return node;
        }
    }
    else {
        var childrenNode = node;
        newNode = childrenNode;
        if (priority !== childrenNode.getPriority().val()) {
            newNode = newNode.updatePriority(new LeafNode_1.LeafNode(priority));
        }
        childrenNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
            var newChildNode = exports.resolveDeferredValueSnapshot(childNode, serverValues);
            if (newChildNode !== childNode) {
                newNode = newNode.updateImmediateChild(childName, newChildNode);
            }
        });
        return newNode;
    }
};

//# sourceMappingURL=ServerValues.js.map


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = __webpack_require__(2);
var PriorityIndex_1 = __webpack_require__(3);
var CountedSet_1 = __webpack_require__(60);
/**
 * Helper class to store a sparse set of snapshots.
 *
 * @constructor
 */
var SparseSnapshotTree = /** @class */ (function () {
    function SparseSnapshotTree() {
        /**
         * @private
         * @type {Node}
         */
        this.value_ = null;
        /**
         * @private
         * @type {CountedSet}
         */
        this.children_ = null;
    }
    /**
     * Gets the node stored at the given path if one exists.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {?Node} The retrieved node, or null.
     */
    SparseSnapshotTree.prototype.find = function (path) {
        if (this.value_ != null) {
            return this.value_.getChild(path);
        }
        else if (!path.isEmpty() && this.children_ != null) {
            var childKey = path.getFront();
            path = path.popFront();
            if (this.children_.contains(childKey)) {
                var childTree = this.children_.get(childKey);
                return childTree.find(path);
            }
            else {
                return null;
            }
        }
        else {
            return null;
        }
    };
    /**
     * Stores the given node at the specified path. If there is already a node
     * at a shallower path, it merges the new data into that snapshot node.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @param {!Node} data The new data, or null.
     */
    SparseSnapshotTree.prototype.remember = function (path, data) {
        if (path.isEmpty()) {
            this.value_ = data;
            this.children_ = null;
        }
        else if (this.value_ !== null) {
            this.value_ = this.value_.updateChild(path, data);
        }
        else {
            if (this.children_ == null) {
                this.children_ = new CountedSet_1.CountedSet();
            }
            var childKey = path.getFront();
            if (!this.children_.contains(childKey)) {
                this.children_.add(childKey, new SparseSnapshotTree());
            }
            var child = this.children_.get(childKey);
            path = path.popFront();
            child.remember(path, data);
        }
    };
    /**
     * Purge the data at path from the cache.
     *
     * @param {!Path} path Path to look up snapshot for.
     * @return {boolean} True if this node should now be removed.
     */
    SparseSnapshotTree.prototype.forget = function (path) {
        if (path.isEmpty()) {
            this.value_ = null;
            this.children_ = null;
            return true;
        }
        else {
            if (this.value_ !== null) {
                if (this.value_.isLeafNode()) {
                    // We're trying to forget a node that doesn't exist
                    return false;
                }
                else {
                    var value = this.value_;
                    this.value_ = null;
                    var self_1 = this;
                    value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {
                        self_1.remember(new Path_1.Path(key), tree);
                    });
                    return this.forget(path);
                }
            }
            else if (this.children_ !== null) {
                var childKey = path.getFront();
                path = path.popFront();
                if (this.children_.contains(childKey)) {
                    var safeToRemove = this.children_.get(childKey).forget(path);
                    if (safeToRemove) {
                        this.children_.remove(childKey);
                    }
                }
                if (this.children_.isEmpty()) {
                    this.children_ = null;
                    return true;
                }
                else {
                    return false;
                }
            }
            else {
                return true;
            }
        }
    };
    /**
     * Recursively iterates through all of the stored tree and calls the
     * callback on each one.
     *
     * @param {!Path} prefixPath Path to look up node for.
     * @param {!Function} func The function to invoke for each tree.
     */
    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {
        if (this.value_ !== null) {
            func(prefixPath, this.value_);
        }
        else {
            this.forEachChild(function (key, tree) {
                var path = new Path_1.Path(prefixPath.toString() + '/' + key);
                tree.forEachTree(path, func);
            });
        }
    };
    /**
     * Iterates through each immediate child and triggers the callback.
     *
     * @param {!Function} func The function to invoke for each child.
     */
    SparseSnapshotTree.prototype.forEachChild = function (func) {
        if (this.children_ !== null) {
            this.children_.each(function (key, tree) {
                func(key, tree);
            });
        }
    };
    return SparseSnapshotTree;
}());
exports.SparseSnapshotTree = SparseSnapshotTree;

//# sourceMappingURL=SparseSnapshotTree.js.map


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Implements a set with a count of elements.
 *
 * @template K, V
 */
var CountedSet = /** @class */ (function () {
    function CountedSet() {
        this.set = {};
    }
    /**
     * @param {!K} item
     * @param {V} val
     */
    CountedSet.prototype.add = function (item, val) {
        this.set[item] = val !== null ? val : true;
    };
    /**
     * @param {!K} key
     * @return {boolean}
     */
    CountedSet.prototype.contains = function (key) {
        return util_1.contains(this.set, key);
    };
    /**
     * @param {!K} item
     * @return {V}
     */
    CountedSet.prototype.get = function (item) {
        return this.contains(item) ? this.set[item] : undefined;
    };
    /**
     * @param {!K} item
     */
    CountedSet.prototype.remove = function (item) {
        delete this.set[item];
    };
    /**
     * Deletes everything in the set
     */
    CountedSet.prototype.clear = function () {
        this.set = {};
    };
    /**
     * True if there's nothing in the set
     * @return {boolean}
     */
    CountedSet.prototype.isEmpty = function () {
        return util_1.isEmpty(this.set);
    };
    /**
     * @return {number} The number of items in the set
     */
    CountedSet.prototype.count = function () {
        return util_1.getCount(this.set);
    };
    /**
     * Run a function on each k,v pair in the set
     * @param {function(K, V)} fn
     */
    CountedSet.prototype.each = function (fn) {
        util_1.forEach(this.set, function (k, v) { return fn(k, v); });
    };
    /**
     * Mostly for debugging
     * @return {Array.<K>} The keys present in this CountedSet
     */
    CountedSet.prototype.keys = function () {
        var keys = [];
        util_1.forEach(this.set, function (k) {
            keys.push(k);
        });
        return keys;
    };
    return CountedSet;
}());
exports.CountedSet = CountedSet;

//# sourceMappingURL=CountedSet.js.map


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = __webpack_require__(10);
var Path_1 = __webpack_require__(2);
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!Node} snap
 * @constructor
 * @implements {Operation}
 */
var Overwrite = /** @class */ (function () {
    function Overwrite(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.OVERWRITE;
    }
    Overwrite.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new Overwrite(this.source, Path_1.Path.Empty, this.snap.getImmediateChild(childName));
        }
        else {
            return new Overwrite(this.source, this.path.popFront(), this.snap);
        }
    };
    return Overwrite;
}());
exports.Overwrite = Overwrite;

//# sourceMappingURL=Overwrite.js.map


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CacheNode_1 = __webpack_require__(24);
var ChildrenNode_1 = __webpack_require__(4);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var ViewCache_1 = __webpack_require__(63);
var View_1 = __webpack_require__(113);
var __referenceConstructor;
/**
 * SyncPoint represents a single location in a SyncTree with 1 or more event registrations, meaning we need to
 * maintain 1 or more Views at this location to cache server data and raise appropriate events for server changes
 * and user writes (set, transaction, update).
 *
 * It's responsible for:
 *  - Maintaining the set of 1 or more views necessary at this location (a SyncPoint with 0 views should be removed).
 *  - Proxying user / server operations to the views as appropriate (i.e. applyServerOverwrite,
 *    applyUserOverwrite, etc.)
 */
var SyncPoint = /** @class */ (function () {
    function SyncPoint() {
        /**
         * The Views being tracked at this location in the tree, stored as a map where the key is a
         * queryId and the value is the View for that query.
         *
         * NOTE: This list will be quite small (usually 1, but perhaps 2 or 3; any more is an odd use case).
         *
         * @type {!Object.<!string, !View>}
         * @private
         */
        this.views_ = {};
    }
    Object.defineProperty(SyncPoint, "__referenceConstructor", {
        get: function () {
            util_1.assert(__referenceConstructor, 'Reference.ts has not been loaded');
            return __referenceConstructor;
        },
        set: function (val) {
            util_1.assert(!__referenceConstructor, '__referenceConstructor has already been defined');
            __referenceConstructor = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.isEmpty = function () {
        return util_2.isEmpty(this.views_);
    };
    /**
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} optCompleteServerCache
     * @return {!Array.<!Event>}
     */
    SyncPoint.prototype.applyOperation = function (operation, writesCache, optCompleteServerCache) {
        var queryId = operation.source.queryId;
        if (queryId !== null) {
            var view = util_2.safeGet(this.views_, queryId);
            util_1.assert(view != null, 'SyncTree gave us an op for an invalid query.');
            return view.applyOperation(operation, writesCache, optCompleteServerCache);
        }
        else {
            var events_1 = [];
            util_2.forEach(this.views_, function (key, view) {
                events_1 = events_1.concat(view.applyOperation(operation, writesCache, optCompleteServerCache));
            });
            return events_1;
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache Complete server cache, if we have it.
     * @param {boolean} serverCacheComplete
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncPoint.prototype.addEventRegistration = function (query, eventRegistration, writesCache, serverCache, serverCacheComplete) {
        var queryId = query.queryIdentifier();
        var view = util_2.safeGet(this.views_, queryId);
        if (!view) {
            // TODO: make writesCache take flag for complete server node
            var eventCache = writesCache.calcCompleteEventCache(serverCacheComplete ? serverCache : null);
            var eventCacheComplete = false;
            if (eventCache) {
                eventCacheComplete = true;
            }
            else if (serverCache instanceof ChildrenNode_1.ChildrenNode) {
                eventCache = writesCache.calcCompleteEventChildren(serverCache);
                eventCacheComplete = false;
            }
            else {
                eventCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                eventCacheComplete = false;
            }
            var viewCache = new ViewCache_1.ViewCache(new CacheNode_1.CacheNode(
            /** @type {!Node} */ (eventCache), eventCacheComplete, false), new CacheNode_1.CacheNode(
            /** @type {!Node} */ (serverCache), serverCacheComplete, false));
            view = new View_1.View(query, viewCache);
            this.views_[queryId] = view;
        }
        // This is guaranteed to exist now, we just created anything that was missing
        view.addEventRegistration(eventRegistration);
        return view.getInitialEvents(eventRegistration);
    };
    /**
     * Remove event callback(s).  Return cancelEvents if a cancelError is specified.
     *
     * If query is the default query, we'll check all views for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified view(s).
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {{removed:!Array.<!Query>, events:!Array.<!Event>}} removed queries and any cancel events
     */
    SyncPoint.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var queryId = query.queryIdentifier();
        var removed = [];
        var cancelEvents = [];
        var hadCompleteView = this.hasCompleteView();
        if (queryId === 'default') {
            // When you do ref.off(...), we search all views for the registration to remove.
            var self_1 = this;
            util_2.forEach(this.views_, function (viewQueryId, view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete self_1.views_[viewQueryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            });
        }
        else {
            // remove the callback from the specific view.
            var view = util_2.safeGet(this.views_, queryId);
            if (view) {
                cancelEvents = cancelEvents.concat(view.removeEventRegistration(eventRegistration, cancelError));
                if (view.isEmpty()) {
                    delete this.views_[queryId];
                    // We'll deal with complete views later.
                    if (!view
                        .getQuery()
                        .getQueryParams()
                        .loadsAllData()) {
                        removed.push(view.getQuery());
                    }
                }
            }
        }
        if (hadCompleteView && !this.hasCompleteView()) {
            // We removed our last complete view.
            removed.push(new SyncPoint.__referenceConstructor(query.repo, query.path));
        }
        return { removed: removed, events: cancelEvents };
    };
    /**
     * @return {!Array.<!View>}
     */
    SyncPoint.prototype.getQueryViews = function () {
        var _this = this;
        var values = Object.keys(this.views_).map(function (key) { return _this.views_[key]; });
        return values.filter(function (view) {
            return !view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
    };
    /**
     *
     * @param {!Path} path The path to the desired complete snapshot
     * @return {?Node} A complete cache, if it exists
     */
    SyncPoint.prototype.getCompleteServerCache = function (path) {
        var serverCache = null;
        util_2.forEach(this.views_, function (key, view) {
            serverCache = serverCache || view.getCompleteServerCache(path);
        });
        return serverCache;
    };
    /**
     * @param {!Query} query
     * @return {?View}
     */
    SyncPoint.prototype.viewForQuery = function (query) {
        var params = query.getQueryParams();
        if (params.loadsAllData()) {
            return this.getCompleteView();
        }
        else {
            var queryId = query.queryIdentifier();
            return util_2.safeGet(this.views_, queryId);
        }
    };
    /**
     * @param {!Query} query
     * @return {boolean}
     */
    SyncPoint.prototype.viewExistsForQuery = function (query) {
        return this.viewForQuery(query) != null;
    };
    /**
     * @return {boolean}
     */
    SyncPoint.prototype.hasCompleteView = function () {
        return this.getCompleteView() != null;
    };
    /**
     * @return {?View}
     */
    SyncPoint.prototype.getCompleteView = function () {
        var completeView = util_2.findValue(this.views_, function (view) {
            return view
                .getQuery()
                .getQueryParams()
                .loadsAllData();
        });
        return completeView || null;
    };
    return SyncPoint;
}());
exports.SyncPoint = SyncPoint;

//# sourceMappingURL=SyncPoint.js.map


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = __webpack_require__(4);
var CacheNode_1 = __webpack_require__(24);
/**
 * Stores the data we have cached for a view.
 *
 * serverSnap is the cached server data, eventSnap is the cached event data (server data plus any local writes).
 *
 * @constructor
 */
var ViewCache = /** @class */ (function () {
    /**
     *
     * @param {!CacheNode} eventCache_
     * @param {!CacheNode} serverCache_
     */
    function ViewCache(eventCache_, serverCache_) {
        this.eventCache_ = eventCache_;
        this.serverCache_ = serverCache_;
    }
    /**
     * @param {!Node} eventSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateEventSnap = function (eventSnap, complete, filtered) {
        return new ViewCache(new CacheNode_1.CacheNode(eventSnap, complete, filtered), this.serverCache_);
    };
    /**
     * @param {!Node} serverSnap
     * @param {boolean} complete
     * @param {boolean} filtered
     * @return {!ViewCache}
     */
    ViewCache.prototype.updateServerSnap = function (serverSnap, complete, filtered) {
        return new ViewCache(this.eventCache_, new CacheNode_1.CacheNode(serverSnap, complete, filtered));
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getEventCache = function () {
        return this.eventCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteEventSnap = function () {
        return this.eventCache_.isFullyInitialized()
            ? this.eventCache_.getNode()
            : null;
    };
    /**
     * @return {!CacheNode}
     */
    ViewCache.prototype.getServerCache = function () {
        return this.serverCache_;
    };
    /**
     * @return {?Node}
     */
    ViewCache.prototype.getCompleteServerSnap = function () {
        return this.serverCache_.isFullyInitialized()
            ? this.serverCache_.getNode()
            : null;
    };
    /**
     * @const
     * @type {ViewCache}
     */
    ViewCache.Empty = new ViewCache(new CacheNode_1.CacheNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false), new CacheNode_1.CacheNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, 
    /*fullyInitialized=*/ false, 
    /*filtered=*/ false));
    return ViewCache;
}());
exports.ViewCache = ViewCache;

//# sourceMappingURL=ViewCache.js.map


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Returns the delta from the previous call to get stats.
 *
 * @param collection_ The collection to "listen" to.
 * @constructor
 */
var StatsListener = /** @class */ (function () {
    function StatsListener(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
    }
    StatsListener.prototype.get = function () {
        var newStats = this.collection_.get();
        var delta = util_1.clone(newStats);
        if (this.last_) {
            util_1.forEach(this.last_, function (stat, value) {
                delta[stat] = delta[stat] - value;
            });
        }
        this.last_ = newStats;
        return delta;
    };
    return StatsListener;
}());
exports.StatsListener = StatsListener;

//# sourceMappingURL=StatsListener.js.map


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = __webpack_require__(8);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var util_3 = __webpack_require__(0);
var util_4 = __webpack_require__(1);
var Path_1 = __webpack_require__(2);
var VisibilityMonitor_1 = __webpack_require__(125);
var OnlineMonitor_1 = __webpack_require__(126);
var util_5 = __webpack_require__(0);
var Connection_1 = __webpack_require__(67);
var util_6 = __webpack_require__(0);
var util_7 = __webpack_require__(0);
var ServerActions_1 = __webpack_require__(70);
var RECONNECT_MIN_DELAY = 1000;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1000; // 5 minutes in milliseconds (Case: 1858)
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1000; // 30 seconds for admin clients (likely to be a backend server)
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 30000; // Reset delay back to MIN_DELAY after being connected for 30sec.
var SERVER_KILL_INTERRUPT_REASON = 'server_kill';
// If auth fails repeatedly, we'll assume something is wrong and log a warning / back off.
var INVALID_AUTH_TOKEN_THRESHOLD = 3;
/**
 * Firebase connection.  Abstracts wire protocol and handles reconnecting.
 *
 * NOTE: All JSON objects sent to the realtime connection must have property names enclosed
 * in quotes to make sure the closure compiler does not minify them.
 */
var PersistentConnection = /** @class */ (function (_super) {
    __extends(PersistentConnection, _super);
    /**
     * @implements {ServerActions}
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param onConnectStatus_
     * @param onServerInfoUpdate_
     * @param authTokenProvider_
     * @param authOverride_
     */
    function PersistentConnection(repoInfo_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, authOverride_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.onConnectStatus_ = onConnectStatus_;
        _this.onServerInfoUpdate_ = onServerInfoUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        _this.authOverride_ = authOverride_;
        // Used for diagnostic logging.
        _this.id = PersistentConnection.nextPersistentConnectionId_++;
        _this.log_ = util_4.logWrapper('p:' + _this.id + ':');
        /** @private {Object} */
        _this.interruptReasons_ = {};
        _this.listens_ = {};
        _this.outstandingPuts_ = [];
        _this.outstandingPutCount_ = 0;
        _this.onDisconnectRequestQueue_ = [];
        _this.connected_ = false;
        _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        _this.securityDebugCallback_ = null;
        _this.lastSessionId = null;
        /** @private {number|null} */
        _this.establishConnectionTimer_ = null;
        /** @private {boolean} */
        _this.visible_ = false;
        // Before we get connected, we keep a queue of pending messages to send.
        _this.requestCBHash_ = {};
        _this.requestNumber_ = 0;
        /** @private {?{
         *   sendRequest(Object),
         *   close()
         * }} */
        _this.realtime_ = null;
        /** @private {string|null} */
        _this.authToken_ = null;
        _this.forceTokenRefresh_ = false;
        _this.invalidAuthTokenCount_ = 0;
        _this.firstConnection_ = true;
        _this.lastConnectionAttemptTime_ = null;
        _this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !util_7.isNodeSdk()) {
            throw new Error('Auth override specified in options, but not supported on non Node.js platforms');
        }
        _this.scheduleConnect_(0);
        VisibilityMonitor_1.VisibilityMonitor.getInstance().on('visible', _this.onVisible_, _this);
        if (repoInfo_.host.indexOf('fblocal') === -1) {
            OnlineMonitor_1.OnlineMonitor.getInstance().on('online', _this.onOnline_, _this);
        }
        return _this;
    }
    /**
     * @param {!string} action
     * @param {*} body
     * @param {function(*)=} onResponse
     * @protected
     */
    PersistentConnection.prototype.sendRequest = function (action, body, onResponse) {
        var curReqNum = ++this.requestNumber_;
        var msg = { r: curReqNum, a: action, b: body };
        this.log_(util_2.stringify(msg));
        util_3.assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
            this.requestCBHash_[curReqNum] = onResponse;
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var queryId = query.queryIdentifier();
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + queryId);
        this.listens_[pathString] = this.listens_[pathString] || {};
        util_3.assert(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'listen() called for non-default but complete query');
        util_3.assert(!this.listens_[pathString][queryId], 'listen() called twice for same path/queryId.');
        var listenSpec = {
            onComplete: onComplete,
            hashFn: currentHashFn,
            query: query,
            tag: tag
        };
        this.listens_[pathString][queryId] = listenSpec;
        if (this.connected_) {
            this.sendListen_(listenSpec);
        }
    };
    /**
     * @param {!{onComplete(),
     *           hashFn():!string,
     *           query: !Query,
     *           tag: ?number}} listenSpec
     * @private
     */
    PersistentConnection.prototype.sendListen_ = function (listenSpec) {
        var _this = this;
        var query = listenSpec.query;
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Listen on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'q';
        // Only bother to send query if it's non-default.
        if (listenSpec.tag) {
            req['q'] = query.queryObject();
            req['t'] = listenSpec.tag;
        }
        req['h'] = listenSpec.hashFn();
        this.sendRequest(action, req, function (message) {
            var payload = message['d'];
            var status = message['s'];
            // print warnings in any case...
            PersistentConnection.warnOnListenWarnings_(payload, query);
            var currentListenSpec = _this.listens_[pathString] && _this.listens_[pathString][queryId];
            // only trigger actions if the listen hasn't been removed and readded
            if (currentListenSpec === listenSpec) {
                _this.log_('listen response', message);
                if (status !== 'ok') {
                    _this.removeListen_(pathString, queryId);
                }
                if (listenSpec.onComplete) {
                    listenSpec.onComplete(status, payload);
                }
            }
        });
    };
    /**
     * @param {*} payload
     * @param {!Query} query
     * @private
     */
    PersistentConnection.warnOnListenWarnings_ = function (payload, query) {
        if (payload && typeof payload === 'object' && util_1.contains(payload, 'w')) {
            var warnings = util_1.safeGet(payload, 'w');
            if (Array.isArray(warnings) && ~warnings.indexOf('no_index')) {
                var indexSpec = '".indexOn": "' +
                    query
                        .getQueryParams()
                        .getIndex()
                        .toString() +
                    '"';
                var indexPath = query.path.toString();
                util_4.warn("Using an unspecified index. Your data will be downloaded and " +
                    ("filtered on the client. Consider adding " + indexSpec + " at ") +
                    (indexPath + " to your security rules for better performance."));
            }
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.refreshAuthToken = function (token) {
        this.authToken_ = token;
        this.log_('Auth token refreshed');
        if (this.authToken_) {
            this.tryAuth();
        }
        else {
            //If we're connected we want to let the server know to unauthenticate us. If we're not connected, simply delete
            //the credential so we dont become authenticated next time we connect.
            if (this.connected_) {
                this.sendRequest('unauth', {}, function () { });
            }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
    };
    /**
     * @param {!string} credential
     * @private
     */
    PersistentConnection.prototype.reduceReconnectDelayIfAdminCredential_ = function (credential) {
        // NOTE: This isn't intended to be bulletproof (a malicious developer can always just modify the client).
        // Additionally, we don't bother resetting the max delay back to the default if auth fails / expires.
        var isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || util_5.isAdmin(credential)) {
            this.log_('Admin auth credential detected.  Reducing max reconnect time.');
            this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
    };
    /**
     * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
     * a auth revoked (the connection is closed).
     */
    PersistentConnection.prototype.tryAuth = function () {
        var _this = this;
        if (this.connected_ && this.authToken_) {
            var token_1 = this.authToken_;
            var authMethod = util_5.isValidFormat(token_1) ? 'auth' : 'gauth';
            var requestData = { cred: token_1 };
            if (this.authOverride_ === null) {
                requestData['noauth'] = true;
            }
            else if (typeof this.authOverride_ === 'object') {
                requestData['authvar'] = this.authOverride_;
            }
            this.sendRequest(authMethod, requestData, function (res) {
                var status = res['s'];
                var data = res['d'] || 'error';
                if (_this.authToken_ === token_1) {
                    if (status === 'ok') {
                        _this.invalidAuthTokenCount_ = 0;
                    }
                    else {
                        // Triggers reconnect and force refresh for auth token
                        _this.onAuthRevoked_(status, data);
                    }
                }
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.unlisten = function (query, tag) {
        var pathString = query.path.toString();
        var queryId = query.queryIdentifier();
        this.log_('Unlisten called for ' + pathString + ' ' + queryId);
        util_3.assert(query.getQueryParams().isDefault() ||
            !query.getQueryParams().loadsAllData(), 'unlisten() called for non-default but complete query');
        var listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
            this.sendUnlisten_(pathString, queryId, query.queryObject(), tag);
        }
    };
    PersistentConnection.prototype.sendUnlisten_ = function (pathString, queryId, queryObj, tag) {
        this.log_('Unlisten on ' + pathString + ' for ' + queryId);
        var req = { /*path*/ p: pathString };
        var action = 'n';
        // Only bother sending queryId if it's non-default.
        if (tag) {
            req['q'] = queryObj;
            req['t'] = tag;
        }
        this.sendRequest(action, req);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectPut = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('o', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'o',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectMerge = function (pathString, data, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('om', pathString, data, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'om',
                data: data,
                onComplete: onComplete
            });
        }
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.onDisconnectCancel = function (pathString, onComplete) {
        if (this.connected_) {
            this.sendOnDisconnect_('oc', pathString, null, onComplete);
        }
        else {
            this.onDisconnectRequestQueue_.push({
                pathString: pathString,
                action: 'oc',
                data: null,
                onComplete: onComplete
            });
        }
    };
    PersistentConnection.prototype.sendOnDisconnect_ = function (action, pathString, data, onComplete) {
        var request = { /*path*/ p: pathString, /*data*/ d: data };
        this.log_('onDisconnect ' + action, request);
        this.sendRequest(action, request, function (response) {
            if (onComplete) {
                setTimeout(function () {
                    onComplete(response['s'], response['d']);
                }, Math.floor(0));
            }
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.put = function (pathString, data, onComplete, hash) {
        this.putInternal('p', pathString, data, onComplete, hash);
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.merge = function (pathString, data, onComplete, hash) {
        this.putInternal('m', pathString, data, onComplete, hash);
    };
    PersistentConnection.prototype.putInternal = function (action, pathString, data, onComplete, hash) {
        var request = {
            /*path*/ p: pathString,
            /*data*/ d: data
        };
        if (hash !== undefined)
            request['h'] = hash;
        // TODO: Only keep track of the most recent put for a given path?
        this.outstandingPuts_.push({
            action: action,
            request: request,
            onComplete: onComplete
        });
        this.outstandingPutCount_++;
        var index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
            this.sendPut_(index);
        }
        else {
            this.log_('Buffering put: ' + pathString);
        }
    };
    PersistentConnection.prototype.sendPut_ = function (index) {
        var _this = this;
        var action = this.outstandingPuts_[index].action;
        var request = this.outstandingPuts_[index].request;
        var onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request, function (message) {
            _this.log_(action + ' response', message);
            delete _this.outstandingPuts_[index];
            _this.outstandingPutCount_--;
            // Clean up array occasionally.
            if (_this.outstandingPutCount_ === 0) {
                _this.outstandingPuts_ = [];
            }
            if (onComplete)
                onComplete(message['s'], message['d']);
        });
    };
    /**
     * @inheritDoc
     */
    PersistentConnection.prototype.reportStats = function (stats) {
        var _this = this;
        // If we're not connected, we just drop the stats.
        if (this.connected_) {
            var request = { /*counters*/ c: stats };
            this.log_('reportStats', request);
            this.sendRequest(/*stats*/ 's', request, function (result) {
                var status = result['s'];
                if (status !== 'ok') {
                    var errorReason = result['d'];
                    _this.log_('reportStats', 'Error sending stats: ' + errorReason);
                }
            });
        }
    };
    /**
     * @param {*} message
     * @private
     */
    PersistentConnection.prototype.onDataMessage_ = function (message) {
        if ('r' in message) {
            // this is a response
            this.log_('from server: ' + util_2.stringify(message));
            var reqNum = message['r'];
            var onResponse = this.requestCBHash_[reqNum];
            if (onResponse) {
                delete this.requestCBHash_[reqNum];
                onResponse(message['b']);
            }
        }
        else if ('error' in message) {
            throw 'A server-side error has occurred: ' + message['error'];
        }
        else if ('a' in message) {
            // a and b are action and body, respectively
            this.onDataPush_(message['a'], message['b']);
        }
    };
    PersistentConnection.prototype.onDataPush_ = function (action, body) {
        this.log_('handleServerMessage', action, body);
        if (action === 'd')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge*/ false, body['t']);
        else if (action === 'm')
            this.onDataUpdate_(body['p'], body['d'], 
            /*isMerge=*/ true, body['t']);
        else if (action === 'c')
            this.onListenRevoked_(body['p'], body['q']);
        else if (action === 'ac')
            this.onAuthRevoked_(body['s'], body['d']);
        else if (action === 'sd')
            this.onSecurityDebugPacket_(body);
        else
            util_4.error('Unrecognized action received from server: ' +
                util_2.stringify(action) +
                '\nAre you using the latest client?');
    };
    PersistentConnection.prototype.onReady_ = function (timestamp, sessionId) {
        this.log_('connection ready');
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = new Date().getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
            this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
    };
    PersistentConnection.prototype.scheduleConnect_ = function (timeout) {
        var _this = this;
        util_3.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
        }
        // NOTE: Even when timeout is 0, it's important to do a setTimeout to work around an infuriating "Security Error" in
        // Firefox when trying to write to our long-polling iframe in some scenarios (e.g. Forge or our unit tests).
        this.establishConnectionTimer_ = setTimeout(function () {
            _this.establishConnectionTimer_ = null;
            _this.establishConnection_();
        }, Math.floor(timeout));
    };
    /**
     * @param {boolean} visible
     * @private
     */
    PersistentConnection.prototype.onVisible_ = function (visible) {
        // NOTE: Tabbing away and back to a window will defeat our reconnect backoff, but I think that's fine.
        if (visible &&
            !this.visible_ &&
            this.reconnectDelay_ === this.maxReconnectDelay_) {
            this.log_('Window became visible.  Reducing delay.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        this.visible_ = visible;
    };
    PersistentConnection.prototype.onOnline_ = function (online) {
        if (online) {
            this.log_('Browser went online.');
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
        else {
            this.log_('Browser went offline.  Killing connection.');
            if (this.realtime_) {
                this.realtime_.close();
            }
        }
    };
    PersistentConnection.prototype.onRealtimeDisconnect_ = function () {
        this.log_('data client disconnected');
        this.connected_ = false;
        this.realtime_ = null;
        // Since we don't know if our sent transactions succeeded or not, we need to cancel them.
        this.cancelSentTransactions_();
        // Clear out the pending requests.
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
            if (!this.visible_) {
                this.log_("Window isn't visible.  Delaying reconnect.");
                this.reconnectDelay_ = this.maxReconnectDelay_;
                this.lastConnectionAttemptTime_ = new Date().getTime();
            }
            else if (this.lastConnectionEstablishedTime_) {
                // If we've been connected long enough, reset reconnect delay to minimum.
                var timeSinceLastConnectSucceeded = new Date().getTime() - this.lastConnectionEstablishedTime_;
                if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT)
                    this.reconnectDelay_ = RECONNECT_MIN_DELAY;
                this.lastConnectionEstablishedTime_ = null;
            }
            var timeSinceLastConnectAttempt = new Date().getTime() - this.lastConnectionAttemptTime_;
            var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
            reconnectDelay = Math.random() * reconnectDelay;
            this.log_('Trying to reconnect in ' + reconnectDelay + 'ms');
            this.scheduleConnect_(reconnectDelay);
            // Adjust reconnect delay for next time.
            this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
    };
    PersistentConnection.prototype.establishConnection_ = function () {
        if (this.shouldReconnect_()) {
            this.log_('Making a connection attempt');
            this.lastConnectionAttemptTime_ = new Date().getTime();
            this.lastConnectionEstablishedTime_ = null;
            var onDataMessage_1 = this.onDataMessage_.bind(this);
            var onReady_1 = this.onReady_.bind(this);
            var onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
            var connId_1 = this.id + ':' + PersistentConnection.nextConnectionId_++;
            var self_1 = this;
            var lastSessionId_1 = this.lastSessionId;
            var canceled_1 = false;
            var connection_1 = null;
            var closeFn_1 = function () {
                if (connection_1) {
                    connection_1.close();
                }
                else {
                    canceled_1 = true;
                    onDisconnect_1();
                }
            };
            var sendRequestFn = function (msg) {
                util_3.assert(connection_1, "sendRequest call when we're not connected not allowed.");
                connection_1.sendRequest(msg);
            };
            this.realtime_ = {
                close: closeFn_1,
                sendRequest: sendRequestFn
            };
            var forceRefresh = this.forceTokenRefresh_;
            this.forceTokenRefresh_ = false;
            // First fetch auth token, and establish connection after fetching the token was successful
            this.authTokenProvider_
                .getToken(forceRefresh)
                .then(function (result) {
                if (!canceled_1) {
                    util_4.log('getToken() completed. Creating connection.');
                    self_1.authToken_ = result && result.accessToken;
                    connection_1 = new Connection_1.Connection(connId_1, self_1.repoInfo_, onDataMessage_1, onReady_1, onDisconnect_1, 
                    /* onKill= */ function (reason) {
                        util_4.warn(reason + ' (' + self_1.repoInfo_.toString() + ')');
                        self_1.interrupt(SERVER_KILL_INTERRUPT_REASON);
                    }, lastSessionId_1);
                }
                else {
                    util_4.log('getToken() completed but was canceled');
                }
            })
                .then(null, function (error) {
                self_1.log_('Failed to get token: ' + error);
                if (!canceled_1) {
                    if (util_6.CONSTANTS.NODE_ADMIN) {
                        // This may be a critical error for the Admin Node.js SDK, so log a warning.
                        // But getToken() may also just have temporarily failed, so we still want to
                        // continue retrying.
                        util_4.warn(error);
                    }
                    closeFn_1();
                }
            });
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.interrupt = function (reason) {
        util_4.log('Interrupting connection for reason: ' + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
            this.realtime_.close();
        }
        else {
            if (this.establishConnectionTimer_) {
                clearTimeout(this.establishConnectionTimer_);
                this.establishConnectionTimer_ = null;
            }
            if (this.connected_) {
                this.onRealtimeDisconnect_();
            }
        }
    };
    /**
     * @param {string} reason
     */
    PersistentConnection.prototype.resume = function (reason) {
        util_4.log('Resuming connection for reason: ' + reason);
        delete this.interruptReasons_[reason];
        if (util_1.isEmpty(this.interruptReasons_)) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            if (!this.realtime_) {
                this.scheduleConnect_(0);
            }
        }
    };
    PersistentConnection.prototype.handleTimestamp_ = function (timestamp) {
        var delta = timestamp - new Date().getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection.prototype.cancelSentTransactions_ = function () {
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            var put = this.outstandingPuts_[i];
            if (put && /*hash*/ 'h' in put.request && put.queued) {
                if (put.onComplete)
                    put.onComplete('disconnect');
                delete this.outstandingPuts_[i];
                this.outstandingPutCount_--;
            }
        }
        // Clean up array occasionally.
        if (this.outstandingPutCount_ === 0)
            this.outstandingPuts_ = [];
    };
    /**
     * @param {!string} pathString
     * @param {Array.<*>=} query
     * @private
     */
    PersistentConnection.prototype.onListenRevoked_ = function (pathString, query) {
        // Remove the listen and manufacture a "permission_denied" error for the failed listen.
        var queryId;
        if (!query) {
            queryId = 'default';
        }
        else {
            queryId = query.map(function (q) { return util_4.ObjectToUniqueKey(q); }).join('$');
        }
        var listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete)
            listen.onComplete('permission_denied');
    };
    /**
     * @param {!string} pathString
     * @param {!string} queryId
     * @return {{queries:Array.<Query>, onComplete:function(string)}}
     * @private
     */
    PersistentConnection.prototype.removeListen_ = function (pathString, queryId) {
        var normalizedPathString = new Path_1.Path(pathString).toString(); // normalize path.
        var listen;
        if (this.listens_[normalizedPathString] !== undefined) {
            listen = this.listens_[normalizedPathString][queryId];
            delete this.listens_[normalizedPathString][queryId];
            if (util_1.getCount(this.listens_[normalizedPathString]) === 0) {
                delete this.listens_[normalizedPathString];
            }
        }
        else {
            // all listens for this path has already been removed
            listen = undefined;
        }
        return listen;
    };
    PersistentConnection.prototype.onAuthRevoked_ = function (statusCode, explanation) {
        util_4.log('Auth token revoked: ' + statusCode + '/' + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === 'invalid_token' || statusCode === 'permission_denied') {
            // We'll wait a couple times before logging the warning / increasing the
            // retry period since oauth tokens will report as "invalid" if they're
            // just expired. Plus there may be transient issues that resolve themselves.
            this.invalidAuthTokenCount_++;
            if (this.invalidAuthTokenCount_ >= INVALID_AUTH_TOKEN_THRESHOLD) {
                // Set a long reconnect delay because recovery is unlikely
                this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
                // Notify the auth token provider that the token is invalid, which will log
                // a warning
                this.authTokenProvider_.notifyForInvalidToken();
            }
        }
    };
    PersistentConnection.prototype.onSecurityDebugPacket_ = function (body) {
        if (this.securityDebugCallback_) {
            this.securityDebugCallback_(body);
        }
        else {
            if ('msg' in body && typeof console !== 'undefined') {
                console.log('FIREBASE: ' + body['msg'].replace('\n', '\nFIREBASE: '));
            }
        }
    };
    PersistentConnection.prototype.restoreState_ = function () {
        var _this = this;
        //Re-authenticate ourselves if we have a credential stored.
        this.tryAuth();
        // Puts depend on having received the corresponding data update from the server before they complete, so we must
        // make sure to send listens before puts.
        util_1.forEach(this.listens_, function (pathString, queries) {
            util_1.forEach(queries, function (key, listenSpec) {
                _this.sendListen_(listenSpec);
            });
        });
        for (var i = 0; i < this.outstandingPuts_.length; i++) {
            if (this.outstandingPuts_[i])
                this.sendPut_(i);
        }
        while (this.onDisconnectRequestQueue_.length) {
            var request = this.onDisconnectRequestQueue_.shift();
            this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
        }
    };
    /**
     * Sends client stats for first connection
     * @private
     */
    PersistentConnection.prototype.sendConnectStats_ = function () {
        var stats = {};
        var clientName = 'js';
        if (util_6.CONSTANTS.NODE_ADMIN) {
            clientName = 'admin_node';
        }
        else if (util_6.CONSTANTS.NODE_CLIENT) {
            clientName = 'node';
        }
        stats['sdk.' + clientName + '.' + app_1.default.SDK_VERSION.replace(/\./g, '-')] = 1;
        if (util_7.isMobileCordova()) {
            stats['framework.cordova'] = 1;
        }
        else if (util_7.isReactNative()) {
            stats['framework.reactnative'] = 1;
        }
        this.reportStats(stats);
    };
    /**
     * @return {boolean}
     * @private
     */
    PersistentConnection.prototype.shouldReconnect_ = function () {
        var online = OnlineMonitor_1.OnlineMonitor.getInstance().currentlyOnline();
        return util_1.isEmpty(this.interruptReasons_) && online;
    };
    /**
     * @private
     */
    PersistentConnection.nextPersistentConnectionId_ = 0;
    /**
     * Counter for number of connections created. Mainly used for tagging in the logs
     * @type {number}
     * @private
     */
    PersistentConnection.nextConnectionId_ = 0;
    return PersistentConnection;
}(ServerActions_1.ServerActions));
exports.PersistentConnection = PersistentConnection;

//# sourceMappingURL=PersistentConnection.js.map


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Base class to be used if you want to emit events. Call the constructor with
 * the set of allowed event names.
 */
var EventEmitter = /** @class */ (function () {
    /**
     * @param {!Array.<string>} allowedEvents_
     */
    function EventEmitter(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        util_1.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, 'Requires a non-empty array');
    }
    /**
     * To be called by derived classes to trigger events.
     * @param {!string} eventType
     * @param {...*} var_args
     */
    EventEmitter.prototype.trigger = function (eventType) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        if (Array.isArray(this.listeners_[eventType])) {
            // Clone the list, since callbacks could add/remove listeners.
            var listeners = this.listeners_[eventType].slice();
            for (var i = 0; i < listeners.length; i++) {
                listeners[i].callback.apply(listeners[i].context, var_args);
            }
        }
    };
    EventEmitter.prototype.on = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback: callback, context: context });
        var eventData = this.getInitialEvent(eventType);
        if (eventData) {
            callback.apply(context, eventData);
        }
    };
    EventEmitter.prototype.off = function (eventType, callback, context) {
        this.validateEventType_(eventType);
        var listeners = this.listeners_[eventType] || [];
        for (var i = 0; i < listeners.length; i++) {
            if (listeners[i].callback === callback &&
                (!context || context === listeners[i].context)) {
                listeners.splice(i, 1);
                return;
            }
        }
    };
    EventEmitter.prototype.validateEventType_ = function (eventType) {
        util_1.assert(this.allowedEvents_.find(function (et) {
            return et === eventType;
        }), 'Unknown event: ' + eventType);
    };
    return EventEmitter;
}());
exports.EventEmitter = EventEmitter;

//# sourceMappingURL=EventEmitter.js.map


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
var storage_1 = __webpack_require__(18);
var Constants_1 = __webpack_require__(19);
var TransportManager_1 = __webpack_require__(127);
// Abort upgrade attempt if it takes longer than 60s.
var UPGRADE_TIMEOUT = 60000;
// For some transports (WebSockets), we need to "validate" the transport by exchanging a few requests and responses.
// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;
// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)
// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout
// but we've sent/received enough bytes, we don't cancel the connection.
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = 't';
var MESSAGE_DATA = 'd';
var CONTROL_SHUTDOWN = 's';
var CONTROL_RESET = 'r';
var CONTROL_ERROR = 'e';
var CONTROL_PONG = 'o';
var SWITCH_ACK = 'a';
var END_TRANSMISSION = 'n';
var PING = 'p';
var SERVER_HELLO = 'h';
/**
 * Creates a new real-time connection to the server using whichever method works
 * best in the current browser.
 *
 * @constructor
 */
var Connection = /** @class */ (function () {
    /**
     * @param {!string} id - an id for this connection
     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to
     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives
     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.
     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost
     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.
     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
     */
    function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0 /* CONNECTING */;
        this.log_ = util_1.logWrapper('c:' + this.id + ':');
        this.transportManager_ = new TransportManager_1.TransportManager(repoInfo_);
        this.log_('Connection created');
        this.start_();
    }
    /**
     * Starts a connection attempt
     * @private
     */
    Connection.prototype.start_ = function () {
        var _this = this;
        var conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;
        var onMessageReceived = this.connReceiver_(this.conn_);
        var onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        /*
         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.
         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.
         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should
         * still have the context of your originating frame.
         */
        setTimeout(function () {
            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it
            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        var healthyTimeout_ms = conn['healthyTimeout'] || 0;
        if (healthyTimeout_ms > 0) {
            this.healthyTimeout_ = util_1.setTimeoutNonBlocking(function () {
                _this.healthyTimeout_ = null;
                if (!_this.isHealthy_) {
                    if (_this.conn_ &&
                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has received ' +
                            _this.conn_.bytesReceived +
                            ' bytes.  Marking connection healthy.');
                        _this.isHealthy_ = true;
                        _this.conn_.markConnectionHealthy();
                    }
                    else if (_this.conn_ &&
                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                        _this.log_('Connection exceeded healthy timeout but has sent ' +
                            _this.conn_.bytesSent +
                            ' bytes.  Leaving connection alive.');
                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to
                        // the server.
                    }
                    else {
                        _this.log_('Closing unhealthy connection after timeout.');
                        _this.close();
                    }
                }
            }, Math.floor(healthyTimeout_ms));
        }
    };
    /**
     * @return {!string}
     * @private
     */
    Connection.prototype.nextTransportId_ = function () {
        return 'c:' + this.id + ':' + this.connectionCount++;
    };
    Connection.prototype.disconnReceiver_ = function (conn) {
        var _this = this;
        return function (everConnected) {
            if (conn === _this.conn_) {
                _this.onConnectionLost_(everConnected);
            }
            else if (conn === _this.secondaryConn_) {
                _this.log_('Secondary connection lost.');
                _this.onSecondaryConnectionLost_();
            }
            else {
                _this.log_('closing an old connection');
            }
        };
    };
    Connection.prototype.connReceiver_ = function (conn) {
        var _this = this;
        return function (message) {
            if (_this.state_ != 2 /* DISCONNECTED */) {
                if (conn === _this.rx_) {
                    _this.onPrimaryMessageReceived_(message);
                }
                else if (conn === _this.secondaryConn_) {
                    _this.onSecondaryMessageReceived_(message);
                }
                else {
                    _this.log_('message on old connection');
                }
            }
        };
    };
    /**
     *
     * @param {Object} dataMsg An arbitrary data message to be sent to the server
     */
    Connection.prototype.sendRequest = function (dataMsg) {
        // wrap in a data message envelope and send it on
        var msg = { t: 'd', d: dataMsg };
        this.sendData_(msg);
    };
    Connection.prototype.tryCleanupConnection = function () {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);
            this.conn_ = this.secondaryConn_;
            this.secondaryConn_ = null;
            // the server will shutdown the old connection
        }
    };
    Connection.prototype.onSecondaryControl_ = function (controlData) {
        if (MESSAGE_TYPE in controlData) {
            var cmd = controlData[MESSAGE_TYPE];
            if (cmd === SWITCH_ACK) {
                this.upgradeIfSecondaryHealthy_();
            }
            else if (cmd === CONTROL_RESET) {
                // Most likely the session wasn't valid. Abandon the switch attempt
                this.log_('Got a reset on secondary, closing it');
                this.secondaryConn_.close();
                // If we were already using this connection for something, than we need to fully close
                if (this.tx_ === this.secondaryConn_ ||
                    this.rx_ === this.secondaryConn_) {
                    this.close();
                }
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on secondary.');
                this.secondaryResponsesRequired_--;
                this.upgradeIfSecondaryHealthy_();
            }
        }
    };
    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {
        var layer = util_1.requireKey('t', parsedData);
        var data = util_1.requireKey('d', parsedData);
        if (layer == 'c') {
            this.onSecondaryControl_(data);
        }
        else if (layer == 'd') {
            // got a data message, but we're still second connection. Need to buffer it up
            this.pendingDataMessages.push(data);
        }
        else {
            throw new Error('Unknown protocol layer: ' + layer);
        }
    };
    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {
        if (this.secondaryResponsesRequired_ <= 0) {
            this.log_('Secondary connection is healthy.');
            this.isHealthy_ = true;
            this.secondaryConn_.markConnectionHealthy();
            this.proceedWithUpgrade_();
        }
        else {
            // Send a ping to make sure the connection is healthy.
            this.log_('sending ping on secondary.');
            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.proceedWithUpgrade_ = function () {
        // tell this connection to consider itself open
        this.secondaryConn_.start();
        // send ack
        this.log_('sending client ack on secondary');
        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });
        // send end packet on primary transport, switch to sending on this one
        // can receive on this one, buffer responses until end received on primary transport
        this.log_('Ending transmission on primary');
        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
    };
    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {
        // Must refer to parsedData properties in quotes, so closure doesn't touch them.
        var layer = util_1.requireKey('t', parsedData);
        var data = util_1.requireKey('d', parsedData);
        if (layer == 'c') {
            this.onControl_(data);
        }
        else if (layer == 'd') {
            this.onDataMessage_(data);
        }
    };
    Connection.prototype.onDataMessage_ = function (message) {
        this.onPrimaryResponse_();
        // We don't do anything with data messages, just kick them up a level
        this.onMessage_(message);
    };
    Connection.prototype.onPrimaryResponse_ = function () {
        if (!this.isHealthy_) {
            this.primaryResponsesRequired_--;
            if (this.primaryResponsesRequired_ <= 0) {
                this.log_('Primary connection is healthy.');
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
            }
        }
    };
    Connection.prototype.onControl_ = function (controlData) {
        var cmd = util_1.requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
            var payload = controlData[MESSAGE_DATA];
            if (cmd === SERVER_HELLO) {
                this.onHandshake_(payload);
            }
            else if (cmd === END_TRANSMISSION) {
                this.log_('recvd end transmission on primary');
                this.rx_ = this.secondaryConn_;
                for (var i = 0; i < this.pendingDataMessages.length; ++i) {
                    this.onDataMessage_(this.pendingDataMessages[i]);
                }
                this.pendingDataMessages = [];
                this.tryCleanupConnection();
            }
            else if (cmd === CONTROL_SHUTDOWN) {
                // This was previously the 'onKill' callback passed to the lower-level connection
                // payload in this case is the reason for the shutdown. Generally a human-readable error
                this.onConnectionShutdown_(payload);
            }
            else if (cmd === CONTROL_RESET) {
                // payload in this case is the host we should contact
                this.onReset_(payload);
            }
            else if (cmd === CONTROL_ERROR) {
                util_1.error('Server Error: ' + payload);
            }
            else if (cmd === CONTROL_PONG) {
                this.log_('got pong on primary.');
                this.onPrimaryResponse_();
                this.sendPingOnPrimaryIfNecessary_();
            }
            else {
                util_1.error('Unknown control packet command: ' + cmd);
            }
        }
    };
    /**
     *
     * @param {Object} handshake The handshake data returned from the server
     * @private
     */
    Connection.prototype.onHandshake_ = function (handshake) {
        var timestamp = handshake.ts;
        var version = handshake.v;
        var host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.updateHost(host);
        // if we've already closed the connection, then don't bother trying to progress further
        if (this.state_ == 0 /* CONNECTING */) {
            this.conn_.start();
            this.onConnectionEstablished_(this.conn_, timestamp);
            if (Constants_1.PROTOCOL_VERSION !== version) {
                util_1.warn('Protocol version mismatch detected');
            }
            // TODO: do we want to upgrade? when? maybe a delay?
            this.tryStartUpgrade_();
        }
    };
    Connection.prototype.tryStartUpgrade_ = function () {
        var conn = this.transportManager_.upgradeTransport();
        if (conn) {
            this.startUpgrade_(conn);
        }
    };
    Connection.prototype.startUpgrade_ = function (conn) {
        var _this = this;
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);
        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we
        // can consider the transport healthy.
        this.secondaryResponsesRequired_ =
            conn['responsesRequiredToBeHealthy'] || 0;
        var onMessage = this.connReceiver_(this.secondaryConn_);
        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect);
        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.
        util_1.setTimeoutNonBlocking(function () {
            if (_this.secondaryConn_) {
                _this.log_('Timed out trying to upgrade.');
                _this.secondaryConn_.close();
            }
        }, Math.floor(UPGRADE_TIMEOUT));
    };
    Connection.prototype.onReset_ = function (host) {
        this.log_('Reset packet received.  New host: ' + host);
        this.repoInfo_.updateHost(host);
        // TODO: if we're already "connected", we need to trigger a disconnect at the next layer up.
        // We don't currently support resets after the connection has already been established
        if (this.state_ === 1 /* CONNECTED */) {
            this.close();
        }
        else {
            // Close whatever connections we have open and start again.
            this.closeConnections_();
            this.start_();
        }
    };
    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {
        var _this = this;
        this.log_('Realtime connection established.');
        this.conn_ = conn;
        this.state_ = 1 /* CONNECTED */;
        if (this.onReady_) {
            this.onReady_(timestamp, this.sessionId);
            this.onReady_ = null;
        }
        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,
        // send some pings.
        if (this.primaryResponsesRequired_ === 0) {
            this.log_('Primary connection is healthy.');
            this.isHealthy_ = true;
        }
        else {
            util_1.setTimeoutNonBlocking(function () {
                _this.sendPingOnPrimaryIfNecessary_();
            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
    };
    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {
        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.
        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {
            this.log_('sending ping on primary.');
            this.sendData_({ t: 'c', d: { t: PING, d: {} } });
        }
    };
    Connection.prototype.onSecondaryConnectionLost_ = function () {
        var conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
            // we are relying on this connection already in some capacity. Therefore, a failure is real
            this.close();
        }
    };
    /**
     *
     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if
     * we should flush the host cache
     * @private
     */
    Connection.prototype.onConnectionLost_ = function (everConnected) {
        this.conn_ = null;
        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting
        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.
        if (!everConnected && this.state_ === 0 /* CONNECTING */) {
            this.log_('Realtime connection failed.');
            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away
            if (this.repoInfo_.isCacheableHost()) {
                storage_1.PersistentStorage.remove('host:' + this.repoInfo_.host);
                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com
                this.repoInfo_.internalHost = this.repoInfo_.host;
            }
        }
        else if (this.state_ === 1 /* CONNECTED */) {
            this.log_('Realtime connection lost.');
        }
        this.close();
    };
    /**
     *
     * @param {string} reason
     * @private
     */
    Connection.prototype.onConnectionShutdown_ = function (reason) {
        this.log_('Connection shutdown command received. Shutting down...');
        if (this.onKill_) {
            this.onKill_(reason);
            this.onKill_ = null;
        }
        // We intentionally don't want to fire onDisconnect (kill is a different case),
        // so clear the callback.
        this.onDisconnect_ = null;
        this.close();
    };
    Connection.prototype.sendData_ = function (data) {
        if (this.state_ !== 1 /* CONNECTED */) {
            throw 'Connection is not connected';
        }
        else {
            this.tx_.send(data);
        }
    };
    /**
     * Cleans up this connection, calling the appropriate callbacks
     */
    Connection.prototype.close = function () {
        if (this.state_ !== 2 /* DISCONNECTED */) {
            this.log_('Closing realtime connection.');
            this.state_ = 2 /* DISCONNECTED */;
            this.closeConnections_();
            if (this.onDisconnect_) {
                this.onDisconnect_();
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     *
     * @private
     */
    Connection.prototype.closeConnections_ = function () {
        this.log_('Shutting down all connections');
        if (this.conn_) {
            this.conn_.close();
            this.conn_ = null;
        }
        if (this.secondaryConn_) {
            this.secondaryConn_.close();
            this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
            clearTimeout(this.healthyTimeout_);
            this.healthyTimeout_ = null;
        }
    };
    return Connection;
}());
exports.Connection = Connection;

//# sourceMappingURL=Connection.js.map


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
var CountedSet_1 = __webpack_require__(60);
var StatsManager_1 = __webpack_require__(34);
var PacketReceiver_1 = __webpack_require__(128);
var Constants_1 = __webpack_require__(19);
var util_2 = __webpack_require__(0);
var util_3 = __webpack_require__(0);
// URL query parameters associated with longpolling
exports.FIREBASE_LONGPOLL_START_PARAM = 'start';
exports.FIREBASE_LONGPOLL_CLOSE_COMMAND = 'close';
exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME = 'pLPCommand';
exports.FIREBASE_LONGPOLL_DATA_CB_NAME = 'pRTLPCB';
exports.FIREBASE_LONGPOLL_ID_PARAM = 'id';
exports.FIREBASE_LONGPOLL_PW_PARAM = 'pw';
exports.FIREBASE_LONGPOLL_SERIAL_PARAM = 'ser';
exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = 'cb';
exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = 'seg';
exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = 'ts';
exports.FIREBASE_LONGPOLL_DATA_PARAM = 'd';
exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM = 'disconn';
exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = 'dframe';
//Data size constants.
//TODO: Perf: the maximum length actually differs from browser to browser.
// We should check what browser we're on and set accordingly.
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30; //ie: &seg=8299234&ts=982389123&d=
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
/**
 * Keepalive period
 * send a fresh request at minimum every 25 seconds. Opera has a maximum request
 * length of 30 seconds that we can't exceed.
 * @const
 * @type {number}
 */
var KEEPALIVE_REQUEST_INTERVAL = 25000;
/**
 * How long to wait before aborting a long-polling connection attempt.
 * @const
 * @type {number}
 */
var LP_CONNECT_TIMEOUT = 30000;
/**
 * This class manages a single long-polling connection.
 *
 * @constructor
 * @implements {Transport}
 */
var BrowserPollConnection = /** @class */ (function () {
    /**
     * @param {string} connId An identifier for this connection, used for logging
     * @param {RepoInfo} repoInfo The info for the endpoint to send data to.
     * @param {string=} transportSessionId Optional transportSessionid if we are reconnecting for an existing
     *                                         transport session
     * @param {string=}  lastSessionId Optional lastSessionId if the PersistentConnection has already created a
     *                                     connection previously
     */
    function BrowserPollConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = util_1.logWrapper(connId);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);
        this.urlFn = function (params) {
            return repoInfo.connectionURL(Constants_1.LONG_POLLING, params);
        };
    }
    /**
     *
     * @param {function(Object)} onMessage Callback when messages arrive
     * @param {function()} onDisconnect Callback with connection lost.
     */
    BrowserPollConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect;
        this.myPacketOrderer = new PacketReceiver_1.PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(function () {
            _this.log_('Timed out trying to connect.');
            // Make sure we clear the host cache
            _this.onClosed_();
            _this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        // Ensure we delay the creation of the iframe until the DOM is loaded.
        util_1.executeWhenDOMReady(function () {
            if (_this.isClosed_)
                return;
            //Set up a callback that gets triggered once a connection is set up.
            _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var command = args[0], arg1 = args[1], arg2 = args[2], arg3 = args[3], arg4 = args[4];
                _this.incrementIncomingBytes_(args);
                if (!_this.scriptTagHolder)
                    return; // we closed the connection.
                if (_this.connectTimeoutTimer_) {
                    clearTimeout(_this.connectTimeoutTimer_);
                    _this.connectTimeoutTimer_ = null;
                }
                _this.everConnected_ = true;
                if (command == exports.FIREBASE_LONGPOLL_START_PARAM) {
                    _this.id = arg1;
                    _this.password = arg2;
                }
                else if (command === exports.FIREBASE_LONGPOLL_CLOSE_COMMAND) {
                    // Don't clear the host cache. We got a response from the server, so we know it's reachable
                    if (arg1) {
                        // We aren't expecting any more data (other than what the server's already in the process of sending us
                        // through our already open polls), so don't send any more.
                        _this.scriptTagHolder.sendNewPolls = false;
                        // arg1 in this case is the last response number sent by the server. We should try to receive
                        // all of the responses up to this one before closing
                        _this.myPacketOrderer.closeAfter(arg1, function () {
                            _this.onClosed_();
                        });
                    }
                    else {
                        _this.onClosed_();
                    }
                }
                else {
                    throw new Error('Unrecognized command received: ' + command);
                }
            }, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var pN = args[0], data = args[1];
                _this.incrementIncomingBytes_(args);
                _this.myPacketOrderer.handleResponse(pN, data);
            }, function () {
                _this.onClosed_();
            }, _this.urlFn);
            //Send the initial request to connect. The serial number is simply to keep the browser from pulling previous results
            //from cache.
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_START_PARAM] = 't';
            urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 100000000);
            if (_this.scriptTagHolder.uniqueCallbackIdentifier)
                urlParams[exports.FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
            urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;
            if (_this.transportSessionId) {
                urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = _this.transportSessionId;
            }
            if (_this.lastSessionId) {
                urlParams[Constants_1.LAST_SESSION_PARAM] = _this.lastSessionId;
            }
            if (!util_3.isNodeSdk() &&
                typeof location !== 'undefined' &&
                location.href &&
                location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {
                urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;
            }
            var connectURL = _this.urlFn(urlParams);
            _this.log_('Connecting via long-poll to ' + connectURL);
            _this.scriptTagHolder.addTag(connectURL, function () {
                /* do nothing */
            });
        });
    };
    /**
     * Call this when a handshake has completed successfully and we want to consider the connection established
     */
    BrowserPollConnection.prototype.start = function () {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
    };
    /**
     * Forces long polling to be considered as a potential transport
     */
    BrowserPollConnection.forceAllow = function () {
        BrowserPollConnection.forceAllow_ = true;
    };
    /**
     * Forces longpolling to not be considered as a potential transport
     */
    BrowserPollConnection.forceDisallow = function () {
        BrowserPollConnection.forceDisallow_ = true;
    };
    // Static method, use string literal so it can be accessed in a generic way
    BrowserPollConnection.isAvailable = function () {
        // NOTE: In React-Native there's normally no 'document', but if you debug a React-Native app in
        // the Chrome debugger, 'document' is defined, but document.createElement is null (2015/06/08).
        return (BrowserPollConnection.forceAllow_ ||
            (!BrowserPollConnection.forceDisallow_ &&
                typeof document !== 'undefined' &&
                document.createElement != null &&
                !util_1.isChromeExtensionContentScript() &&
                !util_1.isWindowsStoreApp() &&
                !util_3.isNodeSdk()));
    };
    /**
     * No-op for polling
     */
    BrowserPollConnection.prototype.markConnectionHealthy = function () { };
    /**
     * Stops polling and cleans up the iframe
     * @private
     */
    BrowserPollConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
            this.scriptTagHolder.close();
            this.scriptTagHolder = null;
        }
        //remove the disconnect frame, which will trigger an XHR call to the server to tell it we're leaving.
        if (this.myDisconnFrame) {
            document.body.removeChild(this.myDisconnFrame);
            this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
            clearTimeout(this.connectTimeoutTimer_);
            this.connectTimeoutTimer_ = null;
        }
    };
    /**
     * Triggered when this transport is closed
     * @private
     */
    BrowserPollConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is closing itself');
            this.shutdown_();
            if (this.onDisconnect_) {
                this.onDisconnect_(this.everConnected_);
                this.onDisconnect_ = null;
            }
        }
    };
    /**
     * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
     * that we've left.
     */
    BrowserPollConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('Longpoll is being closed.');
            this.shutdown_();
        }
    };
    /**
     * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
     * broken into chunks (since URLs have a small maximum length).
     * @param {!Object} data The JSON data to transmit.
     */
    BrowserPollConnection.prototype.send = function (data) {
        var dataStr = util_2.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //first, lets get the base64-encoded data
        var base64data = util_2.base64Encode(dataStr);
        //We can only fit a certain amount in each URL, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = util_1.splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        //Enqueue each segment for transmission. We assign each chunk a sequential ID and a total number
        //of segments so that we can reassemble the packet on the server.
        for (var i = 0; i < dataSegs.length; i++) {
            this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
            this.curSegmentNum++;
        }
    };
    /**
     * This is how we notify the server that we're leaving.
     * We aren't able to send requests with DHTML on a window close event, but we can
     * trigger XHR requests in some browsers (everything but Opera basically).
     * @param {!string} id
     * @param {!string} pw
     */
    BrowserPollConnection.prototype.addDisconnectPingFrame = function (id, pw) {
        if (util_3.isNodeSdk())
            return;
        this.myDisconnFrame = document.createElement('iframe');
        var urlParams = {};
        urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = 't';
        urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = 'none';
        document.body.appendChild(this.myDisconnFrame);
    };
    /**
     * Used to track the bytes received by this client
     * @param {*} args
     * @private
     */
    BrowserPollConnection.prototype.incrementIncomingBytes_ = function (args) {
        // TODO: This is an annoying perf hit just to track the number of incoming bytes.  Maybe it should be opt-in.
        var bytesReceived = util_2.stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter('bytes_received', bytesReceived);
    };
    return BrowserPollConnection;
}());
exports.BrowserPollConnection = BrowserPollConnection;
/*********************************************************************************************
 * A wrapper around an iframe that is used as a long-polling script holder.
 * @constructor
 *********************************************************************************************/
var FirebaseIFrameScriptHolder = /** @class */ (function () {
    /**
     * @param commandCB - The callback to be called when control commands are recevied from the server.
     * @param onMessageCB - The callback to be triggered when responses arrive from the server.
     * @param onDisconnect - The callback to be triggered when this tag holder is closed
     * @param urlFn - A function that provides the URL of the endpoint to send data to.
     */
    function FirebaseIFrameScriptHolder(commandCB, onMessageCB, onDisconnect, urlFn) {
        this.onDisconnect = onDisconnect;
        this.urlFn = urlFn;
        //We maintain a count of all of the outstanding requests, because if we have too many active at once it can cause
        //problems in some browsers.
        /**
         * @type {CountedSet.<number, number>}
         */
        this.outstandingRequests = new CountedSet_1.CountedSet();
        //A queue of the pending segments waiting for transmission to the server.
        this.pendingSegs = [];
        //A serial number. We use this for two things:
        // 1) A way to ensure the browser doesn't cache responses to polls
        // 2) A way to make the server aware when long-polls arrive in a different order than we started them. The
        //    server needs to release both polls in this case or it will cause problems in Opera since Opera can only execute
        //    JSONP code in the order it was added to the iframe.
        this.currentSerial = Math.floor(Math.random() * 100000000);
        // This gets set to false when we're "closing down" the connection (e.g. we're switching transports but there's still
        // incoming data from the server that we're waiting for).
        this.sendNewPolls = true;
        if (!util_3.isNodeSdk()) {
            //Each script holder registers a couple of uniquely named callbacks with the window. These are called from the
            //iframes where we put the long-polling script tags. We have two callbacks:
            //   1) Command Callback - Triggered for control issues, like starting a connection.
            //   2) Message Callback - Triggered when new data arrives.
            this.uniqueCallbackIdentifier = util_1.LUIDGenerator();
            window[exports.FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
            window[exports.FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
            //Create an iframe for us to add script tags to.
            this.myIFrame = FirebaseIFrameScriptHolder.createIFrame_();
            // Set the iframe's contents.
            var script = '';
            // if we set a javascript url, it's IE and we need to set the document domain. The javascript url is sufficient
            // for ie9, but ie8 needs to do it again in the document itself.
            if (this.myIFrame.src &&
                this.myIFrame.src.substr(0, 'javascript:'.length) === 'javascript:') {
                var currentDomain = document.domain;
                script = '<script>document.domain="' + currentDomain + '";</script>';
            }
            var iframeContents = '<html><body>' + script + '</body></html>';
            try {
                this.myIFrame.doc.open();
                this.myIFrame.doc.write(iframeContents);
                this.myIFrame.doc.close();
            }
            catch (e) {
                util_1.log('frame writing exception');
                if (e.stack) {
                    util_1.log(e.stack);
                }
                util_1.log(e);
            }
        }
        else {
            this.commandCB = commandCB;
            this.onMessageCB = onMessageCB;
        }
    }
    /**
     * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
     * actually use.
     * @private
     * @return {Element}
     */
    FirebaseIFrameScriptHolder.createIFrame_ = function () {
        var iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        // This is necessary in order to initialize the document inside the iframe
        if (document.body) {
            document.body.appendChild(iframe);
            try {
                // If document.domain has been modified in IE, this will throw an error, and we need to set the
                // domain of the iframe's document manually. We can do this via a javascript: url as the src attribute
                // Also note that we must do this *after* the iframe has been appended to the page. Otherwise it doesn't work.
                var a = iframe.contentWindow.document;
                if (!a) {
                    // Apologies for the log-spam, I need to do something to keep closure from optimizing out the assignment above.
                    util_1.log('No IE domain setting required');
                }
            }
            catch (e) {
                var domain = document.domain;
                iframe.src =
                    "javascript:void((function(){document.open();document.domain='" +
                        domain +
                        "';document.close();})())";
            }
        }
        else {
            // LongPollConnection attempts to delay initialization until the document is ready, so hopefully this
            // never gets hit.
            throw 'Document body has not initialized. Wait to initialize Firebase until after the document is ready.';
        }
        // Get the document of the iframe in a browser-specific way.
        if (iframe.contentDocument) {
            iframe.doc = iframe.contentDocument; // Firefox, Opera, Safari
        }
        else if (iframe.contentWindow) {
            iframe.doc = iframe.contentWindow.document; // Internet Explorer
        }
        else if (iframe.document) {
            iframe.doc = iframe.document; //others?
        }
        return iframe;
    };
    /**
     * Cancel all outstanding queries and remove the frame.
     */
    FirebaseIFrameScriptHolder.prototype.close = function () {
        var _this = this;
        //Mark this iframe as dead, so no new requests are sent.
        this.alive = false;
        if (this.myIFrame) {
            //We have to actually remove all of the html inside this iframe before removing it from the
            //window, or IE will continue loading and executing the script tags we've already added, which
            //can lead to some errors being thrown. Setting innerHTML seems to be the easiest way to do this.
            this.myIFrame.doc.body.innerHTML = '';
            setTimeout(function () {
                if (_this.myIFrame !== null) {
                    document.body.removeChild(_this.myIFrame);
                    _this.myIFrame = null;
                }
            }, Math.floor(0));
        }
        if (util_3.isNodeSdk() && this.myID) {
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_DISCONN_FRAME_PARAM] = 't';
            urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            var theURL = this.urlFn(urlParams);
            FirebaseIFrameScriptHolder.nodeRestRequest(theURL);
        }
        // Protect from being called recursively.
        var onDisconnect = this.onDisconnect;
        if (onDisconnect) {
            this.onDisconnect = null;
            onDisconnect();
        }
    };
    /**
     * Actually start the long-polling session by adding the first script tag(s) to the iframe.
     * @param {!string} id - The ID of this connection
     * @param {!string} pw - The password for this connection
     */
    FirebaseIFrameScriptHolder.prototype.startLongPoll = function (id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        //send the initial request. If there are requests queued, make sure that we transmit as many as we are currently able to.
        while (this.newRequest_()) { }
    };
    /**
     * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
     * too many outstanding requests and we are still alive.
     *
     * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
     * needed.
     */
    FirebaseIFrameScriptHolder.prototype.newRequest_ = function () {
        // We keep one outstanding request open all the time to receive data, but if we need to send data
        // (pendingSegs.length > 0) then we create a new request to send the data.  The server will automatically
        // close the old request.
        if (this.alive &&
            this.sendNewPolls &&
            this.outstandingRequests.count() < (this.pendingSegs.length > 0 ? 2 : 1)) {
            //construct our url
            this.currentSerial++;
            var urlParams = {};
            urlParams[exports.FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
            urlParams[exports.FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
            urlParams[exports.FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
            var theURL = this.urlFn(urlParams);
            //Now add as much data as we can.
            var curDataString = '';
            var i = 0;
            while (this.pendingSegs.length > 0) {
                //first, lets see if the next segment will fit.
                var nextSeg = this.pendingSegs[0];
                if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <=
                    MAX_URL_DATA_SIZE) {
                    //great, the segment will fit. Lets append it.
                    var theSeg = this.pendingSegs.shift();
                    curDataString =
                        curDataString +
                            '&' +
                            exports.FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM +
                            i +
                            '=' +
                            theSeg.seg +
                            '&' +
                            exports.FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET +
                            i +
                            '=' +
                            theSeg.ts +
                            '&' +
                            exports.FIREBASE_LONGPOLL_DATA_PARAM +
                            i +
                            '=' +
                            theSeg.d;
                    i++;
                }
                else {
                    break;
                }
            }
            theURL = theURL + curDataString;
            this.addLongPollTag_(theURL, this.currentSerial);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Queue a packet for transmission to the server.
     * @param segnum - A sequential id for this packet segment used for reassembly
     * @param totalsegs - The total number of segments in this packet
     * @param data - The data for this segment.
     */
    FirebaseIFrameScriptHolder.prototype.enqueueSegment = function (segnum, totalsegs, data) {
        //add this to the queue of segments to send.
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        //send the data immediately if there isn't already data being transmitted, unless
        //startLongPoll hasn't been called yet.
        if (this.alive) {
            this.newRequest_();
        }
    };
    /**
     * Add a script tag for a regular long-poll request.
     * @param {!string} url - The URL of the script tag.
     * @param {!number} serial - The serial number of the request.
     * @private
     */
    FirebaseIFrameScriptHolder.prototype.addLongPollTag_ = function (url, serial) {
        var _this = this;
        //remember that we sent this request.
        this.outstandingRequests.add(serial, 1);
        var doNewRequest = function () {
            _this.outstandingRequests.remove(serial);
            _this.newRequest_();
        };
        // If this request doesn't return on its own accord (by the server sending us some data), we'll
        // create a new one after the KEEPALIVE interval to make sure we always keep a fresh request open.
        var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        var readyStateCB = function () {
            // Request completed.  Cancel the keepalive.
            clearTimeout(keepaliveTimeout);
            // Trigger a new request so we can continue receiving data.
            doNewRequest();
        };
        this.addTag(url, readyStateCB);
    };
    /**
     * Add an arbitrary script tag to the iframe.
     * @param {!string} url - The URL for the script tag source.
     * @param {!function()} loadCB - A callback to be triggered once the script has loaded.
     */
    FirebaseIFrameScriptHolder.prototype.addTag = function (url, loadCB) {
        var _this = this;
        if (util_3.isNodeSdk()) {
            this.doNodeLongPoll(url, loadCB);
        }
        else {
            setTimeout(function () {
                try {
                    // if we're already closed, don't add this poll
                    if (!_this.sendNewPolls)
                        return;
                    var newScript_1 = _this.myIFrame.doc.createElement('script');
                    newScript_1.type = 'text/javascript';
                    newScript_1.async = true;
                    newScript_1.src = url;
                    newScript_1.onload = newScript_1.onreadystatechange = function () {
                        var rstate = newScript_1.readyState;
                        if (!rstate || rstate === 'loaded' || rstate === 'complete') {
                            newScript_1.onload = newScript_1.onreadystatechange = null;
                            if (newScript_1.parentNode) {
                                newScript_1.parentNode.removeChild(newScript_1);
                            }
                            loadCB();
                        }
                    };
                    newScript_1.onerror = function () {
                        util_1.log('Long-poll script failed to load: ' + url);
                        _this.sendNewPolls = false;
                        _this.close();
                    };
                    _this.myIFrame.doc.body.appendChild(newScript_1);
                }
                catch (e) {
                    // TODO: we should make this error visible somehow
                }
            }, Math.floor(1));
        }
    };
    return FirebaseIFrameScriptHolder;
}());
exports.FirebaseIFrameScriptHolder = FirebaseIFrameScriptHolder;

//# sourceMappingURL=BrowserPollConnection.js.map


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = __webpack_require__(8);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var StatsManager_1 = __webpack_require__(34);
var Constants_1 = __webpack_require__(19);
var util_3 = __webpack_require__(0);
var storage_1 = __webpack_require__(18);
var util_4 = __webpack_require__(0);
var util_5 = __webpack_require__(0);
var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45000;
var WebSocketImpl = null;
if (typeof MozWebSocket !== 'undefined') {
    WebSocketImpl = MozWebSocket;
}
else if (typeof WebSocket !== 'undefined') {
    WebSocketImpl = WebSocket;
}
function setWebSocketImpl(impl) {
    WebSocketImpl = impl;
}
exports.setWebSocketImpl = setWebSocketImpl;
/**
 * Create a new websocket connection with the given callbacks.
 * @constructor
 * @implements {Transport}
 */
var WebSocketConnection = /** @class */ (function () {
    /**
     * @param {string} connId identifier for this transport
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     */
    function WebSocketConnection(connId, repoInfo, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = util_2.logWrapper(this.connId);
        this.stats_ = StatsManager_1.StatsManager.getCollection(repoInfo);
        this.connURL = WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId);
    }
    /**
     * @param {RepoInfo} repoInfo The info for the websocket endpoint.
     * @param {string=} transportSessionId Optional transportSessionId if this is connecting to an existing transport
     *                                         session
     * @param {string=} lastSessionId Optional lastSessionId if there was a previous connection
     * @return {string} connection url
     * @private
     */
    WebSocketConnection.connectionURL_ = function (repoInfo, transportSessionId, lastSessionId) {
        var urlParams = {};
        urlParams[Constants_1.VERSION_PARAM] = Constants_1.PROTOCOL_VERSION;
        if (!util_5.isNodeSdk() &&
            typeof location !== 'undefined' &&
            location.href &&
            location.href.indexOf(Constants_1.FORGE_DOMAIN) !== -1) {
            urlParams[Constants_1.REFERER_PARAM] = Constants_1.FORGE_REF;
        }
        if (transportSessionId) {
            urlParams[Constants_1.TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
            urlParams[Constants_1.LAST_SESSION_PARAM] = lastSessionId;
        }
        return repoInfo.connectionURL(Constants_1.WEBSOCKET, urlParams);
    };
    /**
     *
     * @param onMessage Callback when messages arrive
     * @param onDisconnect Callback with connection lost.
     */
    WebSocketConnection.prototype.open = function (onMessage, onDisconnect) {
        var _this = this;
        this.onDisconnect = onDisconnect;
        this.onMessage = onMessage;
        this.log_('Websocket connecting to ' + this.connURL);
        this.everConnected_ = false;
        // Assume failure until proven otherwise.
        storage_1.PersistentStorage.set('previous_websocket_failure', true);
        try {
            if (util_5.isNodeSdk()) {
                var device = util_3.CONSTANTS.NODE_ADMIN ? 'AdminNode' : 'Node';
                // UA Format: Firebase/<wire_protocol>/<sdk_version>/<platform>/<device>
                var options = {
                    headers: {
                        'User-Agent': "Firebase/" + Constants_1.PROTOCOL_VERSION + "/" + app_1.default.SDK_VERSION + "/" + process.platform + "/" + device
                    }
                };
                // Plumb appropriate http_proxy environment variable into faye-websocket if it exists.
                var env = process['env'];
                var proxy = this.connURL.indexOf('wss://') == 0
                    ? env['HTTPS_PROXY'] || env['https_proxy']
                    : env['HTTP_PROXY'] || env['http_proxy'];
                if (proxy) {
                    options['proxy'] = { origin: proxy };
                }
                this.mySock = new WebSocketImpl(this.connURL, [], options);
            }
            else {
                this.mySock = new WebSocketImpl(this.connURL);
            }
        }
        catch (e) {
            this.log_('Error instantiating WebSocket.');
            var error = e.message || e.data;
            if (error) {
                this.log_(error);
            }
            this.onClosed_();
            return;
        }
        this.mySock.onopen = function () {
            _this.log_('Websocket connected.');
            _this.everConnected_ = true;
        };
        this.mySock.onclose = function () {
            _this.log_('Websocket connection was disconnected.');
            _this.mySock = null;
            _this.onClosed_();
        };
        this.mySock.onmessage = function (m) {
            _this.handleIncomingFrame(m);
        };
        this.mySock.onerror = function (e) {
            _this.log_('WebSocket error.  Closing connection.');
            var error = e.message || e.data;
            if (error) {
                _this.log_(error);
            }
            _this.onClosed_();
        };
    };
    /**
     * No-op for websockets, we don't need to do anything once the connection is confirmed as open
     */
    WebSocketConnection.prototype.start = function () { };
    WebSocketConnection.forceDisallow = function () {
        WebSocketConnection.forceDisallow_ = true;
    };
    WebSocketConnection.isAvailable = function () {
        var isOldAndroid = false;
        if (typeof navigator !== 'undefined' && navigator.userAgent) {
            var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
            var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
            if (oldAndroidMatch && oldAndroidMatch.length > 1) {
                if (parseFloat(oldAndroidMatch[1]) < 4.4) {
                    isOldAndroid = true;
                }
            }
        }
        return (!isOldAndroid &&
            WebSocketImpl !== null &&
            !WebSocketConnection.forceDisallow_);
    };
    /**
     * Returns true if we previously failed to connect with this transport.
     * @return {boolean}
     */
    WebSocketConnection.previouslyFailed = function () {
        // If our persistent storage is actually only in-memory storage,
        // we default to assuming that it previously failed to be safe.
        return (storage_1.PersistentStorage.isInMemoryStorage ||
            storage_1.PersistentStorage.get('previous_websocket_failure') === true);
    };
    WebSocketConnection.prototype.markConnectionHealthy = function () {
        storage_1.PersistentStorage.remove('previous_websocket_failure');
    };
    WebSocketConnection.prototype.appendFrame_ = function (data) {
        this.frames.push(data);
        if (this.frames.length == this.totalFrames) {
            var fullMess = this.frames.join('');
            this.frames = null;
            var jsonMess = util_4.jsonEval(fullMess);
            //handle the message
            this.onMessage(jsonMess);
        }
    };
    /**
     * @param {number} frameCount The number of frames we are expecting from the server
     * @private
     */
    WebSocketConnection.prototype.handleNewFrameCount_ = function (frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
    };
    /**
     * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
     * @param {!String} data
     * @return {?String} Any remaining data to be process, or null if there is none
     * @private
     */
    WebSocketConnection.prototype.extractFrameCount_ = function (data) {
        util_1.assert(this.frames === null, 'We already have a frame buffer');
        // TODO: The server is only supposed to send up to 9999 frames (i.e. length <= 4), but that isn't being enforced
        // currently.  So allowing larger frame counts (length <= 6).  See https://app.asana.com/0/search/8688598998380/8237608042508
        if (data.length <= 6) {
            var frameCount = Number(data);
            if (!isNaN(frameCount)) {
                this.handleNewFrameCount_(frameCount);
                return null;
            }
        }
        this.handleNewFrameCount_(1);
        return data;
    };
    /**
     * Process a websocket frame that has arrived from the server.
     * @param mess The frame data
     */
    WebSocketConnection.prototype.handleIncomingFrame = function (mess) {
        if (this.mySock === null)
            return; // Chrome apparently delivers incoming packets even after we .close() the connection sometimes.
        var data = mess['data'];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter('bytes_received', data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
            // we're buffering
            this.appendFrame_(data);
        }
        else {
            // try to parse out a frame count, otherwise, assume 1 and process it
            var remainingData = this.extractFrameCount_(data);
            if (remainingData !== null) {
                this.appendFrame_(remainingData);
            }
        }
    };
    /**
     * Send a message to the server
     * @param {Object} data The JSON object to transmit
     */
    WebSocketConnection.prototype.send = function (data) {
        this.resetKeepAlive();
        var dataStr = util_4.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter('bytes_sent', dataStr.length);
        //We can only fit a certain amount in each websocket frame, so we need to split this request
        //up into multiple pieces if it doesn't fit in one request.
        var dataSegs = util_2.splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        //Send the length header
        if (dataSegs.length > 1) {
            this.sendString_(String(dataSegs.length));
        }
        //Send the actual data in segments.
        for (var i = 0; i < dataSegs.length; i++) {
            this.sendString_(dataSegs[i]);
        }
    };
    WebSocketConnection.prototype.shutdown_ = function () {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
            clearInterval(this.keepaliveTimer);
            this.keepaliveTimer = null;
        }
        if (this.mySock) {
            this.mySock.close();
            this.mySock = null;
        }
    };
    WebSocketConnection.prototype.onClosed_ = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is closing itself');
            this.shutdown_();
            // since this is an internal close, trigger the close listener
            if (this.onDisconnect) {
                this.onDisconnect(this.everConnected_);
                this.onDisconnect = null;
            }
        }
    };
    /**
     * External-facing close handler.
     * Close the websocket and kill the connection.
     */
    WebSocketConnection.prototype.close = function () {
        if (!this.isClosed_) {
            this.log_('WebSocket is being closed');
            this.shutdown_();
        }
    };
    /**
     * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
     * the last activity.
     */
    WebSocketConnection.prototype.resetKeepAlive = function () {
        var _this = this;
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(function () {
            //If there has been no websocket activity for a while, send a no-op
            if (_this.mySock) {
                _this.sendString_('0');
            }
            _this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    };
    /**
     * Send a string over the websocket.
     *
     * @param {string} str String to send.
     * @private
     */
    WebSocketConnection.prototype.sendString_ = function (str) {
        // Firefox seems to sometimes throw exceptions (NS_ERROR_UNEXPECTED) from websocket .send()
        // calls for some unknown reason.  We treat these as an error and disconnect.
        // See https://app.asana.com/0/58926111402292/68021340250410
        try {
            this.mySock.send(str);
        }
        catch (e) {
            this.log_('Exception thrown from WebSocket.send():', e.message || e.data, 'Closing connection.');
            setTimeout(this.onClosed_.bind(this), 0);
        }
    };
    /**
     * Number of response before we consider the connection "healthy."
     * @type {number}
     */
    WebSocketConnection.responsesRequiredToBeHealthy = 2;
    /**
     * Time to wait for the connection te become healthy before giving up.
     * @type {number}
     */
    WebSocketConnection.healthyTimeout = 30000;
    return WebSocketConnection;
}());
exports.WebSocketConnection = WebSocketConnection;

//# sourceMappingURL=WebSocketConnection.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Interface defining the set of actions that can be performed against the Firebase server
 * (basically corresponds to our wire protocol).
 *
 * @interface
 */
var ServerActions = /** @class */ (function () {
    function ServerActions() {
    }
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.put = function (pathString, data, onComplete, hash) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, ?string)} onComplete
     * @param {string=} hash
     */
    ServerActions.prototype.merge = function (pathString, data, onComplete, hash) { };
    /**
     * Refreshes the auth token for the current connection.
     * @param {string} token The authentication token
     */
    ServerActions.prototype.refreshAuthToken = function (token) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectPut = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {*} data
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectMerge = function (pathString, data, onComplete) { };
    /**
     * @param {string} pathString
     * @param {function(string, string)=} onComplete
     */
    ServerActions.prototype.onDisconnectCancel = function (pathString, onComplete) { };
    /**
     * @param {Object.<string, *>} stats
     */
    ServerActions.prototype.reportStats = function (stats) { };
    return ServerActions;
}());
exports.ServerActions = ServerActions;

//# sourceMappingURL=ServerActions.js.map


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IndexedFilter_1 = __webpack_require__(33);
var PriorityIndex_1 = __webpack_require__(3);
var Node_1 = __webpack_require__(5);
var ChildrenNode_1 = __webpack_require__(4);
/**
 * Filters nodes by range and uses an IndexFilter to track any changes after filtering the node
 *
 * @constructor
 * @implements {NodeFilter}
 */
var RangedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function RangedFilter(params) {
        this.indexedFilter_ = new IndexedFilter_1.IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = RangedFilter.getStartPost_(params);
        this.endPost_ = RangedFilter.getEndPost_(params);
    }
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getStartPost = function () {
        return this.startPost_;
    };
    /**
     * @return {!NamedNode}
     */
    RangedFilter.prototype.getEndPost = function () {
        return this.endPost_;
    };
    /**
     * @param {!NamedNode} node
     * @return {boolean}
     */
    RangedFilter.prototype.matches = function (node) {
        return (this.index_.compare(this.getStartPost(), node) <= 0 &&
            this.index_.compare(node, this.getEndPost()) <= 0);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new Node_1.NamedNode(key, newChild))) {
            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            newSnap = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        var filtered = newSnap.withIndex(this.index_);
        // Don't support priorities on queries
        filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);
        var self = this;
        newSnap.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
            if (!self.matches(new Node_1.NamedNode(key, childNode))) {
                filtered = filtered.updateImmediateChild(key, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
            }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndexedFilter = function () {
        return this.indexedFilter_;
    };
    /**
     * @inheritDoc
     */
    RangedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getStartPost_ = function (params) {
        if (params.hasStart()) {
            var startName = params.getIndexStartName();
            return params.getIndex().makePost(params.getIndexStartValue(), startName);
        }
        else {
            return params.getIndex().minPost();
        }
    };
    /**
     * @param {!QueryParams} params
     * @return {!NamedNode}
     * @private
     */
    RangedFilter.getEndPost_ = function (params) {
        if (params.hasEnd()) {
            var endName = params.getIndexEndName();
            return params.getIndex().makePost(params.getIndexEndValue(), endName);
        }
        else {
            return params.getIndex().maxPost();
        }
    };
    return RangedFilter;
}());
exports.RangedFilter = RangedFilter;

//# sourceMappingURL=RangedFilter.js.map


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__firebase_util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_errors__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__models_token_manager__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__models_notification_permission__ = __webpack_require__(74);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var SENDER_ID_OPTION_NAME = 'messagingSenderId';
var ControllerInterface = /** @class */ (function () {
    /**
     * An interface of the Messaging Service API
     * @param {!firebase.app.App} app
     */
    function ControllerInterface(app) {
        var _this = this;
        this.errorFactory_ = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["ErrorFactory"]('messaging', 'Messaging', __WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].map);
        if (!app.options[SENDER_ID_OPTION_NAME] ||
            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {
            throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.BAD_SENDER_ID);
        }
        this.messagingSenderId_ = app.options[SENDER_ID_OPTION_NAME];
        this.tokenManager_ = new __WEBPACK_IMPORTED_MODULE_2__models_token_manager__["a" /* default */]();
        this.app = app;
        this.INTERNAL = {};
        this.INTERNAL.delete = function () { return _this.delete; };
    }
    /**
     * @export
     * @return {Promise<string> | Promise<null>} Returns a promise that
     * resolves to an FCM token.
     */
    ControllerInterface.prototype.getToken = function () {
        var _this = this;
        // Check with permissions
        var currentPermission = this.getNotificationPermission_();
        if (currentPermission !== __WEBPACK_IMPORTED_MODULE_3__models_notification_permission__["a" /* default */].granted) {
            if (currentPermission === __WEBPACK_IMPORTED_MODULE_3__models_notification_permission__["a" /* default */].denied) {
                return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.NOTIFICATIONS_BLOCKED));
            }
            // We must wait for permission to be granted
            return Promise.resolve(null);
        }
        return this.getSWRegistration_().then(function (registration) {
            return _this.tokenManager_
                .getSavedToken(_this.messagingSenderId_, registration)
                .then(function (token) {
                if (token) {
                    return token;
                }
                return _this.tokenManager_.createToken(_this.messagingSenderId_, registration);
            });
        });
    };
    /**
     * This method deletes tokens that the token manager looks after and then
     * unregisters the push subscription if it exists.
     * @export
     * @param {string} token
     * @return {Promise<void>}
     */
    ControllerInterface.prototype.deleteToken = function (token) {
        var _this = this;
        return this.tokenManager_.deleteToken(token).then(function () {
            return _this.getSWRegistration_()
                .then(function (registration) {
                if (registration) {
                    return registration.pushManager.getSubscription();
                }
            })
                .then(function (subscription) {
                if (subscription) {
                    return subscription.unsubscribe();
                }
            });
        });
    };
    ControllerInterface.prototype.getSWRegistration_ = function () {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.SHOULD_BE_INHERITED);
    };
    //
    // The following methods should only be available in the window.
    //
    ControllerInterface.prototype.requestPermission = function () {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!ServiceWorkerRegistration} registration
     */
    ControllerInterface.prototype.useServiceWorker = function (registration) {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!firebase.Observer|function(*)} nextOrObserver
     * @param {function(!Error)=} optError
     * @param {function()=} optCompleted
     * @return {!function()}
     */
    ControllerInterface.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.AVAILABLE_IN_WINDOW);
    };
    /**
     * @export
     * @param {!firebase.Observer|function()} nextOrObserver An observer object
     * or a function triggered on token refresh.
     * @param {function(!Error)=} optError Optional A function
     * triggered on token refresh error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    ControllerInterface.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.AVAILABLE_IN_WINDOW);
    };
    //
    // The following methods are used by the service worker only.
    //
    /**
     * @export
     * @param {function(Object)} callback
     */
    ControllerInterface.prototype.setBackgroundMessageHandler = function (callback) {
        throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.AVAILABLE_IN_SW);
    };
    //
    // The following methods are used by the service themselves and not exposed
    // publicly or not expected to be used by developers.
    //
    /**
     * This method is required to adhere to the Firebase interface.
     * It closes any currently open indexdb database connections.
     */
    ControllerInterface.prototype.delete = function () {
        return this.tokenManager_.closeDatabase();
    };
    /**
     * Returns the current Notification Permission state.
     * @private
     * @return {string} The currenct permission state.
     */
    ControllerInterface.prototype.getNotificationPermission_ = function () {
        return Notification.permission;
    };
    /**
     * @protected
     * @returns {TokenManager}
     */
    ControllerInterface.prototype.getTokenManager = function () {
        return this.tokenManager_;
    };
    return ControllerInterface;
}());
/* harmony default export */ __webpack_exports__["a"] = (ControllerInterface);

//# sourceMappingURL=controller-interface.js.map


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FCM_APPLICATION_SERVER_KEY = [
    0x04,
    0x33,
    0x94,
    0xf7,
    0xdf,
    0xa1,
    0xeb,
    0xb1,
    0xdc,
    0x03,
    0xa2,
    0x5e,
    0x15,
    0x71,
    0xdb,
    0x48,
    0xd3,
    0x2e,
    0xed,
    0xed,
    0xb2,
    0x34,
    0xdb,
    0xb7,
    0x47,
    0x3a,
    0x0c,
    0x8f,
    0xc4,
    0xcc,
    0xe1,
    0x6f,
    0x3c,
    0x8c,
    0x84,
    0xdf,
    0xab,
    0xb6,
    0x66,
    0x3e,
    0xf2,
    0x0c,
    0xd4,
    0x8b,
    0xfe,
    0xe3,
    0xf9,
    0x76,
    0x2f,
    0x14,
    0x1c,
    0x63,
    0x08,
    0x6a,
    0x6f,
    0x2d,
    0xb1,
    0x1a,
    0x95,
    0xb0,
    0xce,
    0x37,
    0xc0,
    0x9c,
    0x6e
];
var SUBSCRIPTION_DETAILS = {
    userVisibleOnly: true,
    applicationServerKey: new Uint8Array(FCM_APPLICATION_SERVER_KEY)
};
/* harmony default export */ __webpack_exports__["a"] = ({
    ENDPOINT: 'https://fcm.googleapis.com',
    APPLICATION_SERVER_KEY: FCM_APPLICATION_SERVER_KEY,
    SUBSCRIPTION_OPTIONS: SUBSCRIPTION_DETAILS
});

//# sourceMappingURL=fcm-details.js.map


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = ({
    granted: 'granted',
    default: 'default',
    denied: 'denied'
});

//# sourceMappingURL=notification-permission.js.map


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// These fields are strings to prevent closure from thinking goog.getMsg
// should be used to initialise the values
var PARAMS = {
    TYPE_OF_MSG: 'firebase-messaging-msg-type',
    DATA: 'firebase-messaging-msg-data'
};
// This value isn't using the TYPE_OF_MSG short hand as closure
// expects the variable to be defined via goog.getMsg
var msgType = {
    PUSH_MSG_RECEIVED: 'push-msg-received',
    NOTIFICATION_CLICKED: 'notification-clicked'
};
var createNewMsg = function (msgType, msgData) {
    var message = (_a = {},
        _a[PARAMS.TYPE_OF_MSG] = msgType,
        _a[PARAMS.DATA] = msgData,
        _a);
    return message;
    var _a;
};
/* harmony default export */ __webpack_exports__["a"] = ({
    PARAMS: PARAMS,
    TYPES_OF_MSG: msgType,
    createNewMsg: createNewMsg
});

//# sourceMappingURL=worker-page-message.js.map


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorCode; });
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @enum{number}
 */
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["NO_ERROR"] = 0] = "NO_ERROR";
    ErrorCode[ErrorCode["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
    ErrorCode[ErrorCode["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));

//# sourceMappingURL=xhrio.js.map


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Reference; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__implementation_args__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__implementation_blob__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__implementation_error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__implementation_location__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__implementation_metadata__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__implementation_object__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__implementation_path__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__implementation_requests__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__implementation_string__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__implementation_type__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__task__ = __webpack_require__(152);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Defines the Firebase Storage Reference class.
 */












/**
 * Provides methods to interact with a bucket in the Firebase Storage service.
 * @param location An fbs.location, or the URL at
 *     which to base this object, in one of the following forms:
 *         gs://<bucket>/<object-path>
 *         http[s]://firebasestorage.googleapis.com/
 *                     <api-version>/b/<bucket>/o/<object-path>
 *     Any query or fragment strings will be ignored in the http[s]
 *     format. If no value is passed, the storage object will use a URL based on
 *     the project ID of the base firebase.App instance.
 */
var Reference = /** @class */ (function () {
    function Reference(authWrapper, location) {
        this.authWrapper = authWrapper;
        if (location instanceof __WEBPACK_IMPORTED_MODULE_3__implementation_location__["a" /* Location */]) {
            this.location = location;
        }
        else {
            this.location = __WEBPACK_IMPORTED_MODULE_3__implementation_location__["a" /* Location */].makeFromUrl(location);
        }
    }
    /**
     * @return The URL for the bucket and path this object references,
     *     in the form gs://<bucket>/<object-path>
     * @override
     */
    Reference.prototype.toString = function () {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('toString', [], arguments);
        return 'gs://' + this.location.bucket + '/' + this.location.path;
    };
    Reference.prototype.newRef = function (authWrapper, location) {
        return new Reference(authWrapper, location);
    };
    Reference.prototype.mappings = function () {
        return __WEBPACK_IMPORTED_MODULE_4__implementation_metadata__["b" /* getMappings */]();
    };
    /**
     * @return A reference to the object obtained by
     *     appending childPath, removing any duplicate, beginning, or trailing
     *     slashes.
     */
    Reference.prototype.child = function (childPath) {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('child', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["e" /* stringSpec */]()], arguments);
        var newPath = __WEBPACK_IMPORTED_MODULE_6__implementation_path__["a" /* child */](this.location.path, childPath);
        var location = new __WEBPACK_IMPORTED_MODULE_3__implementation_location__["a" /* Location */](this.location.bucket, newPath);
        return this.newRef(this.authWrapper, location);
    };
    Object.defineProperty(Reference.prototype, "parent", {
        /**
         * @return A reference to the parent of the
         *     current object, or null if the current object is the root.
         */
        get: function () {
            var newPath = __WEBPACK_IMPORTED_MODULE_6__implementation_path__["c" /* parent */](this.location.path);
            if (newPath === null) {
                return null;
            }
            var location = new __WEBPACK_IMPORTED_MODULE_3__implementation_location__["a" /* Location */](this.location.bucket, newPath);
            return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "root", {
        /**
         * @return An reference to the root of this
         *     object's bucket.
         */
        get: function () {
            var location = new __WEBPACK_IMPORTED_MODULE_3__implementation_location__["a" /* Location */](this.location.bucket, '');
            return this.newRef(this.authWrapper, location);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "bucket", {
        get: function () {
            return this.location.bucket;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "fullPath", {
        get: function () {
            return this.location.path;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "name", {
        get: function () {
            return __WEBPACK_IMPORTED_MODULE_6__implementation_path__["b" /* lastComponent */](this.location.path);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Reference.prototype, "storage", {
        get: function () {
            return this.authWrapper.service();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Uploads a blob to this object's location.
     * @param data The blob to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.put = function (data, metadata) {
        if (metadata === void 0) { metadata = null; }
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('put', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["f" /* uploadDataSpec */](), __WEBPACK_IMPORTED_MODULE_0__implementation_args__["b" /* metadataSpec */](true)], arguments);
        this.throwIfRoot_('put');
        return new __WEBPACK_IMPORTED_MODULE_10__task__["a" /* UploadTask */](this, this.authWrapper, this.location, this.mappings(), new __WEBPACK_IMPORTED_MODULE_1__implementation_blob__["a" /* FbsBlob */](data), metadata);
    };
    /**
     * Uploads a string to this object's location.
     * @param string The string to upload.
     * @param opt_format The format of the string to upload.
     * @return An UploadTask that lets you control and
     *     observe the upload.
     */
    Reference.prototype.putString = function (string, format, opt_metadata) {
        if (format === void 0) { format = __WEBPACK_IMPORTED_MODULE_8__implementation_string__["a" /* StringFormat */].RAW; }
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('putString', [
            __WEBPACK_IMPORTED_MODULE_0__implementation_args__["e" /* stringSpec */](),
            __WEBPACK_IMPORTED_MODULE_0__implementation_args__["e" /* stringSpec */](__WEBPACK_IMPORTED_MODULE_8__implementation_string__["c" /* formatValidator */], true),
            __WEBPACK_IMPORTED_MODULE_0__implementation_args__["b" /* metadataSpec */](true)
        ], arguments);
        this.throwIfRoot_('putString');
        var data = __WEBPACK_IMPORTED_MODULE_8__implementation_string__["b" /* dataFromString */](format, string);
        var metadata = __WEBPACK_IMPORTED_MODULE_5__implementation_object__["a" /* clone */](opt_metadata);
        if (!__WEBPACK_IMPORTED_MODULE_9__implementation_type__["a" /* isDef */](metadata['contentType']) && __WEBPACK_IMPORTED_MODULE_9__implementation_type__["a" /* isDef */](data.contentType)) {
            metadata['contentType'] = data.contentType;
        }
        return new __WEBPACK_IMPORTED_MODULE_10__task__["a" /* UploadTask */](this, this.authWrapper, this.location, this.mappings(), new __WEBPACK_IMPORTED_MODULE_1__implementation_blob__["a" /* FbsBlob */](data.data, true), metadata);
    };
    /**
     * Deletes the object at this location.
     * @return A promise that resolves if the deletion succeeds.
     */
    Reference.prototype.delete = function () {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('delete', [], arguments);
        this.throwIfRoot_('delete');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_7__implementation_requests__["d" /* deleteObject */](self.authWrapper, self.location);
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     *     A promise that resolves with the metadata for this object. If this
     *     object doesn't exist or metadata cannot be retreived, the promise is
     *     rejected.
     */
    Reference.prototype.getMetadata = function () {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('getMetadata', [], arguments);
        this.throwIfRoot_('getMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_7__implementation_requests__["e" /* getMetadata */](self.authWrapper, self.location, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     * Updates the metadata for this object.
     * @param metadata The new metadata for the object.
     *     Only values that have been explicitly set will be changed. Explicitly
     *     setting a value to null will remove the metadata.
     * @return A promise that resolves
     *     with the new metadata for this object.
     *     @see firebaseStorage.Reference.prototype.getMetadata
     */
    Reference.prototype.updateMetadata = function (metadata) {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('updateMetadata', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["b" /* metadataSpec */]()], arguments);
        this.throwIfRoot_('updateMetadata');
        var self = this;
        return this.authWrapper.getAuthToken().then(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_7__implementation_requests__["i" /* updateMetadata */](self.authWrapper, self.location, metadata, self.mappings());
            return self.authWrapper.makeRequest(requestInfo, authToken).getPromise();
        });
    };
    /**
     * @return A promise that resolves with the download
     *     URL for this object.
     */
    Reference.prototype.getDownloadURL = function () {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('getDownloadURL', [], arguments);
        this.throwIfRoot_('getDownloadURL');
        return this.getMetadata().then(function (metadata) {
            var url = metadata['downloadURLs'][0];
            if (__WEBPACK_IMPORTED_MODULE_9__implementation_type__["a" /* isDef */](url)) {
                return url;
            }
            else {
                throw __WEBPACK_IMPORTED_MODULE_2__implementation_error__["l" /* noDownloadURL */]();
            }
        });
    };
    Reference.prototype.throwIfRoot_ = function (name) {
        if (this.location.path === '') {
            throw __WEBPACK_IMPORTED_MODULE_2__implementation_error__["j" /* invalidRootOperation */](name);
        }
    };
    return Reference;
}());


//# sourceMappingURL=reference.js.map


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = parent;
/* harmony export (immutable) */ __webpack_exports__["a"] = child;
/* harmony export (immutable) */ __webpack_exports__["b"] = lastComponent;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Contains helper methods for manipulating paths.
 */
/**
 * @return Null if the path is already at the root.
 */
function parent(path) {
    if (path.length == 0) {
        return null;
    }
    var index = path.lastIndexOf('/');
    if (index === -1) {
        return '';
    }
    var newPath = path.slice(0, index);
    return newPath;
}
function child(path, childPath) {
    var canonicalChildPath = childPath
        .split('/')
        .filter(function (component) {
        return component.length > 0;
    })
        .join('/');
    if (path.length === 0) {
        return canonicalChildPath;
    }
    else {
        return path + '/' + canonicalChildPath;
    }
}
/**
 * Returns the last component of a path.
 * '/foo/bar' -> 'bar'
 * '/foo/bar/baz/' -> 'baz/'
 * '/a' -> 'a'
 */
function lastComponent(path) {
    var index = path.lastIndexOf('/', path.length - 2);
    if (index === -1) {
        return path;
    }
    else {
        return path.slice(index + 1);
    }
}

//# sourceMappingURL=path.js.map


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FbsBlob; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__fs__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__string__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__type__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @file Provides a Blob-like wrapper for various binary types (including the
 * native Blob type). This makes it possible to upload types like ArrayBuffers,
 * making uploads possible in environments without the native Blob type.
 */




/**
 * @param opt_elideCopy If true, doesn't copy mutable input data
 *     (e.g. Uint8Arrays). Pass true only if you know the objects will not be
 *     modified after this blob's construction.
 */
var FbsBlob = /** @class */ (function () {
    function FbsBlob(data, opt_elideCopy) {
        var size = 0;
        var blobType = '';
        if (__WEBPACK_IMPORTED_MODULE_2__type__["d" /* isNativeBlob */](data)) {
            this.data_ = data;
            size = data.size;
            blobType = data.type;
        }
        else if (data instanceof ArrayBuffer) {
            if (opt_elideCopy) {
                this.data_ = new Uint8Array(data);
            }
            else {
                this.data_ = new Uint8Array(data.byteLength);
                this.data_.set(new Uint8Array(data));
            }
            size = this.data_.length;
        }
        else if (data instanceof Uint8Array) {
            if (opt_elideCopy) {
                this.data_ = data;
            }
            else {
                this.data_ = new Uint8Array(data.length);
                this.data_.set(data);
            }
            size = data.length;
        }
        this.size_ = size;
        this.type_ = blobType;
    }
    FbsBlob.prototype.size = function () {
        return this.size_;
    };
    FbsBlob.prototype.type = function () {
        return this.type_;
    };
    FbsBlob.prototype.slice = function (startByte, endByte) {
        if (__WEBPACK_IMPORTED_MODULE_2__type__["d" /* isNativeBlob */](this.data_)) {
            var realBlob = this.data_;
            var sliced = __WEBPACK_IMPORTED_MODULE_0__fs__["b" /* sliceBlob */](realBlob, startByte, endByte);
            if (sliced === null) {
                return null;
            }
            return new FbsBlob(sliced);
        }
        else {
            var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
            return new FbsBlob(slice, true);
        }
    };
    FbsBlob.getBlob = function () {
        var var_args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            var_args[_i] = arguments[_i];
        }
        if (__WEBPACK_IMPORTED_MODULE_2__type__["e" /* isNativeBlobDefined */]()) {
            var blobby = var_args.map(function (val) {
                if (val instanceof FbsBlob) {
                    return val.data_;
                }
                else {
                    return val;
                }
            });
            return new FbsBlob(__WEBPACK_IMPORTED_MODULE_0__fs__["a" /* getBlob */].apply(null, blobby));
        }
        else {
            var uint8Arrays = var_args.map(function (val) {
                if (__WEBPACK_IMPORTED_MODULE_2__type__["j" /* isString */](val)) {
                    return __WEBPACK_IMPORTED_MODULE_1__string__["b" /* dataFromString */](__WEBPACK_IMPORTED_MODULE_1__string__["a" /* StringFormat */].RAW, val).data;
                }
                else {
                    // Blobs don't exist, so this has to be a Uint8Array.
                    return val.data_;
                }
            });
            var finalLength_1 = 0;
            uint8Arrays.forEach(function (array) {
                finalLength_1 += array.byteLength;
            });
            var merged_1 = new Uint8Array(finalLength_1);
            var index_1 = 0;
            uint8Arrays.forEach(function (array) {
                for (var i = 0; i < array.length; i++) {
                    merged_1[index_1++] = array[i];
                }
            });
            return new FbsBlob(merged_1, true);
        }
    };
    FbsBlob.prototype.uploadData = function () {
        return this.data_;
    };
    return FbsBlob;
}());


//# sourceMappingURL=blob.js.map


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export handlerCheck */
/* unused harmony export metadataHandler */
/* unused harmony export sharedErrorHandler */
/* unused harmony export objectErrorHandler */
/* harmony export (immutable) */ __webpack_exports__["e"] = getMetadata;
/* harmony export (immutable) */ __webpack_exports__["i"] = updateMetadata;
/* harmony export (immutable) */ __webpack_exports__["d"] = deleteObject;
/* unused harmony export determineContentType_ */
/* unused harmony export metadataForUpload_ */
/* harmony export (immutable) */ __webpack_exports__["g"] = multipartUpload;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ResumableUploadStatus; });
/* unused harmony export checkResumeHeader_ */
/* harmony export (immutable) */ __webpack_exports__["c"] = createResumableUpload;
/* harmony export (immutable) */ __webpack_exports__["f"] = getResumableUploadStatus;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return resumableUploadChunkSize; });
/* harmony export (immutable) */ __webpack_exports__["b"] = continueResumableUpload;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__blob__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__metadata__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__object__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__requestinfo__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__type__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__url__ = __webpack_require__(38);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Throws the UNKNOWN FirebaseStorageError if cndn is false.
 */
function handlerCheck(cndn) {
    if (!cndn) {
        throw __WEBPACK_IMPORTED_MODULE_2__error__["s" /* unknown */]();
    }
}
function metadataHandler(authWrapper, mappings) {
    function handler(xhr, text) {
        var metadata = __WEBPACK_IMPORTED_MODULE_3__metadata__["a" /* fromResourceString */](authWrapper, text, mappings);
        handlerCheck(metadata !== null);
        return metadata;
    }
    return handler;
}
function sharedErrorHandler(location) {
    function errorHandler(xhr, err) {
        var newErr;
        if (xhr.getStatus() === 401) {
            newErr = __WEBPACK_IMPORTED_MODULE_2__error__["q" /* unauthenticated */]();
        }
        else {
            if (xhr.getStatus() === 402) {
                newErr = __WEBPACK_IMPORTED_MODULE_2__error__["n" /* quotaExceeded */](location.bucket);
            }
            else {
                if (xhr.getStatus() === 403) {
                    newErr = __WEBPACK_IMPORTED_MODULE_2__error__["r" /* unauthorized */](location.path);
                }
                else {
                    newErr = err;
                }
            }
        }
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    }
    return errorHandler;
}
function objectErrorHandler(location) {
    var shared = sharedErrorHandler(location);
    function errorHandler(xhr, err) {
        var newErr = shared(xhr, err);
        if (xhr.getStatus() === 404) {
            newErr = __WEBPACK_IMPORTED_MODULE_2__error__["m" /* objectNotFound */](location.path);
        }
        newErr.setServerResponseProp(err.serverResponseProp());
        return newErr;
    }
    return errorHandler;
}
function getMetadata(authWrapper, location, mappings) {
    var urlPart = location.fullServerUrl();
    var url = __WEBPACK_IMPORTED_MODULE_7__url__["b" /* makeNormalUrl */](urlPart);
    var method = 'GET';
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function updateMetadata(authWrapper, location, metadata, mappings) {
    var urlPart = location.fullServerUrl();
    var url = __WEBPACK_IMPORTED_MODULE_7__url__["b" /* makeNormalUrl */](urlPart);
    var method = 'PATCH';
    var body = __WEBPACK_IMPORTED_MODULE_3__metadata__["d" /* toResourceString */](metadata, mappings);
    var headers = { 'Content-Type': 'application/json; charset=utf-8' };
    var timeout = authWrapper.maxOperationRetryTime();
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function deleteObject(authWrapper, location) {
    var urlPart = location.fullServerUrl();
    var url = __WEBPACK_IMPORTED_MODULE_7__url__["b" /* makeNormalUrl */](urlPart);
    var method = 'DELETE';
    var timeout = authWrapper.maxOperationRetryTime();
    function handler(xhr, text) { }
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, handler, timeout);
    requestInfo.successCodes = [200, 204];
    requestInfo.errorHandler = objectErrorHandler(location);
    return requestInfo;
}
function determineContentType_(metadata, blob) {
    return ((metadata && metadata['contentType']) ||
        (blob && blob.type()) ||
        'application/octet-stream');
}
function metadataForUpload_(location, blob, opt_metadata) {
    var metadata = __WEBPACK_IMPORTED_MODULE_4__object__["a" /* clone */](opt_metadata);
    metadata['fullPath'] = location.path;
    metadata['size'] = blob.size();
    if (!metadata['contentType']) {
        metadata['contentType'] = determineContentType_(null, blob);
    }
    return metadata;
}
function multipartUpload(authWrapper, location, mappings, blob, opt_metadata) {
    var urlPart = location.bucketOnlyServerUrl();
    var headers = {
        'X-Goog-Upload-Protocol': 'multipart'
    };
    function genBoundary() {
        var str = '';
        for (var i = 0; i < 2; i++) {
            str =
                str +
                    Math.random()
                        .toString()
                        .slice(2);
        }
        return str;
    }
    var boundary = genBoundary();
    headers['Content-Type'] = 'multipart/related; boundary=' + boundary;
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var metadataString = __WEBPACK_IMPORTED_MODULE_3__metadata__["d" /* toResourceString */](metadata, mappings);
    var preBlobPart = '--' +
        boundary +
        '\r\n' +
        'Content-Type: application/json; charset=utf-8\r\n\r\n' +
        metadataString +
        '\r\n--' +
        boundary +
        '\r\n' +
        'Content-Type: ' +
        metadata['contentType'] +
        '\r\n\r\n';
    var postBlobPart = '\r\n--' + boundary + '--';
    var body = __WEBPACK_IMPORTED_MODULE_1__blob__["a" /* FbsBlob */].getBlob(preBlobPart, blob, postBlobPart);
    if (body === null) {
        throw __WEBPACK_IMPORTED_MODULE_2__error__["d" /* cannotSliceBlob */]();
    }
    var urlParams = { name: metadata['fullPath'] };
    var url = __WEBPACK_IMPORTED_MODULE_7__url__["d" /* makeUploadUrl */](urlPart);
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, metadataHandler(authWrapper, mappings), timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * @param current The number of bytes that have been uploaded so far.
 * @param total The total number of bytes in the upload.
 * @param opt_finalized True if the server has finished the upload.
 * @param opt_metadata The upload metadata, should
 *     only be passed if opt_finalized is true.
 * @struct
 */
var ResumableUploadStatus = /** @class */ (function () {
    function ResumableUploadStatus(current, total, finalized, metadata) {
        this.current = current;
        this.total = total;
        this.finalized = !!finalized;
        this.metadata = metadata || null;
    }
    return ResumableUploadStatus;
}());

function checkResumeHeader_(xhr, opt_allowed) {
    var status;
    try {
        status = xhr.getResponseHeader('X-Goog-Upload-Status');
    }
    catch (e) {
        handlerCheck(false);
    }
    var allowed = opt_allowed || ['active'];
    handlerCheck(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* contains */](allowed, status));
    return status;
}
function createResumableUpload(authWrapper, location, mappings, blob, opt_metadata) {
    var urlPart = location.bucketOnlyServerUrl();
    var metadata = metadataForUpload_(location, blob, opt_metadata);
    var urlParams = { name: metadata['fullPath'] };
    var url = __WEBPACK_IMPORTED_MODULE_7__url__["d" /* makeUploadUrl */](urlPart);
    var method = 'POST';
    var headers = {
        'X-Goog-Upload-Protocol': 'resumable',
        'X-Goog-Upload-Command': 'start',
        'X-Goog-Upload-Header-Content-Length': blob.size(),
        'X-Goog-Upload-Header-Content-Type': metadata['contentType'],
        'Content-Type': 'application/json; charset=utf-8'
    };
    var body = __WEBPACK_IMPORTED_MODULE_3__metadata__["d" /* toResourceString */](metadata, mappings);
    var timeout = authWrapper.maxUploadRetryTime();
    function handler(xhr, text) {
        checkResumeHeader_(xhr);
        var url;
        try {
            url = xhr.getResponseHeader('X-Goog-Upload-URL');
        }
        catch (e) {
            handlerCheck(false);
        }
        handlerCheck(__WEBPACK_IMPORTED_MODULE_6__type__["j" /* isString */](url));
        return url;
    }
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, handler, timeout);
    requestInfo.urlParams = urlParams;
    requestInfo.headers = headers;
    requestInfo.body = body;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 */
function getResumableUploadStatus(authWrapper, location, url, blob) {
    var headers = { 'X-Goog-Upload-Command': 'query' };
    function handler(xhr, text) {
        var status = checkResumeHeader_(xhr, ['active', 'final']);
        var sizeString;
        try {
            sizeString = xhr.getResponseHeader('X-Goog-Upload-Size-Received');
        }
        catch (e) {
            handlerCheck(false);
        }
        var size = parseInt(sizeString, 10);
        handlerCheck(!isNaN(size));
        return new ResumableUploadStatus(size, blob.size(), status === 'final');
    }
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}
/**
 * Any uploads via the resumable upload API must transfer a number of bytes
 * that is a multiple of this number.
 */
var resumableUploadChunkSize = 256 * 1024;
/**
 * @param url From a call to fbs.requests.createResumableUpload.
 * @param chunkSize Number of bytes to upload.
 * @param opt_status The previous status.
 *     If not passed or null, we start from the beginning.
 * @throws fbs.Error If the upload is already complete, the passed in status
 *     has a final size inconsistent with the blob, or the blob cannot be sliced
 *     for upload.
 */
function continueResumableUpload(location, authWrapper, url, blob, chunkSize, mappings, opt_status, opt_progressCallback) {
    // TODO(andysoto): standardize on internal asserts
    // assert(!(opt_status && opt_status.finalized));
    var status = new ResumableUploadStatus(0, 0);
    if (opt_status) {
        status.current = opt_status.current;
        status.total = opt_status.total;
    }
    else {
        status.current = 0;
        status.total = blob.size();
    }
    if (blob.size() !== status.total) {
        throw __WEBPACK_IMPORTED_MODULE_2__error__["p" /* serverFileWrongSize */]();
    }
    var bytesLeft = status.total - status.current;
    var bytesToUpload = bytesLeft;
    if (chunkSize > 0) {
        bytesToUpload = Math.min(bytesToUpload, chunkSize);
    }
    var startByte = status.current;
    var endByte = startByte + bytesToUpload;
    var uploadCommand = bytesToUpload === bytesLeft ? 'upload, finalize' : 'upload';
    var headers = {
        'X-Goog-Upload-Command': uploadCommand,
        'X-Goog-Upload-Offset': status.current
    };
    var body = blob.slice(startByte, endByte);
    if (body === null) {
        throw __WEBPACK_IMPORTED_MODULE_2__error__["d" /* cannotSliceBlob */]();
    }
    function handler(xhr, text) {
        // TODO(andysoto): Verify the MD5 of each uploaded range:
        // the 'x-range-md5' header comes back with status code 308 responses.
        // We'll only be able to bail out though, because you can't re-upload a
        // range that you previously uploaded.
        var uploadStatus = checkResumeHeader_(xhr, ['active', 'final']);
        var newCurrent = status.current + bytesToUpload;
        var size = blob.size();
        var metadata;
        if (uploadStatus === 'final') {
            metadata = metadataHandler(authWrapper, mappings)(xhr, text);
        }
        else {
            metadata = null;
        }
        return new ResumableUploadStatus(newCurrent, size, uploadStatus === 'final', metadata);
    }
    var method = 'POST';
    var timeout = authWrapper.maxUploadRetryTime();
    var requestInfo = new __WEBPACK_IMPORTED_MODULE_5__requestinfo__["a" /* RequestInfo */](url, method, handler, timeout);
    requestInfo.headers = headers;
    requestInfo.body = body.uploadData();
    requestInfo.progressCallback = opt_progressCallback || null;
    requestInfo.errorHandler = sharedErrorHandler(location);
    return requestInfo;
}

//# sourceMappingURL=requests.js.map


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = __webpack_require__(102);


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__src_polyfills_promise__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_shims_find__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_shims_find___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__src_shims_find__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__src_shims_findIndex__);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




//# sourceMappingURL=index.js.map


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __global = (function () {
    if (typeof global !== 'undefined') {
        return global;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if (typeof self !== 'undefined') {
        return self;
    }
    throw new Error('unable to locate global object');
})();
// Polyfill Promise
if (typeof Promise === 'undefined') {
    // HACK: TS throws an error if I attempt to use 'dot-notation'
    __global['Promise'] = Promise = __webpack_require__(84);
}

//# sourceMappingURL=promise.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {(function (root) {

  // Store setTimeout reference so promise-polyfill will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var setTimeoutFunc = setTimeout;

  function noop() {}
  
  // Polyfill for Function.prototype.bind
  function bind(fn, thisArg) {
    return function () {
      fn.apply(thisArg, arguments);
    };
  }

  function Promise(fn) {
    if (!(this instanceof Promise)) throw new TypeError('Promises must be constructed via new');
    if (typeof fn !== 'function') throw new TypeError('not a function');
    this._state = 0;
    this._handled = false;
    this._value = undefined;
    this._deferreds = [];

    doResolve(fn, this);
  }

  function handle(self, deferred) {
    while (self._state === 3) {
      self = self._value;
    }
    if (self._state === 0) {
      self._deferreds.push(deferred);
      return;
    }
    self._handled = true;
    Promise._immediateFn(function () {
      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
      if (cb === null) {
        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
        return;
      }
      var ret;
      try {
        ret = cb(self._value);
      } catch (e) {
        reject(deferred.promise, e);
        return;
      }
      resolve(deferred.promise, ret);
    });
  }

  function resolve(self, newValue) {
    try {
      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then;
        if (newValue instanceof Promise) {
          self._state = 3;
          self._value = newValue;
          finale(self);
          return;
        } else if (typeof then === 'function') {
          doResolve(bind(then, newValue), self);
          return;
        }
      }
      self._state = 1;
      self._value = newValue;
      finale(self);
    } catch (e) {
      reject(self, e);
    }
  }

  function reject(self, newValue) {
    self._state = 2;
    self._value = newValue;
    finale(self);
  }

  function finale(self) {
    if (self._state === 2 && self._deferreds.length === 0) {
      Promise._immediateFn(function() {
        if (!self._handled) {
          Promise._unhandledRejectionFn(self._value);
        }
      });
    }

    for (var i = 0, len = self._deferreds.length; i < len; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }

  function Handler(onFulfilled, onRejected, promise) {
    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
    this.promise = promise;
  }

  /**
   * Take a potentially misbehaving resolver function and make sure
   * onFulfilled and onRejected are only called once.
   *
   * Makes no guarantees about asynchrony.
   */
  function doResolve(fn, self) {
    var done = false;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        resolve(self, value);
      }, function (reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      reject(self, ex);
    }
  }

  Promise.prototype['catch'] = function (onRejected) {
    return this.then(null, onRejected);
  };

  Promise.prototype.then = function (onFulfilled, onRejected) {
    var prom = new (this.constructor)(noop);

    handle(this, new Handler(onFulfilled, onRejected, prom));
    return prom;
  };

  Promise.all = function (arr) {
    return new Promise(function (resolve, reject) {
      if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
      var args = Array.prototype.slice.call(arr);
      if (args.length === 0) return resolve([]);
      var remaining = args.length;

      function res(i, val) {
        try {
          if (val && (typeof val === 'object' || typeof val === 'function')) {
            var then = val.then;
            if (typeof then === 'function') {
              then.call(val, function (val) {
                res(i, val);
              }, reject);
              return;
            }
          }
          args[i] = val;
          if (--remaining === 0) {
            resolve(args);
          }
        } catch (ex) {
          reject(ex);
        }
      }

      for (var i = 0; i < args.length; i++) {
        res(i, args[i]);
      }
    });
  };

  Promise.resolve = function (value) {
    if (value && typeof value === 'object' && value.constructor === Promise) {
      return value;
    }

    return new Promise(function (resolve) {
      resolve(value);
    });
  };

  Promise.reject = function (value) {
    return new Promise(function (resolve, reject) {
      reject(value);
    });
  };

  Promise.race = function (values) {
    return new Promise(function (resolve, reject) {
      for (var i = 0, len = values.length; i < len; i++) {
        values[i].then(resolve, reject);
      }
    });
  };

  // Use polyfill for setImmediate for performance gains
  Promise._immediateFn = (typeof setImmediate === 'function' && function (fn) { setImmediate(fn); }) ||
    function (fn) {
      setTimeoutFunc(fn, 0);
    };

  Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
    if (typeof console !== 'undefined' && console) {
      console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
    }
  };

  /**
   * Set the immediate function to execute callbacks
   * @param fn {function} Function to execute
   * @deprecated
   */
  Promise._setImmediateFn = function _setImmediateFn(fn) {
    Promise._immediateFn = fn;
  };

  /**
   * Change the function to execute on unhandled rejection
   * @param {function} fn Function to execute on unhandled rejection
   * @deprecated
   */
  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
    Promise._unhandledRejectionFn = fn;
  };
  
  if (typeof module !== 'undefined' && module.exports) {
    module.exports = Promise;
  } else if (!root.Promise) {
    root.Promise = Promise;
  }

})(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(85).setImmediate))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(86);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28), __webpack_require__(42)))

/***/ }),
/* 87 */
/***/ (function(module, exports) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.find polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
 * https://tc39.github.io/ecma262/#sec-array.prototype.find
 */
if (!Array.prototype.find) {
    Object.defineProperty(Array.prototype, 'find', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return kValue.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return kValue;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return undefined.
            return undefined;
        }
    });
}

//# sourceMappingURL=find.js.map


/***/ }),
/* 88 */
/***/ (function(module, exports) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This is the Array.prototype.findIndex polyfill from MDN
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex
 * https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
 */
if (!Array.prototype.findIndex) {
    Object.defineProperty(Array.prototype, 'findIndex', {
        value: function (predicate) {
            // 1. Let O be ? ToObject(this value).
            if (this == null) {
                throw new TypeError('"this" is null or not defined');
            }
            var o = Object(this);
            // 2. Let len be ? ToLength(? Get(O, "length")).
            var len = o.length >>> 0;
            // 3. If IsCallable(predicate) is false, throw a TypeError exception.
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            // 4. If thisArg was supplied, let T be thisArg; else let T be undefined.
            var thisArg = arguments[1];
            // 5. Let k be 0.
            var k = 0;
            // 6. Repeat, while k < len
            while (k < len) {
                // a. Let Pk be ! ToString(k).
                // b. Let kValue be ? Get(O, Pk).
                // c. Let testResult be ToBoolean(? Call(predicate, T, « kValue, k, O »)).
                // d. If testResult is true, return k.
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o)) {
                    return k;
                }
                // e. Increase k by 1.
                k++;
            }
            // 7. Return -1.
            return -1;
        }
    });
}

//# sourceMappingURL=findIndex.js.map


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = createFirebaseNamespace;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__firebase_util__);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var contains = function (obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var DEFAULT_ENTRY_NAME = '[DEFAULT]';
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var FirebaseAppImpl = /** @class */ (function () {
    function FirebaseAppImpl(options, name, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = name;
        this.options_ = Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["deepCopy"])(options);
        this.INTERNAL = {
            getUid: function () { return null; },
            getToken: function () { return Promise.resolve(null); },
            addAuthTokenListener: function (callback) {
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () { return callback(null); }, 0);
            },
            removeAuthTokenListener: function (callback) {
                tokenListeners = tokenListeners.filter(function (listener) { return listener !== callback; });
            }
        };
    }
    Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function () {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function () {
            this.checkDestroyed_();
            return this.options_;
        },
        enumerable: true,
        configurable: true
    });
    FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.checkDestroyed_();
            resolve();
        })
            .then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            Object.keys(_this.services_).forEach(function (serviceKey) {
                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {
                    services.push(_this.services_[serviceKey][instanceKey]);
                });
            });
            return Promise.all(services.map(function (service) {
                return service.INTERNAL.delete();
            }));
        })
            .then(function () {
            _this.isDeleted_ = true;
            _this.services_ = {};
        });
    };
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) { instanceIdentifier = DEFAULT_ENTRY_NAME; }
        this.checkDestroyed_();
        if (!this.services_[name]) {
            this.services_[name] = {};
        }
        if (!this.services_[name][instanceIdentifier]) {
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME
                ? instanceIdentifier
                : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
    };
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) {
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["deepExtend"])(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
            tokenListeners.forEach(function (listener) {
                _this.INTERNAL.addAuthTokenListener(listener);
            });
            tokenListeners = [];
        }
    };
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            error('app-deleted', { name: this.name_ });
        }
    };
    return FirebaseAppImpl;
}());
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||
    FirebaseAppImpl.prototype.delete ||
    console.log('dc');
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
function createFirebaseNamespace() {
    var apps_ = {};
    var factories = {};
    var appHooks = {};
    // A namespace is a plain JavaScript Object.
    var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '4.8.0',
        INTERNAL: {
            registerService: registerService,
            createFirebaseNamespace: createFirebaseNamespace,
            extendNamespace: extendNamespace,
            createSubscribe: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["createSubscribe"],
            ErrorFactory: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["ErrorFactory"],
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService,
            Promise: Promise,
            deepExtend: __WEBPACK_IMPORTED_MODULE_0__firebase_util__["deepExtend"]
        }
    };
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["patchProperty"])(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', {
        get: getApps
    });
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) {
        var app = apps_[name];
        callAppHooks(app, 'delete');
        delete apps_[name];
    }
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps_, name)) {
            error('no-app', { name: name });
        }
        return apps_[name];
    }
    Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["patchProperty"])(app, 'App', FirebaseAppImpl);
    /**
     * Create a new App instance (name must be unique).
     */
    function initializeApp(options, name) {
        if (name === undefined) {
            name = DEFAULT_ENTRY_NAME;
        }
        else {
            if (typeof name !== 'string' || name === '') {
                error('bad-app-name', { name: name + '' });
            }
        }
        if (contains(apps_, name)) {
            error('duplicate-app', { name: name });
        }
        var app = new FirebaseAppImpl(options, name, namespace);
        apps_[name] = app;
        callAppHooks(app, 'create');
        return app;
    }
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps_).map(function (name) { return apps_[name]; });
    }
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        // Cannot re-register a service that already exists
        if (factories[name]) {
            error('duplicate-service', { name: name });
        }
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) {
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) {
                appHook('create', app);
            });
        }
        // The Service namespace is an accessor function ...
        var serviceNamespace = function (appArg) {
            if (appArg === void 0) { appArg = app(); }
            if (typeof appArg[name] !== 'function') {
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                error('invalid-app-argument', { name: name });
            }
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        };
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) {
            Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["deepExtend"])(serviceNamespace, serviceProperties);
        }
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        FirebaseAppImpl.prototype[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
    }
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) {
        Object(__WEBPACK_IMPORTED_MODULE_0__firebase_util__["deepExtend"])(namespace, props);
    }
    function callAppHooks(app, eventName) {
        Object.keys(factories).forEach(function (serviceName) {
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) {
                return;
            }
            if (appHooks[factoryName]) {
                appHooks[factoryName](eventName, app);
            }
        });
    }
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) {
        if (name === 'serverAuth') {
            return null;
        }
        var useService = name;
        var options = app.options;
        return useService;
    }
    return namespace;
}
function error(code, args) {
    throw appErrors.create(code, args);
}
// TypeScript does not support non-string indexes!
// let errors: {[code: AppError: string} = {
var errors = {
    'no-app': "No Firebase App '{$name}' has been created - " +
        'call Firebase App.initializeApp()',
    'bad-app-name': "Illegal App name: '{$name}",
    'duplicate-app': "Firebase App named '{$name}' already exists",
    'app-deleted': "Firebase App named '{$name}' already deleted",
    'duplicate-service': "Firebase service named '{$name}' already registered",
    'sa-not-supported': 'Initializing the Firebase SDK with a service ' +
        'account is only allowed in a Node.js environment. On client ' +
        'devices, you should instead initialize the SDK with an api key and ' +
        'auth domain',
    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' +
        'Firebase App instance.'
};
var appErrors = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["ErrorFactory"]('app', 'Firebase', errors);


//# sourceMappingURL=firebaseApp.js.map


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
exports.deepCopy = deepCopy;
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            var dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
exports.deepExtend = deepExtend;
// TODO: Really needed (for JSCompiler type checking)?
function patchProperty(obj, prop, value) {
    obj[prop] = value;
}
exports.patchProperty = patchProperty;

//# sourceMappingURL=deepCopy.js.map


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Deferred = /** @class */ (function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback
     * @return {!function(?(Error), ?=)}
     */
    Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
            if (error) {
                _this.reject(error);
            }
            else {
                _this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                _this.promise.catch(function () { });
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                }
                else {
                    callback(error, value);
                }
            }
        };
    };
    return Deferred;
}());
exports.Deferred = Deferred;

//# sourceMappingURL=deferred.js.map


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var constants_1 = __webpack_require__(29);
/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return {string} user agent string
 */
exports.getUA = function () {
    if (typeof navigator !== 'undefined' &&
        typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    }
    else {
        return '';
    }
};
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap in the Ripple emulator) nor
 * Cordova `onDeviceReady`, which would normally wait for a callback.
 *
 * @return {boolean} isMobileCordova
 */
exports.isMobileCordova = function () {
    return (typeof window !== 'undefined' &&
        !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) &&
        /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(exports.getUA()));
};
/**
 * Detect React Native.
 *
 * @return {boolean} True if ReactNative environment is detected.
 */
exports.isReactNative = function () {
    return (typeof navigator === 'object' && navigator['product'] === 'ReactNative');
};
/**
 * Detect Node.js.
 *
 * @return {boolean} True if Node.js environment is detected.
 */
exports.isNodeSdk = function () {
    return constants_1.CONSTANTS.NODE_CLIENT === true || constants_1.CONSTANTS.NODE_ADMIN === true;
};

//# sourceMappingURL=environment.js.map


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ERROR_NAME = 'FirebaseError';
var captureStackTrace = Error
    .captureStackTrace;
// Export for faking in tests
function patchCapture(captureFake) {
    var result = captureStackTrace;
    captureStackTrace = captureFake;
    return result;
}
exports.patchCapture = patchCapture;
var FirebaseError = /** @class */ (function () {
    function FirebaseError(code, message) {
        this.code = code;
        this.message = message;
        var stack;
        // We want the stack value, if implemented by Error
        if (captureStackTrace) {
            // Patches this.stack, omitted calls above ErrorFactory#create
            captureStackTrace(this, ErrorFactory.prototype.create);
        }
        else {
            var err_1 = Error.apply(this, arguments);
            this.name = ERROR_NAME;
            // Make non-enumerable getter for the property.
            Object.defineProperty(this, 'stack', {
                get: function () {
                    return err_1.stack;
                }
            });
        }
    }
    return FirebaseError;
}());
exports.FirebaseError = FirebaseError;
// Back-door inheritance
FirebaseError.prototype = Object.create(Error.prototype);
FirebaseError.prototype.constructor = FirebaseError;
FirebaseError.prototype.name = ERROR_NAME;
var ErrorFactory = /** @class */ (function () {
    function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
        // Matches {$name}, by default.
        this.pattern = /\{\$([^}]+)}/g;
        // empty
    }
    ErrorFactory.prototype.create = function (code, data) {
        if (data === undefined) {
            data = {};
        }
        var template = this.errors[code];
        var fullCode = this.service + '/' + code;
        var message;
        if (template === undefined) {
            message = 'Error';
        }
        else {
            message = template.replace(this.pattern, function (match, key) {
                var value = data[key];
                return value !== undefined ? value.toString() : '<' + key + '?>';
            });
        }
        // Service: Error message (service/code).
        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
        var err = new FirebaseError(fullCode, message);
        // Populate the Error object with message parts for programmatic
        // accesses (e.g., e.file).
        for (var prop in data) {
            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {
                continue;
            }
            err[prop] = data[prop];
        }
        return err;
    };
    return ErrorFactory;
}());
exports.ErrorFactory = ErrorFactory;

//# sourceMappingURL=errors.js.map


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var crypt_1 = __webpack_require__(44);
var json_1 = __webpack_require__(45);
/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {{header: *, claims: *, data: *, signature: string}}
 */
exports.decode = function (token) {
    var header = {}, claims = {}, data = {}, signature = '';
    try {
        var parts = token.split('.');
        header = json_1.jsonEval(crypt_1.base64Decode(parts[0]) || '');
        claims = json_1.jsonEval(crypt_1.base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    }
    catch (e) { }
    return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isValidTimestamp = function (token) {
    var claims = exports.decode(token).claims, now = Math.floor(new Date().getTime() / 1000), validSince, validUntil;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        }
        else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        }
        else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return (now && validSince && validUntil && now >= validSince && now <= validUntil);
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {?number}
 */
exports.issuedAtTime = function (token) {
    var claims = exports.decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty
 * signature.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isValidFormat = function (token) {
    var decoded = exports.decode(token), claims = decoded.claims;
    return (!!decoded.signature &&
        !!claims &&
        typeof claims === 'object' &&
        claims.hasOwnProperty('iat'));
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
exports.isAdmin = function (token) {
    var claims = exports.decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

//# sourceMappingURL=jwt.js.map


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var obj_1 = __webpack_require__(46);
/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 *
 * @param {!Object} querystringParams
 * @return {string}
 */
exports.querystring = function (querystringParams) {
    var params = [];
    obj_1.forEach(querystringParams, function (key, value) {
        if (Array.isArray(value)) {
            value.forEach(function (arrayVal) {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        }
        else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    });
    return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */
exports.querystringDecode = function (querystring) {
    var obj = {};
    var tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(function (token) {
        if (token) {
            var key = token.split('=');
            obj[key[0]] = key[1];
        }
    });
    return obj;
};

//# sourceMappingURL=query.js.map


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var hash_1 = __webpack_require__(97);
/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @extends {Hash}
 * @final
 * @struct
 */
var Sha1 = /** @class */ (function (_super) {
    __extends(Sha1, _super);
    function Sha1() {
        var _this = _super.call(this) || this;
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @type {!Array<number>}
         * @private
         */
        _this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @type {!Array<number>}
         * @private
         */
        _this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @type {!Array<number>}
         * @private
         */
        _this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @type {!Array<number>}
         * @private
         */
        _this.pad_ = [];
        /**
         * @private {number}
         */
        _this.inbuf_ = 0;
        /**
         * @private {number}
         */
        _this.total_ = 0;
        _this.blockSize = 512 / 8;
        _this.pad_[0] = 128;
        for (var i = 1; i < _this.blockSize; ++i) {
            _this.pad_[i] = 0;
        }
        _this.reset();
        return _this;
    }
    Sha1.prototype.reset = function () {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    };
    /**
     * Internal compress helper function.
     * @param {!Array<number>|!Uint8Array|string} buf Block to compress.
     * @param {number=} opt_offset Offset of the block in the buffer.
     * @private
     */
    Sha1.prototype.compress_ = function (buf, opt_offset) {
        if (!opt_offset) {
            opt_offset = 0;
        }
        var W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (var i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] =
                    (buf.charCodeAt(opt_offset) << 24) |
                        (buf.charCodeAt(opt_offset + 1) << 16) |
                        (buf.charCodeAt(opt_offset + 2) << 8) |
                        buf.charCodeAt(opt_offset + 3);
                opt_offset += 4;
            }
        }
        else {
            for (var i = 0; i < 16; i++) {
                W[i] =
                    (buf[opt_offset] << 24) |
                        (buf[opt_offset + 1] << 16) |
                        (buf[opt_offset + 2] << 8) |
                        buf[opt_offset + 3];
                opt_offset += 4;
            }
        }
        // expand to 80 words
        for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = ((t << 1) | (t >>> 31)) & 0xffffffff;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (var i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ (b & (c ^ d));
                    k = 0x5a827999;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            }
            else {
                if (i < 60) {
                    f = (b & c) | (d & (b | c));
                    k = 0x8f1bbcdc;
                }
                else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            var t = (((a << 5) | (a >>> 27)) + f + e + k + W[i]) & 0xffffffff;
            e = d;
            d = c;
            c = ((b << 30) | (b >>> 2)) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = (this.chain_[0] + a) & 0xffffffff;
        this.chain_[1] = (this.chain_[1] + b) & 0xffffffff;
        this.chain_[2] = (this.chain_[2] + c) & 0xffffffff;
        this.chain_[3] = (this.chain_[3] + d) & 0xffffffff;
        this.chain_[4] = (this.chain_[4] + e) & 0xffffffff;
    };
    Sha1.prototype.update = function (bytes, opt_length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (opt_length === undefined) {
            opt_length = bytes.length;
        }
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < opt_length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf == 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < opt_length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
            else {
                while (n < opt_length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
    };
    /** @override */
    Sha1.prototype.digest = function () {
        var digest = [];
        var totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        }
        else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                digest[n] = (this.chain_[i] >> j) & 255;
                ++n;
            }
        }
        return digest;
    };
    return Sha1;
}(hash_1.Hash));
exports.Sha1 = Sha1;

//# sourceMappingURL=sha1.js.map


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Abstract cryptographic hash interface.
 *
 * See Sha1 and Md5 for sample implementations.
 *
 */
/**
 * Create a cryptographic hash instance.
 *
 * @constructor
 * @struct
 */
var Hash = /** @class */ (function () {
    function Hash() {
        /**
         * The block size for the hasher.
         * @type {number}
         */
        this.blockSize = -1;
    }
    return Hash;
}());
exports.Hash = Hash;

//# sourceMappingURL=hash.js.map


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
exports.createSubscribe = createSubscribe;
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */ (function () {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
            .then(function () {
            executor(_this);
        })
            .catch(function (e) {
            _this.error(e);
        });
    }
    ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
            observer.next(value);
        });
    };
    ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
            observer.error(error);
        });
        this.close(error);
    };
    ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
            observer.complete();
        });
        this.close();
    };
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined &&
            error === undefined &&
            complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
            observer = nextOrObserver;
        }
        else {
            observer = {
                next: nextOrObserver,
                error: error,
                complete: complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            this.task.then(function () {
                try {
                    if (_this.finalError) {
                        observer.error(_this.finalError);
                    }
                    else {
                        observer.complete();
                    }
                }
                catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    };
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    };
    ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    };
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () {
            if (_this.observers !== undefined && _this.observers[i] !== undefined) {
                try {
                    fn(_this.observers[i]);
                }
                catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    };
    ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () {
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        });
    };
    return ObserverProxy;
}());
/** Turn synchronous function into one called asynchronously. */
function async(fn, onError) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Promise.resolve(true)
            .then(function () {
            fn.apply(void 0, args);
        })
            .catch(function (error) {
            if (onError) {
                onError(error);
            }
        });
    };
}
exports.async = async;
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {
    // do nothing
}

//# sourceMappingURL=subscribe.js.map


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param {!string} fnName The function name
 * @param {!number} minCount The minimum number of arguments to allow for the function call
 * @param {!number} maxCount The maximum number of argument to allow for the function call
 * @param {!number} argCount The actual number of arguments provided.
 */
exports.validateArgCount = function (fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    }
    else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        var error = fnName +
            ' failed: Was called with ' +
            argCount +
            (argCount === 1 ? ' argument.' : ' arguments.') +
            ' Expects ' +
            argError +
            '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param {!string} fnName The function name
 * @param {!number} argumentNumber The index of the argument
 * @param {boolean} optional Whether or not the argument is optional
 * @return {!string} The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argumentNumber, optional) {
    var argName = '';
    switch (argumentNumber) {
        case 1:
            argName = optional ? 'first' : 'First';
            break;
        case 2:
            argName = optional ? 'second' : 'Second';
            break;
        case 3:
            argName = optional ? 'third' : 'Third';
            break;
        case 4:
            argName = optional ? 'fourth' : 'Fourth';
            break;
        default:
            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
    }
    var error = fnName + ' failed: ';
    error += argName + ' argument ';
    return error;
}
exports.errorPrefix = errorPrefix;
/**
 * @param {!string} fnName
 * @param {!number} argumentNumber
 * @param {!string} namespace
 * @param {boolean} optional
 */
function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace)
        return;
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid firebase namespace.');
    }
}
exports.validateNamespace = validateNamespace;
function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback)
        return;
    if (typeof callback !== 'function')
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid function.');
}
exports.validateCallback = validateCallback;
function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context)
        return;
    if (typeof context !== 'object' || context === null)
        throw new Error(errorPrefix(fnName, argumentNumber, optional) +
            'must be a valid context object.');
}
exports.validateContextObject = validateContextObject;

//# sourceMappingURL=validation.js.map


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = __webpack_require__(43);
// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
exports.stringToByteArray = function (str) {
    var out = [], p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            var high = c - 0xd800; // the high 10 bits.
            i++;
            assert_1.assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        }
        else if (c < 2048) {
            out[p++] = (c >> 6) | 192;
            out[p++] = (c & 63) | 128;
        }
        else if (c < 65536) {
            out[p++] = (c >> 12) | 224;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
        else {
            out[p++] = (c >> 18) | 240;
            out[p++] = ((c >> 12) & 63) | 128;
            out[p++] = ((c >> 6) & 63) | 128;
            out[p++] = (c & 63) | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
exports.stringLength = function (str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        }
        else if (c < 2048) {
            p += 2;
        }
        else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        }
        else {
            p += 3;
        }
    }
    return p;
};

//# sourceMappingURL=utf8.js.map


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {(function() {
  var firebase = __webpack_require__(8).default;
  var h,aa=aa||{},k=this;function m(a){return"string"==typeof a}function ba(a){return"boolean"==typeof a}function ca(){}
function da(a){var b=typeof a;if("object"==b)if(a){if(a instanceof Array)return"array";if(a instanceof Object)return b;var c=Object.prototype.toString.call(a);if("[object Window]"==c)return"object";if("[object Array]"==c||"number"==typeof a.length&&"undefined"!=typeof a.splice&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("splice"))return"array";if("[object Function]"==c||"undefined"!=typeof a.call&&"undefined"!=typeof a.propertyIsEnumerable&&!a.propertyIsEnumerable("call"))return"function"}else return"null";
else if("function"==b&&"undefined"==typeof a.call)return"object";return b}function ea(a){return null===a}function fa(a){return"array"==da(a)}function ha(a){var b=da(a);return"array"==b||"object"==b&&"number"==typeof a.length}function p(a){return"function"==da(a)}function q(a){var b=typeof a;return"object"==b&&null!=a||"function"==b}var ia="closure_uid_"+(1E9*Math.random()>>>0),ja=0;function ka(a,b,c){return a.call.apply(a.bind,arguments)}
function la(a,b,c){if(!a)throw Error();if(2<arguments.length){var d=Array.prototype.slice.call(arguments,2);return function(){var c=Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c,d);return a.apply(b,c)}}return function(){return a.apply(b,arguments)}}function r(a,b,c){Function.prototype.bind&&-1!=Function.prototype.bind.toString().indexOf("native code")?r=ka:r=la;return r.apply(null,arguments)}
function ma(a,b){var c=Array.prototype.slice.call(arguments,1);return function(){var b=c.slice();b.push.apply(b,arguments);return a.apply(this,b)}}var na=Date.now||function(){return+new Date};function t(a,b){function c(){}c.prototype=b.prototype;a.ib=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Rc=function(a,c,f){for(var d=Array(arguments.length-2),e=2;e<arguments.length;e++)d[e-2]=arguments[e];return b.prototype[c].apply(a,d)}};function u(a){if(Error.captureStackTrace)Error.captureStackTrace(this,u);else{var b=Error().stack;b&&(this.stack=b)}a&&(this.message=String(a))}t(u,Error);u.prototype.name="CustomError";function oa(a,b){for(var c=a.split("%s"),d="",e=Array.prototype.slice.call(arguments,1);e.length&&1<c.length;)d+=c.shift()+e.shift();return d+c.join("%s")}var pa=String.prototype.trim?function(a){return a.trim()}:function(a){return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")};
function qa(a){if(!ra.test(a))return a;-1!=a.indexOf("&")&&(a=a.replace(sa,"&amp;"));-1!=a.indexOf("<")&&(a=a.replace(ta,"&lt;"));-1!=a.indexOf(">")&&(a=a.replace(ua,"&gt;"));-1!=a.indexOf('"')&&(a=a.replace(va,"&quot;"));-1!=a.indexOf("'")&&(a=a.replace(wa,"&#39;"));-1!=a.indexOf("\x00")&&(a=a.replace(xa,"&#0;"));return a}var sa=/&/g,ta=/</g,ua=/>/g,va=/"/g,wa=/'/g,xa=/\x00/g,ra=/[\x00&<>"']/;function v(a,b){return-1!=a.indexOf(b)}function ya(a,b){return a<b?-1:a>b?1:0};function za(a,b){b.unshift(a);u.call(this,oa.apply(null,b));b.shift()}t(za,u);za.prototype.name="AssertionError";function Aa(a,b){throw new za("Failure"+(a?": "+a:""),Array.prototype.slice.call(arguments,1));};var Ba=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if(m(a))return m(b)&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1},w=Array.prototype.forEach?function(a,b,c){Array.prototype.forEach.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)f in e&&b.call(c,e[f],f,a)};
function Ca(a,b){var c=a.length,d=m(a)?a.split(""):a;for(--c;0<=c;--c)c in d&&b.call(void 0,d[c],c,a)}var Da=Array.prototype.map?function(a,b,c){return Array.prototype.map.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=Array(d),f=m(a)?a.split(""):a,g=0;g<d;g++)g in f&&(e[g]=b.call(c,f[g],g,a));return e},Ea=Array.prototype.some?function(a,b,c){return Array.prototype.some.call(a,b,c)}:function(a,b,c){for(var d=a.length,e=m(a)?a.split(""):a,f=0;f<d;f++)if(f in e&&b.call(c,e[f],f,a))return!0;return!1};
function Fa(a){a:{var b=Ga;for(var c=a.length,d=m(a)?a.split(""):a,e=0;e<c;e++)if(e in d&&b.call(void 0,d[e],e,a)){b=e;break a}b=-1}return 0>b?null:m(a)?a.charAt(b):a[b]}function Ha(a,b){return 0<=Ba(a,b)}function Ia(a,b){b=Ba(a,b);var c;(c=0<=b)&&Array.prototype.splice.call(a,b,1);return c}function Ja(a,b){var c=0;Ca(a,function(d,e){b.call(void 0,d,e,a)&&1==Array.prototype.splice.call(a,e,1).length&&c++})}function Ka(a){return Array.prototype.concat.apply([],arguments)}
function La(a){var b=a.length;if(0<b){for(var c=Array(b),d=0;d<b;d++)c[d]=a[d];return c}return[]};var Ma;a:{var Na=k.navigator;if(Na){var Oa=Na.userAgent;if(Oa){Ma=Oa;break a}}Ma=""}function x(a){return v(Ma,a)};function Pa(a,b){for(var c in a)b.call(void 0,a[c],c,a)}function Qa(a){var b=[],c=0,d;for(d in a)b[c++]=a[d];return b}function Ra(a){var b=[],c=0,d;for(d in a)b[c++]=d;return b}function Sa(a){for(var b in a)return!1;return!0}function Ta(a,b){for(var c in a)if(!(c in b)||a[c]!==b[c])return!1;for(c in b)if(!(c in a))return!1;return!0}function Ua(a){var b={},c;for(c in a)b[c]=a[c];return b}var Va="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Wa(a,b){for(var c,d,e=1;e<arguments.length;e++){d=arguments[e];for(c in d)a[c]=d[c];for(var f=0;f<Va.length;f++)c=Va[f],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};function Xa(a){Xa[" "](a);return a}Xa[" "]=ca;function Ya(a,b){var c=Za;return Object.prototype.hasOwnProperty.call(c,a)?c[a]:c[a]=b(a)};var $a=x("Opera"),y=x("Trident")||x("MSIE"),ab=x("Edge"),bb=ab||y,cb=x("Gecko")&&!(v(Ma.toLowerCase(),"webkit")&&!x("Edge"))&&!(x("Trident")||x("MSIE"))&&!x("Edge"),db=v(Ma.toLowerCase(),"webkit")&&!x("Edge");function eb(){var a=k.document;return a?a.documentMode:void 0}var fb;
a:{var gb="",hb=function(){var a=Ma;if(cb)return/rv\:([^\);]+)(\)|;)/.exec(a);if(ab)return/Edge\/([\d\.]+)/.exec(a);if(y)return/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);if(db)return/WebKit\/(\S+)/.exec(a);if($a)return/(?:Version)[ \/]?(\S+)/.exec(a)}();hb&&(gb=hb?hb[1]:"");if(y){var ib=eb();if(null!=ib&&ib>parseFloat(gb)){fb=String(ib);break a}}fb=gb}var Za={};
function jb(a){return Ya(a,function(){for(var b=0,c=pa(String(fb)).split("."),d=pa(String(a)).split("."),e=Math.max(c.length,d.length),f=0;0==b&&f<e;f++){var g=c[f]||"",l=d[f]||"";do{g=/(\d*)(\D*)(.*)/.exec(g)||["","","",""];l=/(\d*)(\D*)(.*)/.exec(l)||["","","",""];if(0==g[0].length&&0==l[0].length)break;b=ya(0==g[1].length?0:parseInt(g[1],10),0==l[1].length?0:parseInt(l[1],10))||ya(0==g[2].length,0==l[2].length)||ya(g[2],l[2]);g=g[3];l=l[3]}while(0==b)}return 0<=b})}var kb;var lb=k.document;
kb=lb&&y?eb()||("CSS1Compat"==lb.compatMode?parseInt(fb,10):5):void 0;function mb(a){a.prototype.then=a.prototype.then;a.prototype.$goog_Thenable=!0}function nb(a){if(!a)return!1;try{return!!a.$goog_Thenable}catch(b){return!1}};function ob(a,b,c){this.f=c;this.c=a;this.g=b;this.b=0;this.a=null}ob.prototype.get=function(){if(0<this.b){this.b--;var a=this.a;this.a=a.next;a.next=null}else a=this.c();return a};function pb(a,b){a.g(b);a.b<a.f&&(a.b++,b.next=a.a,a.a=b)};var rb=new ob(function(){return new qb},function(a){a.reset()},100);function sb(){var a=tb,b=null;a.a&&(b=a.a,a.a=a.a.next,a.a||(a.b=null),b.next=null);return b}function qb(){this.next=this.b=this.a=null}qb.prototype.set=function(a,b){this.a=a;this.b=b;this.next=null};qb.prototype.reset=function(){this.next=this.b=this.a=null};function ub(a){k.setTimeout(function(){throw a;},0)}var wb;
function xb(){var a=k.MessageChannel;"undefined"===typeof a&&"undefined"!==typeof window&&window.postMessage&&window.addEventListener&&!x("Presto")&&(a=function(){var a=document.createElement("IFRAME");a.style.display="none";a.src="";document.documentElement.appendChild(a);var b=a.contentWindow;a=b.document;a.open();a.write("");a.close();var c="callImmediate"+Math.random(),d="file:"==b.location.protocol?"*":b.location.protocol+"//"+b.location.host;a=r(function(a){if(("*"==d||a.origin==d)&&a.data==
c)this.port1.onmessage()},this);b.addEventListener("message",a,!1);this.port1={};this.port2={postMessage:function(){b.postMessage(c,d)}}});if("undefined"!==typeof a&&!x("Trident")&&!x("MSIE")){var b=new a,c={},d=c;b.port1.onmessage=function(){if(void 0!==c.next){c=c.next;var a=c.pb;c.pb=null;a()}};return function(a){d.next={pb:a};d=d.next;b.port2.postMessage(0)}}return"undefined"!==typeof document&&"onreadystatechange"in document.createElement("SCRIPT")?function(a){var b=document.createElement("SCRIPT");
b.onreadystatechange=function(){b.onreadystatechange=null;b.parentNode.removeChild(b);b=null;a();a=null};document.documentElement.appendChild(b)}:function(a){k.setTimeout(a,0)}};function yb(a,b){zb||Ab();Bb||(zb(),Bb=!0);var c=tb,d=rb.get();d.set(a,b);c.b?c.b.next=d:c.a=d;c.b=d}var zb;function Ab(){if(-1!=String(k.Promise).indexOf("[native code]")){var a=k.Promise.resolve(void 0);zb=function(){a.then(Cb)}}else zb=function(){var a=Cb;!p(k.setImmediate)||k.Window&&k.Window.prototype&&!x("Edge")&&k.Window.prototype.setImmediate==k.setImmediate?(wb||(wb=xb()),wb(a)):k.setImmediate(a)}}var Bb=!1,tb=new function(){this.b=this.a=null};
function Cb(){for(var a;a=sb();){try{a.a.call(a.b)}catch(b){ub(b)}pb(rb,a)}Bb=!1};function z(a,b){this.a=Db;this.i=void 0;this.f=this.b=this.c=null;this.g=this.h=!1;if(a!=ca)try{var c=this;a.call(b,function(a){Eb(c,Fb,a)},function(a){if(!(a instanceof Gb))try{if(a instanceof Error)throw a;throw Error("Promise rejected.");}catch(e){}Eb(c,Hb,a)})}catch(d){Eb(this,Hb,d)}}var Db=0,Fb=2,Hb=3;function Ib(){this.next=this.f=this.b=this.g=this.a=null;this.c=!1}Ib.prototype.reset=function(){this.f=this.b=this.g=this.a=null;this.c=!1};
var Jb=new ob(function(){return new Ib},function(a){a.reset()},100);function Kb(a,b,c){var d=Jb.get();d.g=a;d.b=b;d.f=c;return d}function A(a){if(a instanceof z)return a;var b=new z(ca);Eb(b,Fb,a);return b}function B(a){return new z(function(b,c){c(a)})}function Lb(a,b,c){Mb(a,b,c,null)||yb(ma(b,a))}function Nb(a){return new z(function(b,c){var d=a.length,e=[];if(d)for(var f=function(a,c){d--;e[a]=c;0==d&&b(e)},g=function(a){c(a)},l=0,n;l<a.length;l++)n=a[l],Lb(n,ma(f,l),g);else b(e)})}
function Ob(a){return new z(function(b){var c=a.length,d=[];if(c)for(var e=function(a,e,f){c--;d[a]=e?{Ub:!0,value:f}:{Ub:!1,reason:f};0==c&&b(d)},f=0,g;f<a.length;f++)g=a[f],Lb(g,ma(e,f,!0),ma(e,f,!1));else b(d)})}z.prototype.then=function(a,b,c){return Pb(this,p(a)?a:null,p(b)?b:null,c)};mb(z);function Qb(a,b){b=Kb(b,b,void 0);b.c=!0;Rb(a,b);return a}h=z.prototype;h.s=function(a,b){return Pb(this,null,a,b)};h.cancel=function(a){this.a==Db&&yb(function(){var b=new Gb(a);Sb(this,b)},this)};
function Sb(a,b){if(a.a==Db)if(a.c){var c=a.c;if(c.b){for(var d=0,e=null,f=null,g=c.b;g&&(g.c||(d++,g.a==a&&(e=g),!(e&&1<d)));g=g.next)e||(f=g);e&&(c.a==Db&&1==d?Sb(c,b):(f?(d=f,d.next==c.f&&(c.f=d),d.next=d.next.next):Tb(c),Ub(c,e,Hb,b)))}a.c=null}else Eb(a,Hb,b)}function Rb(a,b){a.b||a.a!=Fb&&a.a!=Hb||Vb(a);a.f?a.f.next=b:a.b=b;a.f=b}
function Pb(a,b,c,d){var e=Kb(null,null,null);e.a=new z(function(a,g){e.g=b?function(c){try{var e=b.call(d,c);a(e)}catch(D){g(D)}}:a;e.b=c?function(b){try{var e=c.call(d,b);void 0===e&&b instanceof Gb?g(b):a(e)}catch(D){g(D)}}:g});e.a.c=a;Rb(a,e);return e.a}h.Ac=function(a){this.a=Db;Eb(this,Fb,a)};h.Bc=function(a){this.a=Db;Eb(this,Hb,a)};
function Eb(a,b,c){a.a==Db&&(a===c&&(b=Hb,c=new TypeError("Promise cannot resolve to itself")),a.a=1,Mb(c,a.Ac,a.Bc,a)||(a.i=c,a.a=b,a.c=null,Vb(a),b!=Hb||c instanceof Gb||Wb(a,c)))}function Mb(a,b,c,d){if(a instanceof z)return Rb(a,Kb(b||ca,c||null,d)),!0;if(nb(a))return a.then(b,c,d),!0;if(q(a))try{var e=a.then;if(p(e))return Xb(a,e,b,c,d),!0}catch(f){return c.call(d,f),!0}return!1}
function Xb(a,b,c,d,e){function f(a){l||(l=!0,d.call(e,a))}function g(a){l||(l=!0,c.call(e,a))}var l=!1;try{b.call(a,g,f)}catch(n){f(n)}}function Vb(a){a.h||(a.h=!0,yb(a.Qb,a))}function Tb(a){var b=null;a.b&&(b=a.b,a.b=b.next,b.next=null);a.b||(a.f=null);return b}h.Qb=function(){for(var a;a=Tb(this);)Ub(this,a,this.a,this.i);this.h=!1};
function Ub(a,b,c,d){if(c==Hb&&b.b&&!b.c)for(;a&&a.g;a=a.c)a.g=!1;if(b.a)b.a.c=null,Yb(b,c,d);else try{b.c?b.g.call(b.f):Yb(b,c,d)}catch(e){Zb.call(null,e)}pb(Jb,b)}function Yb(a,b,c){b==Fb?a.g.call(a.f,c):a.b&&a.b.call(a.f,c)}function Wb(a,b){a.g=!0;yb(function(){a.g&&Zb.call(null,b)})}var Zb=ub;function Gb(a){u.call(this,a)}t(Gb,u);Gb.prototype.name="cancel";var $b=!y||9<=Number(kb);function ac(){this.a="";this.b=bc}ac.prototype.la=!0;ac.prototype.ja=function(){return this.a};ac.prototype.toString=function(){return"Const{"+this.a+"}"};function cc(a){if(a instanceof ac&&a.constructor===ac&&a.b===bc)return a.a;Aa("expected object of type Const, got '"+a+"'");return"type_error:Const"}var bc={};function dc(a){var b=new ac;b.a=a;return b}dc("");function ec(){this.a="";this.b=fc}ec.prototype.la=!0;ec.prototype.ja=function(){return this.a};ec.prototype.toString=function(){return"TrustedResourceUrl{"+this.a+"}"};function gc(a){if(a instanceof ec&&a.constructor===ec&&a.b===fc)return a.a;Aa("expected object of type TrustedResourceUrl, got '"+a+"' of type "+da(a));return"type_error:TrustedResourceUrl"}function hc(a,b){a=ic(a,b);b=new ec;b.a=a;return b}
function ic(a,b){var c=cc(a);if(!jc.test(c))throw Error("Invalid TrustedResourceUrl format: "+c);return c.replace(kc,function(a,e){if(!Object.prototype.hasOwnProperty.call(b,e))throw Error('Found marker, "'+e+'", in format string, "'+c+'", but no valid label mapping found in args: '+JSON.stringify(b));a=b[e];return a instanceof ac?cc(a):encodeURIComponent(String(a))})}var kc=/%{(\w+)}/g,jc=/^(?:https:)?\/\/[0-9a-z.:[\]-]+\/|^\/[^\/\\]|^about:blank(#|$)/i,fc={};function lc(){this.a="";this.b=mc}lc.prototype.la=!0;lc.prototype.ja=function(){return this.a};lc.prototype.toString=function(){return"SafeUrl{"+this.a+"}"};function nc(a){if(a instanceof lc&&a.constructor===lc&&a.b===mc)return a.a;Aa("expected object of type SafeUrl, got '"+a+"' of type "+da(a));return"type_error:SafeUrl"}var oc=/^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
function pc(a){if(a instanceof lc)return a;a=a.la?a.ja():String(a);oc.test(a)||(a="about:invalid#zClosurez");return qc(a)}var mc={};function qc(a){var b=new lc;b.a=a;return b}qc("about:blank");function rc(){this.a="";this.b=sc}rc.prototype.la=!0;rc.prototype.ja=function(){return this.a};rc.prototype.toString=function(){return"SafeHtml{"+this.a+"}"};function uc(a){if(a instanceof rc&&a.constructor===rc&&a.b===sc)return a.a;Aa("expected object of type SafeHtml, got '"+a+"' of type "+da(a));return"type_error:SafeHtml"}var sc={};function vc(a){var b=new rc;b.a=a;return b}vc("<!DOCTYPE html>");vc("");vc("<br>");function wc(a){var b=document;return m(a)?b.getElementById(a):a}function xc(a,b){Pa(b,function(b,d){b&&b.la&&(b=b.ja());"style"==d?a.style.cssText=b:"class"==d?a.className=b:"for"==d?a.htmlFor=b:yc.hasOwnProperty(d)?a.setAttribute(yc[d],b):0==d.lastIndexOf("aria-",0)||0==d.lastIndexOf("data-",0)?a.setAttribute(d,b):a[d]=b})}
var yc={cellpadding:"cellPadding",cellspacing:"cellSpacing",colspan:"colSpan",frameborder:"frameBorder",height:"height",maxlength:"maxLength",nonce:"nonce",role:"role",rowspan:"rowSpan",type:"type",usemap:"useMap",valign:"vAlign",width:"width"};
function zc(a,b,c){var d=arguments,e=document,f=String(d[0]),g=d[1];if(!$b&&g&&(g.name||g.type)){f=["<",f];g.name&&f.push(' name="',qa(g.name),'"');if(g.type){f.push(' type="',qa(g.type),'"');var l={};Wa(l,g);delete l.type;g=l}f.push(">");f=f.join("")}f=e.createElement(f);g&&(m(g)?f.className=g:fa(g)?f.className=g.join(" "):xc(f,g));2<d.length&&Ac(e,f,d);return f}
function Ac(a,b,c){function d(c){c&&b.appendChild(m(c)?a.createTextNode(c):c)}for(var e=2;e<c.length;e++){var f=c[e];!ha(f)||q(f)&&0<f.nodeType?d(f):w(Bc(f)?La(f):f,d)}}function Bc(a){if(a&&"number"==typeof a.length){if(q(a))return"function"==typeof a.item||"string"==typeof a.item;if(p(a))return"function"==typeof a.item}return!1};function Cc(a){var b=[];Dc(new Ec,a,b);return b.join("")}function Ec(){}
function Dc(a,b,c){if(null==b)c.push("null");else{if("object"==typeof b){if(fa(b)){var d=b;b=d.length;c.push("[");for(var e="",f=0;f<b;f++)c.push(e),Dc(a,d[f],c),e=",";c.push("]");return}if(b instanceof String||b instanceof Number||b instanceof Boolean)b=b.valueOf();else{c.push("{");e="";for(d in b)Object.prototype.hasOwnProperty.call(b,d)&&(f=b[d],"function"!=typeof f&&(c.push(e),Fc(d,c),c.push(":"),Dc(a,f,c),e=","));c.push("}");return}}switch(typeof b){case "string":Fc(b,c);break;case "number":c.push(isFinite(b)&&
!isNaN(b)?String(b):"null");break;case "boolean":c.push(String(b));break;case "function":c.push("null");break;default:throw Error("Unknown type: "+typeof b);}}}var Gc={'"':'\\"',"\\":"\\\\","/":"\\/","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\x0B":"\\u000b"},Hc=/\uffff/.test("\uffff")?/[\\\"\x00-\x1f\x7f-\uffff]/g:/[\\\"\x00-\x1f\x7f-\xff]/g;
function Fc(a,b){b.push('"',a.replace(Hc,function(a){var b=Gc[a];b||(b="\\u"+(a.charCodeAt(0)|65536).toString(16).substr(1),Gc[a]=b);return b}),'"')};function Ic(){0!=Jc&&(Kc[this[ia]||(this[ia]=++ja)]=this);this.oa=this.oa;this.Fa=this.Fa}var Jc=0,Kc={};Ic.prototype.oa=!1;function Lc(a){a.oa||(a.oa=!0,a.ta(),0!=Jc&&(a=a[ia]||(a[ia]=++ja),delete Kc[a]))}Ic.prototype.ta=function(){if(this.Fa)for(;this.Fa.length;)this.Fa.shift()()};var Mc=Object.freeze||function(a){return a};var Nc=!y||9<=Number(kb),Oc=y&&!jb("9"),Pc=function(){if(!k.addEventListener||!Object.defineProperty)return!1;var a=!1,b=Object.defineProperty({},"passive",{get:function(){a=!0}});k.addEventListener("test",ca,b);k.removeEventListener("test",ca,b);return a}();function C(a,b){this.type=a;this.b=this.target=b;this.Bb=!0}C.prototype.c=function(){this.Bb=!1};function Qc(a,b){C.call(this,a?a.type:"");this.relatedTarget=this.b=this.target=null;this.button=this.screenY=this.screenX=this.clientY=this.clientX=0;this.key="";this.metaKey=this.shiftKey=this.altKey=this.ctrlKey=!1;this.pointerId=0;this.pointerType="";this.a=null;if(a){var c=this.type=a.type,d=a.changedTouches?a.changedTouches[0]:null;this.target=a.target||a.srcElement;this.b=b;if(b=a.relatedTarget){if(cb){a:{try{Xa(b.nodeName);var e=!0;break a}catch(f){}e=!1}e||(b=null)}}else"mouseover"==c?b=
a.fromElement:"mouseout"==c&&(b=a.toElement);this.relatedTarget=b;null===d?(this.clientX=void 0!==a.clientX?a.clientX:a.pageX,this.clientY=void 0!==a.clientY?a.clientY:a.pageY,this.screenX=a.screenX||0,this.screenY=a.screenY||0):(this.clientX=void 0!==d.clientX?d.clientX:d.pageX,this.clientY=void 0!==d.clientY?d.clientY:d.pageY,this.screenX=d.screenX||0,this.screenY=d.screenY||0);this.button=a.button;this.key=a.key||"";this.ctrlKey=a.ctrlKey;this.altKey=a.altKey;this.shiftKey=a.shiftKey;this.metaKey=
a.metaKey;this.pointerId=a.pointerId||0;this.pointerType=m(a.pointerType)?a.pointerType:Rc[a.pointerType]||"";this.a=a;a.defaultPrevented&&this.c()}}t(Qc,C);var Rc=Mc({2:"touch",3:"pen",4:"mouse"});Qc.prototype.c=function(){Qc.ib.c.call(this);var a=this.a;if(a.preventDefault)a.preventDefault();else if(a.returnValue=!1,Oc)try{if(a.ctrlKey||112<=a.keyCode&&123>=a.keyCode)a.keyCode=-1}catch(b){}};Qc.prototype.g=function(){return this.a};var Sc="closure_listenable_"+(1E6*Math.random()|0),Tc=0;function Uc(a,b,c,d,e){this.listener=a;this.a=null;this.src=b;this.type=c;this.capture=!!d;this.La=e;this.key=++Tc;this.ma=this.Ha=!1}function Vc(a){a.ma=!0;a.listener=null;a.a=null;a.src=null;a.La=null};function Wc(a){this.src=a;this.a={};this.b=0}function Xc(a,b,c,d,e,f){var g=b.toString();b=a.a[g];b||(b=a.a[g]=[],a.b++);var l=Yc(b,c,e,f);-1<l?(a=b[l],d||(a.Ha=!1)):(a=new Uc(c,a.src,g,!!e,f),a.Ha=d,b.push(a));return a}function Zc(a,b){var c=b.type;c in a.a&&Ia(a.a[c],b)&&(Vc(b),0==a.a[c].length&&(delete a.a[c],a.b--))}function Yc(a,b,c,d){for(var e=0;e<a.length;++e){var f=a[e];if(!f.ma&&f.listener==b&&f.capture==!!c&&f.La==d)return e}return-1};var $c="closure_lm_"+(1E6*Math.random()|0),ad={},bd=0;function cd(a,b,c,d,e){if(d&&d.once)dd(a,b,c,d,e);else if(fa(b))for(var f=0;f<b.length;f++)cd(a,b[f],c,d,e);else c=ed(c),a&&a[Sc]?fd(a,b,c,q(d)?!!d.capture:!!d,e):gd(a,b,c,!1,d,e)}
function gd(a,b,c,d,e,f){if(!b)throw Error("Invalid event type");var g=q(e)?!!e.capture:!!e,l=hd(a);l||(a[$c]=l=new Wc(a));c=Xc(l,b,c,d,g,f);if(!c.a){d=id();c.a=d;d.src=a;d.listener=c;if(a.addEventListener)Pc||(e=g),void 0===e&&(e=!1),a.addEventListener(b.toString(),d,e);else if(a.attachEvent)a.attachEvent(jd(b.toString()),d);else throw Error("addEventListener and attachEvent are unavailable.");bd++}}
function id(){var a=kd,b=Nc?function(c){return a.call(b.src,b.listener,c)}:function(c){c=a.call(b.src,b.listener,c);if(!c)return c};return b}function dd(a,b,c,d,e){if(fa(b))for(var f=0;f<b.length;f++)dd(a,b[f],c,d,e);else c=ed(c),a&&a[Sc]?ld(a,b,c,q(d)?!!d.capture:!!d,e):gd(a,b,c,!0,d,e)}
function E(a,b,c,d,e){if(fa(b))for(var f=0;f<b.length;f++)E(a,b[f],c,d,e);else(d=q(d)?!!d.capture:!!d,c=ed(c),a&&a[Sc])?(a=a.u,b=String(b).toString(),b in a.a&&(f=a.a[b],c=Yc(f,c,d,e),-1<c&&(Vc(f[c]),Array.prototype.splice.call(f,c,1),0==f.length&&(delete a.a[b],a.b--)))):a&&(a=hd(a))&&(b=a.a[b.toString()],a=-1,b&&(a=Yc(b,c,d,e)),(c=-1<a?b[a]:null)&&md(c))}
function md(a){if("number"!=typeof a&&a&&!a.ma){var b=a.src;if(b&&b[Sc])Zc(b.u,a);else{var c=a.type,d=a.a;b.removeEventListener?b.removeEventListener(c,d,a.capture):b.detachEvent&&b.detachEvent(jd(c),d);bd--;(c=hd(b))?(Zc(c,a),0==c.b&&(c.src=null,b[$c]=null)):Vc(a)}}}function jd(a){return a in ad?ad[a]:ad[a]="on"+a}function nd(a,b,c,d){var e=!0;if(a=hd(a))if(b=a.a[b.toString()])for(b=b.concat(),a=0;a<b.length;a++){var f=b[a];f&&f.capture==c&&!f.ma&&(f=od(f,d),e=e&&!1!==f)}return e}
function od(a,b){var c=a.listener,d=a.La||a.src;a.Ha&&md(a);return c.call(d,b)}
function kd(a,b){if(a.ma)return!0;if(!Nc){if(!b)a:{b=["window","event"];for(var c=k,d=0;d<b.length;d++)if(c=c[b[d]],null==c){b=null;break a}b=c}d=b;b=new Qc(d,this);c=!0;if(!(0>d.keyCode||void 0!=d.returnValue)){a:{var e=!1;if(0==d.keyCode)try{d.keyCode=-1;break a}catch(g){e=!0}if(e||void 0==d.returnValue)d.returnValue=!0}d=[];for(e=b.b;e;e=e.parentNode)d.push(e);a=a.type;for(e=d.length-1;0<=e;e--){b.b=d[e];var f=nd(d[e],a,!0,b);c=c&&f}for(e=0;e<d.length;e++)b.b=d[e],f=nd(d[e],a,!1,b),c=c&&f}return c}return od(a,
new Qc(b,this))}function hd(a){a=a[$c];return a instanceof Wc?a:null}var pd="__closure_events_fn_"+(1E9*Math.random()>>>0);function ed(a){if(p(a))return a;a[pd]||(a[pd]=function(b){return a.handleEvent(b)});return a[pd]};function F(){Ic.call(this);this.u=new Wc(this);this.Ib=this;this.Ra=null}t(F,Ic);F.prototype[Sc]=!0;F.prototype.removeEventListener=function(a,b,c,d){E(this,a,b,c,d)};
function G(a,b){var c,d=a.Ra;if(d)for(c=[];d;d=d.Ra)c.push(d);a=a.Ib;d=b.type||b;if(m(b))b=new C(b,a);else if(b instanceof C)b.target=b.target||a;else{var e=b;b=new C(d,a);Wa(b,e)}e=!0;if(c)for(var f=c.length-1;0<=f;f--){var g=b.b=c[f];e=qd(g,d,!0,b)&&e}g=b.b=a;e=qd(g,d,!0,b)&&e;e=qd(g,d,!1,b)&&e;if(c)for(f=0;f<c.length;f++)g=b.b=c[f],e=qd(g,d,!1,b)&&e}
F.prototype.ta=function(){F.ib.ta.call(this);if(this.u){var a=this.u,b=0,c;for(c in a.a){for(var d=a.a[c],e=0;e<d.length;e++)++b,Vc(d[e]);delete a.a[c];a.b--}}this.Ra=null};function fd(a,b,c,d,e){Xc(a.u,String(b),c,!1,d,e)}function ld(a,b,c,d,e){Xc(a.u,String(b),c,!0,d,e)}function qd(a,b,c,d){b=a.u.a[String(b)];if(!b)return!0;b=b.concat();for(var e=!0,f=0;f<b.length;++f){var g=b[f];if(g&&!g.ma&&g.capture==c){var l=g.listener,n=g.La||g.src;g.Ha&&Zc(a.u,g);e=!1!==l.call(n,d)&&e}}return e&&0!=d.Bb};function rd(a,b,c){if(p(a))c&&(a=r(a,c));else if(a&&"function"==typeof a.handleEvent)a=r(a.handleEvent,a);else throw Error("Invalid listener argument");return 2147483647<Number(b)?-1:k.setTimeout(a,b||0)}function sd(a){var b=null;return(new z(function(c,d){b=rd(function(){c(void 0)},a);-1==b&&d(Error("Failed to schedule timer."))})).s(function(a){k.clearTimeout(b);throw a;})};function td(a,b,c,d,e){this.reset(a,b,c,d,e)}td.prototype.a=null;var ud=0;td.prototype.reset=function(a,b,c,d,e){"number"==typeof e||ud++;d||na();this.b=b;delete this.a};function vd(a){this.f=a;this.b=this.c=this.a=null}function wd(a,b){this.name=a;this.value=b}wd.prototype.toString=function(){return this.name};var xd=new wd("SEVERE",1E3),yd=new wd("CONFIG",700),zd=new wd("FINE",500);function Ad(a){if(a.c)return a.c;if(a.a)return Ad(a.a);Aa("Root logger has no level set.");return null}
vd.prototype.log=function(a,b,c){if(a.value>=Ad(this).value)for(p(b)&&(b=b()),a=new td(a,String(b),this.f),c&&(a.a=c),c="log:"+a.b,(a=k.console)&&a.timeStamp&&a.timeStamp(c),(a=k.msWriteProfilerMark)&&a(c),c=this;c;)c=c.a};var Bd={},Cd=null;function Dd(a){Cd||(Cd=new vd(""),Bd[""]=Cd,Cd.c=yd);var b;if(!(b=Bd[a])){b=new vd(a);var c=a.lastIndexOf("."),d=a.substr(c+1);c=Dd(a.substr(0,c));c.b||(c.b={});c.b[d]=b;b.a=c;Bd[a]=b}return b};function Ed(a,b){this.b={};this.a=[];this.c=0;var c=arguments.length;if(1<c){if(c%2)throw Error("Uneven number of arguments");for(var d=0;d<c;d+=2)this.set(arguments[d],arguments[d+1])}else if(a){a instanceof Ed?(c=a.S(),d=a.P()):(c=Ra(a),d=Qa(a));for(var e=0;e<c.length;e++)this.set(c[e],d[e])}}h=Ed.prototype;h.P=function(){Fd(this);for(var a=[],b=0;b<this.a.length;b++)a.push(this.b[this.a[b]]);return a};h.S=function(){Fd(this);return this.a.concat()};
h.clear=function(){this.b={};this.c=this.a.length=0};function Fd(a){if(a.c!=a.a.length){for(var b=0,c=0;b<a.a.length;){var d=a.a[b];Gd(a.b,d)&&(a.a[c++]=d);b++}a.a.length=c}if(a.c!=a.a.length){var e={};for(c=b=0;b<a.a.length;)d=a.a[b],Gd(e,d)||(a.a[c++]=d,e[d]=1),b++;a.a.length=c}}h.get=function(a,b){return Gd(this.b,a)?this.b[a]:b};h.set=function(a,b){Gd(this.b,a)||(this.c++,this.a.push(a));this.b[a]=b};
h.forEach=function(a,b){for(var c=this.S(),d=0;d<c.length;d++){var e=c[d],f=this.get(e);a.call(b,f,e,this)}};function Gd(a,b){return Object.prototype.hasOwnProperty.call(a,b)};function H(a,b){a&&a.log(zd,b,void 0)};function Hd(a){return Da(a,function(a){a=a.toString(16);return 1<a.length?a:"0"+a}).join("")};var Id=null,Jd=null;function Kd(a){var b="";Ld(a,function(a){b+=String.fromCharCode(a)});return b}function Ld(a,b){function c(b){for(;d<a.length;){var c=a.charAt(d++),e=Jd[c];if(null!=e)return e;if(!/^[\s\xa0]*$/.test(c))throw Error("Unknown base64 encoding at char: "+c);}return b}Md();for(var d=0;;){var e=c(-1),f=c(0),g=c(64),l=c(64);if(64===l&&-1===e)break;b(e<<2|f>>4);64!=g&&(b(f<<4&240|g>>2),64!=l&&b(g<<6&192|l))}}
function Md(){if(!Id){Id={};Jd={};for(var a=0;65>a;a++)Id[a]="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(a),Jd[Id[a]]=a,62<=a&&(Jd["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt(a)]=a)}};/*
 Portions of this code are from MochiKit, received by
 The Closure Authors under the MIT license. All other code is Copyright
 2005-2009 The Closure Authors. All Rights Reserved.
*/
function Nd(a,b){this.g=[];this.v=a;this.o=b||null;this.f=this.a=!1;this.c=void 0;this.u=this.w=this.i=!1;this.h=0;this.b=null;this.l=0}Nd.prototype.cancel=function(a){if(this.a)this.c instanceof Nd&&this.c.cancel();else{if(this.b){var b=this.b;delete this.b;a?b.cancel(a):(b.l--,0>=b.l&&b.cancel())}this.v?this.v.call(this.o,this):this.u=!0;this.a||(a=new Od,Pd(this),Qd(this,!1,a))}};Nd.prototype.m=function(a,b){this.i=!1;Qd(this,a,b)};function Qd(a,b,c){a.a=!0;a.c=c;a.f=!b;Rd(a)}
function Pd(a){if(a.a){if(!a.u)throw new Sd;a.u=!1}}Nd.prototype.A=function(a){Pd(this);Qd(this,!0,a)};function Td(a,b){Ud(a,null,b,void 0)}function Ud(a,b,c,d){a.g.push([b,c,d]);a.a&&Rd(a)}Nd.prototype.then=function(a,b,c){var d,e,f=new z(function(a,b){d=a;e=b});Ud(this,d,function(a){a instanceof Od?f.cancel():e(a)});return f.then(a,b,c)};mb(Nd);function Vd(a){return Ea(a.g,function(a){return p(a[1])})}
function Rd(a){if(a.h&&a.a&&Vd(a)){var b=a.h,c=Wd[b];c&&(k.clearTimeout(c.a),delete Wd[b]);a.h=0}a.b&&(a.b.l--,delete a.b);b=a.c;for(var d=c=!1;a.g.length&&!a.i;){var e=a.g.shift(),f=e[0],g=e[1];e=e[2];if(f=a.f?g:f)try{var l=f.call(e||a.o,b);void 0!==l&&(a.f=a.f&&(l==b||l instanceof Error),a.c=b=l);if(nb(b)||"function"===typeof k.Promise&&b instanceof k.Promise)d=!0,a.i=!0}catch(n){b=n,a.f=!0,Vd(a)||(c=!0)}}a.c=b;d&&(l=r(a.m,a,!0),d=r(a.m,a,!1),b instanceof Nd?(Ud(b,l,d),b.w=!0):b.then(l,d));c&&(b=
new Xd(b),Wd[b.a]=b,a.h=b.a)}function Sd(){u.call(this)}t(Sd,u);Sd.prototype.message="Deferred has already fired";Sd.prototype.name="AlreadyCalledError";function Od(){u.call(this)}t(Od,u);Od.prototype.message="Deferred was canceled";Od.prototype.name="CanceledError";function Xd(a){this.a=k.setTimeout(r(this.c,this),0);this.b=a}Xd.prototype.c=function(){delete Wd[this.a];throw this.b;};var Wd={};function Yd(){this.b=-1};function Zd(a,b){this.b=-1;this.b=$d;this.f=k.Uint8Array?new Uint8Array(this.b):Array(this.b);this.g=this.c=0;this.a=[];this.i=a;this.h=b;this.l=k.Int32Array?new Int32Array(64):Array(64);ae||(k.Int32Array?ae=new Int32Array(be):ae=be);this.reset()}var ae;t(Zd,Yd);for(var $d=64,ce=$d-1,de=[],ee=0;ee<ce;ee++)de[ee]=0;var fe=Ka(128,de);Zd.prototype.reset=function(){this.g=this.c=0;this.a=k.Int32Array?new Int32Array(this.h):La(this.h)};
function ge(a){for(var b=a.f,c=a.l,d=0,e=0;e<b.length;)c[d++]=b[e]<<24|b[e+1]<<16|b[e+2]<<8|b[e+3],e=4*d;for(b=16;64>b;b++){e=c[b-15]|0;d=c[b-2]|0;var f=(c[b-16]|0)+((e>>>7|e<<25)^(e>>>18|e<<14)^e>>>3)|0,g=(c[b-7]|0)+((d>>>17|d<<15)^(d>>>19|d<<13)^d>>>10)|0;c[b]=f+g|0}d=a.a[0]|0;e=a.a[1]|0;var l=a.a[2]|0,n=a.a[3]|0,D=a.a[4]|0,vb=a.a[5]|0,tc=a.a[6]|0;f=a.a[7]|0;for(b=0;64>b;b++){var Bj=((d>>>2|d<<30)^(d>>>13|d<<19)^(d>>>22|d<<10))+(d&e^d&l^e&l)|0;g=D&vb^~D&tc;f=f+((D>>>6|D<<26)^(D>>>11|D<<21)^(D>>>
25|D<<7))|0;g=g+(ae[b]|0)|0;g=f+(g+(c[b]|0)|0)|0;f=tc;tc=vb;vb=D;D=n+g|0;n=l;l=e;e=d;d=g+Bj|0}a.a[0]=a.a[0]+d|0;a.a[1]=a.a[1]+e|0;a.a[2]=a.a[2]+l|0;a.a[3]=a.a[3]+n|0;a.a[4]=a.a[4]+D|0;a.a[5]=a.a[5]+vb|0;a.a[6]=a.a[6]+tc|0;a.a[7]=a.a[7]+f|0}
function he(a,b,c){void 0===c&&(c=b.length);var d=0,e=a.c;if(m(b))for(;d<c;)a.f[e++]=b.charCodeAt(d++),e==a.b&&(ge(a),e=0);else if(ha(b))for(;d<c;){var f=b[d++];if(!("number"==typeof f&&0<=f&&255>=f&&f==(f|0)))throw Error("message must be a byte array");a.f[e++]=f;e==a.b&&(ge(a),e=0)}else throw Error("message must be string or array");a.c=e;a.g+=c}
var be=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,
4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function ie(){Zd.call(this,8,je)}t(ie,Zd);var je=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225];function ke(a){if(a.P&&"function"==typeof a.P)return a.P();if(m(a))return a.split("");if(ha(a)){for(var b=[],c=a.length,d=0;d<c;d++)b.push(a[d]);return b}return Qa(a)}function le(a){if(a.S&&"function"==typeof a.S)return a.S();if(!a.P||"function"!=typeof a.P){if(ha(a)||m(a)){var b=[];a=a.length;for(var c=0;c<a;c++)b.push(c);return b}return Ra(a)}}
function me(a,b){if(a.forEach&&"function"==typeof a.forEach)a.forEach(b,void 0);else if(ha(a)||m(a))w(a,b,void 0);else for(var c=le(a),d=ke(a),e=d.length,f=0;f<e;f++)b.call(void 0,d[f],c&&c[f],a)};var ne=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function oe(a,b){if(a){a=a.split("&");for(var c=0;c<a.length;c++){var d=a[c].indexOf("="),e=null;if(0<=d){var f=a[c].substring(0,d);e=a[c].substring(d+1)}else f=a[c];b(f,e?decodeURIComponent(e.replace(/\+/g," ")):"")}}};function pe(a,b){this.b=this.l=this.c="";this.i=null;this.h=this.g="";this.f=!1;if(a instanceof pe){this.f=void 0!==b?b:a.f;qe(this,a.c);this.l=a.l;this.b=a.b;re(this,a.i);this.g=a.g;b=a.a;var c=new se;c.c=b.c;b.a&&(c.a=new Ed(b.a),c.b=b.b);te(this,c);this.h=a.h}else a&&(c=String(a).match(ne))?(this.f=!!b,qe(this,c[1]||"",!0),this.l=ue(c[2]||""),this.b=ue(c[3]||"",!0),re(this,c[4]),this.g=ue(c[5]||"",!0),te(this,c[6]||"",!0),this.h=ue(c[7]||"")):(this.f=!!b,this.a=new se(null,0,this.f))}
pe.prototype.toString=function(){var a=[],b=this.c;b&&a.push(ve(b,we,!0),":");var c=this.b;if(c||"file"==b)a.push("//"),(b=this.l)&&a.push(ve(b,we,!0),"@"),a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g,"%$1")),c=this.i,null!=c&&a.push(":",String(c));if(c=this.g)this.b&&"/"!=c.charAt(0)&&a.push("/"),a.push(ve(c,"/"==c.charAt(0)?xe:ye,!0));(c=this.a.toString())&&a.push("?",c);(c=this.h)&&a.push("#",ve(c,ze));return a.join("")};
function qe(a,b,c){a.c=c?ue(b,!0):b;a.c&&(a.c=a.c.replace(/:$/,""))}function re(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.i=b}else a.i=null}function te(a,b,c){b instanceof se?(a.a=b,Ae(a.a,a.f)):(c||(b=ve(b,Be)),a.a=new se(b,0,a.f))}function I(a,b,c){a.a.set(b,c)}function Ce(a,b){return a.a.get(b)}function De(a){return a instanceof pe?new pe(a):new pe(a,void 0)}function Ee(a,b){var c=new pe(null,void 0);qe(c,"https");a&&(c.b=a);b&&(c.g=b);return c}
function ue(a,b){return a?b?decodeURI(a.replace(/%25/g,"%2525")):decodeURIComponent(a):""}function ve(a,b,c){return m(a)?(a=encodeURI(a).replace(b,Fe),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null}function Fe(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)}var we=/[#\/\?@]/g,ye=/[\#\?:]/g,xe=/[\#\?]/g,Be=/[\#\?@]/g,ze=/#/g;function se(a,b,c){this.b=this.a=null;this.c=a||null;this.f=!!c}
function Ge(a){a.a||(a.a=new Ed,a.b=0,a.c&&oe(a.c,function(b,c){He(a,decodeURIComponent(b.replace(/\+/g," ")),c)}))}function Ie(a){var b=le(a);if("undefined"==typeof b)throw Error("Keys are undefined");var c=new se(null,0,void 0);a=ke(a);for(var d=0;d<b.length;d++){var e=b[d],f=a[d];fa(f)?Je(c,e,f):He(c,e,f)}return c}function He(a,b,c){Ge(a);a.c=null;b=Ke(a,b);var d=a.a.get(b);d||a.a.set(b,d=[]);d.push(c);a.b+=1}
function Le(a,b){Ge(a);b=Ke(a,b);Gd(a.a.b,b)&&(a.c=null,a.b-=a.a.get(b).length,a=a.a,Gd(a.b,b)&&(delete a.b[b],a.c--,a.a.length>2*a.c&&Fd(a)))}h=se.prototype;h.clear=function(){this.a=this.c=null;this.b=0};function Me(a,b){Ge(a);b=Ke(a,b);return Gd(a.a.b,b)}h.forEach=function(a,b){Ge(this);this.a.forEach(function(c,d){w(c,function(c){a.call(b,c,d,this)},this)},this)};h.S=function(){Ge(this);for(var a=this.a.P(),b=this.a.S(),c=[],d=0;d<b.length;d++)for(var e=a[d],f=0;f<e.length;f++)c.push(b[d]);return c};
h.P=function(a){Ge(this);var b=[];if(m(a))Me(this,a)&&(b=Ka(b,this.a.get(Ke(this,a))));else{a=this.a.P();for(var c=0;c<a.length;c++)b=Ka(b,a[c])}return b};h.set=function(a,b){Ge(this);this.c=null;a=Ke(this,a);Me(this,a)&&(this.b-=this.a.get(a).length);this.a.set(a,[b]);this.b+=1;return this};h.get=function(a,b){a=a?this.P(a):[];return 0<a.length?String(a[0]):b};function Je(a,b,c){Le(a,b);0<c.length&&(a.c=null,a.a.set(Ke(a,b),La(c)),a.b+=c.length)}
h.toString=function(){if(this.c)return this.c;if(!this.a)return"";for(var a=[],b=this.a.S(),c=0;c<b.length;c++){var d=b[c],e=encodeURIComponent(String(d));d=this.P(d);for(var f=0;f<d.length;f++){var g=e;""!==d[f]&&(g+="="+encodeURIComponent(String(d[f])));a.push(g)}}return this.c=a.join("&")};function Ke(a,b){b=String(b);a.f&&(b=b.toLowerCase());return b}function Ae(a,b){b&&!a.f&&(Ge(a),a.c=null,a.a.forEach(function(a,b){var c=b.toLowerCase();b!=c&&(Le(this,b),Je(this,c,a))},a));a.f=b};function Ne(){}Ne.prototype.c=null;function Oe(a){return a.c||(a.c=a.b())};var Pe;function Qe(){}t(Qe,Ne);Qe.prototype.a=function(){var a=Re(this);return a?new ActiveXObject(a):new XMLHttpRequest};Qe.prototype.b=function(){var a={};Re(this)&&(a[0]=!0,a[1]=!0);return a};
function Re(a){if(!a.f&&"undefined"==typeof XMLHttpRequest&&"undefined"!=typeof ActiveXObject){for(var b=["MSXML2.XMLHTTP.6.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],c=0;c<b.length;c++){var d=b[c];try{return new ActiveXObject(d),a.f=d}catch(e){}}throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");}return a.f}Pe=new Qe;function Se(a){F.call(this);this.headers=new Ed;this.w=a||null;this.b=!1;this.v=this.a=null;this.g=this.I=this.i="";this.c=this.G=this.h=this.A=!1;this.f=0;this.m=null;this.l=Te;this.o=this.N=!1}t(Se,F);var Te="",Ue=Se.prototype,Ve=Dd("goog.net.XhrIo");Ue.J=Ve;var We=/^https?$/i,Xe=["POST","PUT"];
function Ye(a,b,c,d,e){if(a.a)throw Error("[goog.net.XhrIo] Object is active with another request="+a.i+"; newUri="+b);c=c?c.toUpperCase():"GET";a.i=b;a.g="";a.I=c;a.A=!1;a.b=!0;a.a=a.w?a.w.a():Pe.a();a.v=a.w?Oe(a.w):Oe(Pe);a.a.onreadystatechange=r(a.Ab,a);try{H(a.J,Ze(a,"Opening Xhr")),a.G=!0,a.a.open(c,String(b),!0),a.G=!1}catch(g){H(a.J,Ze(a,"Error opening Xhr: "+g.message));$e(a,g);return}b=d||"";var f=new Ed(a.headers);e&&me(e,function(a,b){f.set(b,a)});e=Fa(f.S());d=k.FormData&&b instanceof
k.FormData;!Ha(Xe,c)||e||d||f.set("Content-Type","application/x-www-form-urlencoded;charset=utf-8");f.forEach(function(a,b){this.a.setRequestHeader(b,a)},a);a.l&&(a.a.responseType=a.l);"withCredentials"in a.a&&a.a.withCredentials!==a.N&&(a.a.withCredentials=a.N);try{af(a),0<a.f&&(a.o=bf(a.a),H(a.J,Ze(a,"Will abort after "+a.f+"ms if incomplete, xhr2 "+a.o)),a.o?(a.a.timeout=a.f,a.a.ontimeout=r(a.Ea,a)):a.m=rd(a.Ea,a.f,a)),H(a.J,Ze(a,"Sending request")),a.h=!0,a.a.send(b),a.h=!1}catch(g){H(a.J,Ze(a,
"Send error: "+g.message)),$e(a,g)}}function bf(a){return y&&jb(9)&&"number"==typeof a.timeout&&void 0!==a.ontimeout}function Ga(a){return"content-type"==a.toLowerCase()}h=Se.prototype;h.Ea=function(){"undefined"!=typeof aa&&this.a&&(this.g="Timed out after "+this.f+"ms, aborting",H(this.J,Ze(this,this.g)),G(this,"timeout"),this.abort(8))};function $e(a,b){a.b=!1;a.a&&(a.c=!0,a.a.abort(),a.c=!1);a.g=b;cf(a);df(a)}function cf(a){a.A||(a.A=!0,G(a,"complete"),G(a,"error"))}
h.abort=function(){this.a&&this.b&&(H(this.J,Ze(this,"Aborting")),this.b=!1,this.c=!0,this.a.abort(),this.c=!1,G(this,"complete"),G(this,"abort"),df(this))};h.ta=function(){this.a&&(this.b&&(this.b=!1,this.c=!0,this.a.abort(),this.c=!1),df(this,!0));Se.ib.ta.call(this)};h.Ab=function(){this.oa||(this.G||this.h||this.c?ef(this):this.jc())};h.jc=function(){ef(this)};
function ef(a){if(a.b&&"undefined"!=typeof aa)if(a.v[1]&&4==ff(a)&&2==gf(a))H(a.J,Ze(a,"Local request error detected and ignored"));else if(a.h&&4==ff(a))rd(a.Ab,0,a);else if(G(a,"readystatechange"),4==ff(a)){H(a.J,Ze(a,"Request complete"));a.b=!1;try{var b=gf(a);a:switch(b){case 200:case 201:case 202:case 204:case 206:case 304:case 1223:var c=!0;break a;default:c=!1}var d;if(!(d=c)){var e;if(e=0===b){var f=String(a.i).match(ne)[1]||null;if(!f&&k.self&&k.self.location){var g=k.self.location.protocol;
f=g.substr(0,g.length-1)}e=!We.test(f?f.toLowerCase():"")}d=e}if(d)G(a,"complete"),G(a,"success");else{try{var l=2<ff(a)?a.a.statusText:""}catch(n){H(a.J,"Can not get status: "+n.message),l=""}a.g=l+" ["+gf(a)+"]";cf(a)}}finally{df(a)}}}function df(a,b){if(a.a){af(a);var c=a.a,d=a.v[0]?ca:null;a.a=null;a.v=null;b||G(a,"ready");try{c.onreadystatechange=d}catch(e){(a=a.J)&&a.log(xd,"Problem encountered resetting onreadystatechange: "+e.message,void 0)}}}
function af(a){a.a&&a.o&&(a.a.ontimeout=null);"number"==typeof a.m&&(k.clearTimeout(a.m),a.m=null)}function ff(a){return a.a?a.a.readyState:0}function gf(a){try{return 2<ff(a)?a.a.status:-1}catch(b){return-1}}function hf(a){try{return a.a?a.a.responseText:""}catch(b){return H(a.J,"Can not get responseText: "+b.message),""}}
h.getResponse=function(){try{if(!this.a)return null;if("response"in this.a)return this.a.response;switch(this.l){case Te:case "text":return this.a.responseText;case "arraybuffer":if("mozResponseArrayBuffer"in this.a)return this.a.mozResponseArrayBuffer}var a=this.J;a&&a.log(xd,"Response type "+this.l+" is not supported on this browser",void 0);return null}catch(b){return H(this.J,"Can not get response: "+b.message),null}};function Ze(a,b){return b+" ["+a.I+" "+a.i+" "+gf(a)+"]"};var jf=/^[+a-zA-Z0-9_.!#$%&'*\/=?^`{|}~-]+@([a-zA-Z0-9-]+\.)+[a-zA-Z0-9]{2,63}$/;function kf(a){var b={},c=b.document||document,d=gc(a),e=document.createElement("SCRIPT"),f={Cb:e,Ea:void 0},g=new Nd(lf,f),l=null,n=null!=b.timeout?b.timeout:5E3;0<n&&(l=window.setTimeout(function(){mf(e,!0);var a=new nf(of,"Timeout reached for loading script "+d);Pd(g);Qd(g,!1,a)},n),f.Ea=l);e.onload=e.onreadystatechange=function(){e.readyState&&"loaded"!=e.readyState&&"complete"!=e.readyState||(mf(e,b.Sc||!1,l),g.A(null))};e.onerror=function(){mf(e,!0,l);var a=new nf(pf,"Error while loading script "+
d);Pd(g);Qd(g,!1,a)};f=b.attributes||{};Wa(f,{type:"text/javascript",charset:"UTF-8"});xc(e,f);e.src=gc(a);qf(c).appendChild(e);return g}function qf(a){var b;return(b=(a||document).getElementsByTagName("HEAD"))&&0!=b.length?b[0]:a.documentElement}function lf(){if(this&&this.Cb){var a=this.Cb;a&&"SCRIPT"==a.tagName&&mf(a,!0,this.Ea)}}
function mf(a,b,c){null!=c&&k.clearTimeout(c);a.onload=ca;a.onerror=ca;a.onreadystatechange=ca;b&&window.setTimeout(function(){a&&a.parentNode&&a.parentNode.removeChild(a)},0)}var pf=0,of=1;function nf(a,b){var c="Jsloader error (code #"+a+")";b&&(c+=": "+b);u.call(this,c);this.code=a}t(nf,u);function rf(){}t(rf,Ne);rf.prototype.a=function(){var a=new XMLHttpRequest;if("withCredentials"in a)return a;if("undefined"!=typeof XDomainRequest)return new sf;throw Error("Unsupported browser");};rf.prototype.b=function(){return{}};
function sf(){this.a=new XDomainRequest;this.readyState=0;this.onreadystatechange=null;this.responseText="";this.status=-1;this.statusText=this.responseXML=null;this.a.onload=r(this.Wb,this);this.a.onerror=r(this.xb,this);this.a.onprogress=r(this.Xb,this);this.a.ontimeout=r(this.Yb,this)}h=sf.prototype;h.open=function(a,b,c){if(null!=c&&!c)throw Error("Only async requests are supported.");this.a.open(a,b)};
h.send=function(a){if(a)if("string"==typeof a)this.a.send(a);else throw Error("Only string data is supported");else this.a.send()};h.abort=function(){this.a.abort()};h.setRequestHeader=function(){};h.getResponseHeader=function(a){return"content-type"==a.toLowerCase()?this.a.contentType:""};h.Wb=function(){this.status=200;this.responseText=this.a.responseText;tf(this,4)};h.xb=function(){this.status=500;this.responseText="";tf(this,4)};h.Yb=function(){this.xb()};
h.Xb=function(){this.status=200;tf(this,1)};function tf(a,b){a.readyState=b;if(a.onreadystatechange)a.onreadystatechange()}h.getAllResponseHeaders=function(){return"content-type: "+this.a.contentType};function uf(){var a=J();return y&&!!kb&&11==kb||/Edge\/\d+/.test(a)}function vf(){return k.window&&k.window.location.href||""}function wf(a,b){b=b||k.window;var c="about:blank";a&&(c=nc(pc(a)));b.location.href=c}function xf(a,b){var c=[],d;for(d in a)d in b?typeof a[d]!=typeof b[d]?c.push(d):fa(a[d])?Ta(a[d],b[d])||c.push(d):"object"==typeof a[d]&&null!=a[d]&&null!=b[d]?0<xf(a[d],b[d]).length&&c.push(d):a[d]!==b[d]&&c.push(d):c.push(d);for(d in b)d in a||c.push(d);return c}
function yf(){var a=J();a=zf(a)!=Af?null:(a=a.match(/\sChrome\/(\d+)/i))&&2==a.length?parseInt(a[1],10):null;return a&&30>a?!1:!y||!kb||9<kb}function Bf(a){a=(a||J()).toLowerCase();return a.match(/android/)||a.match(/webos/)||a.match(/iphone|ipad|ipod/)||a.match(/blackberry/)||a.match(/windows phone/)||a.match(/iemobile/)?!0:!1}function Cf(a){a=a||k.window;try{a.close()}catch(b){}}
function Df(a,b,c){var d=Math.floor(1E9*Math.random()).toString();b=b||500;c=c||600;var e=(window.screen.availHeight-c)/2,f=(window.screen.availWidth-b)/2;b={width:b,height:c,top:0<e?e:0,left:0<f?f:0,location:!0,resizable:!0,statusbar:!0,toolbar:!1};c=J().toLowerCase();d&&(b.target=d,v(c,"crios/")&&(b.target="_blank"));zf(J())==Ef&&(a=a||"http://localhost",b.scrollbars=!0);c=a||"";(d=b)||(d={});a=window;b=c instanceof lc?c:pc("undefined"!=typeof c.href?c.href:String(c));c=d.target||c.target;e=[];
for(g in d)switch(g){case "width":case "height":case "top":case "left":e.push(g+"="+d[g]);break;case "target":case "noreferrer":break;default:e.push(g+"="+(d[g]?1:0))}var g=e.join(",");(x("iPhone")&&!x("iPod")&&!x("iPad")||x("iPad")||x("iPod"))&&a.navigator&&a.navigator.standalone&&c&&"_self"!=c?(g=a.document.createElement("A"),b instanceof lc||b instanceof lc||(b=b.la?b.ja():String(b),oc.test(b)||(b="about:invalid#zClosurez"),b=qc(b)),g.href=nc(b),g.setAttribute("target",c),d.noreferrer&&g.setAttribute("rel",
"noreferrer"),d=document.createEvent("MouseEvent"),d.initMouseEvent("click",!0,!0,a,1),g.dispatchEvent(d),g={}):d.noreferrer?(g=a.open("",c,g),a=nc(b),g&&(bb&&v(a,";")&&(a="'"+a.replace(/'/g,"%27")+"'"),g.opener=null,dc("b/12014412, meta tag with sanitized URL"),a='<META HTTP-EQUIV="refresh" content="0; url='+qa(a)+'">',a=vc(a),g.document.write(uc(a)),g.document.close())):g=a.open(nc(b),c,g);if(g)try{g.focus()}catch(l){}return g}
function Ff(a){return new z(function(b){function c(){sd(2E3).then(function(){if(!a||a.closed)b();else return c()})}return c()})}var Gf=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;function Hf(){var a=null;return(new z(function(b){"complete"==k.document.readyState?b():(a=function(){b()},dd(window,"load",a))})).s(function(b){E(window,"load",a);throw b;})}
function If(){return Jf(void 0)?Hf().then(function(){return new z(function(a,b){var c=k.document,d=setTimeout(function(){b(Error("Cordova framework is not ready."))},1E3);c.addEventListener("deviceready",function(){clearTimeout(d);a()},!1)})}):B(Error("Cordova must run in an Android or iOS file scheme."))}function Jf(a){a=a||J();return!("file:"!==Kf()||!a.toLowerCase().match(/iphone|ipad|ipod|android/))}function Lf(){var a=k.window;try{return!(!a||a==a.top)}catch(b){return!1}}
function K(){return firebase.INTERNAL.hasOwnProperty("reactNative")?"ReactNative":firebase.INTERNAL.hasOwnProperty("node")?"Node":"Browser"}function Mf(){var a=K();return"ReactNative"===a||"Node"===a}var Ef="Firefox",Af="Chrome";
function zf(a){var b=a.toLowerCase();if(v(b,"opera/")||v(b,"opr/")||v(b,"opios/"))return"Opera";if(v(b,"iemobile"))return"IEMobile";if(v(b,"msie")||v(b,"trident/"))return"IE";if(v(b,"edge/"))return"Edge";if(v(b,"firefox/"))return Ef;if(v(b,"silk/"))return"Silk";if(v(b,"blackberry"))return"Blackberry";if(v(b,"webos"))return"Webos";if(!v(b,"safari/")||v(b,"chrome/")||v(b,"crios/")||v(b,"android"))if(!v(b,"chrome/")&&!v(b,"crios/")||v(b,"edge/")){if(v(b,"android"))return"Android";if((a=a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/))&&
2==a.length)return a[1]}else return Af;else return"Safari";return"Other"}var Nf={Gc:"FirebaseCore-web",Ic:"FirebaseUI-web"};function Of(a,b){b=b||[];var c=[],d={},e;for(e in Nf)d[Nf[e]]=!0;for(e=0;e<b.length;e++)"undefined"!==typeof d[b[e]]&&(delete d[b[e]],c.push(b[e]));c.sort();b=c;b.length||(b=["FirebaseCore-web"]);c=K();d="";"Browser"===c?d=zf(J()):d=c;return d+"/JsCore/"+a+"/"+b.join(",")}function J(){return k.navigator&&k.navigator.userAgent||""}
function L(a,b){a=a.split(".");b=b||k;for(var c=0;c<a.length&&"object"==typeof b&&null!=b;c++)b=b[a[c]];c!=a.length&&(b=void 0);return b}function Pf(){try{var a=k.localStorage,b=Qf();if(a)return a.setItem(b,"1"),a.removeItem(b),uf()?!!k.indexedDB:!0}catch(c){}return!1}function Rf(){return(Sf()||"chrome-extension:"===Kf()||Jf())&&!Mf()&&Pf()}function Sf(){return"http:"===Kf()||"https:"===Kf()}function Kf(){return k.location&&k.location.protocol||null}
function Tf(a){a=a||J();return Bf(a)||zf(a)==Ef?!1:!0}function Uf(a){return"undefined"===typeof a?null:Cc(a)}function Vf(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&null!==a[c]&&void 0!==a[c]&&(b[c]=a[c]);return b}function Wf(a){if(null!==a)return JSON.parse(a)}function Qf(a){return a?a:""+Math.floor(1E9*Math.random()).toString()}function Xf(a){a=a||J();return"Safari"==zf(a)||a.toLowerCase().match(/iphone|ipad|ipod/)?!1:!0}
function Yf(){var a=k.___jsl;if(a&&a.H)for(var b in a.H)if(a.H[b].r=a.H[b].r||[],a.H[b].L=a.H[b].L||[],a.H[b].r=a.H[b].L.concat(),a.CP)for(var c=0;c<a.CP.length;c++)a.CP[c]=null}function Zf(){var a=k.navigator;return a&&"boolean"===typeof a.onLine&&(Sf()||"chrome-extension:"===Kf()||"undefined"!==typeof a.connection)?a.onLine:!0}function $f(a,b,c,d){if(a>b)throw Error("Short delay should be less than long delay!");this.c=a;this.b=b;a=c||J();d=d||K();this.a=Bf(a)||"ReactNative"===d}
$f.prototype.get=function(){return this.a?this.b:this.c};function ag(){var a=k.document;return a&&"undefined"!==typeof a.visibilityState?"visible"==a.visibilityState:!0}function bg(){var a=k.document,b=null;return ag()||!a?A():(new z(function(c){b=function(){ag()&&(a.removeEventListener("visibilitychange",b,!1),c())};a.addEventListener("visibilitychange",b,!1)})).s(function(c){a.removeEventListener("visibilitychange",b,!1);throw c;})}
function cg(a){try{var b=new Date(parseInt(a,10));if(!isNaN(b.getTime())&&!/[^0-9]/.test(a))return b.toUTCString()}catch(c){}return null};var dg={};var eg;try{var fg={};Object.defineProperty(fg,"abcd",{configurable:!0,enumerable:!0,value:1});Object.defineProperty(fg,"abcd",{configurable:!0,enumerable:!0,value:2});eg=2==fg.abcd}catch(a){eg=!1}function M(a,b,c){eg?Object.defineProperty(a,b,{configurable:!0,enumerable:!0,value:c}):a[b]=c}function gg(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&M(a,c,b[c])}function hg(a){var b={};gg(b,a);return b}function ig(a){var b={},c;for(c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}
function jg(a,b){if(!b||!b.length)return!0;if(!a)return!1;for(var c=0;c<b.length;c++){var d=a[b[c]];if(void 0===d||null===d||""===d)return!1}return!0}function kg(a){var b=a;if("object"==typeof a&&null!=a){b="length"in a?[]:{};for(var c in a)M(b,c,kg(a[c]))}return b};function lg(a){var b={},c=a[mg],d=a[ng];a=a[og];if(!c||!a)throw Error("Invalid provider user info!");b[pg]=d||null;b[qg]=c;M(this,rg,a);M(this,sg,kg(b))}var mg="email",ng="newEmail",og="requestType",qg="email",pg="fromEmail",sg="data",rg="operation";function N(a,b){this.code=tg+a;this.message=b||ug[a]||""}t(N,Error);N.prototype.B=function(){return{code:this.code,message:this.message}};N.prototype.toJSON=function(){return this.B()};function vg(a){var b=a&&a.code;return b?new N(b.substring(tg.length),a.message):null}
var tg="auth/",ug={"argument-error":"","app-not-authorized":"This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.","app-not-installed":"The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.","captcha-check-failed":"The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",
"code-expired":"The SMS code has expired. Please re-send the verification code to try again.","cordova-not-ready":"Cordova framework is not ready.","cors-unsupported":"This browser is not supported.","credential-already-in-use":"This credential is already associated with a different user account.","custom-token-mismatch":"The custom token corresponds to a different audience.","requires-recent-login":"This operation is sensitive and requires recent authentication. Log in again before retrying this request.",
"dynamic-link-not-activated":"Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.","email-already-in-use":"The email address is already in use by another account.","expired-action-code":"The action code has expired. ","cancelled-popup-request":"This operation has been cancelled due to another conflicting popup being opened.","internal-error":"An internal error has occurred.","invalid-app-credential":"The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
"invalid-app-id":"The mobile app identifier is not registed for the current project.","invalid-user-token":"The user's credential is no longer valid. The user must sign in again.","invalid-auth-event":"An internal error has occurred.","invalid-verification-code":"The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure use the verification code provided by the user.","invalid-continue-uri":"The continue URL provided in the request is invalid.",
"invalid-cordova-configuration":"The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.","invalid-custom-token":"The custom token format is incorrect. Please check the documentation.","invalid-email":"The email address is badly formatted.","invalid-api-key":"Your API key is invalid, please check you have copied it correctly.","invalid-cert-hash":"The SHA-1 certificate hash provided is invalid.",
"invalid-credential":"The supplied auth credential is malformed or has expired.","invalid-persistence-type":"The specified persistence type is invalid. It can only be local, session or none.","invalid-message-payload":"The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-oauth-provider":"EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",
"invalid-oauth-client-id":"The OAuth client ID provided is either invalid or does not match the specified API key.","unauthorized-domain":"This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.","invalid-action-code":"The action code is invalid. This can happen if the code is malformed, expired, or has already been used.","wrong-password":"The password is invalid or the user does not have a password.","invalid-phone-number":"The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
"invalid-recipient-email":"The email corresponding to this action failed to send as the provided recipient email address is invalid.","invalid-sender":"The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.","invalid-verification-id":"The verification ID used to create the phone auth credential is invalid.","missing-android-pkg-name":"An Android Package Name must be provided if the Android App is required to be installed.",
"auth-domain-config-required":"Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.","missing-app-credential":"The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.","missing-verification-code":"The phone auth credential was created with an empty SMS verification code.","missing-continue-uri":"A continue URL must be provided in the request.","missing-iframe-start":"An internal error has occurred.",
"missing-ios-bundle-id":"An iOS Bundle ID must be provided if an App Store ID is provided.","missing-phone-number":"To send verification codes, provide a phone number for the recipient.","missing-verification-id":"The phone auth credential was created with an empty verification ID.","app-deleted":"This instance of FirebaseApp has been deleted.","account-exists-with-different-credential":"An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
"network-request-failed":"A network error (such as timeout, interrupted connection or unreachable host) has occurred.","no-auth-event":"An internal error has occurred.","no-such-provider":"User was not linked to an account with the given provider.","operation-not-allowed":"The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.","operation-not-supported-in-this-environment":'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
"popup-blocked":"Unable to establish a connection with the popup. It may have been blocked by the browser.","popup-closed-by-user":"The popup has been closed by the user before finalizing the operation.","provider-already-linked":"User can only be linked to one identity for the given provider.","quota-exceeded":"The project's quota for this operation has been exceeded.","redirect-cancelled-by-user":"The redirect operation has been cancelled by the user before finalizing.","redirect-operation-pending":"A redirect sign-in operation is already pending.",
timeout:"The operation has timed out.","user-token-expired":"The user's credential is no longer valid. The user must sign in again.","too-many-requests":"We have blocked all requests from this device due to unusual activity. Try again later.","unauthorized-continue-uri":"The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.","unsupported-persistence-type":"The current environment does not support the specified persistence type.","user-cancelled":"User did not grant your application the permissions it requested.",
"user-not-found":"There is no user record corresponding to this identifier. The user may have been deleted.","user-disabled":"The user account has been disabled by an administrator.","user-mismatch":"The supplied credentials do not correspond to the previously signed in user.","user-signed-out":"","weak-password":"The password must be 6 characters long or more.","web-storage-unsupported":"This browser is not supported or 3rd party cookies and data may be disabled."};function wg(a){var b=a[xg];if("undefined"===typeof b)throw new N("missing-continue-uri");if("string"!==typeof b||"string"===typeof b&&!b.length)throw new N("invalid-continue-uri");this.h=b;this.c=this.a=null;this.g=!1;var c=a[yg];if(c&&"object"===typeof c){b=c[zg];var d=c[Ag];c=c[Bg];if("string"===typeof b&&b.length){this.a=b;if("undefined"!==typeof d&&"boolean"!==typeof d)throw new N("argument-error",Ag+" property must be a boolean when specified.");this.g=!!d;if("undefined"!==typeof c&&("string"!==
typeof c||"string"===typeof c&&!c.length))throw new N("argument-error",Bg+" property must be a non empty string when specified.");this.c=c||null}else{if("undefined"!==typeof b)throw new N("argument-error",zg+" property must be a non empty string when specified.");if("undefined"!==typeof d||"undefined"!==typeof c)throw new N("missing-android-pkg-name");}}else if("undefined"!==typeof c)throw new N("argument-error",yg+" property must be a non null object when specified.");this.b=null;if((b=a[Cg])&&"object"===
typeof b)if(b=b[Dg],"string"===typeof b&&b.length)this.b=b;else{if("undefined"!==typeof b)throw new N("argument-error",Dg+" property must be a non empty string when specified.");}else if("undefined"!==typeof b)throw new N("argument-error",Cg+" property must be a non null object when specified.");a=a[Eg];if("undefined"!==typeof a&&"boolean"!==typeof a)throw new N("argument-error",Eg+" property must be a boolean when specified.");if((this.f=!!a)&&!this.b&&!this.a)throw new N("argument-error",Eg+" property can't be true when no mobile application is provided.");
}var yg="android",Eg="handleCodeInApp",Cg="iOS",xg="url",Ag="installApp",Bg="minimumVersion",zg="packageName",Dg="bundleId";function Fg(a){var b={};b.continueUrl=a.h;b.canHandleCodeInApp=a.f;if(b.androidPackageName=a.a)b.androidMinimumVersion=a.c,b.androidInstallApp=a.g;b.iOSBundleId=a.b;for(var c in b)null===b[c]&&delete b[c];return b};function Gg(a){this.b=a.sub;na();this.a=a.provider_id||a.firebase&&a.firebase.sign_in_provider||null}function Hg(a){a=a.split(".");if(3!=a.length)return null;a=a[1];for(var b=(4-a.length%4)%4,c=0;c<b;c++)a+=".";try{var d=JSON.parse(Kd(a));if(d.sub&&d.iss&&d.aud&&d.exp)return new Gg(d)}catch(e){}return null};var Ig="oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version".split(" "),Jg=["client_id","response_type","scope","redirect_uri","state"],Kg={Hc:{Ma:"locale",za:500,ya:600,Na:"facebook.com",$a:Jg},Jc:{Ma:null,za:500,ya:620,Na:"github.com",$a:Jg},Kc:{Ma:"hl",za:515,ya:680,Na:"google.com",$a:Jg},Qc:{Ma:"lang",za:485,ya:705,Na:"twitter.com",$a:Ig}};function Lg(a){for(var b in Kg)if(Kg[b].Na==a)return Kg[b];return null};function Mg(a){var b={};b["facebook.com"]=Ng;b["google.com"]=Og;b["github.com"]=Pg;b["twitter.com"]=Qg;var c=a&&a[Rg];try{if(c)return b[c]?new b[c](a):new Sg(a);if("undefined"!==typeof a[Tg])return new Ug(a)}catch(d){}return null}var Tg="idToken",Rg="providerId";
function Ug(a){var b=a[Rg];if(!b&&a[Tg]){var c=Hg(a[Tg]);c&&c.a&&(b=c.a)}if(!b)throw Error("Invalid additional user info!");if("anonymous"==b||"custom"==b)b=null;c=!1;"undefined"!==typeof a.isNewUser?c=!!a.isNewUser:"identitytoolkit#SignupNewUserResponse"===a.kind&&(c=!0);M(this,"providerId",b);M(this,"isNewUser",c)}function Sg(a){Ug.call(this,a);a=Wf(a.rawUserInfo||"{}");M(this,"profile",kg(a||{}))}t(Sg,Ug);
function Ng(a){Sg.call(this,a);if("facebook.com"!=this.providerId)throw Error("Invalid provider ID!");}t(Ng,Sg);function Pg(a){Sg.call(this,a);if("github.com"!=this.providerId)throw Error("Invalid provider ID!");M(this,"username",this.profile&&this.profile.login||null)}t(Pg,Sg);function Og(a){Sg.call(this,a);if("google.com"!=this.providerId)throw Error("Invalid provider ID!");}t(Og,Sg);
function Qg(a){Sg.call(this,a);if("twitter.com"!=this.providerId)throw Error("Invalid provider ID!");M(this,"username",a.screenName||null)}t(Qg,Sg);function Vg(a,b){return a.then(function(a){if(a[O]){var c=Hg(a[O]);if(!c||b!=c.b)throw new N("user-mismatch");return a}throw new N("user-mismatch");}).s(function(a){throw a&&a.code&&a.code==tg+"user-not-found"?new N("user-mismatch"):a;})}
function Wg(a,b){if(b.idToken||b.accessToken)b.idToken&&M(this,"idToken",b.idToken),b.accessToken&&M(this,"accessToken",b.accessToken);else if(b.oauthToken&&b.oauthTokenSecret)M(this,"accessToken",b.oauthToken),M(this,"secret",b.oauthTokenSecret);else throw new N("internal-error","failed to construct a credential");M(this,"providerId",a)}Wg.prototype.wa=function(a){return Xg(a,Yg(this))};Wg.prototype.b=function(a,b){var c=Yg(this);c.idToken=b;return Zg(a,c)};
Wg.prototype.c=function(a,b){var c=Yg(this);return Vg($g(a,c),b)};function Yg(a){var b={};a.idToken&&(b.id_token=a.idToken);a.accessToken&&(b.access_token=a.accessToken);a.secret&&(b.oauth_token_secret=a.secret);b.providerId=a.providerId;return{postBody:Ie(b).toString(),requestUri:"http://localhost"}}
Wg.prototype.B=function(){var a={providerId:this.providerId};this.idToken&&(a.oauthIdToken=this.idToken);this.accessToken&&(a.oauthAccessToken=this.accessToken);this.secret&&(a.oauthTokenSecret=this.secret);return a};function ah(a,b){this.rc=b||[];gg(this,{providerId:a,isOAuthProvider:!0});this.rb={};this.Wa=(Lg(a)||{}).Ma||null;this.Ua=null}ah.prototype.Ba=function(a){this.rb=Ua(a);return this};function P(a){ah.call(this,a,Jg);this.a=[]}t(P,ah);
P.prototype.sa=function(a){Ha(this.a,a)||this.a.push(a);return this};P.prototype.wb=function(){return La(this.a)};P.prototype.credential=function(a,b){if(!a&&!b)throw new N("argument-error","credential failed: must provide the ID token and/or the access token.");return new Wg(this.providerId,{idToken:a||null,accessToken:b||null})};function bh(){P.call(this,"facebook.com")}t(bh,P);M(bh,"PROVIDER_ID","facebook.com");
function ch(a){if(!a)throw new N("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new bh).credential(null,b)}function dh(){P.call(this,"github.com")}t(dh,P);M(dh,"PROVIDER_ID","github.com");function eh(a){if(!a)throw new N("argument-error","credential failed: expected 1 argument (the OAuth access token).");var b=a;q(a)&&(b=a.accessToken);return(new dh).credential(null,b)}
function fh(){P.call(this,"google.com");this.sa("profile")}t(fh,P);M(fh,"PROVIDER_ID","google.com");function gh(a,b){var c=a;q(a)&&(c=a.idToken,b=a.accessToken);return(new fh).credential(c,b)}function hh(){ah.call(this,"twitter.com",Ig)}t(hh,ah);M(hh,"PROVIDER_ID","twitter.com");
function ih(a,b){var c=a;q(c)||(c={oauthToken:a,oauthTokenSecret:b});if(!c.oauthToken||!c.oauthTokenSecret)throw new N("argument-error","credential failed: expected 2 arguments (the OAuth access token and secret).");return new Wg("twitter.com",c)}function jh(a,b){this.a=a;this.f=b;M(this,"providerId","password")}jh.prototype.wa=function(a){return Q(a,kh,{email:this.a,password:this.f})};jh.prototype.b=function(a,b){return Q(a,lh,{idToken:b,email:this.a,password:this.f})};
jh.prototype.c=function(a,b){return Vg(this.wa(a),b)};jh.prototype.B=function(){return{email:this.a,password:this.f}};function mh(){gg(this,{providerId:"password",isOAuthProvider:!1})}gg(mh,{PROVIDER_ID:"password"});function nh(a){if(!(a.Pa&&a.Oa||a.Da&&a.Y))throw new N("internal-error");this.a=a;M(this,"providerId","phone")}nh.prototype.wa=function(a){return a.Qa(oh(this))};nh.prototype.b=function(a,b){var c=oh(this);c.idToken=b;return Q(a,ph,c)};
nh.prototype.c=function(a,b){var c=oh(this);c.operation="REAUTH";a=Q(a,qh,c);return Vg(a,b)};nh.prototype.B=function(){var a={providerId:"phone"};this.a.Pa&&(a.verificationId=this.a.Pa);this.a.Oa&&(a.verificationCode=this.a.Oa);this.a.Da&&(a.temporaryProof=this.a.Da);this.a.Y&&(a.phoneNumber=this.a.Y);return a};function oh(a){return a.a.Da&&a.a.Y?{temporaryProof:a.a.Da,phoneNumber:a.a.Y}:{sessionInfo:a.a.Pa,code:a.a.Oa}}
function rh(a){try{this.a=a||firebase.auth()}catch(b){throw new N("argument-error","Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().");}gg(this,{providerId:"phone",isOAuthProvider:!1})}
rh.prototype.Qa=function(a,b){var c=this.a.c;return A(b.verify()).then(function(d){if(!m(d))throw new N("argument-error","An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.");switch(b.type){case "recaptcha":return sh(c,{phoneNumber:a,recaptchaToken:d}).then(function(a){"function"===typeof b.reset&&b.reset();return a},function(a){"function"===typeof b.reset&&b.reset();throw a;});default:throw new N("argument-error",
'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');}})};function th(a,b){if(!a)throw new N("missing-verification-id");if(!b)throw new N("missing-verification-code");return new nh({Pa:a,Oa:b})}gg(rh,{PROVIDER_ID:"phone"});
function uh(a){if(a.temporaryProof&&a.phoneNumber)return new nh({Da:a.temporaryProof,Y:a.phoneNumber});var b=a&&a.providerId;if(!b||"password"===b)return null;var c=a&&a.oauthAccessToken,d=a&&a.oauthTokenSecret;a=a&&a.oauthIdToken;try{switch(b){case "google.com":return gh(a,c);case "facebook.com":return ch(c);case "github.com":return eh(c);case "twitter.com":return ih(c,d);default:return(new P(b)).credential(a,c)}}catch(e){return null}}
function vh(a){if(!a.isOAuthProvider)throw new N("invalid-oauth-provider");};function wh(a,b,c,d,e){this.b=a;this.c=b||null;this.f=c||null;this.g=d||null;this.a=e||null;if(this.f||this.a){if(this.f&&this.a)throw new N("invalid-auth-event");if(this.f&&!this.g)throw new N("invalid-auth-event");}else throw new N("invalid-auth-event");}wh.prototype.B=function(){return{type:this.b,eventId:this.c,urlResponse:this.f,sessionId:this.g,error:this.a&&this.a.B()}};function xh(a){a=a||{};return a.type?new wh(a.type,a.eventId,a.urlResponse,a.sessionId,a.error&&vg(a.error)):null};function yh(a){var b="unauthorized-domain",c=void 0,d=De(a);a=d.b;d=d.c;"chrome-extension"==d?c=oa("This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):"http"==d||"https"==d?c=oa("This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.",a):b="operation-not-supported-in-this-environment";
N.call(this,b,c)}t(yh,N);function zh(a,b,c){N.call(this,a,c);a=b||{};a.sb&&M(this,"email",a.sb);a.Y&&M(this,"phoneNumber",a.Y);a.credential&&M(this,"credential",a.credential)}t(zh,N);zh.prototype.B=function(){var a={code:this.code,message:this.message};this.email&&(a.email=this.email);this.phoneNumber&&(a.phoneNumber=this.phoneNumber);var b=this.credential&&this.credential.B();b&&Wa(a,b);return a};zh.prototype.toJSON=function(){return this.B()};
function Ah(a){if(a.code){var b=a.code||"";0==b.indexOf(tg)&&(b=b.substring(tg.length));var c={credential:uh(a)};if(a.email)c.sb=a.email;else if(a.phoneNumber)c.Y=a.phoneNumber;else return new N(b,a.message||void 0);return new zh(b,c,a.message)}return null};function Bh(a){this.f=a}t(Bh,Ne);Bh.prototype.a=function(){return new this.f};Bh.prototype.b=function(){return{}};
function Ch(a,b,c){var d="Node"==K();d=k.XMLHttpRequest||d&&firebase.INTERNAL.node&&firebase.INTERNAL.node.XMLHttpRequest;if(!d)throw new N("internal-error","The XMLHttpRequest compatibility library was not found.");this.b=a;a=b||{};this.i=a.secureTokenEndpoint||"https://securetoken.googleapis.com/v1/token";this.l=a.secureTokenTimeout||Dh;this.c=Ua(a.secureTokenHeaders||Eh);this.g=a.firebaseEndpoint||"https://www.googleapis.com/identitytoolkit/v3/relyingparty/";this.h=a.firebaseTimeout||Fh;this.a=
Ua(a.firebaseHeaders||Gh);c&&(this.a["X-Client-Version"]=c,this.c["X-Client-Version"]=c);this.f=new rf;this.o=new Bh(d)}var Hh,O="idToken",Dh=new $f(3E4,6E4),Eh={"Content-Type":"application/x-www-form-urlencoded"},Fh=new $f(3E4,6E4),Gh={"Content-Type":"application/json"};function Ih(a,b){b?a.a["X-Firebase-Locale"]=b:delete a.a["X-Firebase-Locale"]}function Jh(a,b){b?(a.a["X-Client-Version"]=b,a.c["X-Client-Version"]=b):(delete a.a["X-Client-Version"],delete a.c["X-Client-Version"])}
function Kh(a,b,c,d,e,f,g){Zf()?(yf()?a=r(a.m,a):(Hh||(Hh=new z(function(a,b){Lh(a,b)})),a=r(a.u,a)),a(b,c,d,e,f,g)):c&&c(null)}
Ch.prototype.m=function(a,b,c,d,e,f){var g="Node"==K(),l=Mf()?g?new Se(this.o):new Se:new Se(this.f);if(f){l.f=Math.max(0,f);var n=setTimeout(function(){G(l,"timeout")},f)}fd(l,"complete",function(){n&&clearTimeout(n);var a=null;try{a=JSON.parse(hf(this))||null}catch(vb){a=null}b&&b(a)});ld(l,"ready",function(){n&&clearTimeout(n);Lc(this)});ld(l,"timeout",function(){n&&clearTimeout(n);Lc(this);b&&b(null)});Ye(l,a,c,d,e)};
var Mh=dc("https://apis.google.com/js/client.js?onload=%{onload}"),Nh="__fcb"+Math.floor(1E6*Math.random()).toString();function Lh(a,b){if(((window.gapi||{}).client||{}).request)a();else{k[Nh]=function(){((window.gapi||{}).client||{}).request?a():b(Error("CORS_UNSUPPORTED"))};var c=hc(Mh,{onload:Nh});Td(kf(c),function(){b(Error("CORS_UNSUPPORTED"))})}}
Ch.prototype.u=function(a,b,c,d,e){var f=this;Hh.then(function(){window.gapi.client.setApiKey(f.b);var g=window.gapi.auth.getToken();window.gapi.auth.setToken(null);window.gapi.client.request({path:a,method:c,body:d,headers:e,authType:"none",callback:function(a){window.gapi.auth.setToken(g);b&&b(a)}})}).s(function(a){b&&b({error:{message:a&&a.message||"CORS_UNSUPPORTED"}})})};
function Oh(a,b){return new z(function(c,d){"refresh_token"==b.grant_type&&b.refresh_token||"authorization_code"==b.grant_type&&b.code?Kh(a,a.i+"?key="+encodeURIComponent(a.b),function(a){a?a.error?d(Ph(a)):a.access_token&&a.refresh_token?c(a):d(new N("internal-error")):d(new N("network-request-failed"))},"POST",Ie(b).toString(),a.c,a.l.get()):d(new N("internal-error"))})}
function Qh(a,b,c,d,e,f){var g=De(a.g+b);I(g,"key",a.b);f&&I(g,"cb",na().toString());var l="GET"==c;if(l)for(var n in d)d.hasOwnProperty(n)&&I(g,n,d[n]);return new z(function(b,f){Kh(a,g.toString(),function(a){a?a.error?f(Ph(a,e||{})):b(a):f(new N("network-request-failed"))},c,l?void 0:Cc(Vf(d)),a.a,a.h.get())})}function Rh(a){if(!jf.test(a.email))throw new N("invalid-email");}function Sh(a){"email"in a&&Rh(a)}
function Th(a,b){return Q(a,Uh,{identifier:b,continueUri:Sf()?vf():"http://localhost"}).then(function(a){return a.allProviders||[]})}function Vh(a){return Q(a,Wh,{}).then(function(a){return a.authorizedDomains||[]})}function Xh(a){if(!a[O])throw new N("internal-error");}
function Yh(a){if(a.phoneNumber||a.temporaryProof){if(!a.phoneNumber||!a.temporaryProof)throw new N("internal-error");}else{if(!a.sessionInfo)throw new N("missing-verification-id");if(!a.code)throw new N("missing-verification-code");}}Ch.prototype.gb=function(){return Q(this,Zh,{})};Ch.prototype.kb=function(a,b){return Q(this,$h,{idToken:a,email:b})};Ch.prototype.lb=function(a,b){return Q(this,lh,{idToken:a,password:b})};var ai={displayName:"DISPLAY_NAME",photoUrl:"PHOTO_URL"};h=Ch.prototype;
h.mb=function(a,b){var c={idToken:a},d=[];Pa(ai,function(a,f){var e=b[f];null===e?d.push(a):f in b&&(c[f]=e)});d.length&&(c.deleteAttribute=d);return Q(this,$h,c)};h.cb=function(a,b){a={requestType:"PASSWORD_RESET",email:a};Wa(a,b);return Q(this,bi,a)};h.bb=function(a,b){a={requestType:"VERIFY_EMAIL",idToken:a};Wa(a,b);return Q(this,ci,a)};function sh(a,b){return Q(a,di,b)}h.Qa=function(a){return Q(this,ei,a)};function fi(a,b,c){return Q(a,gi,{idToken:b,deleteProvider:c})}
function hi(a){if(!a.requestUri||!a.sessionId&&!a.postBody)throw new N("internal-error");}function ii(a){var b=null;a.needConfirmation?(a.code="account-exists-with-different-credential",b=Ah(a)):"FEDERATED_USER_ID_ALREADY_LINKED"==a.errorMessage?(a.code="credential-already-in-use",b=Ah(a)):"EMAIL_EXISTS"==a.errorMessage?(a.code="email-already-in-use",b=Ah(a)):a.errorMessage&&(b=ji(a.errorMessage));if(b)throw b;if(!a[O])throw new N("internal-error");}
function Xg(a,b){b.returnIdpCredential=!0;return Q(a,ki,b)}function Zg(a,b){b.returnIdpCredential=!0;return Q(a,li,b)}function $g(a,b){b.returnIdpCredential=!0;b.autoCreate=!1;return Q(a,mi,b)}function ni(a){if(!a.oobCode)throw new N("invalid-action-code");}h.Ta=function(a,b){return Q(this,oi,{oobCode:a,newPassword:b})};h.Ia=function(a){return Q(this,pi,{oobCode:a})};h.Sa=function(a){return Q(this,qi,{oobCode:a})};
var qi={endpoint:"setAccountInfo",D:ni,ga:"email"},pi={endpoint:"resetPassword",D:ni,O:function(a){if(!a.email||!a.requestType)throw new N("internal-error");}},ri={endpoint:"signupNewUser",D:function(a){Rh(a);if(!a.password)throw new N("weak-password");},O:Xh,T:!0},Uh={endpoint:"createAuthUri"},si={endpoint:"deleteAccount",ea:["idToken"]},gi={endpoint:"setAccountInfo",ea:["idToken","deleteProvider"],D:function(a){if(!fa(a.deleteProvider))throw new N("internal-error");}},ti={endpoint:"getAccountInfo"},
ci={endpoint:"getOobConfirmationCode",ea:["idToken","requestType"],D:function(a){if("VERIFY_EMAIL"!=a.requestType)throw new N("internal-error");},ga:"email"},bi={endpoint:"getOobConfirmationCode",ea:["requestType"],D:function(a){if("PASSWORD_RESET"!=a.requestType)throw new N("internal-error");Rh(a)},ga:"email"},Wh={nb:!0,endpoint:"getProjectConfig",zb:"GET"},ui={nb:!0,endpoint:"getRecaptchaParam",zb:"GET",O:function(a){if(!a.recaptchaSiteKey)throw new N("internal-error");}},oi={endpoint:"resetPassword",
D:ni,ga:"email"},di={endpoint:"sendVerificationCode",ea:["phoneNumber","recaptchaToken"],ga:"sessionInfo"},$h={endpoint:"setAccountInfo",ea:["idToken"],D:Sh,T:!0},lh={endpoint:"setAccountInfo",ea:["idToken"],D:function(a){Sh(a);if(!a.password)throw new N("weak-password");},O:Xh,T:!0},Zh={endpoint:"signupNewUser",O:Xh,T:!0},ki={endpoint:"verifyAssertion",D:hi,O:ii,T:!0},mi={endpoint:"verifyAssertion",D:hi,O:function(a){if(a.errorMessage&&"USER_NOT_FOUND"==a.errorMessage)throw new N("user-not-found");
if(a.errorMessage)throw ji(a.errorMessage);if(!a[O])throw new N("internal-error");},T:!0},li={endpoint:"verifyAssertion",D:function(a){hi(a);if(!a.idToken)throw new N("internal-error");},O:ii,T:!0},vi={endpoint:"verifyCustomToken",D:function(a){if(!a.token)throw new N("invalid-custom-token");},O:Xh,T:!0},kh={endpoint:"verifyPassword",D:function(a){Rh(a);if(!a.password)throw new N("wrong-password");},O:Xh,T:!0},ei={endpoint:"verifyPhoneNumber",D:Yh,O:Xh},ph={endpoint:"verifyPhoneNumber",D:function(a){if(!a.idToken)throw new N("internal-error");
Yh(a)},O:function(a){if(a.temporaryProof)throw a.code="credential-already-in-use",Ah(a);Xh(a)}},qh={Pb:{USER_NOT_FOUND:"user-not-found"},endpoint:"verifyPhoneNumber",D:Yh,O:Xh};
function Q(a,b,c){if(!jg(c,b.ea))return B(new N("internal-error"));var d=b.zb||"POST",e;return A(c).then(b.D).then(function(){b.T&&(c.returnSecureToken=!0);return Qh(a,b.endpoint,d,c,b.Pb,b.nb||!1)}).then(function(a){return e=a}).then(b.O).then(function(){if(!b.ga)return e;if(!(b.ga in e))throw new N("internal-error");return e[b.ga]})}function ji(a){return Ph({error:{errors:[{message:a}],code:400,message:a}})}
function Ph(a,b){var c=(a.error&&a.error.errors&&a.error.errors[0]||{}).reason||"";var d={keyInvalid:"invalid-api-key",ipRefererBlocked:"app-not-authorized"};if(c=d[c]?new N(d[c]):null)return c;c=a.error&&a.error.message||"";d={INVALID_CUSTOM_TOKEN:"invalid-custom-token",CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_EMAIL:"invalid-email",INVALID_PASSWORD:"wrong-password",USER_DISABLED:"user-disabled",
MISSING_PASSWORD:"internal-error",EMAIL_EXISTS:"email-already-in-use",PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",INVALID_MESSAGE_PAYLOAD:"invalid-message-payload",INVALID_RECIPIENT_EMAIL:"invalid-recipient-email",INVALID_SENDER:"invalid-sender",EMAIL_NOT_FOUND:"user-not-found",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",
INVALID_ID_TOKEN:"invalid-user-token",TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",CORS_UNSUPPORTED:"cors-unsupported",DYNAMIC_LINK_NOT_ACTIVATED:"dynamic-link-not-activated",INVALID_APP_ID:"invalid-app-id",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",WEAK_PASSWORD:"weak-password",OPERATION_NOT_ALLOWED:"operation-not-allowed",USER_CANCELLED:"user-cancelled",CAPTCHA_CHECK_FAILED:"captcha-check-failed",INVALID_APP_CREDENTIAL:"invalid-app-credential",INVALID_CODE:"invalid-verification-code",
INVALID_PHONE_NUMBER:"invalid-phone-number",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_APP_CREDENTIAL:"missing-app-credential",MISSING_CODE:"missing-verification-code",MISSING_PHONE_NUMBER:"missing-phone-number",MISSING_SESSION_INFO:"missing-verification-id",QUOTA_EXCEEDED:"quota-exceeded",SESSION_EXPIRED:"code-expired",INVALID_CONTINUE_URI:"invalid-continue-uri",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",MISSING_IOS_BUNDLE_ID:"missing-ios-bundle-id",
UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",INVALID_CERT_HASH:"invalid-cert-hash"};Wa(d,b||{});b=(b=c.match(/^[^\s]+\s*:\s*(.*)$/))&&1<b.length?b[1]:void 0;for(var e in d)if(0===c.indexOf(e))return new N(d[e],b);!b&&a&&(b=Uf(a));return new N("internal-error",b)};var wi={Mc:{Va:"https://www.googleapis.com/identitytoolkit/v3/relyingparty/",ab:"https://securetoken.googleapis.com/v1/token",id:"p"},Oc:{Va:"https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/",ab:"https://staging-securetoken.sandbox.googleapis.com/v1/token",id:"s"},Pc:{Va:"https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/",ab:"https://test-securetoken.sandbox.googleapis.com/v1/token",id:"t"}};
function xi(a){for(var b in wi)if(wi[b].id===a)return a=wi[b],{firebaseEndpoint:a.Va,secureTokenEndpoint:a.ab};return null}var yi;yi=xi("__EID__")?"__EID__":void 0;function zi(a){this.b=a;this.a=null;this.Ya=Ai(this)}
function Ai(a){return Bi().then(function(){return new z(function(b,c){L("gapi.iframes.getContext")().open({where:document.body,url:a.b,messageHandlersFilter:L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"),attributes:{style:{position:"absolute",top:"-100px",width:"1px",height:"1px"}},dontclear:!0},function(d){function e(){clearTimeout(f);b()}a.a=d;a.a.restyle({setHideOnLeave:!1});var f=setTimeout(function(){c(Error("Network Error"))},Ci.get());d.ping(e).then(e,function(){c(Error("Network Error"))})})})})}
function Di(a,b){return a.Ya.then(function(){return new z(function(c){a.a.send(b.type,b,c,L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})})}function Ei(a,b){a.Ya.then(function(){a.a.register("authEvent",b,L("gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER"))})}var Fi=dc("https://apis.google.com/js/api.js?onload=%{onload}"),Gi=new $f(3E4,6E4),Ci=new $f(5E3,15E3),Hi=null;
function Bi(){return Hi?Hi:Hi=(new z(function(a,b){if(Zf()){var c=function(){Yf();L("gapi.load")("gapi.iframes",{callback:a,ontimeout:function(){Yf();b(Error("Network Error"))},timeout:Gi.get()})};if(L("gapi.iframes.Iframe"))a();else if(L("gapi.load"))c();else{var d="__iframefcb"+Math.floor(1E6*Math.random()).toString();k[d]=function(){L("gapi.load")?c():b(Error("Network Error"))};d=hc(Fi,{onload:d});A(kf(d)).s(function(){b(Error("Network Error"))})}}else b(Error("Network Error"))})).s(function(a){Hi=
null;throw a;})};function Ii(a,b,c){this.i=a;this.g=b;this.h=c;this.f=null;this.a=Ee(this.i,"/__/auth/iframe");I(this.a,"apiKey",this.g);I(this.a,"appName",this.h);this.b=null;this.c=[]}Ii.prototype.toString=function(){this.f?I(this.a,"v",this.f):Le(this.a.a,"v");this.b?I(this.a,"eid",this.b):Le(this.a.a,"eid");this.c.length?I(this.a,"fw",this.c.join(",")):Le(this.a.a,"fw");return this.a.toString()};function Ji(a,b,c,d,e){this.m=a;this.u=b;this.c=c;this.l=d;this.i=this.g=this.h=null;this.a=e;this.f=null}
Ji.prototype.toString=function(){var a=Ee(this.m,"/__/auth/handler");I(a,"apiKey",this.u);I(a,"appName",this.c);I(a,"authType",this.l);if(this.a.isOAuthProvider){var b=this.a;try{var c=firebase.app(this.c).auth().$()}catch(l){c=null}b.Ua=c;I(a,"providerId",this.a.providerId);b=this.a;c=Vf(b.rb);for(var d in c)c[d]=c[d].toString();d=b.rc;c=Ua(c);for(var e=0;e<d.length;e++){var f=d[e];f in c&&delete c[f]}b.Wa&&b.Ua&&!c[b.Wa]&&(c[b.Wa]=b.Ua);Sa(c)||I(a,"customParameters",Uf(c))}"function"===typeof this.a.wb&&
(b=this.a.wb(),b.length&&I(a,"scopes",b.join(",")));this.h?I(a,"redirectUrl",this.h):Le(a.a,"redirectUrl");this.g?I(a,"eventId",this.g):Le(a.a,"eventId");this.i?I(a,"v",this.i):Le(a.a,"v");if(this.b)for(var g in this.b)this.b.hasOwnProperty(g)&&!Ce(a,g)&&I(a,g,this.b[g]);this.f?I(a,"eid",this.f):Le(a.a,"eid");g=Ki(this.c);g.length&&I(a,"fw",g.join(","));return a.toString()};function Ki(a){try{return firebase.app(a).auth().Ka()}catch(b){return[]}}
function Li(a,b,c,d,e){this.u=a;this.f=b;this.b=c;this.c=d||null;this.h=e||null;this.m=this.o=this.v=null;this.g=[];this.l=this.a=null}
function Mi(a){var b=vf();return Vh(a).then(function(a){a:{var c=De(b),e=c.c;c=c.b;for(var f=0;f<a.length;f++){var g=a[f];var l=c;var n=e;0==g.indexOf("chrome-extension://")?l=De(g).b==l&&"chrome-extension"==n:"http"!=n&&"https"!=n?l=!1:Gf.test(g)?l=l==g:(g=g.split(".").join("\\."),l=(new RegExp("^(.+\\."+g+"|"+g+")$","i")).test(l));if(l){a=!0;break a}}a=!1}if(!a)throw new yh(vf());})}
function Ni(a){if(a.l)return a.l;a.l=Hf().then(function(){if(!a.o){var b=a.c,c=a.h,d=Ki(a.b),e=new Ii(a.u,a.f,a.b);e.f=b;e.b=c;e.c=La(d||[]);a.o=e.toString()}a.i=new zi(a.o);Oi(a)});return a.l}h=Li.prototype;h.Ca=function(a,b,c){var d=new N("popup-closed-by-user"),e=new N("web-storage-unsupported"),f=this,g=!1;return this.ba().then(function(){Pi(f).then(function(c){c||(a&&Cf(a),b(e),g=!0)})}).s(function(){}).then(function(){if(!g)return Ff(a)}).then(function(){if(!g)return sd(c).then(function(){b(d)})})};
h.Db=function(){var a=J();return!Tf(a)&&!Xf(a)};h.yb=function(){return!1};
h.vb=function(a,b,c,d,e,f,g){if(!a)return B(new N("popup-blocked"));if(g&&!Tf())return this.ba().s(function(b){Cf(a);e(b)}),d(),A();this.a||(this.a=Mi(Qi(this)));var l=this;return this.a.then(function(){var b=l.ba().s(function(b){Cf(a);e(b);throw b;});d();return b}).then(function(){vh(c);if(!g){var d=Ri(l.u,l.f,l.b,b,c,null,f,l.c,void 0,l.h);wf(d,a)}}).s(function(a){"auth/network-request-failed"==a.code&&(l.a=null);throw a;})};
function Qi(a){a.m||(a.v=a.c?Of(a.c,Ki(a.b)):null,a.m=new Ch(a.f,xi(a.h),a.v));return a.m}h.Aa=function(a,b,c){this.a||(this.a=Mi(Qi(this)));var d=this;return this.a.then(function(){vh(b);var e=Ri(d.u,d.f,d.b,a,b,vf(),c,d.c,void 0,d.h);wf(e)}).s(function(a){"auth/network-request-failed"==a.code&&(d.a=null);throw a;})};h.ba=function(){var a=this;return Ni(this).then(function(){return a.i.Ya}).s(function(){a.a=null;throw new N("network-request-failed");})};h.Hb=function(){return!0};
function Ri(a,b,c,d,e,f,g,l,n,D){a=new Ji(a,b,c,d,e);a.h=f;a.g=g;a.i=l;a.b=Ua(n||null);a.f=D;return a.toString()}function Oi(a){if(!a.i)throw Error("IfcHandler must be initialized!");Ei(a.i,function(b){var c={};if(b&&b.authEvent){var d=!1;b=xh(b.authEvent);for(c=0;c<a.g.length;c++)d=a.g[c](b)||d;c={};c.status=d?"ACK":"ERROR";return A(c)}c.status="ERROR";return A(c)})}
function Pi(a){var b={type:"webStorageSupport"};return Ni(a).then(function(){return Di(a.i,b)}).then(function(a){if(a&&a.length&&"undefined"!==typeof a[0].webStorageSupport)return a[0].webStorageSupport;throw Error();})}h.ua=function(a){this.g.push(a)};h.Ja=function(a){Ja(this.g,function(b){return b==a})};function Si(a){this.a=a||firebase.INTERNAL.reactNative&&firebase.INTERNAL.reactNative.AsyncStorage;if(!this.a)throw new N("internal-error","The React Native compatibility library was not found.");}h=Si.prototype;h.get=function(a){return A(this.a.getItem(a)).then(function(a){return a&&Wf(a)})};h.set=function(a,b){return A(this.a.setItem(a,Uf(b)))};h.X=function(a){return A(this.a.removeItem(a))};h.ia=function(){};h.da=function(){};function Ti(){this.a={}}h=Ti.prototype;h.get=function(a){return A(this.a[a])};h.set=function(a,b){this.a[a]=b;return A()};h.X=function(a){delete this.a[a];return A()};h.ia=function(){};h.da=function(){};function Ui(a,b,c,d,e,f){try{var g=!!k.indexedDB}catch(l){g=!1}if(!g)throw new N("web-storage-unsupported");this.u=a;this.h=b;this.g=c;this.l=d;this.m=e;this.f={};this.c=[];this.a=0;this.o=f||k.indexedDB}var Vi;function Wi(a){return new z(function(b,c){var d=a.o.open(a.u,a.m);d.onerror=function(a){c(Error(a.target.errorCode))};d.onupgradeneeded=function(b){b=b.target.result;try{b.createObjectStore(a.h,{keyPath:a.g})}catch(f){c(f)}};d.onsuccess=function(a){b(a.target.result)}})}
function Xi(a){a.i||(a.i=Wi(a));return a.i}function Yi(a,b){return b.objectStore(a.h)}function Zi(a,b,c){return b.transaction([a.h],c?"readwrite":"readonly")}function $i(a){return new z(function(b,c){a.onsuccess=function(a){a&&a.target?b(a.target.result):b()};a.onerror=function(a){c(Error(a.target.errorCode))}})}h=Ui.prototype;
h.set=function(a,b){var c=!1,d,e=this;return Qb(Xi(this).then(function(b){d=b;b=Yi(e,Zi(e,d,!0));return $i(b.get(a))}).then(function(f){var g=Yi(e,Zi(e,d,!0));if(f)return f.value=b,$i(g.put(f));e.a++;c=!0;f={};f[e.g]=a;f[e.l]=b;return $i(g.add(f))}).then(function(){e.f[a]=b}),function(){c&&e.a--})};h.get=function(a){var b=this;return Xi(this).then(function(c){return $i(Yi(b,Zi(b,c,!1)).get(a))}).then(function(a){return a&&a.value})};
h.X=function(a){var b=!1,c=this;return Qb(Xi(this).then(function(d){b=!0;c.a++;return $i(Yi(c,Zi(c,d,!0))["delete"](a))}).then(function(){delete c.f[a]}),function(){b&&c.a--})};
h.zc=function(){var a=this;return Xi(this).then(function(b){var c=Yi(a,Zi(a,b,!1));return c.getAll?$i(c.getAll()):new z(function(a,b){var d=[],e=c.openCursor();e.onsuccess=function(b){(b=b.target.result)?(d.push(b.value),b["continue"]()):a(d)};e.onerror=function(a){b(Error(a.target.errorCode))}})}).then(function(b){var c={},d=[];if(0==a.a){for(d=0;d<b.length;d++)c[b[d][a.g]]=b[d][a.l];d=xf(a.f,c);a.f=c}return d})};h.ia=function(a){0==this.c.length&&aj(this);this.c.push(a)};
h.da=function(a){Ja(this.c,function(b){return b==a});0==this.c.length&&this.b&&this.b.cancel("STOP_EVENT")};function aj(a){function b(){a.b=sd(800).then(r(a.zc,a)).then(function(b){0<b.length&&w(a.c,function(a){a(b)})}).then(b).s(function(a){"STOP_EVENT"!=a.message&&b()});return a.b}a.b&&a.b.cancel("STOP_EVENT");b()};function bj(){if(!cj()){if("Node"==K())throw new N("internal-error","The LocalStorage compatibility library was not found.");throw new N("web-storage-unsupported");}this.a=dj()||firebase.INTERNAL.node.localStorage}function dj(){try{var a=k.localStorage,b=Qf();a&&(a.setItem(b,"1"),a.removeItem(b));return a}catch(c){return null}}
function cj(){var a="Node"==K();a=dj()||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.localStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}}h=bj.prototype;h.get=function(a){var b=this;return A().then(function(){var c=b.a.getItem(a);return Wf(c)})};h.set=function(a,b){var c=this;return A().then(function(){var d=Uf(b);null===d?c.X(a):c.a.setItem(a,d)})};h.X=function(a){var b=this;return A().then(function(){b.a.removeItem(a)})};
h.ia=function(a){k.window&&cd(k.window,"storage",a)};h.da=function(a){k.window&&E(k.window,"storage",a)};function ej(){}h=ej.prototype;h.get=function(){return A(null)};h.set=function(){return A()};h.X=function(){return A()};h.ia=function(){};h.da=function(){};function fj(){if(!gj()){if("Node"==K())throw new N("internal-error","The SessionStorage compatibility library was not found.");throw new N("web-storage-unsupported");}this.a=hj()||firebase.INTERNAL.node.sessionStorage}function hj(){try{var a=k.sessionStorage,b=Qf();a&&(a.setItem(b,"1"),a.removeItem(b));return a}catch(c){return null}}
function gj(){var a="Node"==K();a=hj()||a&&firebase.INTERNAL.node&&firebase.INTERNAL.node.sessionStorage;if(!a)return!1;try{return a.setItem("__sak","1"),a.removeItem("__sak"),!0}catch(b){return!1}}h=fj.prototype;h.get=function(a){var b=this;return A().then(function(){var c=b.a.getItem(a);return Wf(c)})};h.set=function(a,b){var c=this;return A().then(function(){var d=Uf(b);null===d?c.X(a):c.a.setItem(a,d)})};h.X=function(a){var b=this;return A().then(function(){b.a.removeItem(a)})};h.ia=function(){};
h.da=function(){};function ij(){var a={};a.Browser=jj;a.Node=kj;a.ReactNative=lj;this.a=a[K()]}var mj,jj={C:bj,jb:fj},kj={C:bj,jb:fj},lj={C:Si,jb:ej};var nj={Lc:"local",NONE:"none",Nc:"session"};function oj(a){var b=new N("invalid-persistence-type"),c=new N("unsupported-persistence-type");a:{for(d in nj)if(nj[d]==a){var d=!0;break a}d=!1}if(!d||"string"!==typeof a)throw b;switch(K()){case "ReactNative":if("session"===a)throw c;break;case "Node":if("none"!==a)throw c;break;default:if(!Pf()&&"none"!==a)throw c;}}
function pj(a,b,c,d,e){this.i=a;this.g=b;this.A=c;this.u=d;this.v=e;this.a={};mj||(mj=new ij);a=mj;try{if(uf()){Vi||(Vi=new Ui("firebaseLocalStorageDb","firebaseLocalStorage","fbase_key","value",1));var f=Vi}else f=new a.a.C;this.l=f}catch(g){this.l=new Ti,this.u=!0}try{this.o=new a.a.jb}catch(g){this.o=new Ti}this.w=new Ti;this.h=r(this.m,this);this.b={}}var qj;function rj(){qj||(qj=new pj("firebase",":",!Xf(J())&&Lf()?!0:!1,Tf(),Pf()));return qj}
function sj(a,b){switch(b){case "session":return a.o;case "none":return a.w;default:return a.l}}function tj(a,b,c){return a.i+a.g+b.name+(c?a.g+c:"")}pj.prototype.get=function(a,b){return sj(this,a.C).get(tj(this,a,b))};function uj(a,b,c){c=tj(a,b,c);"local"==b.C&&(a.b[c]=null);return sj(a,b.C).X(c)}pj.prototype.set=function(a,b,c){var d=tj(this,a,c),e=this,f=sj(this,a.C);return f.set(d,b).then(function(){return f.get(d)}).then(function(b){"local"==a.C&&(e.b[d]=b)})};
function vj(a,b,c,d){b=tj(a,b,c);a.v&&(a.b[b]=k.localStorage.getItem(b));Sa(a.a)&&(sj(a,"local").ia(a.h),a.u||uf()||!a.v||wj(a));a.a[b]||(a.a[b]=[]);a.a[b].push(d)}function xj(a,b,c){b=tj(a,yj("local"),b);a.a[b]&&(Ja(a.a[b],function(a){return a==c}),0==a.a[b].length&&delete a.a[b]);Sa(a.a)&&zj(a)}
function wj(a){Aj(a);a.f=setInterval(function(){for(var b in a.a){var c=k.localStorage.getItem(b),d=a.b[b];c!=d&&(a.b[b]=c,c=new Qc({type:"storage",key:b,target:window,oldValue:d,newValue:c,a:!0}),a.m(c))}},1E3)}function Aj(a){a.f&&(clearInterval(a.f),a.f=null)}function zj(a){sj(a,"local").da(a.h);Aj(a)}
pj.prototype.m=function(a){if(a&&a.g){var b=a.a.key;if(null==b)for(var c in this.a){var d=this.b[c];"undefined"===typeof d&&(d=null);var e=k.localStorage.getItem(c);e!==d&&(this.b[c]=e,this.c(c))}else if(0==b.indexOf(this.i+this.g)&&this.a[b]){"undefined"!==typeof a.a.a?sj(this,"local").da(this.h):Aj(this);if(this.A)if(c=k.localStorage.getItem(b),d=a.a.newValue,d!==c)null!==d?k.localStorage.setItem(b,d):k.localStorage.removeItem(b);else if(this.b[b]===d&&"undefined"===typeof a.a.a)return;var f=this;
c=function(){if("undefined"!==typeof a.a.a||f.b[b]!==k.localStorage.getItem(b))f.b[b]=k.localStorage.getItem(b),f.c(b)};y&&kb&&10==kb&&k.localStorage.getItem(b)!==a.a.newValue&&a.a.newValue!==a.a.oldValue?setTimeout(c,10):c()}}else w(a,r(this.c,this))};pj.prototype.c=function(a){this.a[a]&&w(this.a[a],function(a){a()})};function Cj(a){this.a=a;this.b=rj()}var Dj={name:"authEvent",C:"local"};function Ej(a){return a.b.get(Dj,a.a).then(function(a){return xh(a)})};function Fj(){this.a=rj()};function Gj(a,b,c,d,e,f,g){this.u=a;this.i=b;this.l=c;this.m=d||null;this.o=g||null;this.h=b+":"+c;this.A=new Fj;this.g=new Cj(this.h);this.f=null;this.b=[];this.v=e||500;this.w=f||2E3;this.a=this.c=null}function Hj(a){return new N("invalid-cordova-configuration",a)}h=Gj.prototype;
h.ba=function(){return this.xa?this.xa:this.xa=If().then(function(){if("function"!==typeof L("universalLinks.subscribe",k))throw Hj("cordova-universal-links-plugin is not installed");if("undefined"===typeof L("BuildInfo.packageName",k))throw Hj("cordova-plugin-buildinfo is not installed");if("function"!==typeof L("cordova.plugins.browsertab.openUrl",k))throw Hj("cordova-plugin-browsertab is not installed");if("function"!==typeof L("cordova.InAppBrowser.open",k))throw Hj("cordova-plugin-inappbrowser is not installed");
},function(){throw new N("cordova-not-ready");})};function Ij(){for(var a=20,b=[];0<a;)b.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62*Math.random()))),a--;return b.join("")}function Jj(a){var b=new ie;he(b,a);a=[];var c=8*b.g;56>b.c?he(b,fe,56-b.c):he(b,fe,b.b-(b.c-56));for(var d=63;56<=d;d--)b.f[d]=c&255,c/=256;ge(b);for(d=c=0;d<b.i;d++)for(var e=24;0<=e;e-=8)a[c++]=b.a[d]>>e&255;return Hd(a)}
h.Ca=function(a,b){b(new N("operation-not-supported-in-this-environment"));return A()};h.vb=function(){return B(new N("operation-not-supported-in-this-environment"))};h.Hb=function(){return!1};h.Db=function(){return!0};h.yb=function(){return!0};
h.Aa=function(a,b,c){if(this.c)return B(new N("redirect-operation-pending"));var d=this,e=k.document,f=null,g=null,l=null,n=null;return this.c=Qb(A().then(function(){vh(b);return Kj(d)}).then(function(){return Lj(d,a,b,c)}).then(function(){return(new z(function(a,b){g=function(){var b=L("cordova.plugins.browsertab.close",k);a();"function"===typeof b&&b();d.a&&"function"===typeof d.a.close&&(d.a.close(),d.a=null);return!1};d.ua(g);l=function(){f||(f=sd(d.w).then(function(){b(new N("redirect-cancelled-by-user"))}))};
n=function(){ag()&&l()};e.addEventListener("resume",l,!1);J().toLowerCase().match(/android/)||e.addEventListener("visibilitychange",n,!1)})).s(function(a){return Mj(d).then(function(){throw a;})})}),function(){l&&e.removeEventListener("resume",l,!1);n&&e.removeEventListener("visibilitychange",n,!1);f&&f.cancel();g&&d.Ja(g);d.c=null})};
function Lj(a,b,c,d){var e=Ij(),f=new wh(b,d,null,e,new N("no-auth-event")),g=L("BuildInfo.packageName",k);if("string"!==typeof g)throw new N("invalid-cordova-configuration");var l=L("BuildInfo.displayName",k),n={};if(J().toLowerCase().match(/iphone|ipad|ipod/))n.ibi=g;else if(J().toLowerCase().match(/android/))n.apn=g;else return B(new N("operation-not-supported-in-this-environment"));l&&(n.appDisplayName=l);e=Jj(e);n.sessionId=e;var D=Ri(a.u,a.i,a.l,b,c,null,d,a.m,n,a.o);return a.ba().then(function(){var b=
a.h;return a.A.a.set(Dj,f.B(),b)}).then(function(){var b=L("cordova.plugins.browsertab.isAvailable",k);if("function"!==typeof b)throw new N("invalid-cordova-configuration");var c=null;b(function(b){if(b){c=L("cordova.plugins.browsertab.openUrl",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");c(D)}else{c=L("cordova.InAppBrowser.open",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");b=J();b=!(!b.match(/(iPad|iPhone|iPod).*OS 7_\d/i)&&!b.match(/(iPad|iPhone|iPod).*OS 8_\d/i));
a.a=c(D,b?"_blank":"_system","location=yes")}})})}function Nj(a,b){for(var c=0;c<a.b.length;c++)try{a.b[c](b)}catch(d){}}function Kj(a){a.f||(a.f=a.ba().then(function(){return new z(function(b){function c(d){b(d);a.Ja(c);return!1}a.ua(c);Oj(a)})}));return a.f}function Mj(a){var b=null;return Ej(a.g).then(function(c){b=c;c=a.g;return uj(c.b,Dj,c.a)}).then(function(){return b})}
function Oj(a){function b(b){e=!0;f&&f.cancel();Mj(a).then(function(c){var e=d;if(c&&b&&b.url){e=null;var f=b.url;var g=De(f),l=Ce(g,"link"),n=Ce(De(l),"link");g=Ce(g,"deep_link_id");f=Ce(De(g),"link")||g||n||l||f;-1!=f.indexOf("/__/auth/callback")&&(e=De(f),e=Wf(Ce(e,"firebaseError")||null),e=(e="object"===typeof e?vg(e):null)?new wh(c.b,c.c,null,null,e):new wh(c.b,c.c,f,c.g));e=e||d}Nj(a,e)})}var c=L("universalLinks.subscribe",k);if("function"!==typeof c)throw new N("invalid-cordova-configuration");
var d=new wh("unknown",null,null,null,new N("no-auth-event")),e=!1,f=sd(a.v).then(function(){return Mj(a).then(function(){e||Nj(a,d)})}),g=k.handleOpenURL;k.handleOpenURL=function(a){0==a.toLowerCase().indexOf(L("BuildInfo.packageName",k).toLowerCase()+"://")&&b({url:a});if("function"===typeof g)try{g(a)}catch(n){console.error(n)}};c(null,b)}
h.ua=function(a){this.b.push(a);Kj(this).s(function(b){"auth/invalid-cordova-configuration"===b.code&&(b=new wh("unknown",null,null,null,new N("no-auth-event")),a(b))})};h.Ja=function(a){Ja(this.b,function(b){return b==a})};function Pj(a){this.a=a;this.b=rj()}var Qj={name:"pendingRedirect",C:"session"};function Rj(a){return a.b.set(Qj,"pending",a.a)}function Sj(a){return uj(a.b,Qj,a.a)}function Tj(a){return a.b.get(Qj,a.a).then(function(a){return"pending"==a})};function Uj(a,b,c){this.v=a;this.l=b;this.u=c;this.h=[];this.f=!1;this.i=r(this.m,this);this.c=new Vj;this.o=new Wj;this.g=new Pj(this.l+":"+this.u);this.b={};this.b.unknown=this.c;this.b.signInViaRedirect=this.c;this.b.linkViaRedirect=this.c;this.b.reauthViaRedirect=this.c;this.b.signInViaPopup=this.o;this.b.linkViaPopup=this.o;this.b.reauthViaPopup=this.o;this.a=Xj(this.v,this.l,this.u,yi)}
function Xj(a,b,c,d){var e=firebase.SDK_VERSION||null;return Jf()?new Gj(a,b,c,e,void 0,void 0,d):new Li(a,b,c,e,d)}Uj.prototype.reset=function(){this.f=!1;this.a.Ja(this.i);this.a=Xj(this.v,this.l,this.u)};function Yj(a){a.f||(a.f=!0,a.a.ua(a.i));var b=a.a;return a.a.ba().s(function(c){a.a==b&&a.reset();throw c;})}function Zj(a){a.a.Db()&&Yj(a).s(function(b){var c=new wh("unknown",null,null,null,new N("operation-not-supported-in-this-environment"));ak(b)&&a.m(c)});a.a.yb()||bk(a.c)}
Uj.prototype.subscribe=function(a){Ha(this.h,a)||this.h.push(a);if(!this.f){var b=this;Tj(this.g).then(function(a){a?Sj(b.g).then(function(){Yj(b).s(function(a){var c=new wh("unknown",null,null,null,new N("operation-not-supported-in-this-environment"));ak(a)&&b.m(c)})}):Zj(b)}).s(function(){Zj(b)})}};Uj.prototype.unsubscribe=function(a){Ja(this.h,function(b){return b==a})};
Uj.prototype.m=function(a){if(!a)throw new N("invalid-auth-event");for(var b=!1,c=0;c<this.h.length;c++){var d=this.h[c];if(d.ob(a.b,a.c)){(b=this.b[a.b])&&b.h(a,d);b=!0;break}}bk(this.c);return b};var ck=new $f(2E3,1E4),dk=new $f(3E4,6E4);Uj.prototype.aa=function(){return this.c.aa()};function ek(a,b,c,d,e,f){return a.a.vb(b,c,d,function(){a.f||(a.f=!0,a.a.ua(a.i))},function(){a.reset()},e,f)}function ak(a){return a&&"auth/cordova-not-ready"==a.code?!0:!1}
Uj.prototype.Aa=function(a,b,c){var d=this,e;return Rj(this.g).then(function(){return d.a.Aa(a,b,c).s(function(a){if(ak(a))throw new N("operation-not-supported-in-this-environment");e=a;return Sj(d.g).then(function(){throw e;})}).then(function(){return d.a.Hb()?new z(function(){}):Sj(d.g).then(function(){return d.aa()}).then(function(){}).s(function(){})})})};Uj.prototype.Ca=function(a,b,c,d){return this.a.Ca(c,function(c){a.fa(b,null,c,d)},ck.get())};var fk={};
function gk(a,b,c){var d=b+":"+c;fk[d]||(fk[d]=new Uj(a,b,c));return fk[d]}function Vj(){this.b=null;this.f=[];this.c=[];this.a=null;this.g=!1}Vj.prototype.reset=function(){this.b=null;this.a&&(this.a.cancel(),this.a=null)};
Vj.prototype.h=function(a,b){if(!a)return B(new N("invalid-auth-event"));this.reset();this.g=!0;var c=a.b,d=a.c,e=a.a&&"auth/web-storage-unsupported"==a.a.code,f=a.a&&"auth/operation-not-supported-in-this-environment"==a.a.code;"unknown"!=c||e||f?a.a?(hk(this,!0,null,a.a),a=A()):a=b.va(c,d)?ik(this,a,b):B(new N("invalid-auth-event")):(hk(this,!1,null,null),a=A());return a};function bk(a){a.g||(a.g=!0,hk(a,!1,null,null))}
function ik(a,b,c){c=c.va(b.b,b.c);var d=b.f,e=b.g,f=!!b.b.match(/Redirect$/);return c(d,e).then(function(b){hk(a,f,b,null)}).s(function(b){hk(a,f,null,b)})}function jk(a,b){a.b=function(){return B(b)};if(a.c.length)for(var c=0;c<a.c.length;c++)a.c[c](b)}function kk(a,b){a.b=function(){return A(b)};if(a.f.length)for(var c=0;c<a.f.length;c++)a.f[c](b)}function hk(a,b,c,d){b?d?jk(a,d):kk(a,c):kk(a,{user:null});a.f=[];a.c=[]}
Vj.prototype.aa=function(){var a=this;return new z(function(b,c){a.b?a.b().then(b,c):(a.f.push(b),a.c.push(c),lk(a))})};function lk(a){var b=new N("timeout");a.a&&a.a.cancel();a.a=sd(dk.get()).then(function(){a.b||hk(a,!0,null,b)})}function Wj(){}Wj.prototype.h=function(a,b){if(!a)return B(new N("invalid-auth-event"));var c=a.b,d=a.c;a.a?(b.fa(a.b,null,a.a,a.c),a=A()):a=b.va(c,d)?mk(a,b):B(new N("invalid-auth-event"));return a};
function mk(a,b){var c=a.c,d=a.b;return b.va(d,c)(a.f,a.g).then(function(a){b.fa(d,a,null,c)}).s(function(a){b.fa(d,null,a,c)})};function nk(a,b){this.a=b;M(this,"verificationId",a)}nk.prototype.confirm=function(a){a=th(this.verificationId,a);return this.a(a)};function ok(a,b,c,d){return(new rh(a)).Qa(b,c).then(function(a){return new nk(a,d)})};function pk(a,b,c,d,e,f){this.h=a;this.i=b;this.g=c;this.c=d;this.f=e;this.l=!!f;this.b=null;this.a=this.c;if(this.f<this.c)throw Error("Proactive refresh lower bound greater than upper bound!");}pk.prototype.start=function(){this.a=this.c;qk(this,!0)};function rk(a,b){if(b)return a.a=a.c,a.g();b=a.a;a.a*=2;a.a>a.f&&(a.a=a.f);return b}
function qk(a,b){sk(a);a.b=sd(rk(a,b)).then(function(){return a.l?A():bg()}).then(function(){return a.h()}).then(function(){qk(a,!0)}).s(function(b){a.i(b)&&qk(a,!1)})}function sk(a){a.b&&(a.b.cancel(),a.b=null)};function tk(a){this.f=a;this.b=this.a=null;this.c=0}tk.prototype.B=function(){return{apiKey:this.f.b,refreshToken:this.a,accessToken:this.b,expirationTime:this.c}};function uk(a,b){var c=b[O],d=b.refreshToken;b=vk(b.expiresIn);a.b=c;a.c=b;a.a=d}function vk(a){return na()+1E3*parseInt(a,10)}
function wk(a,b){return Oh(a.f,b).then(function(b){a.b=b.access_token;a.c=vk(b.expires_in);a.a=b.refresh_token;return{accessToken:a.b,expirationTime:a.c,refreshToken:a.a}}).s(function(b){"auth/user-token-expired"==b.code&&(a.a=null);throw b;})}tk.prototype.getToken=function(a){a=!!a;return this.b&&!this.a?B(new N("user-token-expired")):a||!this.b||na()>this.c-3E4?this.a?wk(this,{grant_type:"refresh_token",refresh_token:this.a}):A(null):A({accessToken:this.b,expirationTime:this.c,refreshToken:this.a})};function xk(a,b){this.a=a||null;this.b=b||null;gg(this,{lastSignInTime:cg(b||null),creationTime:cg(a||null)})}function yk(a){return new xk(a.a,a.b)}xk.prototype.B=function(){return{lastLoginAt:this.b,createdAt:this.a}};function zk(a,b,c,d,e,f){gg(this,{uid:a,displayName:d||null,photoURL:e||null,email:c||null,phoneNumber:f||null,providerId:b})}function Ak(a,b){C.call(this,a);for(var c in b)this[c]=b[c]}t(Ak,C);
function Bk(a,b,c){this.A=[];this.G=a.apiKey;this.o=a.appName;this.w=a.authDomain||null;a=firebase.SDK_VERSION?Of(firebase.SDK_VERSION):null;this.c=new Ch(this.G,xi(yi),a);this.h=new tk(this.c);Ck(this,b[O]);uk(this.h,b);M(this,"refreshToken",this.h.a);Dk(this,c||{});F.call(this);this.I=!1;this.w&&Rf()&&(this.a=gk(this.w,this.G,this.o));this.N=[];this.i=null;this.l=Ek(this);this.U=r(this.Ga,this);var d=this;this.ha=null;this.ra=function(a){d.na(a.h)};this.W=null;this.R=[];this.qa=function(a){Fk(d,
a.f)};this.V=null}t(Bk,F);Bk.prototype.na=function(a){this.ha=a;Ih(this.c,a)};Bk.prototype.$=function(){return this.ha};function Gk(a,b){a.W&&E(a.W,"languageCodeChanged",a.ra);(a.W=b)&&cd(b,"languageCodeChanged",a.ra)}function Fk(a,b){a.R=b;Jh(a.c,firebase.SDK_VERSION?Of(firebase.SDK_VERSION,a.R):null)}Bk.prototype.Ka=function(){return La(this.R)};function Hk(a,b){a.V&&E(a.V,"frameworkChanged",a.qa);(a.V=b)&&cd(b,"frameworkChanged",a.qa)}Bk.prototype.Ga=function(){this.l.b&&(sk(this.l),this.l.start())};
function Ik(a){try{return firebase.app(a.o).auth()}catch(b){throw new N("internal-error","No firebase.auth.Auth instance is available for the Firebase App '"+a.o+"'!");}}function Ek(a){return new pk(function(){return a.F(!0)},function(a){return a&&"auth/network-request-failed"==a.code?!0:!1},function(){var b=a.h.c-na()-3E5;return 0<b?b:0},3E4,96E4,!1)}function Jk(a){a.m||a.l.b||(a.l.start(),E(a,"tokenChanged",a.U),cd(a,"tokenChanged",a.U))}function Kk(a){E(a,"tokenChanged",a.U);sk(a.l)}
function Ck(a,b){a.pa=b;M(a,"_lat",b)}function Lk(a,b){Ja(a.N,function(a){return a==b})}function Mk(a){for(var b=[],c=0;c<a.N.length;c++)b.push(a.N[c](a));return Ob(b).then(function(){return a})}function Nk(a){a.a&&!a.I&&(a.I=!0,a.a.subscribe(a))}
function Dk(a,b){gg(a,{uid:b.uid,displayName:b.displayName||null,photoURL:b.photoURL||null,email:b.email||null,emailVerified:b.emailVerified||!1,phoneNumber:b.phoneNumber||null,isAnonymous:b.isAnonymous||!1,metadata:new xk(b.createdAt,b.lastLoginAt),providerData:[]})}M(Bk.prototype,"providerId","firebase");function Ok(){}function Pk(a){return A().then(function(){if(a.m)throw new N("app-deleted");})}function Qk(a){return Da(a.providerData,function(a){return a.providerId})}
function Rk(a,b){b&&(Sk(a,b.providerId),a.providerData.push(b))}function Sk(a,b){Ja(a.providerData,function(a){return a.providerId==b})}function Tk(a,b,c){("uid"!=b||c)&&a.hasOwnProperty(b)&&M(a,b,c)}
function Uk(a,b){a!=b&&(gg(a,{uid:b.uid,displayName:b.displayName,photoURL:b.photoURL,email:b.email,emailVerified:b.emailVerified,phoneNumber:b.phoneNumber,isAnonymous:b.isAnonymous,providerData:[]}),b.metadata?M(a,"metadata",yk(b.metadata)):M(a,"metadata",new xk),w(b.providerData,function(b){Rk(a,b)}),a.h=b.h,M(a,"refreshToken",a.h.a))}h=Bk.prototype;h.reload=function(){var a=this;return R(this,Pk(this).then(function(){return Vk(a).then(function(){return Mk(a)}).then(Ok)}))};
function Vk(a){return a.F().then(function(b){var c=a.isAnonymous;return Wk(a,b).then(function(){c||Tk(a,"isAnonymous",!1);return b})})}h.F=function(a){var b=this;return R(this,Pk(this).then(function(){return b.h.getToken(a)}).then(function(a){if(!a)throw new N("internal-error");a.accessToken!=b.pa&&(Ck(b,a.accessToken),G(b,new Ak("tokenChanged")));Tk(b,"refreshToken",a.refreshToken);return a.accessToken}))};
h.getToken=function(a){dg["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]||(dg["firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."]=!0,"undefined"!==typeof console&&"function"===typeof console.warn&&console.warn("firebase.User.prototype.getToken is deprecated. Please use firebase.User.prototype.getIdToken instead."));return this.F(a)};
function Xk(a,b){b[O]&&a.pa!=b[O]&&(uk(a.h,b),G(a,new Ak("tokenChanged")),Ck(a,b[O]),Tk(a,"refreshToken",a.h.a))}function Wk(a,b){return Q(a.c,ti,{idToken:b}).then(r(a.kc,a))}
h.kc=function(a){a=a.users;if(!a||!a.length)throw new N("internal-error");a=a[0];Dk(this,{uid:a.localId,displayName:a.displayName,photoURL:a.photoUrl,email:a.email,emailVerified:!!a.emailVerified,phoneNumber:a.phoneNumber,lastLoginAt:a.lastLoginAt,createdAt:a.createdAt});for(var b=Yk(a),c=0;c<b.length;c++)Rk(this,b[c]);Tk(this,"isAnonymous",!(this.email&&a.passwordHash)&&!(this.providerData&&this.providerData.length))};
function Yk(a){return(a=a.providerUserInfo)&&a.length?Da(a,function(a){return new zk(a.rawId,a.providerId,a.email,a.displayName,a.photoUrl,a.phoneNumber)}):[]}h.Za=function(a){var b=this,c=null;return R(this,a.c(this.c,this.uid).then(function(a){Xk(b,a);c=Zk(b,a,"reauthenticate");b.i=null;return b.reload()}).then(function(){return c}),!0)};h.mc=function(a){return this.Za(a).then(function(){})};
function $k(a,b){return Vk(a).then(function(){if(Ha(Qk(a),b))return Mk(a).then(function(){throw new N("provider-already-linked");})})}h.Xa=function(a){var b=this,c=null;return R(this,$k(this,a.providerId).then(function(){return b.F()}).then(function(c){return a.b(b.c,c)}).then(function(a){c=Zk(b,a,"link");return al(b,a)}).then(function(){return c}))};h.cc=function(a){return this.Xa(a).then(function(a){return a.user})};
h.dc=function(a,b){var c=this;return R(this,$k(this,"phone").then(function(){return ok(Ik(c),a,b,r(c.Xa,c))}))};h.nc=function(a,b){var c=this;return R(this,A().then(function(){return ok(Ik(c),a,b,r(c.Za,c))}),!0)};function Zk(a,b,c){var d=uh(b);b=Mg(b);return hg({user:a,credential:d,additionalUserInfo:b,operationType:c})}function al(a,b){Xk(a,b);return a.reload().then(function(){return a})}
h.kb=function(a){var b=this;return R(this,this.F().then(function(c){return b.c.kb(c,a)}).then(function(a){Xk(b,a);return b.reload()}))};h.Dc=function(a){var b=this;return R(this,this.F().then(function(c){return a.b(b.c,c)}).then(function(a){Xk(b,a);return b.reload()}))};h.lb=function(a){var b=this;return R(this,this.F().then(function(c){return b.c.lb(c,a)}).then(function(a){Xk(b,a);return b.reload()}))};
h.mb=function(a){if(void 0===a.displayName&&void 0===a.photoURL)return Pk(this);var b=this;return R(this,this.F().then(function(c){return b.c.mb(c,{displayName:a.displayName,photoUrl:a.photoURL})}).then(function(a){Xk(b,a);Tk(b,"displayName",a.displayName||null);Tk(b,"photoURL",a.photoUrl||null);w(b.providerData,function(a){"password"===a.providerId&&(M(a,"displayName",b.displayName),M(a,"photoURL",b.photoURL))});return Mk(b)}).then(Ok))};
h.Cc=function(a){var b=this;return R(this,Vk(this).then(function(c){return Ha(Qk(b),a)?fi(b.c,c,[a]).then(function(a){var c={};w(a.providerUserInfo||[],function(a){c[a.providerId]=!0});w(Qk(b),function(a){c[a]||Sk(b,a)});c[rh.PROVIDER_ID]||M(b,"phoneNumber",null);return Mk(b)}):Mk(b).then(function(){throw new N("no-such-provider");})}))};
h.delete=function(){var a=this;return R(this,this.F().then(function(b){return Q(a.c,si,{idToken:b})}).then(function(){G(a,new Ak("userDeleted"))})).then(function(){for(var b=0;b<a.A.length;b++)a.A[b].cancel("app-deleted");Gk(a,null);Hk(a,null);a.A=[];a.m=!0;Kk(a);M(a,"refreshToken",null);a.a&&a.a.unsubscribe(a)})};
h.ob=function(a,b){return"linkViaPopup"==a&&(this.g||null)==b&&this.f||"reauthViaPopup"==a&&(this.g||null)==b&&this.f||"linkViaRedirect"==a&&(this.Z||null)==b||"reauthViaRedirect"==a&&(this.Z||null)==b?!0:!1};h.fa=function(a,b,c,d){"linkViaPopup"!=a&&"reauthViaPopup"!=a||d!=(this.g||null)||(c&&this.v?this.v(c):b&&!c&&this.f&&this.f(b),this.b&&(this.b.cancel(),this.b=null),delete this.f,delete this.v)};
h.va=function(a,b){return"linkViaPopup"==a&&b==(this.g||null)?r(this.tb,this):"reauthViaPopup"==a&&b==(this.g||null)?r(this.ub,this):"linkViaRedirect"==a&&(this.Z||null)==b?r(this.tb,this):"reauthViaRedirect"==a&&(this.Z||null)==b?r(this.ub,this):null};h.ec=function(a){var b=this;return bl(this,"linkViaPopup",a,function(){return $k(b,a.providerId).then(function(){return Mk(b)})},!1)};h.oc=function(a){return bl(this,"reauthViaPopup",a,function(){return A()},!0)};
function bl(a,b,c,d,e){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));if(a.i&&!e)return B(a.i);var f=Lg(c.providerId),g=Qf(a.uid+":::"),l=null;(!Tf()||Lf())&&a.w&&c.isOAuthProvider&&(l=Ri(a.w,a.G,a.o,b,c,null,g,firebase.SDK_VERSION||null));var n=Df(l,f&&f.za,f&&f.ya);d=d().then(function(){cl(a);if(!e)return a.F().then(function(){})}).then(function(){return ek(a.a,n,b,c,g,!!l)}).then(function(){return new z(function(c,d){a.fa(b,null,new N("cancelled-popup-request"),a.g||null);
a.f=c;a.v=d;a.g=g;a.b=a.a.Ca(a,b,n,g)})}).then(function(a){n&&Cf(n);return a?hg(a):null}).s(function(a){n&&Cf(n);throw a;});return R(a,d,e)}h.fc=function(a){var b=this;return dl(this,"linkViaRedirect",a,function(){return $k(b,a.providerId)},!1)};h.pc=function(a){return dl(this,"reauthViaRedirect",a,function(){return A()},!0)};
function dl(a,b,c,d,e){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));if(a.i&&!e)return B(a.i);var f=null,g=Qf(a.uid+":::");d=d().then(function(){cl(a);if(!e)return a.F().then(function(){})}).then(function(){a.Z=g;return Mk(a)}).then(function(b){a.ca&&(b=a.ca,b=b.b.set(el,a.B(),b.a));return b}).then(function(){return a.a.Aa(b,c,g)}).s(function(b){f=b;if(a.ca)return fl(a.ca);throw f;}).then(function(){if(f)throw f;});return R(a,d,e)}
function cl(a){if(!a.a||!a.I){if(a.a&&!a.I)throw new N("internal-error");throw new N("auth-domain-config-required");}}h.tb=function(a,b){var c=this;this.b&&(this.b.cancel(),this.b=null);var d=null,e=this.F().then(function(d){return Zg(c.c,{requestUri:a,sessionId:b,idToken:d})}).then(function(a){d=Zk(c,a,"link");return al(c,a)}).then(function(){return d});return R(this,e)};
h.ub=function(a,b){var c=this;this.b&&(this.b.cancel(),this.b=null);var d=null,e=A().then(function(){return Vg($g(c.c,{requestUri:a,sessionId:b}),c.uid)}).then(function(a){d=Zk(c,a,"reauthenticate");Xk(c,a);c.i=null;return c.reload()}).then(function(){return d});return R(this,e,!0)};h.bb=function(a){var b=this,c=null;return R(this,this.F().then(function(b){c=b;return"undefined"===typeof a||Sa(a)?{}:Fg(new wg(a))}).then(function(a){return b.c.bb(c,a)}).then(function(a){if(b.email!=a)return b.reload()}).then(function(){}))};
function R(a,b,c){var d=gl(a,b,c);a.A.push(d);Qb(d,function(){Ia(a.A,d)});return d}function gl(a,b,c){return a.i&&!c?(b.cancel(),B(a.i)):b.s(function(b){!b||"auth/user-disabled"!=b.code&&"auth/user-token-expired"!=b.code||(a.i||G(a,new Ak("userInvalidated")),a.i=b);throw b;})}h.toJSON=function(){return this.B()};
h.B=function(){var a={uid:this.uid,displayName:this.displayName,photoURL:this.photoURL,email:this.email,emailVerified:this.emailVerified,phoneNumber:this.phoneNumber,isAnonymous:this.isAnonymous,providerData:[],apiKey:this.G,appName:this.o,authDomain:this.w,stsTokenManager:this.h.B(),redirectEventId:this.Z||null};this.metadata&&Wa(a,this.metadata.B());w(this.providerData,function(b){a.providerData.push(ig(b))});return a};
function hl(a){if(!a.apiKey)return null;var b={apiKey:a.apiKey,authDomain:a.authDomain,appName:a.appName},c={};if(a.stsTokenManager&&a.stsTokenManager.accessToken&&a.stsTokenManager.expirationTime)c[O]=a.stsTokenManager.accessToken,c.refreshToken=a.stsTokenManager.refreshToken||null,c.expiresIn=(a.stsTokenManager.expirationTime-na())/1E3;else return null;var d=new Bk(b,c,a);a.providerData&&w(a.providerData,function(a){a&&Rk(d,hg(a))});a.redirectEventId&&(d.Z=a.redirectEventId);return d}
function il(a,b,c,d){var e=new Bk(a,b);c&&(e.ca=c);d&&Fk(e,d);return e.reload().then(function(){return e})};function jl(a){this.a=a;this.b=rj()}var el={name:"redirectUser",C:"session"};function fl(a){return uj(a.b,el,a.a)}function kl(a,b){return a.b.get(el,a.a).then(function(a){a&&b&&(a.authDomain=b);return hl(a||{})})};function ll(a,b){this.a=a;this.b=b||rj();this.c=null;this.f=ml(this);vj(this.b,yj("local"),this.a,r(this.g,this))}ll.prototype.g=function(){var a=this,b=yj("local");nl(this,function(){return A().then(function(){return a.c&&"local"!=a.c.C?a.b.get(b,a.a):null}).then(function(c){if(c)return ol(a,"local").then(function(){a.c=b})})})};function ol(a,b){var c=[],d;for(d in nj)nj[d]!==b&&c.push(uj(a.b,yj(nj[d]),a.a));c.push(uj(a.b,pl,a.a));return Nb(c)}
function ml(a){var b=yj("local"),c=yj("session"),d=yj("none");return a.b.get(c,a.a).then(function(e){return e?c:a.b.get(d,a.a).then(function(c){return c?d:a.b.get(b,a.a).then(function(c){return c?b:a.b.get(pl,a.a).then(function(a){return a?yj(a):b})})})}).then(function(b){a.c=b;return ol(a,b.C)}).s(function(){a.c||(a.c=b)})}var pl={name:"persistence",C:"session"};function yj(a){return{name:"authUser",C:a}}
ll.prototype.eb=function(a){var b=null,c=this;oj(a);return nl(this,function(){return a!=c.c.C?c.b.get(c.c,c.a).then(function(d){b=d;return ol(c,a)}).then(function(){c.c=yj(a);if(b)return c.b.set(c.c,b,c.a)}):A()})};function ql(a){return nl(a,function(){return a.b.set(pl,a.c.C,a.a)})}function rl(a,b){return nl(a,function(){return a.b.set(a.c,b.B(),a.a)})}function sl(a){return nl(a,function(){return uj(a.b,a.c,a.a)})}
function tl(a,b){return nl(a,function(){return a.b.get(a.c,a.a).then(function(a){a&&b&&(a.authDomain=b);return hl(a||{})})})}function nl(a,b){a.f=a.f.then(b,b);return a.f};function ul(a){this.l=!1;M(this,"app",a);if(S(this).options&&S(this).options.apiKey)a=firebase.SDK_VERSION?Of(firebase.SDK_VERSION):null,this.c=new Ch(S(this).options&&S(this).options.apiKey,xi(yi),a);else throw new N("invalid-api-key");this.N=[];this.m=[];this.I=[];this.Kb=firebase.INTERNAL.createSubscribe(r(this.ac,this));this.R=void 0;this.Lb=firebase.INTERNAL.createSubscribe(r(this.bc,this));vl(this,null);this.h=new ll(S(this).options.apiKey+":"+S(this).name);this.G=new jl(S(this).options.apiKey+
":"+S(this).name);this.U=T(this,wl(this));this.i=T(this,xl(this));this.W=!1;this.ha=r(this.yc,this);this.Ga=r(this.ka,this);this.pa=r(this.Tb,this);this.qa=r(this.Zb,this);this.ra=r(this.$b,this);yl(this);this.INTERNAL={};this.INTERNAL["delete"]=r(this.delete,this);this.INTERNAL.logFramework=r(this.gc,this);this.o=0;F.call(this);zl(this);this.A=[]}t(ul,F);function Al(a){C.call(this,"languageCodeChanged");this.h=a}t(Al,C);function Bl(a){C.call(this,"frameworkChanged");this.f=a}t(Bl,C);h=ul.prototype;
h.eb=function(a){a=this.h.eb(a);return T(this,a)};h.na=function(a){this.V===a||this.l||(this.V=a,Ih(this.c,this.V),G(this,new Al(this.$())))};h.$=function(){return this.V};h.Ec=function(){var a=k.navigator;this.na(a?a.languages&&a.languages[0]||a.language||a.userLanguage||null:null)};h.gc=function(a){this.A.push(a);Jh(this.c,firebase.SDK_VERSION?Of(firebase.SDK_VERSION,this.A):null);G(this,new Bl(this.A))};h.Ka=function(){return La(this.A)};
function zl(a){Object.defineProperty(a,"lc",{get:function(){return this.$()},set:function(a){this.na(a)},enumerable:!1});a.V=null}h.toJSON=function(){return{apiKey:S(this).options.apiKey,authDomain:S(this).options.authDomain,appName:S(this).name,currentUser:U(this)&&U(this).B()}};function Cl(a){return a.Jb||B(new N("auth-domain-config-required"))}
function yl(a){var b=S(a).options.authDomain,c=S(a).options.apiKey;b&&Rf()&&(a.Jb=a.U.then(function(){if(!a.l){a.a=gk(b,c,S(a).name);a.a.subscribe(a);U(a)&&Nk(U(a));if(a.w){Nk(a.w);var d=a.w;d.na(a.$());Gk(d,a);d=a.w;Fk(d,a.A);Hk(d,a);a.w=null}return a.a}}))}h.ob=function(a,b){switch(a){case "unknown":case "signInViaRedirect":return!0;case "signInViaPopup":return this.g==b&&!!this.f;default:return!1}};
h.fa=function(a,b,c,d){"signInViaPopup"==a&&this.g==d&&(c&&this.v?this.v(c):b&&!c&&this.f&&this.f(b),this.b&&(this.b.cancel(),this.b=null),delete this.f,delete this.v)};h.va=function(a,b){return"signInViaRedirect"==a||"signInViaPopup"==a&&this.g==b&&this.f?r(this.Sb,this):null};
h.Sb=function(a,b){var c=this;a={requestUri:a,sessionId:b};this.b&&(this.b.cancel(),this.b=null);var d=null,e=null,f=Xg(c.c,a).then(function(a){d=uh(a);e=Mg(a);return a});a=c.U.then(function(){return f}).then(function(a){return Dl(c,a)}).then(function(){return hg({user:U(c),credential:d,additionalUserInfo:e,operationType:"signIn"})});return T(this,a)};
h.wc=function(a){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var b=this,c=Lg(a.providerId),d=Qf(),e=null;(!Tf()||Lf())&&S(this).options.authDomain&&a.isOAuthProvider&&(e=Ri(S(this).options.authDomain,S(this).options.apiKey,S(this).name,"signInViaPopup",a,null,d,firebase.SDK_VERSION||null));var f=Df(e,c&&c.za,c&&c.ya);c=Cl(this).then(function(b){return ek(b,f,"signInViaPopup",a,d,!!e)}).then(function(){return new z(function(a,c){b.fa("signInViaPopup",null,new N("cancelled-popup-request"),
b.g);b.f=a;b.v=c;b.g=d;b.b=b.a.Ca(b,"signInViaPopup",f,d)})}).then(function(a){f&&Cf(f);return a?hg(a):null}).s(function(a){f&&Cf(f);throw a;});return T(this,c)};h.xc=function(a){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var b=this,c=Cl(this).then(function(){return ql(b.h)}).then(function(){return b.a.Aa("signInViaRedirect",a)});return T(this,c)};
h.aa=function(){if(!Rf())return B(new N("operation-not-supported-in-this-environment"));var a=this,b=Cl(this).then(function(){return a.a.aa()}).then(function(a){return a?hg(a):null});return T(this,b)};function Dl(a,b){var c={};c.apiKey=S(a).options.apiKey;c.authDomain=S(a).options.authDomain;c.appName=S(a).name;return a.U.then(function(){return il(c,b,a.G,a.Ka())}).then(function(b){if(U(a)&&b.uid==U(a).uid)return Uk(U(a),b),a.ka(b);vl(a,b);Nk(b);return a.ka(b)}).then(function(){El(a)})}
function vl(a,b){U(a)&&(Lk(U(a),a.Ga),E(U(a),"tokenChanged",a.pa),E(U(a),"userDeleted",a.qa),E(U(a),"userInvalidated",a.ra),Kk(U(a)));b&&(b.N.push(a.Ga),cd(b,"tokenChanged",a.pa),cd(b,"userDeleted",a.qa),cd(b,"userInvalidated",a.ra),0<a.o&&Jk(b));M(a,"currentUser",b);b&&(b.na(a.$()),Gk(b,a),Fk(b,a.A),Hk(b,a))}h.hb=function(){var a=this,b=this.i.then(function(){if(!U(a))return A();vl(a,null);return sl(a.h).then(function(){El(a)})});return T(this,b)};
function Fl(a){var b=kl(a.G,S(a).options.authDomain).then(function(b){if(a.w=b)b.ca=a.G;return fl(a.G)});return T(a,b)}function wl(a){var b=S(a).options.authDomain,c=Fl(a).then(function(){return tl(a.h,b)}).then(function(b){return b?(b.ca=a.G,a.w&&(a.w.Z||null)==(b.Z||null)?b:b.reload().then(function(){return rl(a.h,b).then(function(){return b})}).s(function(c){return"auth/network-request-failed"==c.code?b:sl(a.h)})):null}).then(function(b){vl(a,b||null)});return T(a,c)}
function xl(a){return a.U.then(function(){return a.aa()}).s(function(){}).then(function(){if(!a.l)return a.ha()}).s(function(){}).then(function(){if(!a.l){a.W=!0;var b=a.h;vj(b.b,yj("local"),b.a,a.ha)}})}
h.yc=function(){var a=this;return tl(this.h,S(this).options.authDomain).then(function(b){if(!a.l){var c;if(c=U(a)&&b){c=U(a).uid;var d=b.uid;c=void 0===c||null===c||""===c||void 0===d||null===d||""===d?!1:c==d}if(c)return Uk(U(a),b),U(a).F();if(U(a)||b)vl(a,b),b&&(Nk(b),b.ca=a.G),a.a&&a.a.subscribe(a),El(a)}})};h.ka=function(a){return rl(this.h,a)};h.Tb=function(){El(this);this.ka(U(this))};h.Zb=function(){this.hb()};h.$b=function(){this.hb()};
function Gl(a,b){var c=null,d=null;return T(a,b.then(function(b){c=uh(b);d=Mg(b);return Dl(a,b)}).then(function(){return hg({user:U(a),credential:c,additionalUserInfo:d,operationType:"signIn"})}))}h.ac=function(a){var b=this;this.addAuthTokenListener(function(){a.next(U(b))})};h.bc=function(a){var b=this;Hl(this,function(){a.next(U(b))})};h.ic=function(a,b,c){var d=this;this.W&&firebase.Promise.resolve().then(function(){p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.Kb(a,b,c)};
h.hc=function(a,b,c){var d=this;this.W&&firebase.Promise.resolve().then(function(){d.R=d.getUid();p(a)?a(U(d)):p(a.next)&&a.next(U(d))});return this.Lb(a,b,c)};h.Vb=function(a){var b=this,c=this.i.then(function(){return U(b)?U(b).F(a).then(function(a){return{accessToken:a}}):null});return T(this,c)};h.tc=function(a){return this.Eb(a).then(function(a){return a.user})};
h.Eb=function(a){var b=this;return this.i.then(function(){return Gl(b,Q(b.c,vi,{token:a}))}).then(function(a){var c=a.user;Tk(c,"isAnonymous",!1);b.ka(c);return a})};h.Fb=function(a,b){var c=this;return this.i.then(function(){return Gl(c,Q(c.c,kh,{email:a,password:b}))})};h.uc=function(a,b){return this.Fb(a,b).then(function(a){return a.user})};h.Ob=function(a,b){return this.qb(a,b).then(function(a){return a.user})};
h.qb=function(a,b){var c=this;return this.i.then(function(){return Gl(c,Q(c.c,ri,{email:a,password:b}))})};h.sc=function(a){return this.fb(a).then(function(a){return a.user})};h.fb=function(a){var b=this;return this.i.then(function(){return Gl(b,a.wa(b.c))})};h.gb=function(){return this.Gb().then(function(a){return a.user})};
h.Gb=function(){var a=this;return this.i.then(function(){var b=U(a);if(b&&b.isAnonymous){var c=hg({providerId:null,isNewUser:!1});return hg({user:b,credential:null,additionalUserInfo:c,operationType:"signIn"})}return Gl(a,a.c.gb()).then(function(b){var c=b.user;Tk(c,"isAnonymous",!0);a.ka(c);return b})})};function S(a){return a.app}function U(a){return a.currentUser}h.getUid=function(){return U(this)&&U(this).uid||null};function Il(a){return U(a)&&U(a)._lat||null}
function El(a){if(a.W){for(var b=0;b<a.m.length;b++)if(a.m[b])a.m[b](Il(a));if(a.R!==a.getUid()&&a.I.length)for(a.R=a.getUid(),b=0;b<a.I.length;b++)if(a.I[b])a.I[b](Il(a))}}h.Mb=function(a){this.addAuthTokenListener(a);this.o++;0<this.o&&U(this)&&Jk(U(this))};h.qc=function(a){var b=this;w(this.m,function(c){c==a&&b.o--});0>this.o&&(this.o=0);0==this.o&&U(this)&&Kk(U(this));this.removeAuthTokenListener(a)};
h.addAuthTokenListener=function(a){var b=this;this.m.push(a);T(this,this.i.then(function(){b.l||Ha(b.m,a)&&a(Il(b))}))};h.removeAuthTokenListener=function(a){Ja(this.m,function(b){return b==a})};function Hl(a,b){a.I.push(b);T(a,a.i.then(function(){!a.l&&Ha(a.I,b)&&a.R!==a.getUid()&&(a.R=a.getUid(),b(Il(a)))}))}h.delete=function(){this.l=!0;for(var a=0;a<this.N.length;a++)this.N[a].cancel("app-deleted");this.N=[];this.h&&(a=this.h,xj(a.b,a.a,this.ha));this.a&&this.a.unsubscribe(this);return firebase.Promise.resolve()};
function T(a,b){a.N.push(b);Qb(b,function(){Ia(a.N,b)});return b}h.Rb=function(a){return T(this,Th(this.c,a))};h.Fc=function(a){return this.Ia(a).then(function(a){return a.data.email})};h.Ta=function(a,b){return T(this,this.c.Ta(a,b).then(function(){}))};h.Ia=function(a){return T(this,this.c.Ia(a).then(function(a){return new lg(a)}))};h.Sa=function(a){return T(this,this.c.Sa(a).then(function(){}))};
h.cb=function(a,b){var c=this;return T(this,A().then(function(){return"undefined"===typeof b||Sa(b)?{}:Fg(new wg(b))}).then(function(b){return c.c.cb(a,b)}).then(function(){}))};h.vc=function(a,b){return T(this,ok(this,a,b,r(this.fb,this)))};function Jl(a,b,c,d){a:{c=Array.prototype.slice.call(c);var e=0;for(var f=!1,g=0;g<b.length;g++)if(b[g].optional)f=!0;else{if(f)throw new N("internal-error","Argument validator encountered a required argument after an optional argument.");e++}f=b.length;if(c.length<e||f<c.length)d="Expected "+(e==f?1==e?"1 argument":e+" arguments":e+"-"+f+" arguments")+" but got "+c.length+".";else{for(e=0;e<c.length;e++)if(f=b[e].optional&&void 0===c[e],!b[e].M(c[e])&&!f){b=b[e];if(0>e||e>=Kl.length)throw new N("internal-error",
"Argument validator received an unsupported number of arguments.");c=Kl[e];d=(d?"":c+" argument ")+(b.name?'"'+b.name+'" ':"")+"must be "+b.K+".";break a}d=null}}if(d)throw new N("argument-error",a+" failed: "+d);}var Kl="First Second Third Fourth Fifth Sixth Seventh Eighth Ninth".split(" ");function V(a,b){return{name:a||"",K:"a valid string",optional:!!b,M:m}}function Ll(){return{name:"opt_forceRefresh",K:"a boolean",optional:!0,M:ba}}
function W(a,b){return{name:a||"",K:"a valid object",optional:!!b,M:q}}function Ml(a,b){return{name:a||"",K:"a function",optional:!!b,M:p}}function Nl(a,b){return{name:a||"",K:"null",optional:!!b,M:ea}}function Ol(){return{name:"",K:"an HTML element",optional:!1,M:function(a){return!!(a&&a instanceof Element)}}}function Pl(){return{name:"auth",K:"an instance of Firebase Auth",optional:!0,M:function(a){return!!(a&&a instanceof ul)}}}
function Ql(){return{name:"app",K:"an instance of Firebase App",optional:!0,M:function(a){return!!(a&&a instanceof firebase.app.App)}}}function Rl(a){return{name:a?a+"Credential":"credential",K:a?"a valid "+a+" credential":"a valid credential",optional:!1,M:function(b){if(!b)return!1;var c=!a||b.providerId===a;return!(!b.wa||!c)}}}
function Sl(){return{name:"authProvider",K:"a valid Auth provider",optional:!1,M:function(a){return!!(a&&a.providerId&&a.hasOwnProperty&&a.hasOwnProperty("isOAuthProvider"))}}}function Tl(){return{name:"applicationVerifier",K:"an implementation of firebase.auth.ApplicationVerifier",optional:!1,M:function(a){return!!(a&&m(a.type)&&p(a.verify))}}}function X(a,b,c,d){return{name:c||"",K:a.K+" or "+b.K,optional:!!d,M:function(c){return a.M(c)||b.M(c)}}};function Ul(a,b,c,d,e,f){M(this,"type","recaptcha");this.b=this.c=null;this.m=!1;this.l=b;this.a=c||{theme:"light",type:"image"};this.g=[];if(this.a[Vl])throw new N("argument-error","sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.");this.h="invisible"===this.a[Wl];if(!wc(b)||!this.h&&wc(b).hasChildNodes())throw new N("argument-error","reCAPTCHA container is either not found or already contains inner elements!");this.u=new Ch(a,f||null,e||null);
this.o=d||function(){return null};var g=this;this.i=[];var l=this.a[Xl];this.a[Xl]=function(a){Yl(g,a);if("function"===typeof l)l(a);else if("string"===typeof l){var b=L(l,k);"function"===typeof b&&b(a)}};var n=this.a[Zl];this.a[Zl]=function(){Yl(g,null);if("function"===typeof n)n();else if("string"===typeof n){var a=L(n,k);"function"===typeof a&&a()}}}var Xl="callback",Zl="expired-callback",Vl="sitekey",Wl="size";function Yl(a,b){for(var c=0;c<a.i.length;c++)try{a.i[c](b)}catch(d){}}
function $l(a,b){Ja(a.i,function(a){return a==b})}function am(a,b){a.g.push(b);Qb(b,function(){Ia(a.g,b)});return b}h=Ul.prototype;
h.xa=function(){var a=this;return this.c?this.c:this.c=am(this,A().then(function(){if(Sf())return Hf();throw new N("operation-not-supported-in-this-environment","RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.");}).then(function(){return bm(cm(),a.o())}).then(function(){return Q(a.u,ui,{})}).then(function(b){a.a[Vl]=b.recaptchaSiteKey}).s(function(b){a.c=null;throw b;}))};
h.render=function(){dm(this);var a=this;return am(this,this.xa().then(function(){if(null===a.b){var b=a.l;if(!a.h){var c=wc(b);b=zc("DIV");c.appendChild(b)}a.b=grecaptcha.render(b,a.a)}return a.b}))};h.verify=function(){dm(this);var a=this;return am(this,this.render().then(function(b){return new z(function(c){var d=grecaptcha.getResponse(b);if(d)c(d);else{var e=function(b){b&&($l(a,e),c(b))};a.i.push(e);a.h&&grecaptcha.execute(a.b)}})}))};h.reset=function(){dm(this);null!==this.b&&grecaptcha.reset(this.b)};
function dm(a){if(a.m)throw new N("internal-error","RecaptchaVerifier instance has been destroyed.");}h.clear=function(){dm(this);this.m=!0;cm().b--;for(var a=0;a<this.g.length;a++)this.g[a].cancel("RecaptchaVerifier instance has been destroyed.");if(!this.h){a=wc(this.l);for(var b;b=a.firstChild;)a.removeChild(b)}};var em=dc("https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}");
function fm(){this.b=k.grecaptcha?Infinity:0;this.c=null;this.a="__rcb"+Math.floor(1E6*Math.random()).toString()}
function bm(a,b){return new z(function(c,d){if(Zf())if(!k.grecaptcha||b!==a.c&&!a.b){k[a.a]=function(){if(k.grecaptcha){a.c=b;var e=k.grecaptcha.render;k.grecaptcha.render=function(b,c){b=e(b,c);a.b++;return b};c()}else d(new N("internal-error"));delete k[a.a]};var e=hc(em,{onload:a.a,hl:b||""});A(kf(e)).s(function(){d(new N("internal-error","Unable to load external reCAPTCHA dependencies!"))})}else c();else d(new N("network-request-failed"))})}var gm=null;
function cm(){gm||(gm=new fm);return gm}function hm(a,b,c){try{this.f=c||firebase.app()}catch(f){throw new N("argument-error","No firebase.app.App instance is currently initialized.");}if(this.f.options&&this.f.options.apiKey)c=this.f.options.apiKey;else throw new N("invalid-api-key");var d=this,e=null;try{e=this.f.auth().Ka()}catch(f){}e=firebase.SDK_VERSION?Of(firebase.SDK_VERSION,e):null;Ul.call(this,c,a,b,function(){try{var a=d.f.auth().$()}catch(g){a=null}return a},e,xi(yi))}t(hm,Ul);function Y(a,b){for(var c in b){var d=b[c].name;a[d]=im(d,a[c],b[c].j)}}function Z(a,b,c,d){a[b]=im(b,c,d)}function im(a,b,c){function d(){var a=Array.prototype.slice.call(arguments);Jl(e,c,a);return b.apply(this,a)}if(!c)return b;var e=jm(a),f;for(f in b)d[f]=b[f];for(f in b.prototype)d.prototype[f]=b.prototype[f];return d}function jm(a){a=a.split(".");return a[a.length-1]};Y(ul.prototype,{Sa:{name:"applyActionCode",j:[V("code")]},Ia:{name:"checkActionCode",j:[V("code")]},Ta:{name:"confirmPasswordReset",j:[V("code"),V("newPassword")]},Ob:{name:"createUserWithEmailAndPassword",j:[V("email"),V("password")]},qb:{name:"createUserAndRetrieveDataWithEmailAndPassword",j:[V("email"),V("password")]},Rb:{name:"fetchProvidersForEmail",j:[V("email")]},aa:{name:"getRedirectResult",j:[]},hc:{name:"onAuthStateChanged",j:[X(W(),Ml(),"nextOrObserver"),Ml("opt_error",!0),Ml("opt_completed",
!0)]},ic:{name:"onIdTokenChanged",j:[X(W(),Ml(),"nextOrObserver"),Ml("opt_error",!0),Ml("opt_completed",!0)]},cb:{name:"sendPasswordResetEmail",j:[V("email"),X(W("opt_actionCodeSettings",!0),Nl(null,!0),"opt_actionCodeSettings",!0)]},eb:{name:"setPersistence",j:[V("persistence")]},fb:{name:"signInAndRetrieveDataWithCredential",j:[Rl()]},gb:{name:"signInAnonymously",j:[]},Gb:{name:"signInAnonymouslyAndRetrieveData",j:[]},sc:{name:"signInWithCredential",j:[Rl()]},tc:{name:"signInWithCustomToken",j:[V("token")]},
Eb:{name:"signInAndRetrieveDataWithCustomToken",j:[V("token")]},uc:{name:"signInWithEmailAndPassword",j:[V("email"),V("password")]},Fb:{name:"signInAndRetrieveDataWithEmailAndPassword",j:[V("email"),V("password")]},vc:{name:"signInWithPhoneNumber",j:[V("phoneNumber"),Tl()]},wc:{name:"signInWithPopup",j:[Sl()]},xc:{name:"signInWithRedirect",j:[Sl()]},hb:{name:"signOut",j:[]},toJSON:{name:"toJSON",j:[V(null,!0)]},Ec:{name:"useDeviceLanguage",j:[]},Fc:{name:"verifyPasswordResetCode",j:[V("code")]}});
(function(a,b){for(var c in b){var d=b[c].name;if(d!==c){var e=b[c].Nb;Object.defineProperty(a,d,{get:function(){return this[c]},set:function(a){Jl(d,[e],[a],!0);this[c]=a},enumerable:!0})}}})(ul.prototype,{lc:{name:"languageCode",Nb:X(V(),Nl(),"languageCode")}});ul.Persistence=nj;ul.Persistence.LOCAL="local";ul.Persistence.SESSION="session";ul.Persistence.NONE="none";
Y(Bk.prototype,{"delete":{name:"delete",j:[]},F:{name:"getIdToken",j:[Ll()]},getToken:{name:"getToken",j:[Ll()]},Xa:{name:"linkAndRetrieveDataWithCredential",j:[Rl()]},cc:{name:"linkWithCredential",j:[Rl()]},dc:{name:"linkWithPhoneNumber",j:[V("phoneNumber"),Tl()]},ec:{name:"linkWithPopup",j:[Sl()]},fc:{name:"linkWithRedirect",j:[Sl()]},Za:{name:"reauthenticateAndRetrieveDataWithCredential",j:[Rl()]},mc:{name:"reauthenticateWithCredential",j:[Rl()]},nc:{name:"reauthenticateWithPhoneNumber",j:[V("phoneNumber"),
Tl()]},oc:{name:"reauthenticateWithPopup",j:[Sl()]},pc:{name:"reauthenticateWithRedirect",j:[Sl()]},reload:{name:"reload",j:[]},bb:{name:"sendEmailVerification",j:[X(W("opt_actionCodeSettings",!0),Nl(null,!0),"opt_actionCodeSettings",!0)]},toJSON:{name:"toJSON",j:[V(null,!0)]},Cc:{name:"unlink",j:[V("provider")]},kb:{name:"updateEmail",j:[V("email")]},lb:{name:"updatePassword",j:[V("password")]},Dc:{name:"updatePhoneNumber",j:[Rl("phone")]},mb:{name:"updateProfile",j:[W("profile")]}});
Y(z.prototype,{s:{name:"catch"},then:{name:"then"}});Y(nk.prototype,{confirm:{name:"confirm",j:[V("verificationCode")]}});Z(mh,"credential",function(a,b){return new jh(a,b)},[V("email"),V("password")]);Y(bh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(bh,"credential",ch,[X(V(),W(),"token")]);Y(dh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});
Z(dh,"credential",eh,[X(V(),W(),"token")]);Y(fh.prototype,{sa:{name:"addScope",j:[V("scope")]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(fh,"credential",gh,[X(V(),X(W(),Nl()),"idToken"),X(V(),Nl(),"accessToken",!0)]);Y(hh.prototype,{Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(hh,"credential",ih,[X(V(),W(),"token"),V("secret",!0)]);
Y(P.prototype,{sa:{name:"addScope",j:[V("scope")]},credential:{name:"credential",j:[X(V(),Nl(),"idToken",!0),X(V(),Nl(),"accessToken",!0)]},Ba:{name:"setCustomParameters",j:[W("customOAuthParameters")]}});Z(rh,"credential",th,[V("verificationId"),V("verificationCode")]);Y(rh.prototype,{Qa:{name:"verifyPhoneNumber",j:[V("phoneNumber"),Tl()]}});Y(N.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});Y(zh.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});
Y(yh.prototype,{toJSON:{name:"toJSON",j:[V(null,!0)]}});Y(hm.prototype,{clear:{name:"clear",j:[]},render:{name:"render",j:[]},verify:{name:"verify",j:[]}});
(function(){if("undefined"!==typeof firebase&&firebase.INTERNAL&&firebase.INTERNAL.registerService){var a={Auth:ul,Error:N};Z(a,"EmailAuthProvider",mh,[]);Z(a,"FacebookAuthProvider",bh,[]);Z(a,"GithubAuthProvider",dh,[]);Z(a,"GoogleAuthProvider",fh,[]);Z(a,"TwitterAuthProvider",hh,[]);Z(a,"OAuthProvider",P,[V("providerId")]);Z(a,"PhoneAuthProvider",rh,[Pl()]);Z(a,"RecaptchaVerifier",hm,[X(V(),Ol(),"recaptchaContainer"),W("recaptchaParameters",!0),Ql()]);firebase.INTERNAL.registerService("auth",function(a,
c){a=new ul(a);c({INTERNAL:{getUid:r(a.getUid,a),getToken:r(a.Vb,a),addAuthTokenListener:r(a.Mb,a),removeAuthTokenListener:r(a.qc,a)}});return a},a,function(a,c){if("create"===a)try{c.auth()}catch(d){}});firebase.INTERNAL.extendNamespace({User:Bk})}else throw Error("Cannot find the firebase namespace; be sure to include firebase-app.js before this library.");})();
}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(28)))

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var app_1 = __webpack_require__(8);
var Database_1 = __webpack_require__(47);
exports.Database = Database_1.Database;
var Query_1 = __webpack_require__(51);
exports.Query = Query_1.Query;
var Reference_1 = __webpack_require__(30);
exports.Reference = Reference_1.Reference;
var util_1 = __webpack_require__(1);
exports.enableLogging = util_1.enableLogging;
var RepoManager_1 = __webpack_require__(35);
var INTERNAL = __webpack_require__(134);
var TEST_ACCESS = __webpack_require__(135);
var util_2 = __webpack_require__(0);
var ServerValue = Database_1.Database.ServerValue;
exports.ServerValue = ServerValue;
function registerDatabase(instance) {
    // Register the Database Service with the 'firebase' namespace.
    var namespace = instance.INTERNAL.registerService('database', function (app, unused, url) { return RepoManager_1.RepoManager.getInstance().databaseFromApp(app, url); }, 
    // firebase.database namespace properties
    {
        Reference: Reference_1.Reference,
        Query: Query_1.Query,
        Database: Database_1.Database,
        enableLogging: util_1.enableLogging,
        INTERNAL: INTERNAL,
        ServerValue: ServerValue,
        TEST_ACCESS: TEST_ACCESS
    }, null, true);
    if (util_2.isNodeSdk()) {
        module.exports = namespace;
    }
}
exports.registerDatabase = registerDatabase;
registerDatabase(app_1.default);
var DataSnapshot_1 = __webpack_require__(31);
exports.DataSnapshot = DataSnapshot_1.DataSnapshot;
var onDisconnect_1 = __webpack_require__(50);
exports.OnDisconnect = onDisconnect_1.OnDisconnect;

//# sourceMappingURL=index.js.map


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Wraps a DOM Storage object and:
 * - automatically encode objects as JSON strings before storing them to allow us to store arbitrary types.
 * - prefixes names with "firebase:" to avoid collisions with app data.
 *
 * We automatically (see storage.js) create two such wrappers, one for sessionStorage,
 * and one for localStorage.
 *
 * @constructor
 */
var DOMStorageWrapper = /** @class */ (function () {
    /**
     * @param {Storage} domStorage_ The underlying storage object (e.g. localStorage or sessionStorage)
     */
    function DOMStorageWrapper(domStorage_) {
        this.domStorage_ = domStorage_;
        // Use a prefix to avoid collisions with other stuff saved by the app.
        this.prefix_ = 'firebase:';
    }
    /**
     * @param {string} key The key to save the value under
     * @param {?Object} value The value being stored, or null to remove the key.
     */
    DOMStorageWrapper.prototype.set = function (key, value) {
        if (value == null) {
            this.domStorage_.removeItem(this.prefixedName_(key));
        }
        else {
            this.domStorage_.setItem(this.prefixedName_(key), util_1.stringify(value));
        }
    };
    /**
     * @param {string} key
     * @return {*} The value that was stored under this key, or null
     */
    DOMStorageWrapper.prototype.get = function (key) {
        var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
        if (storedVal == null) {
            return null;
        }
        else {
            return util_1.jsonEval(storedVal);
        }
    };
    /**
     * @param {string} key
     */
    DOMStorageWrapper.prototype.remove = function (key) {
        this.domStorage_.removeItem(this.prefixedName_(key));
    };
    /**
     * @param {string} name
     * @return {string}
     */
    DOMStorageWrapper.prototype.prefixedName_ = function (name) {
        return this.prefix_ + name;
    };
    DOMStorageWrapper.prototype.toString = function () {
        return this.domStorage_.toString();
    };
    return DOMStorageWrapper;
}());
exports.DOMStorageWrapper = DOMStorageWrapper;

//# sourceMappingURL=DOMStorageWrapper.js.map


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * An in-memory storage implementation that matches the API of DOMStorageWrapper
 * (TODO: create interface for both to implement).
 *
 * @constructor
 */
var MemoryStorage = /** @class */ (function () {
    function MemoryStorage() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
    }
    MemoryStorage.prototype.set = function (key, value) {
        if (value == null) {
            delete this.cache_[key];
        }
        else {
            this.cache_[key] = value;
        }
    };
    MemoryStorage.prototype.get = function (key) {
        if (util_1.contains(this.cache_, key)) {
            return this.cache_[key];
        }
        return null;
    };
    MemoryStorage.prototype.remove = function (key) {
        delete this.cache_[key];
    };
    return MemoryStorage;
}());
exports.MemoryStorage = MemoryStorage;

//# sourceMappingURL=MemoryStorage.js.map


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var TransactionResult = /** @class */ (function () {
    /**
     * A type for the resolve value of Firebase.transaction.
     * @constructor
     * @dict
     * @param {boolean} committed
     * @param {DataSnapshot} snapshot
     */
    function TransactionResult(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
    }
    // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
    // for end-users
    TransactionResult.prototype.toJSON = function () {
        util_1.validateArgCount('TransactionResult.toJSON', 0, 1, arguments.length);
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult;
}());
exports.TransactionResult = TransactionResult;

//# sourceMappingURL=TransactionResult.js.map


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Fancy ID generator that creates 20-character string identifiers with the
 * following properties:
 *
 * 1. They're based on timestamp so that they sort *after* any existing ids.
 * 2. They contain 72-bits of random data after the timestamp so that IDs won't
 *    collide with other clients' IDs.
 * 3. They sort *lexicographically* (so the timestamp is converted to characters
 *    that will sort properly).
 * 4. They're monotonically increasing. Even if you generate more than one in
 *    the same timestamp, the latter ones will sort after the former ones. We do
 *    this by using the previous random bits but "incrementing" them by 1 (only
 *    in the case of a timestamp collision).
 */
exports.nextPushId = (function () {
    // Modeled after base64 web-safe chars, but ordered by ASCII.
    var PUSH_CHARS = '-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz';
    // Timestamp of last push, used to prevent local collisions if you push twice
    // in one ms.
    var lastPushTime = 0;
    // We generate 72-bits of randomness which get turned into 12 characters and
    // appended to the timestamp to prevent collisions with other clients. We
    // store the last characters we generated because in the event of a collision,
    // we'll use those same characters except "incremented" by one.
    var lastRandChars = [];
    return function (now) {
        var duplicateTime = now === lastPushTime;
        lastPushTime = now;
        var i;
        var timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
            timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
            // NOTE: Can't use << here because javascript will convert to int and lose
            // the upper bits.
            now = Math.floor(now / 64);
        }
        util_1.assert(now === 0, 'Cannot push at time == 0');
        var id = timeStampChars.join('');
        if (!duplicateTime) {
            for (i = 0; i < 12; i++) {
                lastRandChars[i] = Math.floor(Math.random() * 64);
            }
        }
        else {
            // If the timestamp hasn't changed since last push, use the same random
            // number, except incremented by 1.
            for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
                lastRandChars[i] = 0;
            }
            lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
            id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        util_1.assert(id.length === 20, 'nextPushId: Length should be 20.');
        return id;
    };
})();

//# sourceMappingURL=NextPushId.js.map


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DataSnapshot_1 = __webpack_require__(31);
var Event_1 = __webpack_require__(108);
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
/**
 * Represents registration for 'value' events.
 */
var ValueEventRegistration = /** @class */ (function () {
    /**
     * @param {?function(!DataSnapshot)} callback_
     * @param {?function(Error)} cancelCallback_
     * @param {?Object} context_
     */
    function ValueEventRegistration(callback_, cancelCallback_, context_) {
        this.callback_ = callback_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.respondsTo = function (eventType) {
        return eventType === 'value';
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createEvent = function (change, query) {
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent('value', this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, query.getRef(), index));
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_1 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_1.call(ctx, eventData.error);
            };
        }
        else {
            var cb_1 = this.callback_;
            return function () {
                cb_1.call(ctx, eventData.snapshot);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new Event_1.CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.matches = function (other) {
        if (!(other instanceof ValueEventRegistration)) {
            return false;
        }
        else if (!other.callback_ || !this.callback_) {
            // If no callback specified, we consider it to match any callback.
            return true;
        }
        else {
            return (other.callback_ === this.callback_ && other.context_ === this.context_);
        }
    };
    /**
     * @inheritDoc
     */
    ValueEventRegistration.prototype.hasAnyCallback = function () {
        return this.callback_ !== null;
    };
    return ValueEventRegistration;
}());
exports.ValueEventRegistration = ValueEventRegistration;
/**
 * Represents the registration of 1 or more child_xxx events.
 *
 * Currently, it is always exactly 1 child_xxx event, but the idea is we might let you
 * register a group of callbacks together in the future.
 *
 * @constructor
 * @implements {EventRegistration}
 */
var ChildEventRegistration = /** @class */ (function () {
    /**
     * @param {?Object.<string, function(!DataSnapshot, ?string=)>} callbacks_
     * @param {?function(Error)} cancelCallback_
     * @param {Object=} context_
     */
    function ChildEventRegistration(callbacks_, cancelCallback_, context_) {
        this.callbacks_ = callbacks_;
        this.cancelCallback_ = cancelCallback_;
        this.context_ = context_;
    }
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.respondsTo = function (eventType) {
        var eventToCheck = eventType === 'children_added' ? 'child_added' : eventType;
        eventToCheck =
            eventToCheck === 'children_removed' ? 'child_removed' : eventToCheck;
        return util_1.contains(this.callbacks_, eventToCheck);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createCancelEvent = function (error, path) {
        if (this.cancelCallback_) {
            return new Event_1.CancelEvent(this, error, path);
        }
        else {
            return null;
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.createEvent = function (change, query) {
        util_2.assert(change.childName != null, 'Child events should have a childName.');
        var ref = query.getRef().child(/** @type {!string} */ (change.childName));
        var index = query.getQueryParams().getIndex();
        return new Event_1.DataEvent(change.type, this, new DataSnapshot_1.DataSnapshot(change.snapshotNode, ref, index), change.prevName);
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.getEventRunner = function (eventData) {
        var ctx = this.context_;
        if (eventData.getEventType() === 'cancel') {
            util_2.assert(this.cancelCallback_, 'Raising a cancel event on a listener with no cancel callback');
            var cancelCB_2 = this.cancelCallback_;
            return function () {
                // We know that error exists, we checked above that this is a cancel event
                cancelCB_2.call(ctx, eventData.error);
            };
        }
        else {
            var cb_2 = this.callbacks_[eventData.eventType];
            return function () {
                cb_2.call(ctx, eventData.snapshot, eventData.prevName);
            };
        }
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.matches = function (other) {
        if (other instanceof ChildEventRegistration) {
            if (!this.callbacks_ || !other.callbacks_) {
                return true;
            }
            else if (this.context_ === other.context_) {
                var otherCount = util_1.getCount(other.callbacks_);
                var thisCount = util_1.getCount(this.callbacks_);
                if (otherCount === thisCount) {
                    // If count is 1, do an exact match on eventType, if either is defined but null, it's a match.
                    //  If event types don't match, not a match
                    // If count is not 1, exact match across all
                    if (otherCount === 1) {
                        var otherKey /** @type {!string} */ = util_1.getAnyKey(other.callbacks_);
                        var thisKey /** @type {!string} */ = util_1.getAnyKey(this.callbacks_);
                        return (thisKey === otherKey &&
                            (!other.callbacks_[otherKey] ||
                                !this.callbacks_[thisKey] ||
                                other.callbacks_[otherKey] === this.callbacks_[thisKey]));
                    }
                    else {
                        // Exact match on each key.
                        return util_1.every(this.callbacks_, function (eventType, cb) { return other.callbacks_[eventType] === cb; });
                    }
                }
            }
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    ChildEventRegistration.prototype.hasAnyCallback = function () {
        return this.callbacks_ !== null;
    };
    return ChildEventRegistration;
}());
exports.ChildEventRegistration = ChildEventRegistration;

//# sourceMappingURL=EventRegistration.js.map


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
/**
 * Encapsulates the data needed to raise an event
 * @implements {Event}
 */
var DataEvent = /** @class */ (function () {
    /**
     * @param {!string} eventType One of: value, child_added, child_changed, child_moved, child_removed
     * @param {!EventRegistration} eventRegistration The function to call to with the event data. User provided
     * @param {!DataSnapshot} snapshot The data backing the event
     * @param {?string=} prevName Optional, the name of the previous child for child_* events.
     */
    function DataEvent(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
    }
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getPath = function () {
        var ref = this.snapshot.getRef();
        if (this.eventType === 'value') {
            return ref.path;
        }
        else {
            return ref.getParent().path;
        }
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventType = function () {
        return this.eventType;
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    DataEvent.prototype.toString = function () {
        return (this.getPath().toString() +
            ':' +
            this.eventType +
            ':' +
            util_1.stringify(this.snapshot.exportVal()));
    };
    return DataEvent;
}());
exports.DataEvent = DataEvent;
var CancelEvent = /** @class */ (function () {
    /**
     * @param {EventRegistration} eventRegistration
     * @param {Error} error
     * @param {!Path} path
     */
    function CancelEvent(eventRegistration, error, path) {
        this.eventRegistration = eventRegistration;
        this.error = error;
        this.path = path;
    }
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getPath = function () {
        return this.path;
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventType = function () {
        return 'cancel';
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.getEventRunner = function () {
        return this.eventRegistration.getEventRunner(this);
    };
    /**
     * @inheritDoc
     */
    CancelEvent.prototype.toString = function () {
        return this.path.toString() + ':cancel';
    };
    return CancelEvent;
}());
exports.CancelEvent = CancelEvent;

//# sourceMappingURL=Event.js.map


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var AckUserWrite_1 = __webpack_require__(110);
var ChildrenNode_1 = __webpack_require__(4);
var util_3 = __webpack_require__(0);
var ImmutableTree_1 = __webpack_require__(32);
var ListenComplete_1 = __webpack_require__(111);
var Merge_1 = __webpack_require__(112);
var Operation_1 = __webpack_require__(10);
var Overwrite_1 = __webpack_require__(61);
var Path_1 = __webpack_require__(2);
var SyncPoint_1 = __webpack_require__(62);
var WriteTree_1 = __webpack_require__(118);
/**
 * SyncTree is the central class for managing event callback registration, data caching, views
 * (query processing), and event generation.  There are typically two SyncTree instances for
 * each Repo, one for the normal Firebase data, and one for the .info data.
 *
 * It has a number of responsibilities, including:
 *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).
 *  - Applying and caching data changes for user set(), transaction(), and update() calls
 *    (applyUserOverwrite(), applyUserMerge()).
 *  - Applying and caching data changes for server data changes (applyServerOverwrite(),
 *    applyServerMerge()).
 *  - Generating user-facing events for server and user changes (all of the apply* methods
 *    return the set of events that need to be raised as a result).
 *  - Maintaining the appropriate set of server listens to ensure we are always subscribed
 *    to the correct set of paths and queries to satisfy the current set of user event
 *    callbacks (listens are started/stopped using the provided listenProvider).
 *
 * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual
 * events are returned to the caller rather than raised synchronously.
 *
 * @constructor
 */
var SyncTree = /** @class */ (function () {
    /**
     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening
     *   to server data.
     */
    function SyncTree(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        /**
         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.
         * @type {!ImmutableTree.<!SyncPoint>}
         * @private
         */
        this.syncPointTree_ = ImmutableTree_1.ImmutableTree.Empty;
        /**
         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).
         * @type {!WriteTree}
         * @private
         */
        this.pendingWriteTree_ = new WriteTree_1.WriteTree();
        this.tagToQueryMap_ = {};
        this.queryToTagMap_ = {};
    }
    /**
     * Apply the data changes for a user-generated set() or transaction() call.
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @param {number} writeId
     * @param {boolean=} visible
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {
        // Record pending write.
        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);
        if (!visible) {
            return [];
        }
        else {
            return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.User, path, newData));
        }
    };
    /**
     * Apply the data from a user-generated update() call
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {
        // Record pending merge.
        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);
        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.User, path, changeTree));
    };
    /**
     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().
     *
     * @param {!number} writeId
     * @param {boolean=} revert True if the given write failed and needs to be reverted
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.ackUserWrite = function (writeId, revert) {
        if (revert === void 0) { revert = false; }
        var write = this.pendingWriteTree_.getWrite(writeId);
        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);
        if (!needToReevaluate) {
            return [];
        }
        else {
            var affectedTree_1 = ImmutableTree_1.ImmutableTree.Empty;
            if (write.snap != null) {
                // overwrite
                affectedTree_1 = affectedTree_1.set(Path_1.Path.Empty, true);
            }
            else {
                util_3.forEach(write.children, function (pathString, node) {
                    affectedTree_1 = affectedTree_1.set(new Path_1.Path(pathString), node);
                });
            }
            return this.applyOperationToSyncPoints_(new AckUserWrite_1.AckUserWrite(write.path, affectedTree_1, revert));
        }
    };
    /**
     * Apply new server data for the specified path..
     *
     * @param {!Path} path
     * @param {!Node} newData
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerOverwrite = function (path, newData) {
        return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.Server, path, newData));
    };
    /**
     * Apply new server data to be merged in at the specified path.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {
        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.Server, path, changeTree));
    };
    /**
     * Apply a listen complete for a query
     *
     * @param {!Path} path
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyListenComplete = function (path) {
        return this.applyOperationToSyncPoints_(new ListenComplete_1.ListenComplete(Operation_1.OperationSource.Server, path));
    };
    /**
     * Apply new server data for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey != null) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var op = new Overwrite_1.Overwrite(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, snap);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // Query must have been removed already
            return [];
        }
    };
    /**
     * Apply server data to be merged in for the specified tagged query.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);
            var op = new Merge_1.Merge(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Apply a listen complete for a tagged query
     *
     * @param {!Path} path
     * @param {!number} tag
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {
        var queryKey = this.queryKeyForTag_(tag);
        if (queryKey) {
            var r = SyncTree.parseQueryKey_(queryKey);
            var queryPath = r.path, queryId = r.queryId;
            var relativePath = Path_1.Path.relativePath(queryPath, path);
            var op = new ListenComplete_1.ListenComplete(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath);
            return this.applyTaggedOperation_(queryPath, op);
        }
        else {
            // We've already removed the query. No big deal, ignore the update
            return [];
        }
    };
    /**
     * Add an event callback for the specified query.
     *
     * @param {!Query} query
     * @param {!EventRegistration} eventRegistration
     * @return {!Array.<!Event>} Events to raise.
     */
    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {
        var path = query.path;
        var serverCache = null;
        var foundAncestorDefaultView = false;
        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.
        // Consider optimizing this once there's a better understanding of what actual behavior will be.
        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {
            var relativePath = Path_1.Path.relativePath(pathToSyncPoint, path);
            serverCache = serverCache || sp.getCompleteServerCache(relativePath);
            foundAncestorDefaultView =
                foundAncestorDefaultView || sp.hasCompleteView();
        });
        var syncPoint = this.syncPointTree_.get(path);
        if (!syncPoint) {
            syncPoint = new SyncPoint_1.SyncPoint();
            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);
        }
        else {
            foundAncestorDefaultView =
                foundAncestorDefaultView || syncPoint.hasCompleteView();
            serverCache = serverCache || syncPoint.getCompleteServerCache(Path_1.Path.Empty);
        }
        var serverCacheComplete;
        if (serverCache != null) {
            serverCacheComplete = true;
        }
        else {
            serverCacheComplete = false;
            serverCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
            var subtree = this.syncPointTree_.subtree(path);
            subtree.foreachChild(function (childName, childSyncPoint) {
                var completeCache = childSyncPoint.getCompleteServerCache(Path_1.Path.Empty);
                if (completeCache) {
                    serverCache = serverCache.updateImmediateChild(childName, completeCache);
                }
            });
        }
        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);
        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {
            // We need to track a tag for this query
            var queryKey = SyncTree.makeQueryKey_(query);
            util_1.assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');
            var tag = SyncTree.getNextQueryTag_();
            this.queryToTagMap_[queryKey] = tag;
            // Coerce to string to avoid sparse arrays.
            this.tagToQueryMap_['_' + tag] = queryKey;
        }
        var writesCache = this.pendingWriteTree_.childWrites(path);
        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);
        if (!viewAlreadyExists && !foundAncestorDefaultView) {
            var view /** @type !View */ = syncPoint.viewForQuery(query);
            events = events.concat(this.setupListener_(query, view));
        }
        return events;
    };
    /**
     * Remove event callback(s).
     *
     * If query is the default query, we'll check all queries for the specified eventRegistration.
     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.
     *
     * @param {!Query} query
     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {
        var _this = this;
        // Find the syncPoint first. Then deal with whether or not it has matching listeners
        var path = query.path;
        var maybeSyncPoint = this.syncPointTree_.get(path);
        var cancelEvents = [];
        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without
        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and
        // not loadsAllData().
        if (maybeSyncPoint &&
            (query.queryIdentifier() === 'default' ||
                maybeSyncPoint.viewExistsForQuery(query))) {
            /**
             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}
             */
            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);
            if (maybeSyncPoint.isEmpty()) {
                this.syncPointTree_ = this.syncPointTree_.remove(path);
            }
            var removed = removedAndEvents.removed;
            cancelEvents = removedAndEvents.events;
            // We may have just removed one of many listeners and can short-circuit this whole process
            // We may also not have removed a default listener, in which case all of the descendant listeners should already be
            // properly set up.
            //
            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of
            // queryId === 'default'
            var removingDefault = -1 !==
                removed.findIndex(function (query) {
                    return query.getQueryParams().loadsAllData();
                });
            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {
                return parentSyncPoint.hasCompleteView();
            });
            if (removingDefault && !covered) {
                var subtree = this.syncPointTree_.subtree(path);
                // There are potentially child listeners. Determine what if any listens we need to send before executing the
                // removal
                if (!subtree.isEmpty()) {
                    // We need to fold over our subtree and collect the listeners to send
                    var newViews = this.collectDistinctViewsForSubTree_(subtree);
                    // Ok, we've collected all the listens we need. Set them up.
                    for (var i = 0; i < newViews.length; ++i) {
                        var view = newViews[i], newQuery = view.getQuery();
                        var listener = this.createListenerForView_(view);
                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);
                    }
                }
                else {
                    // There's nothing below us, so nothing we need to start listening on
                }
            }
            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query
            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.
            // Also, note that if we have a cancelError, it's already been removed at the provider level.
            if (!covered && removed.length > 0 && !cancelError) {
                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one
                // default. Otherwise, we need to iterate through and cancel each individual query
                if (removingDefault) {
                    // We don't tag default listeners
                    var defaultTag = null;
                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);
                }
                else {
                    removed.forEach(function (queryToRemove) {
                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];
                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);
                    });
                }
            }
            // Now, clear all of the tags we're tracking for the removed listens
            this.removeTags_(removed);
        }
        else {
            // No-op, this listener must've been already removed
        }
        return cancelEvents;
    };
    /**
     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above
     * it, but as this is only used by transaction code, that should always be the case anyways.
     *
     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.
     * @param {!Path} path The path to the data we want
     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded
     * @return {?Node}
     */
    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {
        var includeHiddenSets = true;
        var writeTree = this.pendingWriteTree_;
        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {
            var relativePath = Path_1.Path.relativePath(pathSoFar, path);
            var serverCache = syncPoint.getCompleteServerCache(relativePath);
            if (serverCache) {
                return serverCache;
            }
        });
        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);
    };
    /**
     * This collapses multiple unfiltered views into a single view, since we only need a single
     * listener for them.
     *
     * @param {!ImmutableTree.<!SyncPoint>} subtree
     * @return {!Array.<!View>}
     * @private
     */
    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {
        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {
                var completeView = maybeChildSyncPoint.getCompleteView();
                return [completeView];
            }
            else {
                // No complete view here, flatten any deeper listens into an array
                var views_1 = [];
                if (maybeChildSyncPoint) {
                    views_1 = maybeChildSyncPoint.getQueryViews();
                }
                util_3.forEach(childMap, function (key, childViews) {
                    views_1 = views_1.concat(childViews);
                });
                return views_1;
            }
        });
    };
    /**
     * @param {!Array.<!Query>} queries
     * @private
     */
    SyncTree.prototype.removeTags_ = function (queries) {
        for (var j = 0; j < queries.length; ++j) {
            var removedQuery = queries[j];
            if (!removedQuery.getQueryParams().loadsAllData()) {
                // We should have a tag for this
                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);
                var removedQueryTag = this.queryToTagMap_[removedQueryKey];
                delete this.queryToTagMap_[removedQueryKey];
                delete this.tagToQueryMap_['_' + removedQueryTag];
            }
        }
    };
    /**
     * Normalizes a query to a query we send the server for listening
     * @param {!Query} query
     * @return {!Query} The normalized query
     * @private
     */
    SyncTree.queryForListening_ = function (query) {
        if (query.getQueryParams().loadsAllData() &&
            !query.getQueryParams().isDefault()) {
            // We treat queries that load all data as default queries
            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits
            // from Query
            return /** @type {!Query} */ query.getRef();
        }
        else {
            return query;
        }
    };
    /**
     * For a given new listen, manage the de-duplication of outstanding subscriptions.
     *
     * @param {!Query} query
     * @param {!View} view
     * @return {!Array.<!Event>} This method can return events to support synchronous data sources
     * @private
     */
    SyncTree.prototype.setupListener_ = function (query, view) {
        var path = query.path;
        var tag = this.tagForQuery_(query);
        var listener = this.createListenerForView_(view);
        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);
        var subtree = this.syncPointTree_.subtree(path);
        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we
        // may need to shadow other listens as well.
        if (tag) {
            util_1.assert(!subtree.value.hasCompleteView(), "If we're adding a query, it shouldn't be shadowed");
        }
        else {
            // Shadow everything at or below this location, this is a default listener.
            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {
                if (!relativePath.isEmpty() &&
                    maybeChildSyncPoint &&
                    maybeChildSyncPoint.hasCompleteView()) {
                    return [maybeChildSyncPoint.getCompleteView().getQuery()];
                }
                else {
                    // No default listener here, flatten any deeper queries into an array
                    var queries_1 = [];
                    if (maybeChildSyncPoint) {
                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));
                    }
                    util_3.forEach(childMap, function (key, childQueries) {
                        queries_1 = queries_1.concat(childQueries);
                    });
                    return queries_1;
                }
            });
            for (var i = 0; i < queriesToStop.length; ++i) {
                var queryToStop = queriesToStop[i];
                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));
            }
        }
        return events;
    };
    /**
     *
     * @param {!View} view
     * @return {{hashFn: function(), onComplete: function(!string, *)}}
     * @private
     */
    SyncTree.prototype.createListenerForView_ = function (view) {
        var _this = this;
        var query = view.getQuery();
        var tag = this.tagForQuery_(query);
        return {
            hashFn: function () {
                var cache = view.getServerCache() || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                return cache.hash();
            },
            onComplete: function (status) {
                if (status === 'ok') {
                    if (tag) {
                        return _this.applyTaggedListenComplete(query.path, tag);
                    }
                    else {
                        return _this.applyListenComplete(query.path);
                    }
                }
                else {
                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.
                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children
                    var error = util_2.errorForServerCode(status, query);
                    return _this.removeEventRegistration(query, 
                    /*eventRegistration*/ null, error);
                }
            }
        };
    };
    /**
     * Given a query, computes a "queryKey" suitable for use in our queryToTagMap_.
     * @private
     * @param {!Query} query
     * @return {string}
     */
    SyncTree.makeQueryKey_ = function (query) {
        return query.path.toString() + '$' + query.queryIdentifier();
    };
    /**
     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.
     * @private
     * @param {!string} queryKey
     * @return {{queryId: !string, path: !Path}}
     */
    SyncTree.parseQueryKey_ = function (queryKey) {
        var splitIndex = queryKey.indexOf('$');
        util_1.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');
        return {
            queryId: queryKey.substr(splitIndex + 1),
            path: new Path_1.Path(queryKey.substr(0, splitIndex))
        };
    };
    /**
     * Return the query associated with the given tag, if we have one
     * @param {!number} tag
     * @return {?string}
     * @private
     */
    SyncTree.prototype.queryKeyForTag_ = function (tag) {
        return this.tagToQueryMap_['_' + tag];
    };
    /**
     * Return the tag associated with the given query.
     * @param {!Query} query
     * @return {?number}
     * @private
     */
    SyncTree.prototype.tagForQuery_ = function (query) {
        var queryKey = SyncTree.makeQueryKey_(query);
        return util_3.safeGet(this.queryToTagMap_, queryKey);
    };
    /**
     * Static accessor for query tags.
     * @return {number}
     * @private
     */
    SyncTree.getNextQueryTag_ = function () {
        return SyncTree.nextQueryTag_++;
    };
    /**
     * A helper method to apply tagged operations
     *
     * @param {!Path} queryPath
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {
        var syncPoint = this.syncPointTree_.get(queryPath);
        util_1.assert(syncPoint, "Missing sync point for query tag that we're tracking");
        var writesCache = this.pendingWriteTree_.childWrites(queryPath);
        return syncPoint.applyOperation(operation, writesCache, 
        /*serverCache=*/ null);
    };
    /**
     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.
     *
     * NOTES:
     * - Descendant SyncPoints will be visited first (since we raise events depth-first).
  
     * - We call applyOperation() on each SyncPoint passing three things:
     *   1. A version of the Operation that has been made relative to the SyncPoint location.
     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.
     *   3. A snapshot Node with cached server data, if we have it.
  
     * - We concatenate all of the events returned by each SyncPoint and return the result.
     *
     * @param {!Operation} operation
     * @return {!Array.<!Event>}
     * @private
     */
    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {
        return this.applyOperationHelper_(operation, this.syncPointTree_, 
        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path_1.Path.Empty));
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        if (operation.path.isEmpty()) {
            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
        }
        else {
            var syncPoint = syncPointTree.get(Path_1.Path.Empty);
            // If we don't have cached server data, see if we can get it from this SyncPoint.
            if (serverCache == null && syncPoint != null) {
                serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);
            }
            var events = [];
            var childName = operation.path.getFront();
            var childOperation = operation.operationForChild(childName);
            var childTree = syncPointTree.children.get(childName);
            if (childTree && childOperation) {
                var childServerCache = serverCache
                    ? serverCache.getImmediateChild(childName)
                    : null;
                var childWritesCache = writesCache.child(childName);
                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
            if (syncPoint) {
                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
            }
            return events;
        }
    };
    /**
     * Recursive helper for applyOperationToSyncPoints_
     *
     * @private
     * @param {!Operation} operation
     * @param {ImmutableTree.<!SyncPoint>} syncPointTree
     * @param {?Node} serverCache
     * @param {!WriteTreeRef} writesCache
     * @return {!Array.<!Event>}
     */
    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {
        var _this = this;
        var syncPoint = syncPointTree.get(Path_1.Path.Empty);
        // If we don't have cached server data, see if we can get it from this SyncPoint.
        if (serverCache == null && syncPoint != null) {
            serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);
        }
        var events = [];
        syncPointTree.children.inorderTraversal(function (childName, childTree) {
            var childServerCache = serverCache
                ? serverCache.getImmediateChild(childName)
                : null;
            var childWritesCache = writesCache.child(childName);
            var childOperation = operation.operationForChild(childName);
            if (childOperation) {
                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
            }
        });
        if (syncPoint) {
            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));
        }
        return events;
    };
    /**
     * Static tracker for next query tag.
     * @type {number}
     * @private
     */
    SyncTree.nextQueryTag_ = 1;
    return SyncTree;
}());
exports.SyncTree = SyncTree;

//# sourceMappingURL=SyncTree.js.map


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Path_1 = __webpack_require__(2);
var Operation_1 = __webpack_require__(10);
var AckUserWrite = /** @class */ (function () {
    /**
     *
     * @param {!Path} path
     * @param {!ImmutableTree<!boolean>} affectedTree A tree containing true for each affected path. Affected paths can't overlap.
     * @param {!boolean} revert
     */
    function AckUserWrite(
        /**@inheritDoc */ path, 
        /**@inheritDoc */ affectedTree, 
        /**@inheritDoc */ revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.ACK_USER_WRITE;
        /** @inheritDoc */
        this.source = Operation_1.OperationSource.User;
    }
    /**
     * @inheritDoc
     */
    AckUserWrite.prototype.operationForChild = function (childName) {
        if (!this.path.isEmpty()) {
            util_1.assert(this.path.getFront() === childName, 'operationForChild called for unrelated child.');
            return new AckUserWrite(this.path.popFront(), this.affectedTree, this.revert);
        }
        else if (this.affectedTree.value != null) {
            util_1.assert(this.affectedTree.children.isEmpty(), 'affectedTree should not have overlapping affected paths.');
            // All child locations are affected as well; just return same operation.
            return this;
        }
        else {
            var childTree = this.affectedTree.subtree(new Path_1.Path(childName));
            return new AckUserWrite(Path_1.Path.Empty, childTree, this.revert);
        }
    };
    return AckUserWrite;
}());
exports.AckUserWrite = AckUserWrite;

//# sourceMappingURL=AckUserWrite.js.map


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Path_1 = __webpack_require__(2);
var Operation_1 = __webpack_require__(10);
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @constructor
 * @implements {Operation}
 */
var ListenComplete = /** @class */ (function () {
    function ListenComplete(source, path) {
        this.source = source;
        this.path = path;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.LISTEN_COMPLETE;
    }
    ListenComplete.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            return new ListenComplete(this.source, Path_1.Path.Empty);
        }
        else {
            return new ListenComplete(this.source, this.path.popFront());
        }
    };
    return ListenComplete;
}());
exports.ListenComplete = ListenComplete;

//# sourceMappingURL=ListenComplete.js.map


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = __webpack_require__(10);
var Overwrite_1 = __webpack_require__(61);
var Path_1 = __webpack_require__(2);
var util_1 = __webpack_require__(0);
/**
 * @param {!OperationSource} source
 * @param {!Path} path
 * @param {!ImmutableTree.<!Node>} children
 * @constructor
 * @implements {Operation}
 */
var Merge = /** @class */ (function () {
    function Merge(
        /**@inheritDoc */ source, 
        /**@inheritDoc */ path, 
        /**@inheritDoc */ children) {
        this.source = source;
        this.path = path;
        this.children = children;
        /** @inheritDoc */
        this.type = Operation_1.OperationType.MERGE;
    }
    /**
     * @inheritDoc
     */
    Merge.prototype.operationForChild = function (childName) {
        if (this.path.isEmpty()) {
            var childTree = this.children.subtree(new Path_1.Path(childName));
            if (childTree.isEmpty()) {
                // This child is unaffected
                return null;
            }
            else if (childTree.value) {
                // We have a snapshot for the child in question.  This becomes an overwrite of the child.
                return new Overwrite_1.Overwrite(this.source, Path_1.Path.Empty, childTree.value);
            }
            else {
                // This is a merge at a deeper level
                return new Merge(this.source, Path_1.Path.Empty, childTree);
            }
        }
        else {
            util_1.assert(this.path.getFront() === childName, "Can't get a merge for a child not on the path of the operation");
            return new Merge(this.source, this.path.popFront(), this.children);
        }
    };
    /**
     * @inheritDoc
     */
    Merge.prototype.toString = function () {
        return ('Operation(' +
            this.path +
            ': ' +
            this.source.toString() +
            ' merge: ' +
            this.children.toString() +
            ')');
    };
    return Merge;
}());
exports.Merge = Merge;

//# sourceMappingURL=Merge.js.map


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IndexedFilter_1 = __webpack_require__(33);
var ViewProcessor_1 = __webpack_require__(114);
var ChildrenNode_1 = __webpack_require__(4);
var CacheNode_1 = __webpack_require__(24);
var ViewCache_1 = __webpack_require__(63);
var EventGenerator_1 = __webpack_require__(117);
var util_1 = __webpack_require__(0);
var Operation_1 = __webpack_require__(10);
var Change_1 = __webpack_require__(12);
var PriorityIndex_1 = __webpack_require__(3);
/**
 * A view represents a specific location and query that has 1 or more event registrations.
 *
 * It does several things:
 *  - Maintains the list of event registrations for this location/query.
 *  - Maintains a cache of the data visible for this location/query.
 *  - Applies new operations (via applyOperation), updates the cache, and based on the event
 *    registrations returns the set of events to be raised.
 * @constructor
 */
var View = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     * @param {!ViewCache} initialViewCache
     */
    function View(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        var params = this.query_.getQueryParams();
        var indexFilter = new IndexedFilter_1.IndexedFilter(params.getIndex());
        var filter = params.getNodeFilter();
        /**
         * @type {ViewProcessor}
         * @private
         */
        this.processor_ = new ViewProcessor_1.ViewProcessor(filter);
        var initialServerCache = initialViewCache.getServerCache();
        var initialEventCache = initialViewCache.getEventCache();
        // Don't filter server node with other filter than index, wait for tagged listen
        var serverSnap = indexFilter.updateFullNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        var eventSnap = filter.updateFullNode(ChildrenNode_1.ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        var newServerCache = new CacheNode_1.CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        var newEventCache = new CacheNode_1.CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        /**
         * @type {!ViewCache}
         * @private
         */
        this.viewCache_ = new ViewCache_1.ViewCache(newEventCache, newServerCache);
        /**
         * @type {!EventGenerator}
         * @private
         */
        this.eventGenerator_ = new EventGenerator_1.EventGenerator(this.query_);
    }
    /**
     * @return {!Query}
     */
    View.prototype.getQuery = function () {
        return this.query_;
    };
    /**
     * @return {?Node}
     */
    View.prototype.getServerCache = function () {
        return this.viewCache_.getServerCache().getNode();
    };
    /**
     * @param {!Path} path
     * @return {?Node}
     */
    View.prototype.getCompleteServerCache = function (path) {
        var cache = this.viewCache_.getCompleteServerSnap();
        if (cache) {
            // If this isn't a "loadsAllData" view, then cache isn't actually a complete cache and
            // we need to see if it contains the child we're interested in.
            if (this.query_.getQueryParams().loadsAllData() ||
                (!path.isEmpty() && !cache.getImmediateChild(path.getFront()).isEmpty())) {
                return cache.getChild(path);
            }
        }
        return null;
    };
    /**
     * @return {boolean}
     */
    View.prototype.isEmpty = function () {
        return this.eventRegistrations_.length === 0;
    };
    /**
     * @param {!EventRegistration} eventRegistration
     */
    View.prototype.addEventRegistration = function (eventRegistration) {
        this.eventRegistrations_.push(eventRegistration);
    };
    /**
     * @param {?EventRegistration} eventRegistration If null, remove all callbacks.
     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.
     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.
     */
    View.prototype.removeEventRegistration = function (eventRegistration, cancelError) {
        var cancelEvents = [];
        if (cancelError) {
            util_1.assert(eventRegistration == null, 'A cancel should cancel all event registrations.');
            var path_1 = this.query_.path;
            this.eventRegistrations_.forEach(function (registration) {
                cancelError /** @type {!Error} */ = cancelError;
                var maybeEvent = registration.createCancelEvent(cancelError, path_1);
                if (maybeEvent) {
                    cancelEvents.push(maybeEvent);
                }
            });
        }
        if (eventRegistration) {
            var remaining = [];
            for (var i = 0; i < this.eventRegistrations_.length; ++i) {
                var existing = this.eventRegistrations_[i];
                if (!existing.matches(eventRegistration)) {
                    remaining.push(existing);
                }
                else if (eventRegistration.hasAnyCallback()) {
                    // We're removing just this one
                    remaining = remaining.concat(this.eventRegistrations_.slice(i + 1));
                    break;
                }
            }
            this.eventRegistrations_ = remaining;
        }
        else {
            this.eventRegistrations_ = [];
        }
        return cancelEvents;
    };
    /**
     * Applies the given Operation, updates our cache, and returns the appropriate events.
     *
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @return {!Array.<!Event>}
     */
    View.prototype.applyOperation = function (operation, writesCache, completeServerCache) {
        if (operation.type === Operation_1.OperationType.MERGE &&
            operation.source.queryId !== null) {
            util_1.assert(this.viewCache_.getCompleteServerSnap(), 'We should always have a full cache before handling merges');
            util_1.assert(this.viewCache_.getCompleteEventSnap(), 'Missing event cache, even though we have a server cache');
        }
        var oldViewCache = this.viewCache_;
        var result = this.processor_.applyOperation(oldViewCache, operation, writesCache, completeServerCache);
        this.processor_.assertIndexed(result.viewCache);
        util_1.assert(result.viewCache.getServerCache().isFullyInitialized() ||
            !oldViewCache.getServerCache().isFullyInitialized(), 'Once a server snap is complete, it should never go back');
        this.viewCache_ = result.viewCache;
        return this.generateEventsForChanges_(result.changes, result.viewCache.getEventCache().getNode(), null);
    };
    /**
     * @param {!EventRegistration} registration
     * @return {!Array.<!Event>}
     */
    View.prototype.getInitialEvents = function (registration) {
        var eventSnap = this.viewCache_.getEventCache();
        var initialChanges = [];
        if (!eventSnap.getNode().isLeafNode()) {
            var eventNode = eventSnap.getNode();
            eventNode.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, childNode) {
                initialChanges.push(Change_1.Change.childAddedChange(key, childNode));
            });
        }
        if (eventSnap.isFullyInitialized()) {
            initialChanges.push(Change_1.Change.valueChange(eventSnap.getNode()));
        }
        return this.generateEventsForChanges_(initialChanges, eventSnap.getNode(), registration);
    };
    /**
     * @private
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {EventRegistration=} eventRegistration
     * @return {!Array.<!Event>}
     */
    View.prototype.generateEventsForChanges_ = function (changes, eventCache, eventRegistration) {
        var registrations = eventRegistration
            ? [eventRegistration]
            : this.eventRegistrations_;
        return this.eventGenerator_.generateEventsForChanges(changes, eventCache, registrations);
    };
    return View;
}());
exports.View = View;

//# sourceMappingURL=View.js.map


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Operation_1 = __webpack_require__(10);
var util_1 = __webpack_require__(0);
var ChildChangeAccumulator_1 = __webpack_require__(115);
var Change_1 = __webpack_require__(12);
var ChildrenNode_1 = __webpack_require__(4);
var KeyIndex_1 = __webpack_require__(14);
var ImmutableTree_1 = __webpack_require__(32);
var Path_1 = __webpack_require__(2);
var CompleteChildSource_1 = __webpack_require__(116);
/**
 * @constructor
 * @struct
 */
var ProcessorResult = /** @class */ (function () {
    /**
     * @param {!ViewCache} viewCache
     * @param {!Array.<!Change>} changes
     */
    function ProcessorResult(viewCache, changes) {
        this.viewCache = viewCache;
        this.changes = changes;
    }
    return ProcessorResult;
}());
exports.ProcessorResult = ProcessorResult;
/**
 * @constructor
 */
var ViewProcessor = /** @class */ (function () {
    /**
     * @param {!NodeFilter} filter_
     */
    function ViewProcessor(filter_) {
        this.filter_ = filter_;
    }
    /**
     * @param {!ViewCache} viewCache
     */
    ViewProcessor.prototype.assertIndexed = function (viewCache) {
        util_1.assert(viewCache
            .getEventCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Event snap not indexed');
        util_1.assert(viewCache
            .getServerCache()
            .getNode()
            .isIndexed(this.filter_.getIndex()), 'Server snap not indexed');
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Operation} operation
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @return {!ProcessorResult}
     */
    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {
        var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();
        var newViewCache, filterServerNode;
        if (operation.type === Operation_1.OperationType.OVERWRITE) {
            var overwrite = operation;
            if (overwrite.source.fromUser) {
                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
            }
            else {
                util_1.assert(overwrite.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered  and the
                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered
                // again
                filterServerNode =
                    overwrite.source.tagged ||
                        (oldViewCache.getServerCache().isFiltered() &&
                            !overwrite.path.isEmpty());
                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.MERGE) {
            var merge = operation;
            if (merge.source.fromUser) {
                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
            }
            else {
                util_1.assert(merge.source.fromServer, 'Unknown source.');
                // We filter the node if it's a tagged update or the node has been previously filtered
                filterServerNode =
                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();
                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {
            var ackUserWrite = operation;
            if (!ackUserWrite.revert) {
                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
            }
            else {
                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
            }
        }
        else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {
            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);
        }
        else {
            throw util_1.assertionError('Unknown operation type: ' + operation.type);
        }
        var changes = accumulator.getChanges();
        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);
        return new ProcessorResult(newViewCache, changes);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!ViewCache} newViewCache
     * @param {!Array.<!Change>} accumulator
     * @private
     */
    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {
        var eventSnap = newViewCache.getEventCache();
        if (eventSnap.isFullyInitialized()) {
            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();
            if (accumulator.length > 0 ||
                !oldViewCache.getEventCache().isFullyInitialized() ||
                (isLeafOrEmpty &&
                    !eventSnap
                        .getNode()
                        .equals(/** @type {!Node} */ (oldCompleteSnap))) ||
                !eventSnap
                    .getNode()
                    .getPriority()
                    .equals(oldCompleteSnap.getPriority())) {
                accumulator.push(Change_1.Change.valueChange(
                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));
            }
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} changePath
     * @param {!WriteTreeRef} writesCache
     * @param {!CompleteChildSource} source
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {
        var oldEventSnap = viewCache.getEventCache();
        if (writesCache.shadowingWrite(changePath) != null) {
            // we have a shadowing write, ignore changes
            return viewCache;
        }
        else {
            var newEventCache = void 0, serverNode = void 0;
            if (changePath.isEmpty()) {
                // TODO: figure out how this plays with "sliding ack windows"
                util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');
                if (viewCache.getServerCache().isFiltered()) {
                    // We need to special case this, because we need to only apply writes to complete children, or
                    // we might end up raising events for incomplete children. If the server data is filtered deep
                    // writes cannot be guaranteed to be complete
                    var serverCache = viewCache.getCompleteServerSnap();
                    var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode
                        ? serverCache
                        : ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);
                }
                else {
                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);
                }
            }
            else {
                var childKey = changePath.getFront();
                if (childKey == '.priority') {
                    util_1.assert(changePath.getLength() == 1, "Can't have a priority with additional path components");
                    var oldEventNode = oldEventSnap.getNode();
                    serverNode = viewCache.getServerCache().getNode();
                    // we might have overwrites for this priority
                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);
                    if (updatedPriority != null) {
                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);
                    }
                    else {
                        // priority didn't change, keep old node
                        newEventCache = oldEventSnap.getNode();
                    }
                }
                else {
                    var childChangePath = changePath.popFront();
                    // update child
                    var newEventChild = void 0;
                    if (oldEventSnap.isCompleteForChild(childKey)) {
                        serverNode = viewCache.getServerCache().getNode();
                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);
                        if (eventChildUpdate != null) {
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey)
                                .updateChild(childChangePath, eventChildUpdate);
                        }
                        else {
                            // Nothing changed, just keep the old child
                            newEventChild = oldEventSnap
                                .getNode()
                                .getImmediateChild(childKey);
                        }
                    }
                    else {
                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                    }
                    if (newEventChild != null) {
                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
                    }
                    else {
                        // no complete child available or no change
                        newEventCache = oldEventSnap.getNode();
                    }
                }
            }
            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());
        }
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
        var oldServerSnap = oldViewCache.getServerCache();
        var newServerCache;
        var serverFilter = filterServerNode
            ? this.filter_
            : this.filter_.getIndexedFilter();
        if (changePath.isEmpty()) {
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
        }
        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update
            var newServerNode = oldServerSnap
                .getNode()
                .updateChild(changePath, changedSnap);
            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
        }
        else {
            var childKey = changePath.getFront();
            if (!oldServerSnap.isCompleteForPath(changePath) &&
                changePath.getLength() > 1) {
                // We don't update incomplete nodes with updates intended for other listeners
                return oldViewCache;
            }
            var childChangePath = changePath.popFront();
            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
            var newChildNode = childNode.updateChild(childChangePath, changedSnap);
            if (childKey == '.priority') {
                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
            }
            else {
                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);
            }
        }
        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());
        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);
        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);
    };
    /**
     * @param {!ViewCache} oldViewCache
     * @param {!Path} changePath
     * @param {!Node} changedSnap
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
        var oldEventSnap = oldViewCache.getEventCache();
        var newViewCache, newEventCache;
        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
        if (changePath.isEmpty()) {
            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);
            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());
        }
        else {
            var childKey = changePath.getFront();
            if (childKey === '.priority') {
                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);
                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
            }
            else {
                var childChangePath = changePath.popFront();
                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
                var newChild = void 0;
                if (childChangePath.isEmpty()) {
                    // Child overwrite, we can replace the child
                    newChild = changedSnap;
                }
                else {
                    var childNode = source.getCompleteChild(childKey);
                    if (childNode != null) {
                        if (childChangePath.getBack() === '.priority' &&
                            childNode.getChild(childChangePath.parent()).isEmpty()) {
                            // This is a priority update on an empty node. If this node exists on the server, the
                            // server will send down the priority in the update, so ignore for now
                            newChild = childNode;
                        }
                        else {
                            newChild = childNode.updateChild(childChangePath, changedSnap);
                        }
                    }
                    else {
                        // There is no complete child node available
                        newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    }
                }
                if (!oldChild.equals(newChild)) {
                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());
                }
                else {
                    newViewCache = oldViewCache;
                }
            }
        }
        return newViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {string} childKey
     * @return {boolean}
     * @private
     */
    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {
        return viewCache.getEventCache().isCompleteForChild(childKey);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
        var _this = this;
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        changedChildren.foreach(function (relativePath, childNode) {
            var writePath = path.child(relativePath);
            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {
                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!Node} node
     * @param {ImmutableTree.<!Node>} merge
     * @return {!Node}
     * @private
     */
    ViewProcessor.prototype.applyMerge_ = function (node, merge) {
        merge.foreach(function (relativePath, childNode) {
            node = node.updateChild(relativePath, childNode);
        });
        return node;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!ImmutableTree.<!Node>} changedChildren
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} serverCache
     * @param {boolean} filterServerNode
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
        var _this = this;
        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and
        // wait for the complete data update coming soon.
        if (viewCache
            .getServerCache()
            .getNode()
            .isEmpty() &&
            !viewCache.getServerCache().isFullyInitialized()) {
            return viewCache;
        }
        // HACK: In the case of a limit query, there may be some changes that bump things out of the
        // window leaving room for new items.  It's important we process these changes first, so we
        // iterate the changes twice, first processing any that affect items currently in view.
        // TODO: I consider an item "in view" if cacheHasChild is true, which checks both the server
        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but
        // not the other.
        var curViewCache = viewCache;
        var viewMergeTree;
        if (path.isEmpty()) {
            viewMergeTree = changedChildren;
        }
        else {
            viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);
        }
        var serverNode = viewCache.getServerCache().getNode();
        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {
            if (serverNode.hasChild(childKey)) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {
            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&
                childMergeTree.value == null;
            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
                var serverChild = viewCache
                    .getServerCache()
                    .getNode()
                    .getImmediateChild(childKey);
                var newChild = _this.applyMerge_(serverChild, childMergeTree);
                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
            }
        });
        return curViewCache;
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} ackPath
     * @param {!ImmutableTree<!boolean>} affectedTree
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
        if (writesCache.shadowingWrite(ackPath) != null) {
            return viewCache;
        }
        // Only filter server node if it is currently filtered
        var filterServerNode = viewCache.getServerCache().isFiltered();
        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update
        // now that it won't be shadowed.
        var serverCache = viewCache.getServerCache();
        if (affectedTree.value != null) {
            // This is an overwrite.
            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||
                serverCache.isCompleteForPath(ackPath)) {
                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
            }
            else if (ackPath.isEmpty()) {
                // This is a goofy edge case where we are acking data at this location but don't have full data.  We
                // should just re-apply whatever we have in our cache as a merge.
                var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;
                serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {
                    changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);
                });
                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
            }
            else {
                return viewCache;
            }
        }
        else {
            // This is a merge.
            var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;
            affectedTree.foreach(function (mergePath, value) {
                var serverCachePath = ackPath.child(mergePath);
                if (serverCache.isCompleteForPath(serverCachePath)) {
                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
                }
            });
            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
        }
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {
        var oldServerNode = viewCache.getServerCache();
        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());
        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);
    };
    /**
     * @param {!ViewCache} viewCache
     * @param {!Path} path
     * @param {!WriteTreeRef} writesCache
     * @param {?Node} completeServerCache
     * @param {!ChildChangeAccumulator} accumulator
     * @return {!ViewCache}
     * @private
     */
    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {
        var complete;
        if (writesCache.shadowingWrite(path) != null) {
            return viewCache;
        }
        else {
            var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
            var oldEventCache = viewCache.getEventCache().getNode();
            var newEventCache = void 0;
            if (path.isEmpty() || path.getFront() === '.priority') {
                var newNode = void 0;
                if (viewCache.getServerCache().isFullyInitialized()) {
                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                }
                else {
                    var serverChildren = viewCache.getServerCache().getNode();
                    util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');
                    newNode = writesCache.calcCompleteEventChildren(serverChildren);
                }
                newNode = newNode;
                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);
            }
            else {
                var childKey = path.getFront();
                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());
                if (newChild == null &&
                    viewCache.getServerCache().isCompleteForChild(childKey)) {
                    newChild = oldEventCache.getImmediateChild(childKey);
                }
                if (newChild != null) {
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);
                }
                else if (viewCache
                    .getEventCache()
                    .getNode()
                    .hasChild(childKey)) {
                    // No complete child available, delete the existing one, if any
                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);
                }
                else {
                    newEventCache = oldEventCache;
                }
                if (newEventCache.isEmpty() &&
                    viewCache.getServerCache().isFullyInitialized()) {
                    // We might have reverted all child writes. Maybe the old event was a leaf node
                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());
                    if (complete.isLeafNode()) {
                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);
                    }
                }
            }
            complete =
                viewCache.getServerCache().isFullyInitialized() ||
                    writesCache.shadowingWrite(Path_1.Path.Empty) != null;
            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());
        }
    };
    return ViewProcessor;
}());
exports.ViewProcessor = ViewProcessor;

//# sourceMappingURL=ViewProcessor.js.map


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Change_1 = __webpack_require__(12);
var util_2 = __webpack_require__(0);
/**
 * @constructor
 */
var ChildChangeAccumulator = /** @class */ (function () {
    function ChildChangeAccumulator() {
        this.changeMap_ = {};
    }
    /**
     * @param {!Change} change
     */
    ChildChangeAccumulator.prototype.trackChildChange = function (change) {
        var type = change.type;
        var childKey /** @type {!string} */ = change.childName;
        util_2.assert(type == Change_1.Change.CHILD_ADDED ||
            type == Change_1.Change.CHILD_CHANGED ||
            type == Change_1.Change.CHILD_REMOVED, 'Only child changes supported for tracking');
        util_2.assert(childKey !== '.priority', 'Only non-priority child changes can be tracked.');
        var oldChange = util_1.safeGet(this.changeMap_, childKey);
        if (oldChange) {
            var oldType = oldChange.type;
            if (type == Change_1.Change.CHILD_ADDED && oldType == Change_1.Change.CHILD_REMOVED) {
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.snapshotNode);
            }
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_ADDED) {
                delete this.changeMap_[childKey];
            }
            else if (type == Change_1.Change.CHILD_REMOVED &&
                oldType == Change_1.Change.CHILD_CHANGED) {
                this.changeMap_[childKey] = Change_1.Change.childRemovedChange(childKey, oldChange.oldSnap);
            }
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_ADDED) {
                this.changeMap_[childKey] = Change_1.Change.childAddedChange(childKey, change.snapshotNode);
            }
            else if (type == Change_1.Change.CHILD_CHANGED &&
                oldType == Change_1.Change.CHILD_CHANGED) {
                this.changeMap_[childKey] = Change_1.Change.childChangedChange(childKey, change.snapshotNode, oldChange.oldSnap);
            }
            else {
                throw util_2.assertionError('Illegal combination of changes: ' +
                    change +
                    ' occurred after ' +
                    oldChange);
            }
        }
        else {
            this.changeMap_[childKey] = change;
        }
    };
    /**
     * @return {!Array.<!Change>}
     */
    ChildChangeAccumulator.prototype.getChanges = function () {
        return util_1.getValues(this.changeMap_);
    };
    return ChildChangeAccumulator;
}());
exports.ChildChangeAccumulator = ChildChangeAccumulator;

//# sourceMappingURL=ChildChangeAccumulator.js.map


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var CacheNode_1 = __webpack_require__(24);
/**
 * An implementation of CompleteChildSource that never returns any additional children
 *
 * @private
 * @constructor
 * @implements CompleteChildSource
 */
var NoCompleteChildSource_ = /** @class */ (function () {
    function NoCompleteChildSource_() {
    }
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getCompleteChild = function (childKey) {
        return null;
    };
    /**
     * @inheritDoc
     */
    NoCompleteChildSource_.prototype.getChildAfterChild = function (index, child, reverse) {
        return null;
    };
    return NoCompleteChildSource_;
}());
exports.NoCompleteChildSource_ = NoCompleteChildSource_;
/**
 * Singleton instance.
 * @const
 * @type {!CompleteChildSource}
 */
exports.NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
/**
 * An implementation of CompleteChildSource that uses a WriteTree in addition to any other server data or
 * old event caches available to calculate complete children.
 *
 *
 * @implements CompleteChildSource
 */
var WriteTreeCompleteChildSource = /** @class */ (function () {
    /**
     * @param {!WriteTreeRef} writes_
     * @param {!ViewCache} viewCache_
     * @param {?Node} optCompleteServerCache_
     */
    function WriteTreeCompleteChildSource(writes_, viewCache_, optCompleteServerCache_) {
        if (optCompleteServerCache_ === void 0) { optCompleteServerCache_ = null; }
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getCompleteChild = function (childKey) {
        var node = this.viewCache_.getEventCache();
        if (node.isCompleteForChild(childKey)) {
            return node.getNode().getImmediateChild(childKey);
        }
        else {
            var serverNode = this.optCompleteServerCache_ != null
                ? new CacheNode_1.CacheNode(this.optCompleteServerCache_, true, false)
                : this.viewCache_.getServerCache();
            return this.writes_.calcCompleteChild(childKey, serverNode);
        }
    };
    /**
     * @inheritDoc
     */
    WriteTreeCompleteChildSource.prototype.getChildAfterChild = function (index, child, reverse) {
        var completeServerData = this.optCompleteServerCache_ != null
            ? this.optCompleteServerCache_
            : this.viewCache_.getCompleteServerSnap();
        var nodes = this.writes_.calcIndexedSlice(completeServerData, child, 1, reverse, index);
        if (nodes.length === 0) {
            return null;
        }
        else {
            return nodes[0];
        }
    };
    return WriteTreeCompleteChildSource;
}());
exports.WriteTreeCompleteChildSource = WriteTreeCompleteChildSource;

//# sourceMappingURL=CompleteChildSource.js.map


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Node_1 = __webpack_require__(5);
var Change_1 = __webpack_require__(12);
var util_1 = __webpack_require__(0);
/**
 * An EventGenerator is used to convert "raw" changes (Change) as computed by the
 * CacheDiffer into actual events (Event) that can be raised.  See generateEventsForChanges()
 * for details.
 *
 * @constructor
 */
var EventGenerator = /** @class */ (function () {
    /**
     *
     * @param {!Query} query_
     */
    function EventGenerator(query_) {
        this.query_ = query_;
        /**
         * @private
         * @type {!Index}
         */
        this.index_ = this.query_.getQueryParams().getIndex();
    }
    /**
     * Given a set of raw changes (no moved events and prevName not specified yet), and a set of
     * EventRegistrations that should be notified of these changes, generate the actual events to be raised.
     *
     * Notes:
     *  - child_moved events will be synthesized at this time for any child_changed events that affect
     *    our index.
     *  - prevName will be calculated based on the index ordering.
     *
     * @param {!Array.<!Change>} changes
     * @param {!Node} eventCache
     * @param {!Array.<!EventRegistration>} eventRegistrations
     * @return {!Array.<!Event>}
     */
    EventGenerator.prototype.generateEventsForChanges = function (changes, eventCache, eventRegistrations) {
        var _this = this;
        var events = [];
        var moves = [];
        changes.forEach(function (change) {
            if (change.type === Change_1.Change.CHILD_CHANGED &&
                _this.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
                moves.push(Change_1.Change.childMovedChange(change.childName, change.snapshotNode));
            }
        });
        this.generateEventsForType_(events, Change_1.Change.CHILD_REMOVED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_ADDED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_MOVED, moves, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.CHILD_CHANGED, changes, eventRegistrations, eventCache);
        this.generateEventsForType_(events, Change_1.Change.VALUE, changes, eventRegistrations, eventCache);
        return events;
    };
    /**
     * Given changes of a single change type, generate the corresponding events.
     *
     * @param {!Array.<!Event>} events
     * @param {!string} eventType
     * @param {!Array.<!Change>} changes
     * @param {!Array.<!EventRegistration>} registrations
     * @param {!Node} eventCache
     * @private
     */
    EventGenerator.prototype.generateEventsForType_ = function (events, eventType, changes, registrations, eventCache) {
        var _this = this;
        var filteredChanges = changes.filter(function (change) { return change.type === eventType; });
        filteredChanges.sort(this.compareChanges_.bind(this));
        filteredChanges.forEach(function (change) {
            var materializedChange = _this.materializeSingleChange_(change, eventCache);
            registrations.forEach(function (registration) {
                if (registration.respondsTo(change.type)) {
                    events.push(registration.createEvent(materializedChange, _this.query_));
                }
            });
        });
    };
    /**
     * @param {!Change} change
     * @param {!Node} eventCache
     * @return {!Change}
     * @private
     */
    EventGenerator.prototype.materializeSingleChange_ = function (change, eventCache) {
        if (change.type === 'value' || change.type === 'child_removed') {
            return change;
        }
        else {
            change.prevName = eventCache.getPredecessorChildName(
            /** @type {!string} */
            change.childName, change.snapshotNode, this.index_);
            return change;
        }
    };
    /**
     * @param {!Change} a
     * @param {!Change} b
     * @return {number}
     * @private
     */
    EventGenerator.prototype.compareChanges_ = function (a, b) {
        if (a.childName == null || b.childName == null) {
            throw util_1.assertionError('Should only compare child_ events.');
        }
        var aWrapped = new Node_1.NamedNode(a.childName, a.snapshotNode);
        var bWrapped = new Node_1.NamedNode(b.childName, b.snapshotNode);
        return this.index_.compare(aWrapped, bWrapped);
    };
    return EventGenerator;
}());
exports.EventGenerator = EventGenerator;

//# sourceMappingURL=EventGenerator.js.map


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
var Path_1 = __webpack_require__(2);
var CompoundWrite_1 = __webpack_require__(119);
var PriorityIndex_1 = __webpack_require__(3);
var ChildrenNode_1 = __webpack_require__(4);
/**
 * WriteTree tracks all pending user-initiated writes and has methods to calculate the result of merging them
 * with underlying server data (to create "event cache" data).  Pending writes are added with addOverwrite()
 * and addMerge(), and removed with removeWrite().
 *
 * @constructor
 */
var WriteTree = /** @class */ (function () {
    function WriteTree() {
        /**
         * A tree tracking the result of applying all visible writes.  This does not include transactions with
         * applyLocally=false or writes that are completely shadowed by other writes.
         *
         * @type {!CompoundWrite}
         * @private
         */
        this.visibleWrites_ = CompoundWrite_1.CompoundWrite.Empty;
        /**
         * A list of all pending writes, regardless of visibility and shadowed-ness.  Used to calculate arbitrary
         * sets of the changed data, such as hidden writes (from transactions) or changes with certain writes excluded (also
         * used by transactions).
         *
         * @type {!Array.<!WriteRecord>}
         * @private
         */
        this.allWrites_ = [];
        this.lastWriteId_ = -1;
    }
    /**
     * Create a new WriteTreeRef for the given path. For use with a new sync point at the given path.
     *
     * @param {!Path} path
     * @return {!WriteTreeRef}
     */
    WriteTree.prototype.childWrites = function (path) {
        return new WriteTreeRef(path, this);
    };
    /**
     * Record a new overwrite from user code.
     *
     * @param {!Path} path
     * @param {!Node} snap
     * @param {!number} writeId
     * @param {boolean=} visible This is set to false by some transactions. It should be excluded from event caches
     */
    WriteTree.prototype.addOverwrite = function (path, snap, writeId, visible) {
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older write on top of newer ones');
        if (visible === undefined) {
            visible = true;
        }
        this.allWrites_.push({
            path: path,
            snap: snap,
            writeId: writeId,
            visible: visible
        });
        if (visible) {
            this.visibleWrites_ = this.visibleWrites_.addWrite(path, snap);
        }
        this.lastWriteId_ = writeId;
    };
    /**
     * Record a new merge from user code.
     *
     * @param {!Path} path
     * @param {!Object.<string, !Node>} changedChildren
     * @param {!number} writeId
     */
    WriteTree.prototype.addMerge = function (path, changedChildren, writeId) {
        util_2.assert(writeId > this.lastWriteId_, 'Stacking an older merge on top of newer ones');
        this.allWrites_.push({
            path: path,
            children: changedChildren,
            writeId: writeId,
            visible: true
        });
        this.visibleWrites_ = this.visibleWrites_.addWrites(path, changedChildren);
        this.lastWriteId_ = writeId;
    };
    /**
     * @param {!number} writeId
     * @return {?WriteRecord}
     */
    WriteTree.prototype.getWrite = function (writeId) {
        for (var i = 0; i < this.allWrites_.length; i++) {
            var record = this.allWrites_[i];
            if (record.writeId === writeId) {
                return record;
            }
        }
        return null;
    };
    /**
     * Remove a write (either an overwrite or merge) that has been successfully acknowledge by the server. Recalculates
     * the tree if necessary.  We return true if it may have been visible, meaning views need to reevaluate.
     *
     * @param {!number} writeId
     * @return {boolean} true if the write may have been visible (meaning we'll need to reevaluate / raise
     * events as a result).
     */
    WriteTree.prototype.removeWrite = function (writeId) {
        // Note: disabling this check. It could be a transaction that preempted another transaction, and thus was applied
        // out of order.
        //const validClear = revert || this.allWrites_.length === 0 || writeId <= this.allWrites_[0].writeId;
        //assert(validClear, "Either we don't have this write, or it's the first one in the queue");
        var _this = this;
        var idx = this.allWrites_.findIndex(function (s) {
            return s.writeId === writeId;
        });
        util_2.assert(idx >= 0, 'removeWrite called with nonexistent writeId.');
        var writeToRemove = this.allWrites_[idx];
        this.allWrites_.splice(idx, 1);
        var removedWriteWasVisible = writeToRemove.visible;
        var removedWriteOverlapsWithOtherWrites = false;
        var i = this.allWrites_.length - 1;
        while (removedWriteWasVisible && i >= 0) {
            var currentWrite = this.allWrites_[i];
            if (currentWrite.visible) {
                if (i >= idx &&
                    this.recordContainsPath_(currentWrite, writeToRemove.path)) {
                    // The removed write was completely shadowed by a subsequent write.
                    removedWriteWasVisible = false;
                }
                else if (writeToRemove.path.contains(currentWrite.path)) {
                    // Either we're covering some writes or they're covering part of us (depending on which came first).
                    removedWriteOverlapsWithOtherWrites = true;
                }
            }
            i--;
        }
        if (!removedWriteWasVisible) {
            return false;
        }
        else if (removedWriteOverlapsWithOtherWrites) {
            // There's some shadowing going on. Just rebuild the visible writes from scratch.
            this.resetTree_();
            return true;
        }
        else {
            // There's no shadowing.  We can safely just remove the write(s) from visibleWrites.
            if (writeToRemove.snap) {
                this.visibleWrites_ = this.visibleWrites_.removeWrite(writeToRemove.path);
            }
            else {
                var children = writeToRemove.children;
                util_1.forEach(children, function (childName) {
                    _this.visibleWrites_ = _this.visibleWrites_.removeWrite(writeToRemove.path.child(childName));
                });
            }
            return true;
        }
    };
    /**
     * Return a complete snapshot for the given path if there's visible write data at that path, else null.
     * No server data is considered.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.getCompleteWriteData = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * Given optional, underlying server data, and an optional set of constraints (exclude some sets, include hidden
     * writes), attempt to calculate a complete snapshot for the given path
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude An optional set to be excluded
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteEventCache = function (treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        if (!writeIdsToExclude && !includeHiddenWrites) {
            var shadowingNode = this.visibleWrites_.getCompleteNode(treePath);
            if (shadowingNode != null) {
                return shadowingNode;
            }
            else {
                var subMerge = this.visibleWrites_.childCompoundWrite(treePath);
                if (subMerge.isEmpty()) {
                    return completeServerCache;
                }
                else if (completeServerCache == null &&
                    !subMerge.hasCompleteWrite(Path_1.Path.Empty)) {
                    // We wouldn't have a complete snapshot, since there's no underlying data and no complete shadow
                    return null;
                }
                else {
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return subMerge.apply(layeredCache);
                }
            }
        }
        else {
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            if (!includeHiddenWrites && merge.isEmpty()) {
                return completeServerCache;
            }
            else {
                // If the server cache is null, and we don't have a complete cache, we need to return null
                if (!includeHiddenWrites &&
                    completeServerCache == null &&
                    !merge.hasCompleteWrite(Path_1.Path.Empty)) {
                    return null;
                }
                else {
                    var filter = function (write) {
                        return ((write.visible || includeHiddenWrites) &&
                            (!writeIdsToExclude ||
                                !~writeIdsToExclude.indexOf(write.writeId)) &&
                            (write.path.contains(treePath) || treePath.contains(write.path)));
                    };
                    var mergeAtPath = WriteTree.layerTree_(this.allWrites_, filter, treePath);
                    var layeredCache = completeServerCache || ChildrenNode_1.ChildrenNode.EMPTY_NODE;
                    return mergeAtPath.apply(layeredCache);
                }
            }
        }
    };
    /**
     * With optional, underlying server data, attempt to return a children node of children that we have complete data for.
     * Used when creating new views, to pre-fill their complete event children snapshot.
     *
     * @param {!Path} treePath
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTree.prototype.calcCompleteEventChildren = function (treePath, completeServerChildren) {
        var completeChildren = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        var topLevelSet = this.visibleWrites_.getCompleteNode(treePath);
        if (topLevelSet) {
            if (!topLevelSet.isLeafNode()) {
                // we're shadowing everything. Return the children.
                topLevelSet.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childSnap) {
                    completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
                });
            }
            return completeChildren;
        }
        else if (completeServerChildren) {
            // Layer any children we have on top of this
            // We know we don't have a top-level set, so just enumerate existing children
            var merge_1 = this.visibleWrites_.childCompoundWrite(treePath);
            completeServerChildren.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
                var node = merge_1
                    .childCompoundWrite(new Path_1.Path(childName))
                    .apply(childNode);
                completeChildren = completeChildren.updateImmediateChild(childName, node);
            });
            // Add any complete children we have from the set
            merge_1.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
        else {
            // We don't have anything to layer on top of. Layer on any children we have
            // Note that we can return an empty snap if we have a defined delete
            var merge = this.visibleWrites_.childCompoundWrite(treePath);
            merge.getCompleteChildren().forEach(function (namedNode) {
                completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
            });
            return completeChildren;
        }
    };
    /**
     * Given that the underlying server data has updated, determine what, if anything, needs to be
     * applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events
     *
     * Either existingEventSnap or existingServerSnap must exist
     *
     * @param {!Path} treePath
     * @param {!Path} childPath
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcEventCacheAfterServerOverwrite = function (treePath, childPath, existingEventSnap, existingServerSnap) {
        util_2.assert(existingEventSnap || existingServerSnap, 'Either existingEventSnap or existingServerSnap must exist');
        var path = treePath.child(childPath);
        if (this.visibleWrites_.hasCompleteWrite(path)) {
            // At this point we can probably guarantee that we're in case 2, meaning no events
            // May need to check visibility while doing the findRootMostValueAndPath call
            return null;
        }
        else {
            // No complete shadowing. We're either partially shadowing or not shadowing at all.
            var childMerge = this.visibleWrites_.childCompoundWrite(path);
            if (childMerge.isEmpty()) {
                // We're not shadowing at all. Case 1
                return existingServerSnap.getChild(childPath);
            }
            else {
                // This could be more efficient if the serverNode + updates doesn't change the eventSnap
                // However this is tricky to find out, since user updates don't necessary change the server
                // snap, e.g. priority updates on empty nodes, or deep deletes. Another special case is if the server
                // adds nodes, but doesn't change any existing writes. It is therefore not enough to
                // only check if the updates change the serverNode.
                // Maybe check if the merge tree contains these special cases and only do a full overwrite in that case?
                return childMerge.apply(existingServerSnap.getChild(childPath));
            }
        }
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!Path} treePath
     * @param {!string} childKey
     * @param {!CacheNode} existingServerSnap
     * @return {?Node}
     */
    WriteTree.prototype.calcCompleteChild = function (treePath, childKey, existingServerSnap) {
        var path = treePath.child(childKey);
        var shadowingNode = this.visibleWrites_.getCompleteNode(path);
        if (shadowingNode != null) {
            return shadowingNode;
        }
        else {
            if (existingServerSnap.isCompleteForChild(childKey)) {
                var childMerge = this.visibleWrites_.childCompoundWrite(path);
                return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));
            }
            else {
                return null;
            }
        }
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTree.prototype.shadowingWrite = function (path) {
        return this.visibleWrites_.getCompleteNode(path);
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window.
     *
     * @param {!Path} treePath
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTree.prototype.calcIndexedSlice = function (treePath, completeServerData, startPost, count, reverse, index) {
        var toIterate;
        var merge = this.visibleWrites_.childCompoundWrite(treePath);
        var shadowingNode = merge.getCompleteNode(Path_1.Path.Empty);
        if (shadowingNode != null) {
            toIterate = shadowingNode;
        }
        else if (completeServerData != null) {
            toIterate = merge.apply(completeServerData);
        }
        else {
            // no children to iterate on
            return [];
        }
        toIterate = toIterate.withIndex(index);
        if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
            var nodes = [];
            var cmp = index.getCompare();
            var iter = reverse
                ? toIterate.getReverseIteratorFrom(startPost, index)
                : toIterate.getIteratorFrom(startPost, index);
            var next = iter.getNext();
            while (next && nodes.length < count) {
                if (cmp(next, startPost) !== 0) {
                    nodes.push(next);
                }
                next = iter.getNext();
            }
            return nodes;
        }
        else {
            return [];
        }
    };
    /**
     * @param {!WriteRecord} writeRecord
     * @param {!Path} path
     * @return {boolean}
     * @private
     */
    WriteTree.prototype.recordContainsPath_ = function (writeRecord, path) {
        if (writeRecord.snap) {
            return writeRecord.path.contains(path);
        }
        else {
            // findKey can return undefined, so use !! to coerce to boolean
            return !!util_1.findKey(writeRecord.children, function (childSnap, childName) {
                return writeRecord.path.child(childName).contains(path);
            });
        }
    };
    /**
     * Re-layer the writes and merges into a tree so we can efficiently calculate event snapshots
     * @private
     */
    WriteTree.prototype.resetTree_ = function () {
        this.visibleWrites_ = WriteTree.layerTree_(this.allWrites_, WriteTree.DefaultFilter_, Path_1.Path.Empty);
        if (this.allWrites_.length > 0) {
            this.lastWriteId_ = this.allWrites_[this.allWrites_.length - 1].writeId;
        }
        else {
            this.lastWriteId_ = -1;
        }
    };
    /**
     * The default filter used when constructing the tree. Keep everything that's visible.
     *
     * @param {!WriteRecord} write
     * @return {boolean}
     * @private
     */
    WriteTree.DefaultFilter_ = function (write) {
        return write.visible;
    };
    /**
     * Static method. Given an array of WriteRecords, a filter for which ones to include, and a path, construct the tree of
     * event data at that path.
     *
     * @param {!Array.<!WriteRecord>} writes
     * @param {!function(!WriteRecord):boolean} filter
     * @param {!Path} treeRoot
     * @return {!CompoundWrite}
     * @private
     */
    WriteTree.layerTree_ = function (writes, filter, treeRoot) {
        var compoundWrite = CompoundWrite_1.CompoundWrite.Empty;
        for (var i = 0; i < writes.length; ++i) {
            var write = writes[i];
            // Theory, a later set will either:
            // a) abort a relevant transaction, so no need to worry about excluding it from calculating that transaction
            // b) not be relevant to a transaction (separate branch), so again will not affect the data for that transaction
            if (filter(write)) {
                var writePath = write.path;
                var relativePath = void 0;
                if (write.snap) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrite(relativePath, write.snap);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, write.snap.getChild(relativePath));
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else if (write.children) {
                    if (treeRoot.contains(writePath)) {
                        relativePath = Path_1.Path.relativePath(treeRoot, writePath);
                        compoundWrite = compoundWrite.addWrites(relativePath, write.children);
                    }
                    else if (writePath.contains(treeRoot)) {
                        relativePath = Path_1.Path.relativePath(writePath, treeRoot);
                        if (relativePath.isEmpty()) {
                            compoundWrite = compoundWrite.addWrites(Path_1.Path.Empty, write.children);
                        }
                        else {
                            var child = util_1.safeGet(write.children, relativePath.getFront());
                            if (child) {
                                // There exists a child in this node that matches the root path
                                var deepNode = child.getChild(relativePath.popFront());
                                compoundWrite = compoundWrite.addWrite(Path_1.Path.Empty, deepNode);
                            }
                        }
                    }
                    else {
                        // There is no overlap between root path and write path, ignore write
                    }
                }
                else {
                    throw util_2.assertionError('WriteRecord should have .snap or .children');
                }
            }
        }
        return compoundWrite;
    };
    return WriteTree;
}());
exports.WriteTree = WriteTree;
/**
 * A WriteTreeRef wraps a WriteTree and a path, for convenient access to a particular subtree.  All of the methods
 * just proxy to the underlying WriteTree.
 *
 * @constructor
 */
var WriteTreeRef = /** @class */ (function () {
    /**
     * @param {!Path} path
     * @param {!WriteTree} writeTree
     */
    function WriteTreeRef(path, writeTree) {
        this.treePath_ = path;
        this.writeTree_ = writeTree;
    }
    /**
     * If possible, returns a complete event cache, using the underlying server data if possible. In addition, can be used
     * to get a cache that includes hidden writes, and excludes arbitrary writes. Note that customizing the returned node
     * can lead to a more expensive calculation.
     *
     * @param {?Node} completeServerCache
     * @param {Array.<number>=} writeIdsToExclude Optional writes to exclude.
     * @param {boolean=} includeHiddenWrites Defaults to false, whether or not to layer on writes with visible set to false
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteEventCache = function (completeServerCache, writeIdsToExclude, includeHiddenWrites) {
        return this.writeTree_.calcCompleteEventCache(this.treePath_, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    };
    /**
     * If possible, returns a children node containing all of the complete children we have data for. The returned data is a
     * mix of the given server data and write data.
     *
     * @param {?ChildrenNode} completeServerChildren
     * @return {!ChildrenNode}
     */
    WriteTreeRef.prototype.calcCompleteEventChildren = function (completeServerChildren) {
        return this.writeTree_.calcCompleteEventChildren(this.treePath_, completeServerChildren);
    };
    /**
     * Given that either the underlying server data has updated or the outstanding writes have updated, determine what,
     * if anything, needs to be applied to the event cache.
     *
     * Possibilities:
     *
     * 1. No writes are shadowing. Events should be raised, the snap to be applied comes from the server data
     *
     * 2. Some write is completely shadowing. No events to be raised
     *
     * 3. Is partially shadowed. Events should be raised
     *
     * Either existingEventSnap or existingServerSnap must exist, this is validated via an assert
     *
     * @param {!Path} path
     * @param {?Node} existingEventSnap
     * @param {?Node} existingServerSnap
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcEventCacheAfterServerOverwrite = function (path, existingEventSnap, existingServerSnap) {
        return this.writeTree_.calcEventCacheAfterServerOverwrite(this.treePath_, path, existingEventSnap, existingServerSnap);
    };
    /**
     * Returns a node if there is a complete overwrite for this path. More specifically, if there is a write at
     * a higher path, this will return the child of that write relative to the write and this path.
     * Returns null if there is no write at this path.
     *
     * @param {!Path} path
     * @return {?Node}
     */
    WriteTreeRef.prototype.shadowingWrite = function (path) {
        return this.writeTree_.shadowingWrite(this.treePath_.child(path));
    };
    /**
     * This method is used when processing child remove events on a query. If we can, we pull in children that were outside
     * the window, but may now be in the window
     *
     * @param {?Node} completeServerData
     * @param {!NamedNode} startPost
     * @param {!number} count
     * @param {boolean} reverse
     * @param {!Index} index
     * @return {!Array.<!NamedNode>}
     */
    WriteTreeRef.prototype.calcIndexedSlice = function (completeServerData, startPost, count, reverse, index) {
        return this.writeTree_.calcIndexedSlice(this.treePath_, completeServerData, startPost, count, reverse, index);
    };
    /**
     * Returns a complete child for a given server snap after applying all user writes or null if there is no
     * complete child for this ChildKey.
     *
     * @param {!string} childKey
     * @param {!CacheNode} existingServerCache
     * @return {?Node}
     */
    WriteTreeRef.prototype.calcCompleteChild = function (childKey, existingServerCache) {
        return this.writeTree_.calcCompleteChild(this.treePath_, childKey, existingServerCache);
    };
    /**
     * Return a WriteTreeRef for a child.
     *
     * @param {string} childName
     * @return {!WriteTreeRef}
     */
    WriteTreeRef.prototype.child = function (childName) {
        return new WriteTreeRef(this.treePath_.child(childName), this.writeTree_);
    };
    return WriteTreeRef;
}());
exports.WriteTreeRef = WriteTreeRef;

//# sourceMappingURL=WriteTree.js.map


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ImmutableTree_1 = __webpack_require__(32);
var Path_1 = __webpack_require__(2);
var util_1 = __webpack_require__(0);
var Node_1 = __webpack_require__(5);
var PriorityIndex_1 = __webpack_require__(3);
var util_2 = __webpack_require__(0);
/**
 * This class holds a collection of writes that can be applied to nodes in unison. It abstracts away the logic with
 * dealing with priority writes and multiple nested writes. At any given path there is only allowed to be one write
 * modifying that path. Any write to an existing path or shadowing an existing path will modify that existing write
 * to reflect the write added.
 *
 * @constructor
 * @param {!ImmutableTree.<!Node>} writeTree
 */
var CompoundWrite = /** @class */ (function () {
    function CompoundWrite(writeTree_) {
        this.writeTree_ = writeTree_;
    }
    /**
     * @param {!Path} path
     * @param {!Node} node
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrite = function (path, node) {
        if (path.isEmpty()) {
            return new CompoundWrite(new ImmutableTree_1.ImmutableTree(node));
        }
        else {
            var rootmost = this.writeTree_.findRootMostValueAndPath(path);
            if (rootmost != null) {
                var rootMostPath = rootmost.path;
                var value = rootmost.value;
                var relativePath = Path_1.Path.relativePath(rootMostPath, path);
                value = value.updateChild(relativePath, node);
                return new CompoundWrite(this.writeTree_.set(rootMostPath, value));
            }
            else {
                var subtree = new ImmutableTree_1.ImmutableTree(node);
                var newWriteTree = this.writeTree_.setTree(path, subtree);
                return new CompoundWrite(newWriteTree);
            }
        }
    };
    /**
     * @param {!Path} path
     * @param {!Object.<string, !Node>} updates
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.addWrites = function (path, updates) {
        var newWrite = this;
        util_1.forEach(updates, function (childKey, node) {
            newWrite = newWrite.addWrite(path.child(childKey), node);
        });
        return newWrite;
    };
    /**
     * Will remove a write at the given path and deeper paths. This will <em>not</em> modify a write at a higher
     * location, which must be removed by calling this method with that path.
     *
     * @param {!Path} path The path at which a write and all deeper writes should be removed
     * @return {!CompoundWrite} The new CompoundWrite with the removed path
     */
    CompoundWrite.prototype.removeWrite = function (path) {
        if (path.isEmpty()) {
            return CompoundWrite.Empty;
        }
        else {
            var newWriteTree = this.writeTree_.setTree(path, ImmutableTree_1.ImmutableTree.Empty);
            return new CompoundWrite(newWriteTree);
        }
    };
    /**
     * Returns whether this CompoundWrite will fully overwrite a node at a given location and can therefore be
     * considered "complete".
     *
     * @param {!Path} path The path to check for
     * @return {boolean} Whether there is a complete write at that path
     */
    CompoundWrite.prototype.hasCompleteWrite = function (path) {
        return this.getCompleteNode(path) != null;
    };
    /**
     * Returns a node for a path if and only if the node is a "complete" overwrite at that path. This will not aggregate
     * writes from deeper paths, but will return child nodes from a more shallow path.
     *
     * @param {!Path} path The path to get a complete write
     * @return {?Node} The node if complete at that path, or null otherwise.
     */
    CompoundWrite.prototype.getCompleteNode = function (path) {
        var rootmost = this.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
            return this.writeTree_
                .get(rootmost.path)
                .getChild(Path_1.Path.relativePath(rootmost.path, path));
        }
        else {
            return null;
        }
    };
    /**
     * Returns all children that are guaranteed to be a complete overwrite.
     *
     * @return {!Array.<NamedNode>} A list of all complete children.
     */
    CompoundWrite.prototype.getCompleteChildren = function () {
        var children = [];
        var node = this.writeTree_.value;
        if (node != null) {
            // If it's a leaf node, it has no children; so nothing to do.
            if (!node.isLeafNode()) {
                node.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (childName, childNode) {
                    children.push(new Node_1.NamedNode(childName, childNode));
                });
            }
        }
        else {
            this.writeTree_.children.inorderTraversal(function (childName, childTree) {
                if (childTree.value != null) {
                    children.push(new Node_1.NamedNode(childName, childTree.value));
                }
            });
        }
        return children;
    };
    /**
     * @param {!Path} path
     * @return {!CompoundWrite}
     */
    CompoundWrite.prototype.childCompoundWrite = function (path) {
        if (path.isEmpty()) {
            return this;
        }
        else {
            var shadowingNode = this.getCompleteNode(path);
            if (shadowingNode != null) {
                return new CompoundWrite(new ImmutableTree_1.ImmutableTree(shadowingNode));
            }
            else {
                return new CompoundWrite(this.writeTree_.subtree(path));
            }
        }
    };
    /**
     * Returns true if this CompoundWrite is empty and therefore does not modify any nodes.
     * @return {boolean} Whether this CompoundWrite is empty
     */
    CompoundWrite.prototype.isEmpty = function () {
        return this.writeTree_.isEmpty();
    };
    /**
     * Applies this CompoundWrite to a node. The node is returned with all writes from this CompoundWrite applied to the
     * node
     * @param {!Node} node The node to apply this CompoundWrite to
     * @return {!Node} The node with all writes applied
     */
    CompoundWrite.prototype.apply = function (node) {
        return CompoundWrite.applySubtreeWrite_(Path_1.Path.Empty, this.writeTree_, node);
    };
    /**
     * @type {!CompoundWrite}
     */
    CompoundWrite.Empty = new CompoundWrite(new ImmutableTree_1.ImmutableTree(null));
    /**
     * @param {!Path} relativePath
     * @param {!ImmutableTree.<!Node>} writeTree
     * @param {!Node} node
     * @return {!Node}
     * @private
     */
    CompoundWrite.applySubtreeWrite_ = function (relativePath, writeTree, node) {
        if (writeTree.value != null) {
            // Since there a write is always a leaf, we're done here
            return node.updateChild(relativePath, writeTree.value);
        }
        else {
            var priorityWrite_1 = null;
            writeTree.children.inorderTraversal(function (childKey, childTree) {
                if (childKey === '.priority') {
                    // Apply priorities at the end so we don't update priorities for either empty nodes or forget
                    // to apply priorities to empty nodes that are later filled
                    util_2.assert(childTree.value !== null, 'Priority writes must always be leaf nodes');
                    priorityWrite_1 = childTree.value;
                }
                else {
                    node = CompoundWrite.applySubtreeWrite_(relativePath.child(childKey), childTree, node);
                }
            });
            // If there was a priority write, we only apply it if the node is not empty
            if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
                node = node.updateChild(relativePath.child('.priority'), priorityWrite_1);
            }
            return node;
        }
    };
    return CompoundWrite;
}());
exports.CompoundWrite = CompoundWrite;

//# sourceMappingURL=CompoundWrite.js.map


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ChildrenNode_1 = __webpack_require__(4);
/**
 * Mutable object which basically just stores a reference to the "latest" immutable snapshot.
 *
 * @constructor
 */
var SnapshotHolder = /** @class */ (function () {
    function SnapshotHolder() {
        this.rootNode_ = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
    }
    SnapshotHolder.prototype.getNode = function (path) {
        return this.rootNode_.getChild(path);
    };
    SnapshotHolder.prototype.updateSnapshot = function (path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder;
}());
exports.SnapshotHolder = SnapshotHolder;

//# sourceMappingURL=SnapshotHolder.js.map


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
/**
 * Abstraction around FirebaseApp's token fetching capabilities.
 */
var AuthTokenProvider = /** @class */ (function () {
    /**
     * @param {!FirebaseApp} app_
     */
    function AuthTokenProvider(app_) {
        this.app_ = app_;
    }
    /**
     * @param {boolean} forceRefresh
     * @return {!Promise<FirebaseAuthTokenData>}
     */
    AuthTokenProvider.prototype.getToken = function (forceRefresh) {
        return this.app_['INTERNAL']['getToken'](forceRefresh).then(null, 
        // .catch
        function (error) {
            // TODO: Need to figure out all the cases this is raised and whether
            // this makes sense.
            if (error && error.code === 'auth/token-not-initialized') {
                util_1.log('Got auth/token-not-initialized error.  Treating as null token.');
                return null;
            }
            else {
                return Promise.reject(error);
            }
        });
    };
    AuthTokenProvider.prototype.addTokenChangeListener = function (listener) {
        // TODO: We might want to wrap the listener and call it with no args to
        // avoid a leaky abstraction, but that makes removing the listener harder.
        this.app_['INTERNAL']['addAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.removeTokenChangeListener = function (listener) {
        this.app_['INTERNAL']['removeAuthTokenListener'](listener);
    };
    AuthTokenProvider.prototype.notifyForInvalidToken = function () {
        var errorMessage = 'Provided authentication credentials for the app named "' +
            this.app_.name +
            '" are invalid. This usually indicates your app was not ' +
            'initialized correctly. ';
        if ('credential' in this.app_.options) {
            errorMessage +=
                'Make sure the "credential" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else if ('serviceAccount' in this.app_.options) {
            errorMessage +=
                'Make sure the "serviceAccount" property provided to initializeApp() ' +
                    'is authorized to access the specified "databaseURL" and is from the correct ' +
                    'project.';
        }
        else {
            errorMessage +=
                'Make sure the "apiKey" and "databaseURL" properties provided to ' +
                    'initializeApp() match the values provided for your app at ' +
                    'https://console.firebase.google.com/.';
        }
        util_1.warn(errorMessage);
    };
    return AuthTokenProvider;
}());
exports.AuthTokenProvider = AuthTokenProvider;

//# sourceMappingURL=AuthTokenProvider.js.map


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(0);
/**
 * Tracks a collection of stats.
 *
 * @constructor
 */
var StatsCollection = /** @class */ (function () {
    function StatsCollection() {
        this.counters_ = {};
    }
    StatsCollection.prototype.incrementCounter = function (name, amount) {
        if (amount === void 0) { amount = 1; }
        if (!util_2.contains(this.counters_, name))
            this.counters_[name] = 0;
        this.counters_[name] += amount;
    };
    StatsCollection.prototype.get = function () {
        return util_1.deepCopy(this.counters_);
    };
    return StatsCollection;
}());
exports.StatsCollection = StatsCollection;

//# sourceMappingURL=StatsCollection.js.map


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var StatsListener_1 = __webpack_require__(64);
// Assuming some apps may have a short amount of time on page, and a bulk of firebase operations probably
// happen on page load, we try to report our first set of stats pretty quickly, but we wait at least 10
// seconds to try to ensure the Firebase connection is established / settled.
var FIRST_STATS_MIN_TIME = 10 * 1000;
var FIRST_STATS_MAX_TIME = 30 * 1000;
// We'll continue to report stats on average every 5 minutes.
var REPORT_STATS_INTERVAL = 5 * 60 * 1000;
/**
 * @constructor
 */
var StatsReporter = /** @class */ (function () {
    /**
     * @param collection
     * @param server_
     */
    function StatsReporter(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener_1.StatsListener(collection);
        var timeout = FIRST_STATS_MIN_TIME +
            (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter.prototype.includeStat = function (stat) {
        this.statsToReport_[stat] = true;
    };
    StatsReporter.prototype.reportStats_ = function () {
        var _this = this;
        var stats = this.statsListener_.get();
        var reportedStats = {};
        var haveStatsToReport = false;
        util_1.forEach(stats, function (stat, value) {
            if (value > 0 && util_1.contains(_this.statsToReport_, stat)) {
                reportedStats[stat] = value;
                haveStatsToReport = true;
            }
        });
        if (haveStatsToReport) {
            this.server_.reportStats(reportedStats);
        }
        // queue our next run.
        util_2.setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter;
}());
exports.StatsReporter = StatsReporter;

//# sourceMappingURL=StatsReporter.js.map


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
/**
 * The event queue serves a few purposes:
 * 1. It ensures we maintain event order in the face of event callbacks doing operations that result in more
 *    events being queued.
 * 2. raiseQueuedEvents() handles being called reentrantly nicely.  That is, if in the course of raising events,
 *    raiseQueuedEvents() is called again, the "inner" call will pick up raising events where the "outer" call
 *    left off, ensuring that the events are still raised synchronously and in order.
 * 3. You can use raiseEventsAtPath and raiseEventsForChangedPath to ensure only relevant previously-queued
 *    events are raised synchronously.
 *
 * NOTE: This can all go away if/when we move to async events.
 *
 * @constructor
 */
var EventQueue = /** @class */ (function () {
    function EventQueue() {
        /**
         * @private
         * @type {!Array.<EventList>}
         */
        this.eventLists_ = [];
        /**
         * Tracks recursion depth of raiseQueuedEvents_, for debugging purposes.
         * @private
         * @type {!number}
         */
        this.recursionDepth_ = 0;
    }
    /**
     * @param {!Array.<Event>} eventDataList The new events to queue.
     */
    EventQueue.prototype.queueEvents = function (eventDataList) {
        // We group events by path, storing them in a single EventList, to make it easier to skip over them quickly.
        var currList = null;
        for (var i = 0; i < eventDataList.length; i++) {
            var eventData = eventDataList[i];
            var eventPath = eventData.getPath();
            if (currList !== null && !eventPath.equals(currList.getPath())) {
                this.eventLists_.push(currList);
                currList = null;
            }
            if (currList === null) {
                currList = new EventList(eventPath);
            }
            currList.add(eventData);
        }
        if (currList) {
            this.eventLists_.push(currList);
        }
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones)
     * for the specified path.
     *
     * It is assumed that the new events are all for the specified path.
     *
     * @param {!Path} path The path to raise events for.
     * @param {!Array.<Event>} eventDataList The new events to raise.
     */
    EventQueue.prototype.raiseEventsAtPath = function (path, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.equals(path);
        });
    };
    /**
     * Queues the specified events and synchronously raises all events (including previously queued ones) for
     * locations related to the specified change path (i.e. all ancestors and descendants).
     *
     * It is assumed that the new events are all related (ancestor or descendant) to the specified path.
     *
     * @param {!Path} changedPath The path to raise events for.
     * @param {!Array.<!Event>} eventDataList The events to raise
     */
    EventQueue.prototype.raiseEventsForChangedPath = function (changedPath, eventDataList) {
        this.queueEvents(eventDataList);
        this.raiseQueuedEventsMatchingPredicate_(function (eventPath) {
            return eventPath.contains(changedPath) || changedPath.contains(eventPath);
        });
    };
    /**
     * @param {!function(!Path):boolean} predicate
     * @private
     */
    EventQueue.prototype.raiseQueuedEventsMatchingPredicate_ = function (predicate) {
        this.recursionDepth_++;
        var sentAll = true;
        for (var i = 0; i < this.eventLists_.length; i++) {
            var eventList = this.eventLists_[i];
            if (eventList) {
                var eventPath = eventList.getPath();
                if (predicate(eventPath)) {
                    this.eventLists_[i].raise();
                    this.eventLists_[i] = null;
                }
                else {
                    sentAll = false;
                }
            }
        }
        if (sentAll) {
            this.eventLists_ = [];
        }
        this.recursionDepth_--;
    };
    return EventQueue;
}());
exports.EventQueue = EventQueue;
/**
 * @param {!Path} path
 * @constructor
 */
var EventList = /** @class */ (function () {
    function EventList(path_) {
        this.path_ = path_;
        /**
         * @type {!Array.<Event>}
         * @private
         */
        this.events_ = [];
    }
    /**
     * @param {!Event} eventData
     */
    EventList.prototype.add = function (eventData) {
        this.events_.push(eventData);
    };
    /**
     * Iterates through the list and raises each event
     */
    EventList.prototype.raise = function () {
        for (var i = 0; i < this.events_.length; i++) {
            var eventData = this.events_[i];
            if (eventData !== null) {
                this.events_[i] = null;
                var eventFn = eventData.getEventRunner();
                if (util_1.logger) {
                    util_1.log('event: ' + eventData.toString());
                }
                util_1.exceptionGuard(eventFn);
            }
        }
    };
    /**
     * @return {!Path}
     */
    EventList.prototype.getPath = function () {
        return this.path_;
    };
    return EventList;
}());
exports.EventList = EventList;

//# sourceMappingURL=EventQueue.js.map


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var EventEmitter_1 = __webpack_require__(66);
var util_1 = __webpack_require__(0);
/**
 * @extends {EventEmitter}
 */
var VisibilityMonitor = /** @class */ (function (_super) {
    __extends(VisibilityMonitor, _super);
    function VisibilityMonitor() {
        var _this = _super.call(this, ['visible']) || this;
        var hidden;
        var visibilityChange;
        if (typeof document !== 'undefined' &&
            typeof document.addEventListener !== 'undefined') {
            if (typeof document['hidden'] !== 'undefined') {
                // Opera 12.10 and Firefox 18 and later support
                visibilityChange = 'visibilitychange';
                hidden = 'hidden';
            }
            else if (typeof document['mozHidden'] !== 'undefined') {
                visibilityChange = 'mozvisibilitychange';
                hidden = 'mozHidden';
            }
            else if (typeof document['msHidden'] !== 'undefined') {
                visibilityChange = 'msvisibilitychange';
                hidden = 'msHidden';
            }
            else if (typeof document['webkitHidden'] !== 'undefined') {
                visibilityChange = 'webkitvisibilitychange';
                hidden = 'webkitHidden';
            }
        }
        // Initially, we always assume we are visible. This ensures that in browsers
        // without page visibility support or in cases where we are never visible
        // (e.g. chrome extension), we act as if we are visible, i.e. don't delay
        // reconnects
        _this.visible_ = true;
        if (visibilityChange) {
            document.addEventListener(visibilityChange, function () {
                var visible = !document[hidden];
                if (visible !== _this.visible_) {
                    _this.visible_ = visible;
                    _this.trigger('visible', visible);
                }
            }, false);
        }
        return _this;
    }
    VisibilityMonitor.getInstance = function () {
        return new VisibilityMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    VisibilityMonitor.prototype.getInitialEvent = function (eventType) {
        util_1.assert(eventType === 'visible', 'Unknown event type: ' + eventType);
        return [this.visible_];
    };
    return VisibilityMonitor;
}(EventEmitter_1.EventEmitter));
exports.VisibilityMonitor = VisibilityMonitor;

//# sourceMappingURL=VisibilityMonitor.js.map


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var EventEmitter_1 = __webpack_require__(66);
var util_2 = __webpack_require__(0);
/**
 * Monitors online state (as reported by window.online/offline events).
 *
 * The expectation is that this could have many false positives (thinks we are online
 * when we're not), but no false negatives.  So we can safely use it to determine when
 * we definitely cannot reach the internet.
 *
 * @extends {EventEmitter}
 */
var OnlineMonitor = /** @class */ (function (_super) {
    __extends(OnlineMonitor, _super);
    function OnlineMonitor() {
        var _this = _super.call(this, ['online']) || this;
        _this.online_ = true;
        // We've had repeated complaints that Cordova apps can get stuck "offline", e.g.
        // https://forum.ionicframework.com/t/firebase-connection-is-lost-and-never-come-back/43810
        // It would seem that the 'online' event does not always fire consistently. So we disable it
        // for Cordova.
        if (typeof window !== 'undefined' &&
            typeof window.addEventListener !== 'undefined' &&
            !util_2.isMobileCordova()) {
            window.addEventListener('online', function () {
                if (!_this.online_) {
                    _this.online_ = true;
                    _this.trigger('online', true);
                }
            }, false);
            window.addEventListener('offline', function () {
                if (_this.online_) {
                    _this.online_ = false;
                    _this.trigger('online', false);
                }
            }, false);
        }
        return _this;
    }
    OnlineMonitor.getInstance = function () {
        return new OnlineMonitor();
    };
    /**
     * @param {!string} eventType
     * @return {Array.<boolean>}
     */
    OnlineMonitor.prototype.getInitialEvent = function (eventType) {
        util_1.assert(eventType === 'online', 'Unknown event type: ' + eventType);
        return [this.online_];
    };
    /**
     * @return {boolean}
     */
    OnlineMonitor.prototype.currentlyOnline = function () {
        return this.online_;
    };
    return OnlineMonitor;
}(EventEmitter_1.EventEmitter));
exports.OnlineMonitor = OnlineMonitor;

//# sourceMappingURL=OnlineMonitor.js.map


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserPollConnection_1 = __webpack_require__(68);
var WebSocketConnection_1 = __webpack_require__(69);
var util_1 = __webpack_require__(1);
/**
 * Currently simplistic, this class manages what transport a Connection should use at various stages of its
 * lifecycle.
 *
 * It starts with longpolling in a browser, and httppolling on node. It then upgrades to websockets if
 * they are available.
 * @constructor
 */
var TransportManager = /** @class */ (function () {
    /**
     * @param {!RepoInfo} repoInfo Metadata around the namespace we're connecting to
     */
    function TransportManager(repoInfo) {
        this.initTransports_(repoInfo);
    }
    Object.defineProperty(TransportManager, "ALL_TRANSPORTS", {
        /**
         * @const
         * @type {!Array.<function(new:Transport, string, RepoInfo, string=)>}
         */
        get: function () {
            return [BrowserPollConnection_1.BrowserPollConnection, WebSocketConnection_1.WebSocketConnection];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {!RepoInfo} repoInfo
     * @private
     */
    TransportManager.prototype.initTransports_ = function (repoInfo) {
        var isWebSocketsAvailable = WebSocketConnection_1.WebSocketConnection && WebSocketConnection_1.WebSocketConnection['isAvailable']();
        var isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection_1.WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
            if (!isWebSocketsAvailable)
                util_1.warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
            isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
            this.transports_ = [WebSocketConnection_1.WebSocketConnection];
        }
        else {
            var transports_1 = (this.transports_ = []);
            util_1.each(TransportManager.ALL_TRANSPORTS, function (i, transport) {
                if (transport && transport['isAvailable']()) {
                    transports_1.push(transport);
                }
            });
        }
    };
    /**
     * @return {function(new:Transport, !string, !RepoInfo, string=, string=)} The constructor for the
     * initial transport to use
     */
    TransportManager.prototype.initialTransport = function () {
        if (this.transports_.length > 0) {
            return this.transports_[0];
        }
        else {
            throw new Error('No transports available');
        }
    };
    /**
     * @return {?function(new:Transport, function(),function(), string=)} The constructor for the next
     * transport, or null
     */
    TransportManager.prototype.upgradeTransport = function () {
        if (this.transports_.length > 1) {
            return this.transports_[1];
        }
        else {
            return null;
        }
    };
    return TransportManager;
}());
exports.TransportManager = TransportManager;

//# sourceMappingURL=TransportManager.js.map


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(1);
/**
 * This class ensures the packets from the server arrive in order
 * This class takes data from the server and ensures it gets passed into the callbacks in order.
 * @constructor
 */
var PacketReceiver = /** @class */ (function () {
    /**
     * @param onMessage_
     */
    function PacketReceiver(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
    }
    PacketReceiver.prototype.closeAfter = function (responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
            this.onClose();
            this.onClose = null;
        }
    };
    /**
     * Each message from the server comes with a response number, and an array of data. The responseNumber
     * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
     * browsers will respond in the same order as the requests we sent
     * @param {number} requestNum
     * @param {Array} data
     */
    PacketReceiver.prototype.handleResponse = function (requestNum, data) {
        var _this = this;
        this.pendingResponses[requestNum] = data;
        var _loop_1 = function () {
            var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
            delete this_1.pendingResponses[this_1.currentResponseNum];
            var _loop_2 = function (i) {
                if (toProcess[i]) {
                    util_1.exceptionGuard(function () {
                        _this.onMessage_(toProcess[i]);
                    });
                }
            };
            for (var i = 0; i < toProcess.length; ++i) {
                _loop_2(i);
            }
            if (this_1.currentResponseNum === this_1.closeAfterResponse) {
                if (this_1.onClose) {
                    this_1.onClose();
                    this_1.onClose = null;
                }
                return "break";
            }
            this_1.currentResponseNum++;
        };
        var this_1 = this;
        while (this.pendingResponses[this.currentResponseNum]) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
    };
    return PacketReceiver;
}());
exports.PacketReceiver = PacketReceiver;

//# sourceMappingURL=PacketReceiver.js.map


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var util_3 = __webpack_require__(0);
var util_4 = __webpack_require__(0);
var util_5 = __webpack_require__(0);
var ServerActions_1 = __webpack_require__(70);
/**
 * An implementation of ServerActions that communicates with the server via REST requests.
 * This is mostly useful for compatibility with crawlers, where we don't want to spin up a full
 * persistent connection (using WebSockets or long-polling)
 */
var ReadonlyRestClient = /** @class */ (function (_super) {
    __extends(ReadonlyRestClient, _super);
    /**
     * @param {!RepoInfo} repoInfo_ Data about the namespace we are connecting to
     * @param {function(string, *, boolean, ?number)} onDataUpdate_ A callback for new data from the server
     * @param {AuthTokenProvider} authTokenProvider_
     * @implements {ServerActions}
     */
    function ReadonlyRestClient(repoInfo_, onDataUpdate_, authTokenProvider_) {
        var _this = _super.call(this) || this;
        _this.repoInfo_ = repoInfo_;
        _this.onDataUpdate_ = onDataUpdate_;
        _this.authTokenProvider_ = authTokenProvider_;
        /** @private {function(...[*])} */
        _this.log_ = util_2.logWrapper('p:rest:');
        /**
         * We don't actually need to track listens, except to prevent us calling an onComplete for a listen
         * that's been removed. :-/
         *
         * @private {!Object.<string, !Object>}
         */
        _this.listens_ = {};
        return _this;
    }
    ReadonlyRestClient.prototype.reportStats = function (stats) {
        throw new Error('Method not implemented.');
    };
    /**
     * @param {!Query} query
     * @param {?number=} tag
     * @return {string}
     * @private
     */
    ReadonlyRestClient.getListenId_ = function (query, tag) {
        if (tag !== undefined) {
            return 'tag$' + tag;
        }
        else {
            util_1.assert(query.getQueryParams().isDefault(), "should have a tag if it's not a default query.");
            return query.path.toString();
        }
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.listen = function (query, currentHashFn, tag, onComplete) {
        var _this = this;
        var pathString = query.path.toString();
        this.log_('Listen called for ' + pathString + ' ' + query.queryIdentifier());
        // Mark this listener so we can tell if it's removed.
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        var thisListen = {};
        this.listens_[listenId] = thisListen;
        var queryStringParamaters = query
            .getQueryParams()
            .toRestQueryStringParameters();
        this.restRequest_(pathString + '.json', queryStringParamaters, function (error, result) {
            var data = result;
            if (error === 404) {
                data = null;
                error = null;
            }
            if (error === null) {
                _this.onDataUpdate_(pathString, data, /*isMerge=*/ false, tag);
            }
            if (util_4.safeGet(_this.listens_, listenId) === thisListen) {
                var status_1;
                if (!error) {
                    status_1 = 'ok';
                }
                else if (error == 401) {
                    status_1 = 'permission_denied';
                }
                else {
                    status_1 = 'rest_error:' + error;
                }
                onComplete(status_1, null);
            }
        });
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.unlisten = function (query, tag) {
        var listenId = ReadonlyRestClient.getListenId_(query, tag);
        delete this.listens_[listenId];
    };
    /** @inheritDoc */
    ReadonlyRestClient.prototype.refreshAuthToken = function (token) {
        // no-op since we just always call getToken.
    };
    /**
     * Performs a REST request to the given path, with the provided query string parameters,
     * and any auth credentials we have.
     *
     * @param {!string} pathString
     * @param {!Object.<string, *>} queryStringParameters
     * @param {?function(?number, *=)} callback
     * @private
     */
    ReadonlyRestClient.prototype.restRequest_ = function (pathString, queryStringParameters, callback) {
        var _this = this;
        if (queryStringParameters === void 0) { queryStringParameters = {}; }
        queryStringParameters['format'] = 'export';
        this.authTokenProvider_
            .getToken(/*forceRefresh=*/ false)
            .then(function (authTokenData) {
            var authToken = authTokenData && authTokenData.accessToken;
            if (authToken) {
                queryStringParameters['auth'] = authToken;
            }
            var url = (_this.repoInfo_.secure ? 'https://' : 'http://') +
                _this.repoInfo_.host +
                pathString +
                '?' +
                util_5.querystring(queryStringParameters);
            _this.log_('Sending REST request for ' + url);
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (callback && xhr.readyState === 4) {
                    _this.log_('REST Response for ' + url + ' received. status:', xhr.status, 'response:', xhr.responseText);
                    var res = null;
                    if (xhr.status >= 200 && xhr.status < 300) {
                        try {
                            res = util_3.jsonEval(xhr.responseText);
                        }
                        catch (e) {
                            util_2.warn('Failed to parse JSON response for ' +
                                url +
                                ': ' +
                                xhr.responseText);
                        }
                        callback(null, res);
                    }
                    else {
                        // 401 and 404 are expected.
                        if (xhr.status !== 401 && xhr.status !== 404) {
                            util_2.warn('Got unsuccessful REST response for ' +
                                url +
                                ' Status: ' +
                                xhr.status);
                        }
                        callback(xhr.status);
                    }
                    callback = null;
                }
            };
            xhr.open('GET', url, /*asynchronous=*/ true);
            xhr.send();
        });
    };
    return ReadonlyRestClient;
}(ServerActions_1.ServerActions));
exports.ReadonlyRestClient = ReadonlyRestClient;

//# sourceMappingURL=ReadonlyRestClient.js.map


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var util_2 = __webpack_require__(1);
var KeyIndex_1 = __webpack_require__(14);
var PriorityIndex_1 = __webpack_require__(3);
var ValueIndex_1 = __webpack_require__(53);
var PathIndex_1 = __webpack_require__(57);
var IndexedFilter_1 = __webpack_require__(33);
var LimitedFilter_1 = __webpack_require__(131);
var RangedFilter_1 = __webpack_require__(71);
var util_3 = __webpack_require__(0);
/**
 * This class is an immutable-from-the-public-api struct containing a set of query parameters defining a
 * range to be returned for a particular location. It is assumed that validation of parameters is done at the
 * user-facing API level, so it is not done here.
 * @constructor
 */
var QueryParams = /** @class */ (function () {
    function QueryParams() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = '';
        this.indexStartValue_ = null;
        this.indexStartName_ = '';
        this.indexEndValue_ = null;
        this.indexEndName_ = '';
        this.index_ = PriorityIndex_1.PRIORITY_INDEX;
    }
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasStart = function () {
        return this.startSet_;
    };
    /**
     * @return {boolean} True if it would return from left.
     */
    QueryParams.prototype.isViewFromLeft = function () {
        if (this.viewFrom_ === '') {
            // limit(), rather than limitToFirst or limitToLast was called.
            // This means that only one of startSet_ and endSet_ is true. Use them
            // to calculate which side of the view to anchor to. If neither is set,
            // anchor to the end.
            return this.startSet_;
        }
        else {
            return (this.viewFrom_ === QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT);
        }
    };
    /**
     * Only valid to call if hasStart() returns true
     * @return {*}
     */
    QueryParams.prototype.getIndexStartValue = function () {
        util_1.assert(this.startSet_, 'Only valid if start has been set');
        return this.indexStartValue_;
    };
    /**
     * Only valid to call if hasStart() returns true.
     * Returns the starting key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexStartName = function () {
        util_1.assert(this.startSet_, 'Only valid if start has been set');
        if (this.startNameSet_) {
            return this.indexStartName_;
        }
        else {
            return util_2.MIN_NAME;
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasEnd = function () {
        return this.endSet_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * @return {*}
     */
    QueryParams.prototype.getIndexEndValue = function () {
        util_1.assert(this.endSet_, 'Only valid if end has been set');
        return this.indexEndValue_;
    };
    /**
     * Only valid to call if hasEnd() returns true.
     * Returns the end key name for the range defined by these query parameters
     * @return {!string}
     */
    QueryParams.prototype.getIndexEndName = function () {
        util_1.assert(this.endSet_, 'Only valid if end has been set');
        if (this.endNameSet_) {
            return this.indexEndName_;
        }
        else {
            return util_2.MAX_NAME;
        }
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.hasLimit = function () {
        return this.limitSet_;
    };
    /**
     * @return {boolean} True if a limit has been set and it has been explicitly anchored
     */
    QueryParams.prototype.hasAnchoredLimit = function () {
        return this.limitSet_ && this.viewFrom_ !== '';
    };
    /**
     * Only valid to call if hasLimit() returns true
     * @return {!number}
     */
    QueryParams.prototype.getLimit = function () {
        util_1.assert(this.limitSet_, 'Only valid if limit has been set');
        return this.limit_;
    };
    /**
     * @return {!Index}
     */
    QueryParams.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @return {!QueryParams}
     * @private
     */
    QueryParams.prototype.copy_ = function () {
        var copy = new QueryParams();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limit = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = '';
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToFirst = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_LEFT;
        return newParams;
    };
    /**
     * @param {!number} newLimit
     * @return {!QueryParams}
     */
    QueryParams.prototype.limitToLast = function (newLimit) {
        var newParams = this.copy_();
        newParams.limitSet_ = true;
        newParams.limit_ = newLimit;
        newParams.viewFrom_ = QueryParams.WIRE_PROTOCOL_CONSTANTS_.VIEW_FROM_RIGHT;
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.startAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.startSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexStartValue_ = indexValue;
        if (key != null) {
            newParams.startNameSet_ = true;
            newParams.indexStartName_ = key;
        }
        else {
            newParams.startNameSet_ = false;
            newParams.indexStartName_ = '';
        }
        return newParams;
    };
    /**
     * @param {*} indexValue
     * @param {?string=} key
     * @return {!QueryParams}
     */
    QueryParams.prototype.endAt = function (indexValue, key) {
        var newParams = this.copy_();
        newParams.endSet_ = true;
        if (!(indexValue !== undefined)) {
            indexValue = null;
        }
        newParams.indexEndValue_ = indexValue;
        if (key !== undefined) {
            newParams.endNameSet_ = true;
            newParams.indexEndName_ = key;
        }
        else {
            newParams.endNameSet_ = false;
            newParams.indexEndName_ = '';
        }
        return newParams;
    };
    /**
     * @param {!Index} index
     * @return {!QueryParams}
     */
    QueryParams.prototype.orderBy = function (index) {
        var newParams = this.copy_();
        newParams.index_ = index;
        return newParams;
    };
    /**
     * @return {!Object}
     */
    QueryParams.prototype.getQueryObject = function () {
        var WIRE_PROTOCOL_CONSTANTS = QueryParams.WIRE_PROTOCOL_CONSTANTS_;
        var obj = {};
        if (this.startSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE] = this.indexStartValue_;
            if (this.startNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME] = this.indexStartName_;
            }
        }
        if (this.endSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE] = this.indexEndValue_;
            if (this.endNameSet_) {
                obj[WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME] = this.indexEndName_;
            }
        }
        if (this.limitSet_) {
            obj[WIRE_PROTOCOL_CONSTANTS.LIMIT] = this.limit_;
            var viewFrom = this.viewFrom_;
            if (viewFrom === '') {
                if (this.isViewFromLeft()) {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_LEFT;
                }
                else {
                    viewFrom = WIRE_PROTOCOL_CONSTANTS.VIEW_FROM_RIGHT;
                }
            }
            obj[WIRE_PROTOCOL_CONSTANTS.VIEW_FROM] = viewFrom;
        }
        // For now, priority index is the default, so we only specify if it's some other index
        if (this.index_ !== PriorityIndex_1.PRIORITY_INDEX) {
            obj[WIRE_PROTOCOL_CONSTANTS.INDEX] = this.index_.toString();
        }
        return obj;
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.loadsAllData = function () {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    /**
     * @return {boolean}
     */
    QueryParams.prototype.isDefault = function () {
        return this.loadsAllData() && this.index_ == PriorityIndex_1.PRIORITY_INDEX;
    };
    /**
     * @return {!NodeFilter}
     */
    QueryParams.prototype.getNodeFilter = function () {
        if (this.loadsAllData()) {
            return new IndexedFilter_1.IndexedFilter(this.getIndex());
        }
        else if (this.hasLimit()) {
            return new LimitedFilter_1.LimitedFilter(this);
        }
        else {
            return new RangedFilter_1.RangedFilter(this);
        }
    };
    /**
     * Returns a set of REST query string parameters representing this query.
     *
     * @return {!Object.<string,*>} query string parameters
     */
    QueryParams.prototype.toRestQueryStringParameters = function () {
        var REST_CONSTANTS = QueryParams.REST_QUERY_CONSTANTS_;
        var qs = {};
        if (this.isDefault()) {
            return qs;
        }
        var orderBy;
        if (this.index_ === PriorityIndex_1.PRIORITY_INDEX) {
            orderBy = REST_CONSTANTS.PRIORITY_INDEX;
        }
        else if (this.index_ === ValueIndex_1.VALUE_INDEX) {
            orderBy = REST_CONSTANTS.VALUE_INDEX;
        }
        else if (this.index_ === KeyIndex_1.KEY_INDEX) {
            orderBy = REST_CONSTANTS.KEY_INDEX;
        }
        else {
            util_1.assert(this.index_ instanceof PathIndex_1.PathIndex, 'Unrecognized index type!');
            orderBy = this.index_.toString();
        }
        qs[REST_CONSTANTS.ORDER_BY] = util_3.stringify(orderBy);
        if (this.startSet_) {
            qs[REST_CONSTANTS.START_AT] = util_3.stringify(this.indexStartValue_);
            if (this.startNameSet_) {
                qs[REST_CONSTANTS.START_AT] += ',' + util_3.stringify(this.indexStartName_);
            }
        }
        if (this.endSet_) {
            qs[REST_CONSTANTS.END_AT] = util_3.stringify(this.indexEndValue_);
            if (this.endNameSet_) {
                qs[REST_CONSTANTS.END_AT] += ',' + util_3.stringify(this.indexEndName_);
            }
        }
        if (this.limitSet_) {
            if (this.isViewFromLeft()) {
                qs[REST_CONSTANTS.LIMIT_TO_FIRST] = this.limit_;
            }
            else {
                qs[REST_CONSTANTS.LIMIT_TO_LAST] = this.limit_;
            }
        }
        return qs;
    };
    /**
     * Wire Protocol Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.WIRE_PROTOCOL_CONSTANTS_ = {
        INDEX_START_VALUE: 'sp',
        INDEX_START_NAME: 'sn',
        INDEX_END_VALUE: 'ep',
        INDEX_END_NAME: 'en',
        LIMIT: 'l',
        VIEW_FROM: 'vf',
        VIEW_FROM_LEFT: 'l',
        VIEW_FROM_RIGHT: 'r',
        INDEX: 'i'
    };
    /**
     * REST Query Constants
     * @const
     * @enum {string}
     * @private
     */
    QueryParams.REST_QUERY_CONSTANTS_ = {
        ORDER_BY: 'orderBy',
        PRIORITY_INDEX: '$priority',
        VALUE_INDEX: '$value',
        KEY_INDEX: '$key',
        START_AT: 'startAt',
        END_AT: 'endAt',
        LIMIT_TO_FIRST: 'limitToFirst',
        LIMIT_TO_LAST: 'limitToLast'
    };
    /**
     * Default, empty query parameters
     * @type {!QueryParams}
     * @const
     */
    QueryParams.DEFAULT = new QueryParams();
    return QueryParams;
}());
exports.QueryParams = QueryParams;

//# sourceMappingURL=QueryParams.js.map


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RangedFilter_1 = __webpack_require__(71);
var ChildrenNode_1 = __webpack_require__(4);
var Node_1 = __webpack_require__(5);
var util_1 = __webpack_require__(0);
var Change_1 = __webpack_require__(12);
/**
 * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible
 *
 * @constructor
 * @implements {NodeFilter}
 */
var LimitedFilter = /** @class */ (function () {
    /**
     * @param {!QueryParams} params
     */
    function LimitedFilter(params) {
        this.rangedFilter_ = new RangedFilter_1.RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
    }
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new Node_1.NamedNode(key, newChild))) {
            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key).equals(newChild)) {
            // No change
            return snap;
        }
        else if (snap.numChildren() < this.limit_) {
            return this.rangedFilter_
                .getIndexedFilter()
                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
        }
        else {
            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
        }
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {
        var filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
            // Make sure we have a children node with the correct index, not a leaf node;
            filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        }
        else {
            if (this.limit_ * 2 < newSnap.numChildren() &&
                newSnap.isIndexed(this.index_)) {
                // Easier to build up a snapshot, since what we're given has more than twice the elements we want
                filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);
                // anchor to the startPost, endPost, or last element as appropriate
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
                }
                else {
                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
                }
                var count = 0;
                while (iterator.hasNext() && count < this.limit_) {
                    var next = iterator.getNext();
                    var inRange = void 0;
                    if (this.reverse_) {
                        inRange =
                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
                    }
                    else {
                        inRange =
                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
                    }
                    if (inRange) {
                        filtered = filtered.updateImmediateChild(next.name, next.node);
                        count++;
                    }
                    else {
                        // if we have reached the end post, we cannot keep adding elemments
                        break;
                    }
                }
            }
            else {
                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one
                filtered = newSnap.withIndex(this.index_);
                // Don't support priorities on queries
                filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                var startPost = void 0;
                var endPost = void 0;
                var cmp = void 0;
                var iterator = void 0;
                if (this.reverse_) {
                    iterator = filtered.getReverseIterator(this.index_);
                    startPost = this.rangedFilter_.getEndPost();
                    endPost = this.rangedFilter_.getStartPost();
                    var indexCompare_1 = this.index_.getCompare();
                    cmp = function (a, b) { return indexCompare_1(b, a); };
                }
                else {
                    iterator = filtered.getIterator(this.index_);
                    startPost = this.rangedFilter_.getStartPost();
                    endPost = this.rangedFilter_.getEndPost();
                    cmp = this.index_.getCompare();
                }
                var count = 0;
                var foundStartPost = false;
                while (iterator.hasNext()) {
                    var next = iterator.getNext();
                    if (!foundStartPost && cmp(startPost, next) <= 0) {
                        // start adding
                        foundStartPost = true;
                    }
                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
                    if (inRange) {
                        count++;
                    }
                    else {
                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                    }
                }
            }
        }
        return this.rangedFilter_
            .getIndexedFilter()
            .updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {
        // Don't support priorities on queries
        return oldSnap;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.filtersNodes = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndexedFilter = function () {
        return this.rangedFilter_.getIndexedFilter();
    };
    /**
     * @inheritDoc
     */
    LimitedFilter.prototype.getIndex = function () {
        return this.index_;
    };
    /**
     * @param {!Node} snap
     * @param {string} childKey
     * @param {!Node} childSnap
     * @param {!CompleteChildSource} source
     * @param {?ChildChangeAccumulator} changeAccumulator
     * @return {!Node}
     * @private
     */
    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {
        // TODO: rename all cache stuff etc to general snap terminology
        var cmp;
        if (this.reverse_) {
            var indexCmp_1 = this.index_.getCompare();
            cmp = function (a, b) { return indexCmp_1(b, a); };
        }
        else {
            cmp = this.index_.getCompare();
        }
        var oldEventCache = snap;
        util_1.assert(oldEventCache.numChildren() == this.limit_, '');
        var newChildNamedNode = new Node_1.NamedNode(childKey, childSnap);
        var windowBoundary = this.reverse_
            ? oldEventCache.getFirstChild(this.index_)
            : oldEventCache.getLastChild(this.index_);
        var inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
            var oldChildSnap = oldEventCache.getImmediateChild(childKey);
            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
            while (nextChild != null &&
                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {
                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't
                // been applied to the limited filter yet. Ignore this next child which will be updated later in
                // the limited filter...
                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
            }
            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
            if (remainsInWindow) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childChangedChange(childKey, childSnap, oldChildSnap));
                }
                return oldEventCache.updateImmediateChild(childKey, childSnap);
            }
            else {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(childKey, oldChildSnap));
                }
                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
                if (nextChildInRange) {
                    if (changeAccumulator != null) {
                        changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(nextChild.name, nextChild.node));
                    }
                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
                }
                else {
                    return newEventCache;
                }
            }
        }
        else if (childSnap.isEmpty()) {
            // we're deleting a node, but it was not in the window, so ignore it
            return snap;
        }
        else if (inRange) {
            if (cmp(windowBoundary, newChildNamedNode) >= 0) {
                if (changeAccumulator != null) {
                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(windowBoundary.name, windowBoundary.node));
                    changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(childKey, childSnap));
                }
                return oldEventCache
                    .updateImmediateChild(childKey, childSnap)
                    .updateImmediateChild(windowBoundary.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);
            }
            else {
                return snap;
            }
        }
        else {
            return snap;
        }
    };
    return LimitedFilter;
}());
exports.LimitedFilter = LimitedFilter;

//# sourceMappingURL=LimitedFilter.js.map


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Reference_1 = __webpack_require__(30);
var DataSnapshot_1 = __webpack_require__(31);
var Path_1 = __webpack_require__(2);
var Tree_1 = __webpack_require__(133);
var PriorityIndex_1 = __webpack_require__(3);
var util_2 = __webpack_require__(1);
var ServerValues_1 = __webpack_require__(58);
var validation_1 = __webpack_require__(9);
var util_3 = __webpack_require__(0);
var nodeFromJSON_1 = __webpack_require__(15);
var ChildrenNode_1 = __webpack_require__(4);
var Repo_1 = __webpack_require__(23);
// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific
// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well
// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.
// For now it's part of Repo, but in its own file.
/**
 * @enum {number}
 */
var TransactionStatus;
(function (TransactionStatus) {
    // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the
    // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to
    // mismatched hash.
    TransactionStatus[TransactionStatus["RUN"] = 0] = "RUN";
    // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted
    // or rejected yet).
    TransactionStatus[TransactionStatus["SENT"] = 1] = "SENT";
    // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be
    // removed when we get a chance to prune completed ones.
    TransactionStatus[TransactionStatus["COMPLETED"] = 2] = "COMPLETED";
    // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).
    // If it comes back as unsuccessful, we'll abort it.
    TransactionStatus[TransactionStatus["SENT_NEEDS_ABORT"] = 3] = "SENT_NEEDS_ABORT";
    // Temporary state used to mark transactions that need to be aborted.
    TransactionStatus[TransactionStatus["NEEDS_ABORT"] = 4] = "NEEDS_ABORT";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's
 * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.
 * @type {number}
 * @const
 * @private
 */
Repo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;
/**
 * Setup the transaction data structures
 * @private
 */
Repo_1.Repo.prototype.transactions_init_ = function () {
    /**
     * Stores queues of outstanding transactions for Firebase locations.
     *
     * @type {!Tree.<Array.<!Transaction>>}
     * @private
     */
    this.transactionQueueTree_ = new Tree_1.Tree();
};
/**
 * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.
 *
 * @param {!Path} path Path at which to do transaction.
 * @param {function(*):*} transactionUpdate Update callback.
 * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.
 * @param {boolean} applyLocally Whether or not to make intermediate results visible
 */
Repo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {
    this.log_('transaction on ' + path);
    // Add a watch to make sure we get server updates.
    var valueCallback = function () { };
    var watchRef = new Reference_1.Reference(this, path);
    watchRef.on('value', valueCallback);
    var unwatcher = function () {
        watchRef.off('value', valueCallback);
    };
    // Initialize transaction.
    var transaction = {
        path: path,
        update: transactionUpdate,
        onComplete: onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out which one goes first.
        order: util_2.LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally: applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher: unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
    };
    // Run transaction initially.
    var currentState = this.getLatestState_(path);
    transaction.currentInputSnapshot = currentState;
    var newVal = transaction.update(currentState.val());
    if (newVal === undefined) {
        // Abort transaction.
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
            // We just set the input snapshot, so this cast should be safe
            var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);
            transaction.onComplete(null, false, snapshot);
        }
    }
    else {
        validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);
        // Mark as run and add to our queue.
        transaction.status = TransactionStatus.RUN;
        var queueNode = this.transactionQueueTree_.subTree(path);
        var nodeQueue = queueNode.getValue() || [];
        nodeQueue.push(transaction);
        queueNode.setValue(nodeQueue);
        // Update visibleData and raise events
        // Note: We intentionally raise events after updating all of our transaction state, since the user could
        // start new transactions from the event callbacks.
        var priorityForNode = void 0;
        if (typeof newVal === 'object' &&
            newVal !== null &&
            util_3.contains(newVal, '.priority')) {
            priorityForNode = util_3.safeGet(newVal, '.priority');
            util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +
                'Priority must be a valid string, finite number, server value, or null.');
        }
        else {
            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) ||
                ChildrenNode_1.ChildrenNode.EMPTY_NODE;
            priorityForNode = currentNode.getPriority().val();
        }
        priorityForNode /** @type {null|number|string} */ = priorityForNode;
        var serverValues = this.generateServerValues();
        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);
        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = this.getNextWriteId_();
        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        this.sendReadyTransactions_();
    }
};
/**
 * @param {!Path} path
 * @param {Array.<number>=} excludeSets A specific set to exclude
 * @return {Node}
 * @private
 */
Repo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {
    return (this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||
        ChildrenNode_1.ChildrenNode.EMPTY_NODE);
};
/**
 * Sends any already-run transactions that aren't waiting for outstanding transactions to
 * complete.
 *
 * Externally it's called with no arguments, but it calls itself recursively with a particular
 * transactionQueueTree node to recurse through the tree.
 *
 * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.
 * @private
 */
Repo_1.Repo.prototype.sendReadyTransactions_ = function (node) {
    var _this = this;
    if (node === void 0) { node = this.transactionQueueTree_; }
    // Before recursing, make sure any completed transactions are removed.
    if (!node) {
        this.pruneCompletedTransactionsBelowNode_(node);
    }
    if (node.getValue() !== null) {
        var queue = this.buildTransactionQueue_(node);
        util_1.assert(queue.length > 0, 'Sending zero length transaction queue');
        var allRun = queue.every(function (transaction) { return transaction.status === TransactionStatus.RUN; });
        // If they're all run (and not sent), we can send them.  Else, we must wait.
        if (allRun) {
            this.sendTransactionQueue_(node.path(), queue);
        }
    }
    else if (node.hasChildren()) {
        node.forEachChild(function (childNode) {
            _this.sendReadyTransactions_(childNode);
        });
    }
};
/**
 * Given a list of run transactions, send them to the server and then handle the result (success or failure).
 *
 * @param {!Path} path The location of the queue.
 * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.
 * @private
 */
Repo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {
    var _this = this;
    // Mark transactions as sent and increment retry count!
    var setsToIgnore = queue.map(function (txn) {
        return txn.currentWriteId;
    });
    var latestState = this.getLatestState_(path, setsToIgnore);
    var snapToSend = latestState;
    var latestHash = latestState.hash();
    for (var i = 0; i < queue.length; i++) {
        var txn = queue[i];
        util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');
        txn.status = TransactionStatus.SENT;
        txn.retryCount++;
        var relativePath = Path_1.Path.relativePath(path, txn.path);
        // If we've gotten to this point, the output snapshot must be defined.
        snapToSend = snapToSend.updateChild(relativePath /**@type {!Node} */, txn.currentOutputSnapshotRaw);
    }
    var dataToSend = snapToSend.val(true);
    var pathToSend = path;
    // Send the put.
    this.server_.put(pathToSend.toString(), dataToSend, function (status) {
        _this.log_('transaction put response', {
            path: pathToSend.toString(),
            status: status
        });
        var events = [];
        if (status === 'ok') {
            // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
            // the callback could trigger more transactions or sets.
            var callbacks = [];
            for (var i = 0; i < queue.length; i++) {
                queue[i].status = TransactionStatus.COMPLETED;
                events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));
                if (queue[i].onComplete) {
                    // We never unset the output snapshot, and given that this transaction is complete, it should be set
                    var node = queue[i].currentOutputSnapshotResolved;
                    var ref = new Reference_1.Reference(_this, queue[i].path);
                    var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);
                    callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));
                }
                queue[i].unwatcher();
            }
            // Now remove the completed transactions.
            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));
            // There may be pending transactions that we can now send.
            _this.sendReadyTransactions_();
            _this.eventQueue_.raiseEventsForChangedPath(path, events);
            // Finally, trigger onComplete callbacks.
            for (var i = 0; i < callbacks.length; i++) {
                util_2.exceptionGuard(callbacks[i]);
            }
        }
        else {
            // transactions are no longer sent.  Update their status appropriately.
            if (status === 'datastale') {
                for (var i = 0; i < queue.length; i++) {
                    if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)
                        queue[i].status = TransactionStatus.NEEDS_ABORT;
                    else
                        queue[i].status = TransactionStatus.RUN;
                }
            }
            else {
                util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);
                for (var i = 0; i < queue.length; i++) {
                    queue[i].status = TransactionStatus.NEEDS_ABORT;
                    queue[i].abortReason = status;
                }
            }
            _this.rerunTransactions_(path);
        }
    }, latestHash);
};
/**
 * Finds all transactions dependent on the data at changedPath and reruns them.
 *
 * Should be called any time cached data changes.
 *
 * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to
 * be raised for.
 *
 * @param {!Path} changedPath The path in mergedData that changed.
 * @return {!Path} The rootmost path that was affected by rerunning transactions.
 * @private
 */
Repo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {
    var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);
    var path = rootMostTransactionNode.path();
    var queue = this.buildTransactionQueue_(rootMostTransactionNode);
    this.rerunTransactionQueue_(queue, path);
    return path;
};
/**
 * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).
 *
 * @param {Array.<Transaction>} queue The queue of transactions to run.
 * @param {!Path} path The path the queue is for.
 * @private
 */
Repo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {
    if (queue.length === 0) {
        return; // Nothing to do!
    }
    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
    // the callback could trigger more transactions or sets.
    var callbacks = [];
    var events = [];
    // Ignore all of the sets we're going to re-run.
    var txnsToRerun = queue.filter(function (q) {
        return q.status === TransactionStatus.RUN;
    });
    var setsToIgnore = txnsToRerun.map(function (q) {
        return q.currentWriteId;
    });
    for (var i = 0; i < queue.length; i++) {
        var transaction = queue[i];
        var relativePath = Path_1.Path.relativePath(path, transaction.path);
        var abortTransaction = false, abortReason = void 0;
        util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');
        if (transaction.status === TransactionStatus.NEEDS_ABORT) {
            abortTransaction = true;
            abortReason = transaction.abortReason;
            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
        }
        else if (transaction.status === TransactionStatus.RUN) {
            if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {
                abortTransaction = true;
                abortReason = 'maxretry';
                events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
            }
            else {
                // This code reruns a transaction
                var currentNode = this.getLatestState_(transaction.path, setsToIgnore);
                transaction.currentInputSnapshot = currentNode;
                var newData = queue[i].update(currentNode.val());
                if (newData !== undefined) {
                    validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);
                    var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);
                    var hasExplicitPriority = typeof newData === 'object' &&
                        newData != null &&
                        util_3.contains(newData, '.priority');
                    if (!hasExplicitPriority) {
                        // Keep the old priority if there wasn't a priority explicitly specified.
                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());
                    }
                    var oldWriteId = transaction.currentWriteId;
                    var serverValues = this.generateServerValues();
                    var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);
                    transaction.currentOutputSnapshotRaw = newDataNode;
                    transaction.currentOutputSnapshotResolved = newNodeResolved;
                    transaction.currentWriteId = this.getNextWriteId_();
                    // Mutates setsToIgnore in place
                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
                    events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
                    events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));
                }
                else {
                    abortTransaction = true;
                    abortReason = 'nodata';
                    events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));
                }
            }
        }
        this.eventQueue_.raiseEventsForChangedPath(path, events);
        events = [];
        if (abortTransaction) {
            // Abort.
            queue[i].status = TransactionStatus.COMPLETED;
            // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).
            // So defer the unwatcher until we're done.
            (function (unwatcher) {
                setTimeout(unwatcher, Math.floor(0));
            })(queue[i].unwatcher);
            if (queue[i].onComplete) {
                if (abortReason === 'nodata') {
                    var ref = new Reference_1.Reference(this, queue[i].path);
                    // We set this field immediately, so it's safe to cast to an actual snapshot
                    var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;
                    var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);
                    callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));
                }
                else {
                    callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));
                }
            }
        }
    }
    // Clean up completed transactions.
    this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);
    // Now fire callbacks, now that we're in a good, known state.
    for (var i = 0; i < callbacks.length; i++) {
        util_2.exceptionGuard(callbacks[i]);
    }
    // Try to send the transaction result to the server.
    this.sendReadyTransactions_();
};
/**
 * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns
 * the node for the given path if there are no pending transactions on any ancestor.
 *
 * @param {!Path} path The location to start at.
 * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.
 * @private
 */
Repo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {
    var front;
    // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.
    var transactionNode = this.transactionQueueTree_;
    while ((front = path.getFront()) !== null &&
        transactionNode.getValue() === null) {
        transactionNode = transactionNode.subTree(front);
        path = path.popFront();
    }
    return transactionNode;
};
/**
 * Builds the queue of all transactions at or below the specified transactionNode.
 *
 * @param {!Tree.<Array.<Transaction>>} transactionNode
 * @return {Array.<Transaction>} The generated queue.
 * @private
 */
Repo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {
    // Walk any child transaction queues and aggregate them into a single queue.
    var transactionQueue = [];
    this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);
    // Sort them by the order the transactions were created.
    transactionQueue.sort(function (a, b) {
        return a.order - b.order;
    });
    return transactionQueue;
};
/**
 * @param {!Tree.<Array.<Transaction>>} node
 * @param {Array.<Transaction>} queue
 * @private
 */
Repo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {
    var _this = this;
    var nodeQueue = node.getValue();
    if (nodeQueue !== null) {
        for (var i = 0; i < nodeQueue.length; i++) {
            queue.push(nodeQueue[i]);
        }
    }
    node.forEachChild(function (child) {
        _this.aggregateTransactionQueuesForNode_(child, queue);
    });
};
/**
 * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
 *
 * @param {!Tree.<Array.<!Transaction>>} node
 * @private
 */
Repo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {
    var _this = this;
    var queue = node.getValue();
    if (queue) {
        var to = 0;
        for (var from = 0; from < queue.length; from++) {
            if (queue[from].status !== TransactionStatus.COMPLETED) {
                queue[to] = queue[from];
                to++;
            }
        }
        queue.length = to;
        node.setValue(queue.length > 0 ? queue : null);
    }
    node.forEachChild(function (childNode) {
        _this.pruneCompletedTransactionsBelowNode_(childNode);
    });
};
/**
 * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()
 * since we consider them incompatible with transactions.
 *
 * @param {!Path} path Path for which we want to abort related transactions.
 * @return {!Path}
 * @private
 */
Repo_1.Repo.prototype.abortTransactions_ = function (path) {
    var _this = this;
    var affectedPath = this.getAncestorTransactionNode_(path).path();
    var transactionNode = this.transactionQueueTree_.subTree(path);
    transactionNode.forEachAncestor(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    this.abortTransactionsOnNode_(transactionNode);
    transactionNode.forEachDescendant(function (node) {
        _this.abortTransactionsOnNode_(node);
    });
    return affectedPath;
};
/**
 * Abort transactions stored in this transaction queue node.
 *
 * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.
 * @private
 */
Repo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {
    var queue = node.getValue();
    if (queue !== null) {
        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since
        // the callback could trigger more transactions or sets.
        var callbacks = [];
        // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones
        // can be immediately aborted and removed.
        var events = [];
        var lastSent = -1;
        for (var i = 0; i < queue.length; i++) {
            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {
                // Already marked.  No action needed.
            }
            else if (queue[i].status === TransactionStatus.SENT) {
                util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');
                lastSent = i;
                // Mark transaction for abort when it comes back.
                queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;
                queue[i].abortReason = 'set';
            }
            else {
                util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');
                // We can abort it immediately.
                queue[i].unwatcher();
                events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));
                if (queue[i].onComplete) {
                    var snapshot = null;
                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));
                }
            }
        }
        if (lastSent === -1) {
            // We're not waiting for any sent transactions.  We can clear the queue.
            node.setValue(null);
        }
        else {
            // Remove the transactions we aborted.
            queue.length = lastSent + 1;
        }
        // Now fire the callbacks.
        this.eventQueue_.raiseEventsForChangedPath(node.path(), events);
        for (var i = 0; i < callbacks.length; i++) {
            util_2.exceptionGuard(callbacks[i]);
        }
    }
};

//# sourceMappingURL=Repo_transaction.js.map


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(0);
var Path_1 = __webpack_require__(2);
var util_2 = __webpack_require__(0);
/**
 * Node in a Tree.
 */
var TreeNode = /** @class */ (function () {
    function TreeNode() {
        // TODO: Consider making accessors that create children and value lazily or
        // separate Internal / Leaf 'types'.
        this.children = {};
        this.childCount = 0;
        this.value = null;
    }
    return TreeNode;
}());
exports.TreeNode = TreeNode;
/**
 * A light-weight tree, traversable by path.  Nodes can have both values and children.
 * Nodes are not enumerated (by forEachChild) unless they have a value or non-empty
 * children.
 */
var Tree = /** @class */ (function () {
    /**
     * @template T
     * @param {string=} name_ Optional name of the node.
     * @param {Tree=} parent_ Optional parent node.
     * @param {TreeNode=} node_ Optional node to wrap.
     */
    function Tree(name_, parent_, node_) {
        if (name_ === void 0) { name_ = ''; }
        if (parent_ === void 0) { parent_ = null; }
        if (node_ === void 0) { node_ = new TreeNode(); }
        this.name_ = name_;
        this.parent_ = parent_;
        this.node_ = node_;
    }
    /**
     * Returns a sub-Tree for the given path.
     *
     * @param {!(string|Path)} pathObj Path to look up.
     * @return {!Tree.<T>} Tree for path.
     */
    Tree.prototype.subTree = function (pathObj) {
        // TODO: Require pathObj to be Path?
        var path = pathObj instanceof Path_1.Path ? pathObj : new Path_1.Path(pathObj);
        var child = this, next;
        while ((next = path.getFront()) !== null) {
            var childNode = util_2.safeGet(child.node_.children, next) || new TreeNode();
            child = new Tree(next, child, childNode);
            path = path.popFront();
        }
        return child;
    };
    /**
     * Returns the data associated with this tree node.
     *
     * @return {?T} The data or null if no data exists.
     */
    Tree.prototype.getValue = function () {
        return this.node_.value;
    };
    /**
     * Sets data to this tree node.
     *
     * @param {!T} value Value to set.
     */
    Tree.prototype.setValue = function (value) {
        util_1.assert(typeof value !== 'undefined', 'Cannot set value to undefined');
        this.node_.value = value;
        this.updateParents_();
    };
    /**
     * Clears the contents of the tree node (its value and all children).
     */
    Tree.prototype.clear = function () {
        this.node_.value = null;
        this.node_.children = {};
        this.node_.childCount = 0;
        this.updateParents_();
    };
    /**
     * @return {boolean} Whether the tree has any children.
     */
    Tree.prototype.hasChildren = function () {
        return this.node_.childCount > 0;
    };
    /**
     * @return {boolean} Whether the tree is empty (no value or children).
     */
    Tree.prototype.isEmpty = function () {
        return this.getValue() === null && !this.hasChildren();
    };
    /**
     * Calls action for each child of this tree node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachChild = function (action) {
        var _this = this;
        util_2.forEach(this.node_.children, function (child, childTree) {
            action(new Tree(child, _this, childTree));
        });
    };
    /**
     * Does a depth-first traversal of this node's descendants, calling action for each one.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     * @param {boolean=} includeSelf Whether to call action on this node as well. Defaults to
     *   false.
     * @param {boolean=} childrenFirst Whether to call action on children before calling it on
     *   parent.
     */
    Tree.prototype.forEachDescendant = function (action, includeSelf, childrenFirst) {
        if (includeSelf && !childrenFirst)
            action(this);
        this.forEachChild(function (child) {
            child.forEachDescendant(action, /*includeSelf=*/ true, childrenFirst);
        });
        if (includeSelf && childrenFirst)
            action(this);
    };
    /**
     * Calls action on each ancestor node.
     *
     * @param {function(!Tree.<T>)} action Action to be called on each parent; return
     *   true to abort.
     * @param {boolean=} includeSelf Whether to call action on this node as well.
     * @return {boolean} true if the action callback returned true.
     */
    Tree.prototype.forEachAncestor = function (action, includeSelf) {
        var node = includeSelf ? this : this.parent();
        while (node !== null) {
            if (action(node)) {
                return true;
            }
            node = node.parent();
        }
        return false;
    };
    /**
     * Does a depth-first traversal of this node's descendants.  When a descendant with a value
     * is found, action is called on it and traversal does not continue inside the node.
     * Action is *not* called on this node.
     *
     * @param {function(!Tree.<T>)} action Action to be called for each child.
     */
    Tree.prototype.forEachImmediateDescendantWithValue = function (action) {
        this.forEachChild(function (child) {
            if (child.getValue() !== null)
                action(child);
            else
                child.forEachImmediateDescendantWithValue(action);
        });
    };
    /**
     * @return {!Path} The path of this tree node, as a Path.
     */
    Tree.prototype.path = function () {
        return new Path_1.Path(this.parent_ === null
            ? this.name_
            : this.parent_.path() + '/' + this.name_);
    };
    /**
     * @return {string} The name of the tree node.
     */
    Tree.prototype.name = function () {
        return this.name_;
    };
    /**
     * @return {?Tree} The parent tree node, or null if this is the root of the tree.
     */
    Tree.prototype.parent = function () {
        return this.parent_;
    };
    /**
     * Adds or removes this child from its parent based on whether it's empty or not.
     *
     * @private
     */
    Tree.prototype.updateParents_ = function () {
        if (this.parent_ !== null)
            this.parent_.updateChild_(this.name_, this);
    };
    /**
     * Adds or removes the passed child to this tree node, depending on whether it's empty.
     *
     * @param {string} childName The name of the child to update.
     * @param {!Tree.<T>} child The child to update.
     * @private
     */
    Tree.prototype.updateChild_ = function (childName, child) {
        var childEmpty = child.isEmpty();
        var childExists = util_2.contains(this.node_.children, childName);
        if (childEmpty && childExists) {
            delete this.node_.children[childName];
            this.node_.childCount--;
            this.updateParents_();
        }
        else if (!childEmpty && !childExists) {
            this.node_.children[childName] = child.node_;
            this.node_.childCount++;
            this.updateParents_();
        }
    };
    return Tree;
}());
exports.Tree = Tree;

//# sourceMappingURL=Tree.js.map


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var WebSocketConnection_1 = __webpack_require__(69);
var BrowserPollConnection_1 = __webpack_require__(68);
/**
 * INTERNAL methods for internal-use only (tests, etc.).
 *
 * Customers shouldn't use these or else should be aware that they could break at any time.
 *
 * @const
 */
exports.forceLongPolling = function () {
    WebSocketConnection_1.WebSocketConnection.forceDisallow();
    BrowserPollConnection_1.BrowserPollConnection.forceAllow();
};
exports.forceWebSockets = function () {
    BrowserPollConnection_1.BrowserPollConnection.forceDisallow();
};
/* Used by App Manager */
exports.isWebSocketsAvailable = function () {
    return WebSocketConnection_1.WebSocketConnection['isAvailable']();
};
exports.setSecurityDebugCallback = function (ref, callback) {
    ref.repo.persistentConnection_.securityDebugCallback_ = callback;
};
exports.stats = function (ref, showDelta) {
    ref.repo.stats(showDelta);
};
exports.statsIncrementCounter = function (ref, metric) {
    ref.repo.statsIncrementCounter(metric);
};
exports.dataUpdateCount = function (ref) {
    return ref.repo.dataUpdateCount;
};
exports.interceptServerData = function (ref, callback) {
    return ref.repo.interceptServerData_(callback);
};

//# sourceMappingURL=internal.js.map


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var RepoInfo_1 = __webpack_require__(49);
var PersistentConnection_1 = __webpack_require__(65);
var RepoManager_1 = __webpack_require__(35);
var Connection_1 = __webpack_require__(67);
exports.DataConnection = PersistentConnection_1.PersistentConnection;
/**
 * @param {!string} pathString
 * @param {function(*)} onComplete
 */
PersistentConnection_1.PersistentConnection.prototype.simpleListen = function (pathString, onComplete) {
    this.sendRequest('q', { p: pathString }, onComplete);
};
/**
 * @param {*} data
 * @param {function(*)} onEcho
 */
PersistentConnection_1.PersistentConnection.prototype.echo = function (data, onEcho) {
    this.sendRequest('echo', { d: data }, onEcho);
};
// RealTimeConnection properties that we use in tests.
exports.RealTimeConnection = Connection_1.Connection;
/**
 * @param {function(): string} newHash
 * @return {function()}
 */
exports.hijackHash = function (newHash) {
    var oldPut = PersistentConnection_1.PersistentConnection.prototype.put;
    PersistentConnection_1.PersistentConnection.prototype.put = function (pathString, data, opt_onComplete, opt_hash) {
        if (opt_hash !== undefined) {
            opt_hash = newHash();
        }
        oldPut.call(this, pathString, data, opt_onComplete, opt_hash);
    };
    return function () {
        PersistentConnection_1.PersistentConnection.prototype.put = oldPut;
    };
};
/**
 * @type {function(new:RepoInfo, !string, boolean, !string, boolean): undefined}
 */
exports.ConnectionTarget = RepoInfo_1.RepoInfo;
/**
 * @param {!Query} query
 * @return {!string}
 */
exports.queryIdentifier = function (query) {
    return query.queryIdentifier();
};
/**
 * @param {!Query} firebaseRef
 * @return {!Object}
 */
exports.listens = function (firebaseRef) {
    return firebaseRef.repo.persistentConnection_.listens_;
};
/**
 * Forces the RepoManager to create Repos that use ReadonlyRestClient instead of PersistentConnection.
 *
 * @param {boolean} forceRestClient
 */
exports.forceRestClient = function (forceRestClient) {
    RepoManager_1.RepoManager.getInstance().forceRestClient(forceRestClient);
};

//# sourceMappingURL=test_access.js.map


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _firebase = __webpack_require__(137);

var firebase = _interopRequireWildcard(_firebase);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var config = {
  apiKey: "AIzaSyBWyd3lRjkN6cV7h9KavIF3C6vu19trPj4",
  authDomain: "sunflower-33166247.firebaseapp.com",
  databaseURL: "https://sunflower-33166247.firebaseio.com",
  projectId: "sunflower-33166247",
  storageBucket: "sunflower-33166247.appspot.com",
  messagingSenderId: "1047833269465"
};

firebase.initializeApp(config);

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var firebase = __webpack_require__(40);
__webpack_require__(41);
__webpack_require__(81);
__webpack_require__(138);
__webpack_require__(145);

module.exports = firebase;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(139);


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["registerMessaging"] = registerMessaging;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_controllers_window_controller__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_controllers_sw_controller__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__firebase_app__ = __webpack_require__(8);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




function registerMessaging(instance) {
    var messagingName = 'messaging';
    var factoryMethod = function (app) {
        if (self && 'ServiceWorkerGlobalScope' in self) {
            return new __WEBPACK_IMPORTED_MODULE_1__src_controllers_sw_controller__["a" /* default */](app);
        }
        // Assume we are in the window context.
        return new __WEBPACK_IMPORTED_MODULE_0__src_controllers_window_controller__["a" /* default */](app);
    };
    var namespaceExports = {
        // no-inline
        Messaging: __WEBPACK_IMPORTED_MODULE_0__src_controllers_window_controller__["a" /* default */]
    };
    instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);
}
registerMessaging(__WEBPACK_IMPORTED_MODULE_2__firebase_app__["default"]);

//# sourceMappingURL=index.js.map


/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__controller_interface__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_errors__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__models_default_sw__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__models_notification_permission__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__firebase_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__firebase_util__);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var WindowController = /** @class */ (function (_super) {
    __extends(WindowController, _super);
    /**
     * A service that provides a MessagingService instance.
     * @param {!firebase.app.App} app
     */
    function WindowController(app) {
        var _this = _super.call(this, app) || this;
        /**
         * @private
         * @type {ServiceWorkerRegistration}
         */
        _this.registrationToUse_;
        /**
         * @private
         * @type {Promise}
         */
        _this.manifestCheckPromise_;
        /**
         * @private
         * @type {firebase.Observer}
         */
        _this.messageObserver_ = null;
        /**
         * @private {!firebase.Subscribe} The subscribe function to the onMessage
         * observer.
         */
        _this.onMessage_ = Object(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["createSubscribe"])(function (observer) {
            _this.messageObserver_ = observer;
        });
        /**
         * @private
         * @type {firebase.Observer}
         */
        _this.tokenRefreshObserver_ = null;
        _this.onTokenRefresh_ = Object(__WEBPACK_IMPORTED_MODULE_5__firebase_util__["createSubscribe"])(function (observer) {
            _this.tokenRefreshObserver_ = observer;
        });
        _this.setupSWMessageListener_();
        return _this;
    }
    /**
     * This method returns an FCM token if it can be generated.
     * The return promise will reject if the browser doesn't support
     * FCM, if permission is denied for notifications or it's not
     * possible to generate a token.
     * @export
     * @return {Promise<string> | Promise<null>} Returns a promise the
     * resolves to an FCM token or null if permission isn't granted.
     */
    WindowController.prototype.getToken = function () {
        var _this = this;
        // Check that the required API's are available
        if (!this.isSupported_()) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.UNSUPPORTED_BROWSER));
        }
        return this.manifestCheck_().then(function () {
            return _super.prototype.getToken.call(_this);
        });
    };
    /**
     * The method checks that a manifest is defined and has the correct GCM
     * sender ID.
     * @private
     * @return {Promise} Returns a promise that resolves if the manifest matches
     * our required sender ID
     */
    WindowController.prototype.manifestCheck_ = function () {
        var _this = this;
        if (this.manifestCheckPromise_) {
            return this.manifestCheckPromise_;
        }
        var manifestTag = document.querySelector('link[rel="manifest"]');
        if (!manifestTag) {
            this.manifestCheckPromise_ = Promise.resolve();
        }
        else {
            this.manifestCheckPromise_ = fetch(manifestTag.href)
                .then(function (response) {
                return response.json();
            })
                .catch(function () {
                // If the download or parsing fails allow check.
                // We only want to error if we KNOW that the gcm_sender_id is incorrect.
                return Promise.resolve();
            })
                .then(function (manifestContent) {
                if (!manifestContent) {
                    return;
                }
                if (!manifestContent['gcm_sender_id']) {
                    return;
                }
                if (manifestContent['gcm_sender_id'] !== '103953800507') {
                    throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.INCORRECT_GCM_SENDER_ID);
                }
            });
        }
        return this.manifestCheckPromise_;
    };
    /**
     * Request permission if it is not currently granted
     * @export
     * @returns {Promise} Resolves if the permission was granted, otherwise
     * rejects
     */
    WindowController.prototype.requestPermission = function () {
        var _this = this;
        if (Notification.permission === __WEBPACK_IMPORTED_MODULE_4__models_notification_permission__["a" /* default */].granted) {
            return Promise.resolve();
        }
        return new Promise(function (resolve, reject) {
            var managePermissionResult = function (result) {
                if (result === __WEBPACK_IMPORTED_MODULE_4__models_notification_permission__["a" /* default */].granted) {
                    return resolve();
                }
                else if (result === __WEBPACK_IMPORTED_MODULE_4__models_notification_permission__["a" /* default */].denied) {
                    return reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.PERMISSION_BLOCKED));
                }
                else {
                    return reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.PERMISSION_DEFAULT));
                }
            };
            // The Notification.requestPermission API was changed to
            // return a promise so now have to handle both in case
            // browsers stop support callbacks for promised version
            var permissionPromise = Notification.requestPermission(function (result) {
                if (permissionPromise) {
                    // Let the promise manage this
                    return;
                }
                managePermissionResult(result);
            });
            if (permissionPromise) {
                // Prefer the promise version as it's the future API.
                permissionPromise.then(managePermissionResult);
            }
        });
    };
    /**
     * This method allows a developer to override the default service worker and
     * instead use a custom service worker.
     * @export
     * @param {!ServiceWorkerRegistration} registration The service worker
     * registration that should be used to receive the push messages.
     */
    WindowController.prototype.useServiceWorker = function (registration) {
        if (!(registration instanceof ServiceWorkerRegistration)) {
            throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.SW_REGISTRATION_EXPECTED);
        }
        if (typeof this.registrationToUse_ !== 'undefined') {
            throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.USE_SW_BEFORE_GET_TOKEN);
        }
        this.registrationToUse_ = registration;
    };
    /**
     * @export
     * @param {!firebase.Observer|function(*)} nextOrObserver An observer object
     * or a function triggered on message.
     * @param {function(!Error)=} optError Optional A function triggered on
     * message error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    WindowController.prototype.onMessage = function (nextOrObserver, optError, optCompleted) {
        return this.onMessage_(nextOrObserver, optError, optCompleted);
    };
    /**
     * @export
     * @param {!firebase.Observer|function()} nextOrObserver An observer object
     * or a function triggered on token refresh.
     * @param {function(!Error)=} optError Optional A function
     * triggered on token refresh error.
     * @param {function()=} optCompleted Optional function triggered when the
     * observer is removed.
     * @return {!function()} The unsubscribe function for the observer.
     */
    WindowController.prototype.onTokenRefresh = function (nextOrObserver, optError, optCompleted) {
        return this.onTokenRefresh_(nextOrObserver, optError, optCompleted);
    };
    /**
     * Given a registration, wait for the service worker it relates to
     * become activer
     * @private
     * @param  {ServiceWorkerRegistration} registration Registration to wait
     * for service worker to become active
     * @return {Promise<!ServiceWorkerRegistration>} Wait for service worker
     * registration to become active
     */
    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {
        var _this = this;
        var serviceWorker = registration.installing || registration.waiting || registration.active;
        return new Promise(function (resolve, reject) {
            if (!serviceWorker) {
                // This is a rare scenario but has occured in firefox
                reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.NO_SW_IN_REG));
                return;
            }
            // Because the Promise function is called on next tick there is a
            // small chance that the worker became active or redundant already.
            if (serviceWorker.state === 'activated') {
                resolve(registration);
                return;
            }
            if (serviceWorker.state === 'redundant') {
                reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.SW_REG_REDUNDANT));
                return;
            }
            var stateChangeListener = function () {
                if (serviceWorker.state === 'activated') {
                    resolve(registration);
                }
                else if (serviceWorker.state === 'redundant') {
                    reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.SW_REG_REDUNDANT));
                }
                else {
                    // Return early and wait to next state change
                    return;
                }
                serviceWorker.removeEventListener('statechange', stateChangeListener);
            };
            serviceWorker.addEventListener('statechange', stateChangeListener);
        });
    };
    /**
     * This will regiater the default service worker and return the registration
     * @private
     * @return {Promise<!ServiceWorkerRegistration>} The service worker
     * registration to be used for the push service.
     */
    WindowController.prototype.getSWRegistration_ = function () {
        var _this = this;
        if (this.registrationToUse_) {
            return this.waitForRegistrationToActivate_(this.registrationToUse_);
        }
        // Make the registration null so we know useServiceWorker will not
        // use a new service worker as registrationToUse_ is no longer undefined
        this.registrationToUse_ = null;
        return navigator.serviceWorker
            .register(__WEBPACK_IMPORTED_MODULE_3__models_default_sw__["a" /* default */].path, {
            scope: __WEBPACK_IMPORTED_MODULE_3__models_default_sw__["a" /* default */].scope
        })
            .catch(function (err) {
            throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.FAILED_DEFAULT_REGISTRATION, {
                browserErrorMessage: err.message
            });
        })
            .then(function (registration) {
            return _this.waitForRegistrationToActivate_(registration).then(function () {
                _this.registrationToUse_ = registration;
                // We update after activation due to an issue with Firefox v49 where
                // a race condition occassionally causes the service work to not
                // install
                registration.update();
                return registration;
            });
        });
    };
    /**
     * This method will set up a message listener to handle
     * events from the service worker that should trigger
     * events in the page.
     *
     * @private
     */
    WindowController.prototype.setupSWMessageListener_ = function () {
        var _this = this;
        if (!('serviceWorker' in navigator)) {
            return;
        }
        navigator.serviceWorker.addEventListener('message', function (event) {
            if (!event.data || !event.data[__WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].PARAMS.TYPE_OF_MSG]) {
                // Not a message from FCM
                return;
            }
            var workerPageMessage = event.data;
            switch (workerPageMessage[__WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].PARAMS.TYPE_OF_MSG]) {
                case __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].TYPES_OF_MSG.PUSH_MSG_RECEIVED:
                case __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].TYPES_OF_MSG.NOTIFICATION_CLICKED:
                    var pushMessage = workerPageMessage[__WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].PARAMS.DATA];
                    _this.messageObserver_.next(pushMessage);
                    break;
                default:
                    // Noop.
                    break;
            }
        }, false);
    };
    /**
     * Checks to see if the required API's are valid or not.
     * @private
     * @return {boolean} Returns true if the desired APIs are available.
     */
    WindowController.prototype.isSupported_ = function () {
        return ('serviceWorker' in navigator &&
            'PushManager' in window &&
            'Notification' in window &&
            'fetch' in window &&
            ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&
            PushSubscription.prototype.hasOwnProperty('getKey'));
    };
    return WindowController;
}(__WEBPACK_IMPORTED_MODULE_0__controller_interface__["a" /* default */]));
/* harmony default export */ __webpack_exports__["a"] = (WindowController);

//# sourceMappingURL=window-controller.js.map


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_util___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__firebase_util__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__errors__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__fcm_details__ = __webpack_require__(73);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var FCM_TOKEN_OBJ_STORE = 'fcm_token_object_Store';
var FCM_TOKEN_DETAILS_DB_VERSION = 1;
var TokenManager = /** @class */ (function () {
    function TokenManager() {
        this.errorFactory_ = new __WEBPACK_IMPORTED_MODULE_0__firebase_util__["ErrorFactory"]('messaging', 'Messaging', __WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].map);
        this.openDbPromise_ = null;
    }
    /**
     * Get the indexedDB as a promsie.
     * @private
     * @return {Promise<IDBDatabase>} The IndexedDB database
     */
    TokenManager.prototype.openDatabase_ = function () {
        if (this.openDbPromise_) {
            return this.openDbPromise_;
        }
        this.openDbPromise_ = new Promise(function (resolve, reject) {
            var request = indexedDB.open(TokenManager.DB_NAME, FCM_TOKEN_DETAILS_DB_VERSION);
            request.onerror = function (event) {
                reject(event.target.error);
            };
            request.onsuccess = function (event) {
                resolve(event.target.result);
            };
            request.onupgradeneeded = function (event) {
                var db = event.target.result;
                var objectStore = db.createObjectStore(FCM_TOKEN_OBJ_STORE, {
                    keyPath: 'swScope'
                });
                // Make sure the sender ID can be searched
                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {
                    unique: false
                });
                objectStore.createIndex('fcmToken', 'fcmToken', {
                    unique: true
                });
            };
        });
        return this.openDbPromise_;
    };
    /**
     * Close the currently open database.
     * @return {Promise<?>} Returns the result of the promise chain.
     */
    TokenManager.prototype.closeDatabase = function () {
        var _this = this;
        if (this.openDbPromise_) {
            return this.openDbPromise_.then(function (db) {
                db.close();
                _this.openDbPromise_ = null;
            });
        }
        return Promise.resolve();
    };
    /**
     * Given a token, this method will look up the details in indexedDB.
     * @public
     * @param {string} fcmToken
     * @return {Promise<Object>} The details associated with that token.
     */
    TokenManager.prototype.getTokenDetailsFromToken = function (fcmToken) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var index = objectStore.index('fcmToken');
                var request = index.get(fcmToken);
                request.onerror = function (event) {
                    reject(event.target.error);
                };
                request.onsuccess = function (event) {
                    resolve(event.target.result);
                };
            });
        });
    };
    TokenManager.prototype.getTokenDetailsFromSWScope_ = function (swScope) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var scopeRequest = objectStore.get(swScope);
                scopeRequest.onerror = function (event) {
                    reject(event.target.error);
                };
                scopeRequest.onsuccess = function (event) {
                    resolve(event.target.result);
                };
            });
        });
    };
    TokenManager.prototype.getAllTokenDetailsForSenderId_ = function (senderId) {
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE]);
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var senderIdTokens = [];
                var cursorRequest = objectStore.openCursor();
                cursorRequest.onerror = function (event) {
                    reject(event.target.error);
                };
                cursorRequest.onsuccess = function (event) {
                    var cursor = event.target.result;
                    if (cursor) {
                        if (cursor.value['fcmSenderId'] === senderId) {
                            senderIdTokens.push(cursor.value);
                        }
                        cursor.continue();
                    }
                    else {
                        resolve(senderIdTokens);
                    }
                };
            });
        });
    };
    /**
     * Given a PushSubscription and messagingSenderId, get an FCM token.
     * @public
     * @param  {string} senderId The 'messagingSenderId' to tie the token to.
     * @param  {PushSubscription} subscription The PushSusbcription to "federate".
     * @param  {string=} pushSet If defined this will swap the subscription for
     * matching FCM token.
     * @return {Promise<!Object>} Returns the FCM token to be used in place
     * of the PushSubscription.
     */
    TokenManager.prototype.subscribeToFCM = function (senderId, subscription, pushSet) {
        var _this = this;
        var p256dh = Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('p256dh'));
        var auth = Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('auth'));
        var fcmSubscribeBody = "authorized_entity=" + senderId + "&" +
            ("endpoint=" + subscription.endpoint + "&") +
            ("encryption_key=" + p256dh + "&") +
            ("encryption_auth=" + auth);
        if (pushSet) {
            fcmSubscribeBody += "&pushSet=" + pushSet;
        }
        var headers = new Headers();
        headers.append('Content-Type', 'application/x-www-form-urlencoded');
        var subscribeOptions = {
            method: 'POST',
            headers: headers,
            body: fcmSubscribeBody
        };
        return fetch(__WEBPACK_IMPORTED_MODULE_3__fcm_details__["a" /* default */].ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)
            .then(function (response) { return response.json(); })
            .then(function (response) {
            var fcmTokenResponse = response;
            if (fcmTokenResponse['error']) {
                var message = fcmTokenResponse['error']['message'];
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.TOKEN_SUBSCRIBE_FAILED, {
                    message: message
                });
            }
            if (!fcmTokenResponse['token']) {
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.TOKEN_SUBSCRIBE_NO_TOKEN);
            }
            if (!fcmTokenResponse['pushSet']) {
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.TOKEN_SUBSCRIBE_NO_PUSH_SET);
            }
            return {
                token: fcmTokenResponse['token'],
                pushSet: fcmTokenResponse['pushSet']
            };
        });
    };
    /**
     * Checks the that fields in the PushSubscription are equivalent to the
     * details stores in the masterTokenDetails.
     * @private
     * @param  {PushSubscription} subscription The push subscription we expect
     * the master token to match.
     * @param  {Object}  masterTokenDetails The saved details we wish to compare
     * with the PushSubscription
     * @return {boolean} true if the subscription and token details are
     * equivalent.
     */
    TokenManager.prototype.isSameSubscription_ = function (subscription, masterTokenDetails) {
        // getKey() isn't defined in the PushSubscription externs file, hence
        // subscription['getKey']('<key name>').
        return (subscription.endpoint === masterTokenDetails['endpoint'] &&
            Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('auth')) ===
                masterTokenDetails['auth'] &&
            Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('p256dh')) ===
                masterTokenDetails['p256dh']);
    };
    /**
     * Save the details for the fcm token for re-use at a later date.
     * @private
     * @param  {string} senderId The 'messagingSenderId' used for this project
     * @param  {ServiceWorkerRegistration} swRegistration The service worker
     * used to subscribe the user for web push
     * @param  {PushSubscription} subscription The push subscription passed to
     * FCM for the current token.
     * @param  {string} fcmToken The FCM token currently used on this
     * device.
     * @param  {string} fcmPushSet The FCM push tied to the fcm token.
     * @return {Promise<void>}
     */
    TokenManager.prototype.saveTokenDetails_ = function (senderId, swRegistration, subscription, fcmToken, fcmPushSet) {
        var details = {
            swScope: swRegistration.scope,
            endpoint: subscription.endpoint,
            auth: Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('auth')),
            p256dh: Object(__WEBPACK_IMPORTED_MODULE_2__helpers_array_buffer_to_base64__["a" /* default */])(subscription['getKey']('p256dh')),
            fcmToken: fcmToken,
            fcmPushSet: fcmPushSet,
            fcmSenderId: senderId
        };
        return this.openDatabase_().then(function (db) {
            return new Promise(function (resolve, reject) {
                var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                var request = objectStore.put(details);
                request.onerror = function (event) {
                    reject(event.target.error);
                };
                request.onsuccess = function (event) {
                    resolve();
                };
            });
        });
    };
    /**
     * Returns the saved FCM Token if one is available and still valid,
     * otherwise `null` is returned.
     * @param {string} senderId This should be the sender ID associated with the
     * FCM Token being retrieved.
     * @param {ServiceWorkerRegistration} swRegistration Registration to be used
     * to subscribe the user to push.
     * @return {Promise<string> | Promise} Returns the saved FCM Token if
     * avilable and valid.
     * @export
     */
    TokenManager.prototype.getSavedToken = function (senderId, swRegistration) {
        var _this = this;
        if (!(swRegistration instanceof ServiceWorkerRegistration)) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.SW_REGISTRATION_EXPECTED));
        }
        if (typeof senderId !== 'string' || senderId.length === 0) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.BAD_SENDER_ID));
        }
        return this.getAllTokenDetailsForSenderId_(senderId)
            .then(function (allTokenDetails) {
            if (allTokenDetails.length === 0) {
                return;
            }
            var index = allTokenDetails.findIndex(function (tokenDetails) {
                return (swRegistration.scope === tokenDetails['swScope'] &&
                    senderId === tokenDetails['fcmSenderId']);
            });
            if (index === -1) {
                return;
            }
            return allTokenDetails[index];
        })
            .then(function (tokenDetails) {
            if (!tokenDetails) {
                return;
            }
            return swRegistration.pushManager
                .getSubscription()
                .catch(function (err) {
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.GET_SUBSCRIPTION_FAILED);
            })
                .then(function (subscription) {
                if (subscription &&
                    _this.isSameSubscription_(subscription, tokenDetails)) {
                    return tokenDetails['fcmToken'];
                }
            });
        });
    };
    /**
     * Creates a new FCM token.
     */
    TokenManager.prototype.createToken = function (senderId, swRegistration) {
        var _this = this;
        if (typeof senderId !== 'string' || senderId.length === 0) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.BAD_SENDER_ID));
        }
        if (!(swRegistration instanceof ServiceWorkerRegistration)) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.SW_REGISTRATION_EXPECTED));
        }
        // Check for existing subscription first
        var subscription;
        var fcmTokenDetails;
        return swRegistration.pushManager
            .getSubscription()
            .then(function (subscription) {
            if (subscription) {
                return subscription;
            }
            return swRegistration.pushManager.subscribe(__WEBPACK_IMPORTED_MODULE_3__fcm_details__["a" /* default */].SUBSCRIPTION_OPTIONS);
        })
            .then(function (sub) {
            subscription = sub;
            return _this.subscribeToFCM(senderId, subscription);
        })
            .then(function (tokenDetails) {
            fcmTokenDetails = tokenDetails;
            return _this.saveTokenDetails_(senderId, swRegistration, subscription, fcmTokenDetails['token'], fcmTokenDetails['pushSet']);
        })
            .then(function () { return fcmTokenDetails['token']; });
    };
    /**
     * This method deletes details of the current FCM token.
     * It's returning a promise in case we need to move to an async
     * method for deleting at a later date.
     * @param {string} token Token to be deleted
     * @return {Promise<Object>} Resolves once the FCM token details have been
     * deleted and returns the deleted details.
     */
    TokenManager.prototype.deleteToken = function (token) {
        var _this = this;
        if (typeof token !== 'string' || token.length === 0) {
            return Promise.reject(this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.INVALID_DELETE_TOKEN));
        }
        return this.getTokenDetailsFromToken(token).then(function (details) {
            if (!details) {
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.DELETE_TOKEN_NOT_FOUND);
            }
            return _this.openDatabase_().then(function (db) {
                return new Promise(function (resolve, reject) {
                    var transaction = db.transaction([FCM_TOKEN_OBJ_STORE], 'readwrite');
                    var objectStore = transaction.objectStore(FCM_TOKEN_OBJ_STORE);
                    var request = objectStore.delete(details['swScope']);
                    request.onerror = function (event) {
                        reject(event.target.error);
                    };
                    request.onsuccess = function (event) {
                        if (event.target.result === 0) {
                            reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__errors__["a" /* default */].codes.FAILED_TO_DELETE_TOKEN));
                            return;
                        }
                        resolve(details);
                    };
                });
            });
        });
    };
    return TokenManager;
}());
/* harmony default export */ __webpack_exports__["a"] = (TokenManager);

//# sourceMappingURL=token-manager.js.map


/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function toBase64(arrayBuffer) {
    var uint8Version = new Uint8Array(arrayBuffer);
    return window.btoa(String.fromCharCode.apply(null, uint8Version));
}
/* harmony default export */ __webpack_exports__["a"] = (function (arrayBuffer) {
    var base64String = toBase64(arrayBuffer);
    return base64String
        .replace(/=/g, '')
        .replace(/\+/g, '-')
        .replace(/\//g, '_');
});;

//# sourceMappingURL=array-buffer-to-base64.js.map


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = ({
    path: '/firebase-messaging-sw.js',
    scope: '/firebase-cloud-messaging-push-scope'
});

//# sourceMappingURL=default-sw.js.map


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__controller_interface__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__models_errors__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__models_fcm_details__ = __webpack_require__(73);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var FCM_MSG = 'FCM_MSG';
var SWController = /** @class */ (function (_super) {
    __extends(SWController, _super);
    function SWController(app) {
        var _this = _super.call(this, app) || this;
        self.addEventListener('push', function (e) { return _this.onPush_(e); }, false);
        self.addEventListener('pushsubscriptionchange', function (e) { return _this.onSubChange_(e); }, false);
        self.addEventListener('notificationclick', function (e) { return _this.onNotificationClick_(e); }, false);
        /**
         * @private
         * @type {function(Object)|null}
         */
        _this.bgMessageHandler_ = null;
        return _this;
    }
    /**
     * A handler for push events that shows notifications based on the content of
     * the payload.
     *
     * The payload must be a JSON-encoded Object with a `notification` key. The
     * value of the `notification` property will be used as the NotificationOptions
     * object passed to showNotification. Additionally, the `title` property of the
     * notification object will be used as the title.
     *
     * If there is no notification data in the payload then no notification will be
     * shown.
     * @private
     */
    SWController.prototype.onPush_ = function (event) {
        var _this = this;
        var msgPayload;
        try {
            msgPayload = event.data.json();
        }
        catch (err) {
            // Not JSON so not an FCM message
            return;
        }
        var handleMsgPromise = this.hasVisibleClients_().then(function (hasVisibleClients) {
            if (hasVisibleClients) {
                // Do not need to show a notification.
                if (msgPayload.notification || _this.bgMessageHandler_) {
                    // Send to page
                    return _this.sendMessageToWindowClients_(msgPayload);
                }
                return;
            }
            var notificationDetails = _this.getNotificationData_(msgPayload);
            if (notificationDetails) {
                var notificationTitle = notificationDetails.title || '';
                return self.registration.showNotification(notificationTitle, notificationDetails);
            }
            else if (_this.bgMessageHandler_) {
                return _this.bgMessageHandler_(msgPayload);
            }
        });
        event.waitUntil(handleMsgPromise);
    };
    /**
     * @private
     */
    SWController.prototype.onSubChange_ = function (event) {
        var _this = this;
        var promiseChain = this.getToken().then(function (token) {
            if (!token) {
                // We can't resubscribe if we don't have an FCM token for this scope.
                throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.NO_FCM_TOKEN_FOR_RESUBSCRIBE);
            }
            var tokenDetails = null;
            var tokenManager = _this.getTokenManager();
            return tokenManager
                .getTokenDetailsFromToken(token)
                .then(function (details) {
                tokenDetails = details;
                if (!tokenDetails) {
                    throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.INVALID_SAVED_TOKEN);
                }
                // Attempt to get a new subscription
                return self.registration.pushManager.subscribe(__WEBPACK_IMPORTED_MODULE_3__models_fcm_details__["a" /* default */].SUBSCRIPTION_OPTIONS);
            })
                .then(function (newSubscription) {
                // Send new subscription to FCM.
                return tokenManager.subscribeToFCM(tokenDetails.fcmSenderId, newSubscription, tokenDetails.fcmPushSet);
            })
                .catch(function (err) {
                // The best thing we can do is log this to the terminal so
                // developers might notice the error.
                return tokenManager.deleteToken(tokenDetails.fcmToken).then(function () {
                    throw _this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.UNABLE_TO_RESUBSCRIBE, {
                        message: err
                    });
                });
            });
        });
        event.waitUntil(promiseChain);
    };
    /**
     * @private
     */
    SWController.prototype.onNotificationClick_ = function (event) {
        var _this = this;
        if (!(event.notification &&
            event.notification.data &&
            event.notification.data[FCM_MSG])) {
            // Not an FCM notification, do nothing.
            return;
        }
        // Prevent other listeners from receiving the event
        event.stopImmediatePropagation();
        event.notification.close();
        var msgPayload = event.notification.data[FCM_MSG];
        var clickAction = msgPayload['notification']['click_action'];
        if (!clickAction) {
            // Nothing to do.
            return;
        }
        var promiseChain = this.getWindowClient_(clickAction)
            .then(function (windowClient) {
            if (!windowClient) {
                // Unable to find window client so need to open one.
                return self.clients.openWindow(clickAction);
            }
            return windowClient;
        })
            .then(function (windowClient) {
            if (!windowClient) {
                // Window Client will not be returned if it's for a third party origin.
                return;
            }
            // Delete notification data from payload before sending to the page.
            var notificationData = msgPayload['notification'];
            delete msgPayload['notification'];
            var internalMsg = __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].createNewMsg(__WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].TYPES_OF_MSG.NOTIFICATION_CLICKED, msgPayload);
            // Attempt to send a message to the client to handle the data
            // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728
            return _this.attemptToMessageClient_(windowClient, internalMsg);
        });
        event.waitUntil(promiseChain);
    };
    /**
     * @private
     * @param {Object} msgPayload
     * @return {NotificationOptions|undefined}
     */
    SWController.prototype.getNotificationData_ = function (msgPayload) {
        if (!msgPayload) {
            return;
        }
        if (typeof msgPayload.notification !== 'object') {
            return;
        }
        var notificationInformation = Object.assign({}, msgPayload.notification);
        // Put the message payload under FCM_MSG name so we can identify the
        // notification as being an FCM notification vs a notification from
        // somewhere else (i.e. normal web push or developer generated
        // notification).
        notificationInformation['data'] = (_a = {},
            _a[FCM_MSG] = msgPayload,
            _a);
        return notificationInformation;
        var _a;
    };
    /**
     * Calling setBackgroundMessageHandler will opt in to some specific
     * behaviours.
     * 1.) If a notification doesn't need to be shown due to a window already
     * being visible, then push messages will be sent to the page.
     * 2.) If a notification needs to be shown, and the message contains no
     * notification data this method will be called
     * and the promise it returns will be passed to event.waitUntil.
     * If you do not set this callback then all push messages will let and the
     * developer can handle them in a their own 'push' event callback
     * @export
     * @param {function(Object)} callback The callback to be called when a push
     * message is received and a notification must be shown. The callback will
     * be given the data from the push message.
     */
    SWController.prototype.setBackgroundMessageHandler = function (callback) {
        if (callback && typeof callback !== 'function') {
            throw this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.BG_HANDLER_FUNCTION_EXPECTED);
        }
        this.bgMessageHandler_ = callback;
    };
    /**
     * @private
     * @param {string} url The URL to look for when focusing a client.
     * @return {Object} Returns an existing window client or a newly opened
     * WindowClient.
     */
    SWController.prototype.getWindowClient_ = function (url) {
        // Use URL to normalize the URL when comparing to windowClients.
        // This at least handles whether to include trailing slashes or not
        var parsedURL = new URL(url).href;
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            var suitableClient = null;
            for (var i = 0; i < clientList.length; i++) {
                var parsedClientUrl = new URL(clientList[i].url).href;
                if (parsedClientUrl === parsedURL) {
                    suitableClient = clientList[i];
                    break;
                }
            }
            if (suitableClient) {
                suitableClient.focus();
                return suitableClient;
            }
        });
    };
    /**
     * This message will attempt to send the message to a window client.
     * @private
     * @param {Object} client The WindowClient to send the message to.
     * @param {Object} message The message to send to the client.
     * @returns {Promise} Returns a promise that resolves after sending the
     * message. This does not guarantee that the message was successfully
     * received.
     */
    SWController.prototype.attemptToMessageClient_ = function (client, message) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (!client) {
                return reject(_this.errorFactory_.create(__WEBPACK_IMPORTED_MODULE_1__models_errors__["a" /* default */].codes.NO_WINDOW_CLIENT_TO_MSG));
            }
            client.postMessage(message);
            resolve();
        });
    };
    /**
     * @private
     * @returns {Promise<boolean>} If there is currently a visible WindowClient,
     * this method will resolve to true, otherwise false.
     */
    SWController.prototype.hasVisibleClients_ = function () {
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            return clientList.some(function (client) { return client.visibilityState === 'visible'; });
        });
    };
    /**
     * @private
     * @param {Object} msgPayload The data from the push event that should be sent
     * to all available pages.
     * @returns {Promise} Returns a promise that resolves once the message
     * has been sent to all WindowClients.
     */
    SWController.prototype.sendMessageToWindowClients_ = function (msgPayload) {
        var _this = this;
        return self.clients
            .matchAll({
            type: 'window',
            includeUncontrolled: true
        })
            .then(function (clientList) {
            var internalMsg = __WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].createNewMsg(__WEBPACK_IMPORTED_MODULE_2__models_worker_page_message__["a" /* default */].TYPES_OF_MSG.PUSH_MSG_RECEIVED, msgPayload);
            return Promise.all(clientList.map(function (client) {
                return _this.attemptToMessageClient_(client, internalMsg);
            }));
        });
    };
    /**
     * This will register the default service worker and return the registration.
     * @private
     * @return {Promise<!ServiceWorkerRegistration>} The service worker
     * registration to be used for the push service.
     */
    SWController.prototype.getSWRegistration_ = function () {
        return Promise.resolve(self.registration);
    };
    return SWController;
}(__WEBPACK_IMPORTED_MODULE_0__controller_interface__["a" /* default */]));
/* harmony default export */ __webpack_exports__["a"] = (SWController);

//# sourceMappingURL=sw-controller.js.map


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

__webpack_require__(146);


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["registerStorage"] = registerStorage;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_implementation_string__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_implementation_taskenums__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_implementation_xhriopool__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_reference__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_service__ = __webpack_require__(156);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Type constant for Firebase Storage.
 */
var STORAGE_TYPE = 'storage';
function factory(app, unused, opt_url) {
    return new __WEBPACK_IMPORTED_MODULE_5__src_service__["a" /* Service */](app, new __WEBPACK_IMPORTED_MODULE_3__src_implementation_xhriopool__["a" /* XhrIoPool */](), opt_url);
}
function registerStorage(instance) {
    var namespaceExports = {
        // no-inline
        TaskState: __WEBPACK_IMPORTED_MODULE_2__src_implementation_taskenums__["c" /* TaskState */],
        TaskEvent: __WEBPACK_IMPORTED_MODULE_2__src_implementation_taskenums__["b" /* TaskEvent */],
        StringFormat: __WEBPACK_IMPORTED_MODULE_1__src_implementation_string__["a" /* StringFormat */],
        Storage: __WEBPACK_IMPORTED_MODULE_5__src_service__["a" /* Service */],
        Reference: __WEBPACK_IMPORTED_MODULE_4__src_reference__["a" /* Reference */]
    };
    instance.INTERNAL.registerService(STORAGE_TYPE, factory, namespaceExports, undefined, 
    // Allow multiple storage instances per app.
    true);
}
registerStorage(__WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"]);

//# sourceMappingURL=index.js.map


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return XhrIoPool; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__xhrio_network__ = __webpack_require__(148);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Factory-like class for creating XhrIo instances.
 */
var XhrIoPool = /** @class */ (function () {
    function XhrIoPool() {
    }
    XhrIoPool.prototype.createXhrIo = function () {
        return new __WEBPACK_IMPORTED_MODULE_0__xhrio_network__["a" /* NetworkXhrIo */]();
    };
    return XhrIoPool;
}());


//# sourceMappingURL=xhriopool.js.map


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NetworkXhrIo; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__object__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__promise_external__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__type__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__xhrio__ = __webpack_require__(76);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * We use this instead of goog.net.XhrIo because goog.net.XhrIo is hyuuuuge and
 * doesn't work in React Native on Android.
 */
var NetworkXhrIo = /** @class */ (function () {
    function NetworkXhrIo() {
        var _this = this;
        this.sent_ = false;
        this.xhr_ = new XMLHttpRequest();
        this.errorCode_ = __WEBPACK_IMPORTED_MODULE_4__xhrio__["a" /* ErrorCode */].NO_ERROR;
        this.sendPromise_ = __WEBPACK_IMPORTED_MODULE_2__promise_external__["a" /* make */](function (resolve, reject) {
            _this.xhr_.addEventListener('abort', function (event) {
                _this.errorCode_ = __WEBPACK_IMPORTED_MODULE_4__xhrio__["a" /* ErrorCode */].ABORT;
                resolve(_this);
            });
            _this.xhr_.addEventListener('error', function (event) {
                _this.errorCode_ = __WEBPACK_IMPORTED_MODULE_4__xhrio__["a" /* ErrorCode */].NETWORK_ERROR;
                resolve(_this);
            });
            _this.xhr_.addEventListener('load', function (event) {
                resolve(_this);
            });
        });
    }
    /**
     * @override
     */
    NetworkXhrIo.prototype.send = function (url, method, opt_body, opt_headers) {
        var _this = this;
        if (this.sent_) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["e" /* internalError */]('cannot .send() more than once');
        }
        this.sent_ = true;
        this.xhr_.open(method, url, true);
        if (__WEBPACK_IMPORTED_MODULE_3__type__["a" /* isDef */](opt_headers)) {
            var headers = opt_headers;
            __WEBPACK_IMPORTED_MODULE_1__object__["b" /* forEach */](headers, function (key, val) {
                _this.xhr_.setRequestHeader(key, val.toString());
            });
        }
        if (__WEBPACK_IMPORTED_MODULE_3__type__["a" /* isDef */](opt_body)) {
            this.xhr_.send(opt_body);
        }
        else {
            this.xhr_.send();
        }
        return this.sendPromise_;
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getErrorCode = function () {
        if (!this.sent_) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["e" /* internalError */]('cannot .getErrorCode() before sending');
        }
        return this.errorCode_;
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getStatus = function () {
        if (!this.sent_) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["e" /* internalError */]('cannot .getStatus() before sending');
        }
        try {
            return this.xhr_.status;
        }
        catch (e) {
            return -1;
        }
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getResponseText = function () {
        if (!this.sent_) {
            throw __WEBPACK_IMPORTED_MODULE_0__error__["e" /* internalError */]('cannot .getResponseText() before sending');
        }
        return this.xhr_.responseText;
    };
    /**
     * Aborts the request.
     * @override
     */
    NetworkXhrIo.prototype.abort = function () {
        this.xhr_.abort();
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.getResponseHeader = function (header) {
        return this.xhr_.getResponseHeader(header);
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.addUploadProgressListener = function (listener) {
        if (__WEBPACK_IMPORTED_MODULE_3__type__["a" /* isDef */](this.xhr_.upload)) {
            this.xhr_.upload.addEventListener('progress', listener);
        }
    };
    /**
     * @override
     */
    NetworkXhrIo.prototype.removeUploadProgressListener = function (listener) {
        if (__WEBPACK_IMPORTED_MODULE_3__type__["a" /* isDef */](this.xhr_.upload)) {
            this.xhr_.upload.removeEventListener('progress', listener);
        }
    };
    return NetworkXhrIo;
}());


//# sourceMappingURL=xhrio_network.js.map


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = jsonObjectOrNull;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the Object resulting from parsing the given JSON, or null if the
 * given string does not represent a JSON object.
 */
function jsonObjectOrNull(s) {
    var obj;
    try {
        obj = JSON.parse(s);
    }
    catch (e) {
        return null;
    }
    if (__WEBPACK_IMPORTED_MODULE_0__type__["f" /* isNonArrayObject */](obj)) {
        return obj;
    }
    else {
        return null;
    }
}

//# sourceMappingURL=json.js.map


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getBlob;
/* harmony export (immutable) */ __webpack_exports__["b"] = sliceBlob;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(6);

function getBlobBuilder() {
    if (typeof BlobBuilder !== 'undefined') {
        return BlobBuilder;
    }
    else if (typeof WebKitBlobBuilder !== 'undefined') {
        return WebKitBlobBuilder;
    }
    else {
        return undefined;
    }
}
/**
 * Concatenates one or more values together and converts them to a Blob.
 *
 * @param var_args The values that will make up the resulting blob.
 * @return The blob.
 */
function getBlob() {
    var var_args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        var_args[_i] = arguments[_i];
    }
    var BlobBuilder = getBlobBuilder();
    if (BlobBuilder !== undefined) {
        var bb = new BlobBuilder();
        for (var i = 0; i < var_args.length; i++) {
            bb.append(var_args[i]);
        }
        return bb.getBlob();
    }
    else {
        if (__WEBPACK_IMPORTED_MODULE_0__type__["e" /* isNativeBlobDefined */]()) {
            return new Blob(var_args);
        }
        else {
            throw Error("This browser doesn't seem to support creating Blobs");
        }
    }
}
/**
 * Slices the blob. The returned blob contains data from the start byte
 * (inclusive) till the end byte (exclusive). Negative indices cannot be used.
 *
 * @param blob The blob to be sliced.
 * @param start Index of the starting byte.
 * @param end Index of the ending byte.
 * @return The blob slice or null if not supported.
 */
function sliceBlob(blob, start, end) {
    if (blob.webkitSlice) {
        return blob.webkitSlice(start, end);
    }
    else if (blob.mozSlice) {
        return blob.mozSlice(start, end);
    }
    else if (blob.slice) {
        return blob.slice(start, end);
    }
    return null;
}

//# sourceMappingURL=fs.js.map


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RequestInfo; });
var RequestInfo = /** @class */ (function () {
    function RequestInfo(url, method, 
        /**
         * Returns the value with which to resolve the request's promise. Only called
         * if the request is successful. Throw from this function to reject the
         * returned Request's promise with the thrown error.
         * Note: The XhrIo passed to this function may be reused after this callback
         * returns. Do not keep a reference to it in any way.
         */
        handler, timeout) {
        this.url = url;
        this.method = method;
        this.handler = handler;
        this.timeout = timeout;
        this.urlParams = {};
        this.headers = {};
        this.body = null;
        this.errorHandler = null;
        /**
         * Called with the current number of bytes uploaded and total size (-1 if not
         * computable) of the request body (i.e. used to report upload progress).
         */
        this.progressCallback = null;
        this.successCodes = [200];
        this.additionalRetryCodes = [];
    }
    return RequestInfo;
}());


//# sourceMappingURL=requestinfo.js.map


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UploadTask; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__implementation_observer__ = __webpack_require__(153);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tasksnapshot__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__implementation_args__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__implementation_array__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__implementation_async__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__implementation_error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__implementation_promise_external__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__implementation_requests__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__implementation_type__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Defines types for interacting with blob transfer tasks.
 */












/**
 * Represents a blob being uploaded. Can be used to pause/resume/cancel the
 * upload and manage callbacks for various events.
 */
var UploadTask = /** @class */ (function () {
    /**
     * @param ref The firebaseStorage.Reference object this task came
     *     from, untyped to avoid cyclic dependencies.
     * @param blob The blob to upload.
     */
    function UploadTask(ref, authWrapper, location, mappings, blob, metadata) {
        if (metadata === void 0) { metadata = null; }
        var _this = this;
        this.transferred_ = 0;
        this.needToFetchStatus_ = false;
        this.needToFetchMetadata_ = false;
        this.observers_ = [];
        this.error_ = null;
        this.uploadUrl_ = null;
        this.request_ = null;
        this.chunkMultiplier_ = 1;
        this.resolve_ = null;
        this.reject_ = null;
        this.ref_ = ref;
        this.authWrapper_ = authWrapper;
        this.location_ = location;
        this.blob_ = blob;
        this.metadata_ = metadata;
        this.mappings_ = mappings;
        this.resumable_ = this.shouldDoResumable_(this.blob_);
        this.state_ = __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING;
        this.errorHandler_ = function (error) {
            _this.request_ = null;
            _this.chunkMultiplier_ = 1;
            if (error.codeEquals(__WEBPACK_IMPORTED_MODULE_6__implementation_error__["a" /* Code */].CANCELED)) {
                _this.needToFetchStatus_ = true;
                _this.completeTransitions_();
            }
            else {
                _this.error_ = error;
                _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].ERROR);
            }
        };
        this.metadataErrorHandler_ = function (error) {
            _this.request_ = null;
            if (error.codeEquals(__WEBPACK_IMPORTED_MODULE_6__implementation_error__["a" /* Code */].CANCELED)) {
                _this.completeTransitions_();
            }
            else {
                _this.error_ = error;
                _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].ERROR);
            }
        };
        this.promise_ = __WEBPACK_IMPORTED_MODULE_7__implementation_promise_external__["a" /* make */](function (resolve, reject) {
            _this.resolve_ = resolve;
            _this.reject_ = reject;
            _this.start_();
        });
        // Prevent uncaught rejections on the internal promise from bubbling out
        // to the top level with a dummy handler.
        this.promise_.then(null, function () { });
    }
    UploadTask.prototype.makeProgressCallback_ = function () {
        var _this = this;
        var sizeBefore = this.transferred_;
        return function (loaded, total) {
            _this.updateProgress_(sizeBefore + loaded);
        };
    };
    UploadTask.prototype.shouldDoResumable_ = function (blob) {
        return blob.size() > 256 * 1024;
    };
    UploadTask.prototype.start_ = function () {
        if (this.state_ !== __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING) {
            // This can happen if someone pauses us in a resume callback, for example.
            return;
        }
        if (this.request_ !== null) {
            return;
        }
        if (this.resumable_) {
            if (this.uploadUrl_ === null) {
                this.createResumable_();
            }
            else {
                if (this.needToFetchStatus_) {
                    this.fetchStatus_();
                }
                else {
                    if (this.needToFetchMetadata_) {
                        // Happens if we miss the metadata on upload completion.
                        this.fetchMetadata_();
                    }
                    else {
                        this.continueUpload_();
                    }
                }
            }
        }
        else {
            this.oneShotUpload_();
        }
    };
    UploadTask.prototype.resolveToken_ = function (callback) {
        var _this = this;
        this.authWrapper_.getAuthToken().then(function (authToken) {
            switch (_this.state_) {
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING:
                    callback(authToken);
                    break;
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELING:
                    _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELED);
                    break;
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING:
                    _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSED);
                    break;
                default:
            }
        });
    };
    // TODO(andysoto): assert false
    UploadTask.prototype.createResumable_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["c" /* createResumableUpload */](_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var createRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = createRequest;
            createRequest.getPromise().then(function (url) {
                _this.request_ = null;
                _this.uploadUrl_ = url;
                _this.needToFetchStatus_ = false;
                _this.completeTransitions_();
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.fetchStatus_ = function () {
        var _this = this;
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["f" /* getResumableUploadStatus */](_this.authWrapper_, _this.location_, url, _this.blob_);
            var statusRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = statusRequest;
            statusRequest.getPromise().then(function (status) {
                status = status;
                _this.request_ = null;
                _this.updateProgress_(status.current);
                _this.needToFetchStatus_ = false;
                if (status.finalized) {
                    _this.needToFetchMetadata_ = true;
                }
                _this.completeTransitions_();
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.continueUpload_ = function () {
        var _this = this;
        var chunkSize = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["h" /* resumableUploadChunkSize */] * this.chunkMultiplier_;
        var status = new __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["a" /* ResumableUploadStatus */](this.transferred_, this.blob_.size());
        // TODO(andysoto): assert(this.uploadUrl_ !== null);
        var url = this.uploadUrl_;
        this.resolveToken_(function (authToken) {
            var requestInfo;
            try {
                requestInfo = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["b" /* continueResumableUpload */](_this.location_, _this.authWrapper_, url, _this.blob_, chunkSize, _this.mappings_, status, _this.makeProgressCallback_());
            }
            catch (e) {
                _this.error_ = e;
                _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].ERROR);
                return;
            }
            var uploadRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = uploadRequest;
            uploadRequest
                .getPromise()
                .then(function (newStatus) {
                _this.increaseMultiplier_();
                _this.request_ = null;
                _this.updateProgress_(newStatus.current);
                if (newStatus.finalized) {
                    _this.metadata_ = newStatus.metadata;
                    _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].SUCCESS);
                }
                else {
                    _this.completeTransitions_();
                }
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.increaseMultiplier_ = function () {
        var currentSize = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["h" /* resumableUploadChunkSize */] * this.chunkMultiplier_;
        // Max chunk size is 32M.
        if (currentSize < 32 * 1024 * 1024) {
            this.chunkMultiplier_ *= 2;
        }
    };
    UploadTask.prototype.fetchMetadata_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["e" /* getMetadata */](_this.authWrapper_, _this.location_, _this.mappings_);
            var metadataRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = metadataRequest;
            metadataRequest.getPromise().then(function (metadata) {
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].SUCCESS);
            }, _this.metadataErrorHandler_);
        });
    };
    UploadTask.prototype.oneShotUpload_ = function () {
        var _this = this;
        this.resolveToken_(function (authToken) {
            var requestInfo = __WEBPACK_IMPORTED_MODULE_8__implementation_requests__["g" /* multipartUpload */](_this.authWrapper_, _this.location_, _this.mappings_, _this.blob_, _this.metadata_);
            var multipartRequest = _this.authWrapper_.makeRequest(requestInfo, authToken);
            _this.request_ = multipartRequest;
            multipartRequest.getPromise().then(function (metadata) {
                _this.request_ = null;
                _this.metadata_ = metadata;
                _this.updateProgress_(_this.blob_.size());
                _this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].SUCCESS);
            }, _this.errorHandler_);
        });
    };
    UploadTask.prototype.updateProgress_ = function (transferred) {
        var old = this.transferred_;
        this.transferred_ = transferred;
        // A progress update can make the "transferred" value smaller (e.g. a
        // partial upload not completed by server, after which the "transferred"
        // value may reset to the value at the beginning of the request).
        if (this.transferred_ !== old) {
            this.notifyObservers_();
        }
    };
    UploadTask.prototype.transition_ = function (state) {
        if (this.state_ === state) {
            return;
        }
        switch (state) {
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                if (this.request_ !== null) {
                    this.request_.cancel();
                }
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING);
                this.state_ = state;
                if (this.request_ !== null) {
                    this.request_.cancel();
                }
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.PAUSING);
                var wasPaused = this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSED;
                this.state_ = state;
                if (wasPaused) {
                    this.notifyObservers_();
                    this.start_();
                }
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELED:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.PAUSED ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.error_ = __WEBPACK_IMPORTED_MODULE_6__implementation_error__["c" /* canceled */]();
                this.state_ = state;
                this.notifyObservers_();
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].ERROR:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].SUCCESS:
                // TODO(andysoto):
                // assert(this.state_ === InternalTaskState.RUNNING ||
                //        this.state_ === InternalTaskState.PAUSING ||
                //        this.state_ === InternalTaskState.CANCELING);
                this.state_ = state;
                this.notifyObservers_();
                break;
        }
    };
    UploadTask.prototype.completeTransitions_ = function () {
        switch (this.state_) {
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING:
                this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSED);
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELING:
                this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELED);
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING:
                this.start_();
                break;
            default:
                // TODO(andysoto): assert(false);
                break;
        }
    };
    Object.defineProperty(UploadTask.prototype, "snapshot", {
        get: function () {
            var externalState = __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["d" /* taskStateFromInternalTaskState */](this.state_);
            return new __WEBPACK_IMPORTED_MODULE_2__tasksnapshot__["a" /* UploadTaskSnapshot */](this.transferred_, this.blob_.size(), externalState, this.metadata_, this, this.ref_);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a callback for an event.
     * @param type The type of event to listen for.
     */
    UploadTask.prototype.on = function (type, nextOrObserver, error, completed) {
        if (nextOrObserver === void 0) { nextOrObserver = undefined; }
        if (error === void 0) { error = undefined; }
        if (completed === void 0) { completed = undefined; }
        function typeValidator(_p) {
            if (type !== __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["b" /* TaskEvent */].STATE_CHANGED) {
                throw "Expected one of the event types: [" + __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["b" /* TaskEvent */].STATE_CHANGED + "].";
            }
        }
        var nextOrObserverMessage = 'Expected a function or an Object with one of ' +
            '`next`, `error`, `complete` properties.';
        var nextValidator = __WEBPACK_IMPORTED_MODULE_3__implementation_args__["d" /* nullFunctionSpec */](true).validator;
        var observerValidator = __WEBPACK_IMPORTED_MODULE_3__implementation_args__["a" /* looseObjectSpec */](null, true).validator;
        function nextOrObserverValidator(p) {
            try {
                nextValidator(p);
                return;
            }
            catch (e) { }
            try {
                observerValidator(p);
                var anyDefined = __WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](p['next']) ||
                    __WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](p['error']) ||
                    __WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](p['complete']);
                if (!anyDefined) {
                    throw '';
                }
                return;
            }
            catch (e) {
                throw nextOrObserverMessage;
            }
        }
        var specs = [
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["e" /* stringSpec */](typeValidator),
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["a" /* looseObjectSpec */](nextOrObserverValidator, true),
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["d" /* nullFunctionSpec */](true),
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["d" /* nullFunctionSpec */](true)
        ];
        __WEBPACK_IMPORTED_MODULE_3__implementation_args__["g" /* validate */]('on', specs, arguments);
        var self = this;
        function makeBinder(specs) {
            function binder(nextOrObserver, error, opt_complete) {
                if (specs !== null) {
                    __WEBPACK_IMPORTED_MODULE_3__implementation_args__["g" /* validate */]('on', specs, arguments);
                }
                var observer = new __WEBPACK_IMPORTED_MODULE_1__implementation_observer__["a" /* Observer */](nextOrObserver, error, completed);
                self.addObserver_(observer);
                return function () {
                    self.removeObserver_(observer);
                };
            }
            return binder;
        }
        function binderNextOrObserverValidator(p) {
            if (p === null) {
                throw nextOrObserverMessage;
            }
            nextOrObserverValidator(p);
        }
        var binderSpecs = [
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["a" /* looseObjectSpec */](binderNextOrObserverValidator),
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["d" /* nullFunctionSpec */](true),
            __WEBPACK_IMPORTED_MODULE_3__implementation_args__["d" /* nullFunctionSpec */](true)
        ];
        var typeOnly = !(__WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](nextOrObserver) ||
            __WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](error) ||
            __WEBPACK_IMPORTED_MODULE_9__implementation_type__["c" /* isJustDef */](completed));
        if (typeOnly) {
            return makeBinder(binderSpecs);
        }
        else {
            return makeBinder(null)(nextOrObserver, error, completed);
        }
    };
    /**
     * This object behaves like a Promise, and resolves with its snapshot data
     * when the upload completes.
     * @param onFulfilled The fulfillment callback. Promise chaining works as normal.
     * @param onRejected The rejection callback.
     */
    UploadTask.prototype.then = function (onFulfilled, onRejected) {
        // These casts are needed so that TypeScript can infer the types of the
        // resulting Promise.
        return this.promise_.then(onFulfilled, onRejected);
    };
    /**
     * Equivalent to calling `then(null, onRejected)`.
     */
    UploadTask.prototype.catch = function (onRejected) {
        return this.then(null, onRejected);
    };
    /**
     * Adds the given observer.
     */
    UploadTask.prototype.addObserver_ = function (observer) {
        this.observers_.push(observer);
        this.notifyObserver_(observer);
    };
    /**
     * Removes the given observer.
     */
    UploadTask.prototype.removeObserver_ = function (observer) {
        __WEBPACK_IMPORTED_MODULE_4__implementation_array__["c" /* remove */](this.observers_, observer);
    };
    UploadTask.prototype.notifyObservers_ = function () {
        var _this = this;
        this.finishPromise_();
        var observers = __WEBPACK_IMPORTED_MODULE_4__implementation_array__["a" /* clone */](this.observers_);
        observers.forEach(function (observer) {
            _this.notifyObserver_(observer);
        });
    };
    UploadTask.prototype.finishPromise_ = function () {
        if (this.resolve_ !== null) {
            var triggered = true;
            switch (__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["d" /* taskStateFromInternalTaskState */](this.state_)) {
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].SUCCESS:
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(this.resolve_.bind(null, this.snapshot))();
                    break;
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].CANCELED:
                case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].ERROR:
                    var toCall = this.reject_;
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(toCall.bind(null, this.error_))();
                    break;
                default:
                    triggered = false;
                    break;
            }
            if (triggered) {
                this.resolve_ = null;
                this.reject_ = null;
            }
        }
    };
    UploadTask.prototype.notifyObserver_ = function (observer) {
        var externalState = __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["d" /* taskStateFromInternalTaskState */](this.state_);
        switch (externalState) {
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].RUNNING:
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].PAUSED:
                if (observer.next !== null) {
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(observer.next.bind(observer, this.snapshot))();
                }
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].SUCCESS:
                if (observer.complete !== null) {
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(observer.complete.bind(observer))();
                }
                break;
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].CANCELED:
            case __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["c" /* TaskState */].ERROR:
                if (observer.error !== null) {
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(observer.error.bind(observer, this.error_))();
                }
                break;
            default:
                // TODO(andysoto): assert(false);
                if (observer.error !== null) {
                    Object(__WEBPACK_IMPORTED_MODULE_5__implementation_async__["a" /* async */])(observer.error.bind(observer, this.error_))();
                }
        }
    };
    /**
     * Resumes a paused task. Has no effect on a currently running or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.resume = function () {
        __WEBPACK_IMPORTED_MODULE_3__implementation_args__["g" /* validate */]('resume', [], arguments);
        var valid = this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSED ||
            this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING;
        if (valid) {
            this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING);
        }
        return valid;
    };
    /**
     * Pauses a currently running task. Has no effect on a paused or failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.pause = function () {
        __WEBPACK_IMPORTED_MODULE_3__implementation_args__["g" /* validate */]('pause', [], arguments);
        var valid = this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING;
        if (valid) {
            this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING);
        }
        return valid;
    };
    /**
     * Cancels a currently running or paused task. Has no effect on a complete or
     * failed task.
     * @return True if the operation took effect, false if ignored.
     */
    UploadTask.prototype.cancel = function () {
        __WEBPACK_IMPORTED_MODULE_3__implementation_args__["g" /* validate */]('cancel', [], arguments);
        var valid = this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].RUNNING ||
            this.state_ === __WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].PAUSING;
        if (valid) {
            this.transition_(__WEBPACK_IMPORTED_MODULE_0__implementation_taskenums__["a" /* InternalTaskState */].CANCELING);
        }
        return valid;
    };
    return UploadTask;
}());


//# sourceMappingURL=task.js.map


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Observer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__type__ = __webpack_require__(6);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @struct
 */
var Observer = /** @class */ (function () {
    function Observer(nextOrObserver, opt_error, opt_complete) {
        var asFunctions = __WEBPACK_IMPORTED_MODULE_0__type__["b" /* isFunction */](nextOrObserver) ||
            __WEBPACK_IMPORTED_MODULE_0__type__["a" /* isDef */](opt_error) ||
            __WEBPACK_IMPORTED_MODULE_0__type__["a" /* isDef */](opt_complete);
        if (asFunctions) {
            this.next = nextOrObserver;
            this.error = opt_error || null;
            this.complete = opt_complete || null;
        }
        else {
            var observer = nextOrObserver;
            this.next = observer.next || null;
            this.error = observer.error || null;
            this.complete = observer.complete || null;
        }
    }
    return Observer;
}());


//# sourceMappingURL=observer.js.map


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return UploadTaskSnapshot; });
var UploadTaskSnapshot = /** @class */ (function () {
    function UploadTaskSnapshot(bytesTransferred, totalBytes, state, metadata, task, ref) {
        this.bytesTransferred = bytesTransferred;
        this.totalBytes = totalBytes;
        this.state = state;
        this.metadata = metadata;
        this.task = task;
        this.ref = ref;
    }
    Object.defineProperty(UploadTaskSnapshot.prototype, "downloadURL", {
        get: function () {
            if (this.metadata !== null) {
                var urls = this.metadata['downloadURLs'];
                if (urls != null && urls[0] != null) {
                    return urls[0];
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    return UploadTaskSnapshot;
}());


//# sourceMappingURL=tasksnapshot.js.map


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = async;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__promise_external__ = __webpack_require__(11);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Method for invoking a callback asynchronously.
 */

/**
 * Returns a function that invokes f with its arguments asynchronously as a
 * microtask, i.e. as soon as possible after the current script returns back
 * into browser code.
 */
function async(f) {
    return function () {
        var argsToForward = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            argsToForward[_i] = arguments[_i];
        }
        __WEBPACK_IMPORTED_MODULE_0__promise_external__["c" /* resolve */](true).then(function () {
            f.apply(null, argsToForward);
        });
    };
}

//# sourceMappingURL=async.js.map


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Service; });
/* unused harmony export ServiceInternals */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__implementation_args__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__implementation_authwrapper__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__implementation_location__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__implementation_promise_external__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__implementation_request__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__reference__ = __webpack_require__(77);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * A service that provides firebaseStorage.Reference instances.
 * @param opt_url gs:// url to a custom Storage Bucket
 *
 * @struct
 */
var Service = /** @class */ (function () {
    function Service(app, pool, url) {
        this.bucket_ = null;
        function maker(authWrapper, loc) {
            return new __WEBPACK_IMPORTED_MODULE_5__reference__["a" /* Reference */](authWrapper, loc);
        }
        this.authWrapper_ = new __WEBPACK_IMPORTED_MODULE_1__implementation_authwrapper__["a" /* AuthWrapper */](app, maker, __WEBPACK_IMPORTED_MODULE_4__implementation_request__["a" /* makeRequest */], this, pool);
        this.app_ = app;
        if (url != null) {
            this.bucket_ = __WEBPACK_IMPORTED_MODULE_2__implementation_location__["a" /* Location */].makeFromBucketSpec(url);
        }
        else {
            var authWrapperBucket = this.authWrapper_.bucket();
            if (authWrapperBucket != null) {
                this.bucket_ = new __WEBPACK_IMPORTED_MODULE_2__implementation_location__["a" /* Location */](authWrapperBucket, '');
            }
        }
        this.internals_ = new ServiceInternals(this);
    }
    /**
     * Returns a firebaseStorage.Reference for the given path in the default
     * bucket.
     */
    Service.prototype.ref = function (path) {
        function validator(path) {
            if (/^[A-Za-z]+:\/\//.test(path)) {
                throw 'Expected child path but got a URL, use refFromURL instead.';
            }
        }
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('ref', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["e" /* stringSpec */](validator, true)], arguments);
        if (this.bucket_ == null) {
            throw new Error('No Storage Bucket defined in Firebase Options.');
        }
        var ref = new __WEBPACK_IMPORTED_MODULE_5__reference__["a" /* Reference */](this.authWrapper_, this.bucket_);
        if (path != null) {
            return ref.child(path);
        }
        else {
            return ref;
        }
    };
    /**
     * Returns a firebaseStorage.Reference object for the given absolute URL,
     * which must be a gs:// or http[s]:// URL.
     */
    Service.prototype.refFromURL = function (url) {
        function validator(p) {
            if (!/^[A-Za-z]+:\/\//.test(p)) {
                throw 'Expected full URL but got a child path, use ref instead.';
            }
            try {
                __WEBPACK_IMPORTED_MODULE_2__implementation_location__["a" /* Location */].makeFromUrl(p);
            }
            catch (e) {
                throw 'Expected valid full URL but got an invalid one.';
            }
        }
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('refFromURL', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["e" /* stringSpec */](validator, false)], arguments);
        return new __WEBPACK_IMPORTED_MODULE_5__reference__["a" /* Reference */](this.authWrapper_, url);
    };
    Object.defineProperty(Service.prototype, "maxUploadRetryTime", {
        get: function () {
            return this.authWrapper_.maxUploadRetryTime();
        },
        enumerable: true,
        configurable: true
    });
    Service.prototype.setMaxUploadRetryTime = function (time) {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('setMaxUploadRetryTime', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["c" /* nonNegativeNumberSpec */]()], arguments);
        this.authWrapper_.setMaxUploadRetryTime(time);
    };
    Object.defineProperty(Service.prototype, "maxOperationRetryTime", {
        get: function () {
            return this.authWrapper_.maxOperationRetryTime();
        },
        enumerable: true,
        configurable: true
    });
    Service.prototype.setMaxOperationRetryTime = function (time) {
        __WEBPACK_IMPORTED_MODULE_0__implementation_args__["g" /* validate */]('setMaxOperationRetryTime', [__WEBPACK_IMPORTED_MODULE_0__implementation_args__["c" /* nonNegativeNumberSpec */]()], arguments);
        this.authWrapper_.setMaxOperationRetryTime(time);
    };
    Object.defineProperty(Service.prototype, "app", {
        get: function () {
            return this.app_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Service.prototype, "INTERNAL", {
        get: function () {
            return this.internals_;
        },
        enumerable: true,
        configurable: true
    });
    return Service;
}());

/**
 * @struct
 */
var ServiceInternals = /** @class */ (function () {
    function ServiceInternals(service) {
        this.service_ = service;
    }
    /**
     * Called when the associated app is deleted.
     * @see {!fbs.AuthWrapper.prototype.deleteApp}
     */
    ServiceInternals.prototype.delete = function () {
        this.service_.authWrapper_.deleteApp();
        return __WEBPACK_IMPORTED_MODULE_3__implementation_promise_external__["c" /* resolve */](undefined);
    };
    return ServiceInternals;
}());


//# sourceMappingURL=service.js.map


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuthWrapper; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__failrequest__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__location__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__promise_external__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__requestmap__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__type__ = __webpack_require__(6);







/**
 * @param app If null, getAuthToken always resolves with null.
 * @param service The storage service associated with this auth wrapper.
 *     Untyped to avoid circular type dependencies.
 * @struct
 */
var AuthWrapper = /** @class */ (function () {
    function AuthWrapper(app, maker, requestMaker, service, pool) {
        this.bucket_ = null;
        this.deleted_ = false;
        this.app_ = app;
        if (this.app_ !== null) {
            var options = this.app_.options;
            if (__WEBPACK_IMPORTED_MODULE_6__type__["a" /* isDef */](options)) {
                this.bucket_ = AuthWrapper.extractBucket_(options);
            }
        }
        this.storageRefMaker_ = maker;
        this.requestMaker_ = requestMaker;
        this.pool_ = pool;
        this.service_ = service;
        this.maxOperationRetryTime_ = __WEBPACK_IMPORTED_MODULE_0__constants__["d" /* defaultMaxOperationRetryTime */];
        this.maxUploadRetryTime_ = __WEBPACK_IMPORTED_MODULE_0__constants__["e" /* defaultMaxUploadRetryTime */];
        this.requestMap_ = new __WEBPACK_IMPORTED_MODULE_5__requestmap__["a" /* RequestMap */]();
    }
    AuthWrapper.extractBucket_ = function (config) {
        var bucketString = config[__WEBPACK_IMPORTED_MODULE_0__constants__["c" /* configOption */]] || null;
        if (bucketString == null) {
            return null;
        }
        var loc = __WEBPACK_IMPORTED_MODULE_3__location__["a" /* Location */].makeFromBucketSpec(bucketString);
        return loc.bucket;
    };
    AuthWrapper.prototype.getAuthToken = function () {
        // TODO(andysoto): remove ifDef checks after firebase-app implements stubs
        // (b/28673818).
        if (this.app_ !== null &&
            __WEBPACK_IMPORTED_MODULE_6__type__["a" /* isDef */](this.app_.INTERNAL) &&
            __WEBPACK_IMPORTED_MODULE_6__type__["a" /* isDef */](this.app_.INTERNAL.getToken)) {
            return this.app_.INTERNAL.getToken().then(function (response) {
                if (response !== null) {
                    return response.accessToken;
                }
                else {
                    return null;
                }
            }, function (_error) {
                return null;
            });
        }
        else {
            return __WEBPACK_IMPORTED_MODULE_4__promise_external__["c" /* resolve */](null);
        }
    };
    AuthWrapper.prototype.bucket = function () {
        if (this.deleted_) {
            throw __WEBPACK_IMPORTED_MODULE_1__error__["b" /* appDeleted */]();
        }
        else {
            return this.bucket_;
        }
    };
    /**
     * The service associated with this auth wrapper. Untyped to avoid circular
     * type dependencies.
     */
    AuthWrapper.prototype.service = function () {
        return this.service_;
    };
    /**
     * Returns a new firebaseStorage.Reference object referencing this AuthWrapper
     * at the given Location.
     * @param loc The Location.
     * @return Actually a firebaseStorage.Reference, typing not allowed
     *     because of circular dependency problems.
     */
    AuthWrapper.prototype.makeStorageReference = function (loc) {
        return this.storageRefMaker_(this, loc);
    };
    AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {
        if (!this.deleted_) {
            var request = this.requestMaker_(requestInfo, authToken, this.pool_);
            this.requestMap_.addRequest(request);
            return request;
        }
        else {
            return new __WEBPACK_IMPORTED_MODULE_2__failrequest__["a" /* FailRequest */](__WEBPACK_IMPORTED_MODULE_1__error__["b" /* appDeleted */]());
        }
    };
    /**
     * Stop running requests and prevent more from being created.
     */
    AuthWrapper.prototype.deleteApp = function () {
        this.deleted_ = true;
        this.app_ = null;
        this.requestMap_.clear();
    };
    AuthWrapper.prototype.maxUploadRetryTime = function () {
        return this.maxUploadRetryTime_;
    };
    AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {
        this.maxUploadRetryTime_ = time;
    };
    AuthWrapper.prototype.maxOperationRetryTime = function () {
        return this.maxOperationRetryTime_;
    };
    AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {
        this.maxOperationRetryTime_ = time;
    };
    return AuthWrapper;
}());


//# sourceMappingURL=authwrapper.js.map


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FailRequest; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__promise_external__ = __webpack_require__(11);

/**
 * A request whose promise always fails.
 * @struct
 * @template T
 */
var FailRequest = /** @class */ (function () {
    function FailRequest(error) {
        this.promise_ = __WEBPACK_IMPORTED_MODULE_0__promise_external__["b" /* reject */](error);
    }
    /** @inheritDoc */
    FailRequest.prototype.getPromise = function () {
        return this.promise_;
    };
    /** @inheritDoc */
    FailRequest.prototype.cancel = function (appDelete) {
        if (appDelete === void 0) { appDelete = false; }
    };
    return FailRequest;
}());


//# sourceMappingURL=failrequest.js.map


/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RequestMap; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__object__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants__ = __webpack_require__(26);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @struct
 */
var RequestMap = /** @class */ (function () {
    function RequestMap() {
        this.map_ = {};
        this.id_ = __WEBPACK_IMPORTED_MODULE_1__constants__["h" /* minSafeInteger */];
    }
    /**
     * Registers the given request with this map.
     * The request is unregistered when it completes.
     * @param r The request to register.
     */
    RequestMap.prototype.addRequest = function (r) {
        var id = this.id_;
        this.id_++;
        this.map_[id] = r;
        var self = this;
        function unmap() {
            delete self.map_[id];
        }
        r.getPromise().then(unmap, unmap);
    };
    /**
     * Cancels all registered requests.
     */
    RequestMap.prototype.clear = function () {
        __WEBPACK_IMPORTED_MODULE_0__object__["b" /* forEach */](this.map_, function (key, val) {
            if (val) {
                val.cancel(true);
            }
        });
        this.map_ = {};
    };
    return RequestMap;
}());


//# sourceMappingURL=requestmap.js.map


/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export RequestEndStatus */
/* unused harmony export addAuthHeader_ */
/* unused harmony export addVersionHeader_ */
/* harmony export (immutable) */ __webpack_exports__["a"] = makeRequest;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__firebase_app__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__backoff__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__error__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__object__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__promise_external__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__type__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__url__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__xhrio__ = __webpack_require__(76);
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Defines methods used to actually send HTTP requests from
 * abstract representations.
 */









/**
 * @struct
 * @template T
 */
var NetworkRequest = /** @class */ (function () {
    function NetworkRequest(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
        this.pendingXhr_ = null;
        this.backoffId_ = null;
        this.resolve_ = null;
        this.reject_ = null;
        this.canceled_ = false;
        this.appDelete_ = false;
        this.url_ = url;
        this.method_ = method;
        this.headers_ = headers;
        this.body_ = body;
        this.successCodes_ = successCodes.slice();
        this.additionalRetryCodes_ = additionalRetryCodes.slice();
        this.callback_ = callback;
        this.errorCallback_ = errorCallback;
        this.progressCallback_ = progressCallback;
        this.timeout_ = timeout;
        this.pool_ = pool;
        var self = this;
        this.promise_ = __WEBPACK_IMPORTED_MODULE_5__promise_external__["a" /* make */](function (resolve, reject) {
            self.resolve_ = resolve;
            self.reject_ = reject;
            self.start_();
        });
    }
    /**
     * Actually starts the retry loop.
     */
    NetworkRequest.prototype.start_ = function () {
        var self = this;
        function doTheRequest(backoffCallback, canceled) {
            if (canceled) {
                backoffCallback(false, new RequestEndStatus(false, null, true));
                return;
            }
            var xhr = self.pool_.createXhrIo();
            self.pendingXhr_ = xhr;
            function progressListener(progressEvent) {
                var loaded = progressEvent.loaded;
                var total = progressEvent.lengthComputable ? progressEvent.total : -1;
                if (self.progressCallback_ !== null) {
                    self.progressCallback_(loaded, total);
                }
            }
            if (self.progressCallback_ !== null) {
                xhr.addUploadProgressListener(progressListener);
            }
            xhr
                .send(self.url_, self.method_, self.body_, self.headers_)
                .then(function (xhr) {
                if (self.progressCallback_ !== null) {
                    xhr.removeUploadProgressListener(progressListener);
                }
                self.pendingXhr_ = null;
                xhr = xhr;
                var hitServer = xhr.getErrorCode() === __WEBPACK_IMPORTED_MODULE_8__xhrio__["a" /* ErrorCode */].NO_ERROR;
                var status = xhr.getStatus();
                if (!hitServer || self.isRetryStatusCode_(status)) {
                    var wasCanceled = xhr.getErrorCode() === __WEBPACK_IMPORTED_MODULE_8__xhrio__["a" /* ErrorCode */].ABORT;
                    backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
                    return;
                }
                var successCode = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* contains */](self.successCodes_, status);
                backoffCallback(true, new RequestEndStatus(successCode, xhr));
            });
        }
        /**
         * @param requestWentThrough True if the request eventually went
         *     through, false if it hit the retry limit or was canceled.
         */
        function backoffDone(requestWentThrough, status) {
            var resolve = self.resolve_;
            var reject = self.reject_;
            var xhr = status.xhr;
            if (status.wasSuccessCode) {
                try {
                    var result = self.callback_(xhr, xhr.getResponseText());
                    if (__WEBPACK_IMPORTED_MODULE_6__type__["c" /* isJustDef */](result)) {
                        resolve(result);
                    }
                    else {
                        resolve();
                    }
                }
                catch (e) {
                    reject(e);
                }
            }
            else {
                if (xhr !== null) {
                    var err = __WEBPACK_IMPORTED_MODULE_3__error__["s" /* unknown */]();
                    err.setServerResponseProp(xhr.getResponseText());
                    if (self.errorCallback_) {
                        reject(self.errorCallback_(xhr, err));
                    }
                    else {
                        reject(err);
                    }
                }
                else {
                    if (status.canceled) {
                        var err = self.appDelete_
                            ? __WEBPACK_IMPORTED_MODULE_3__error__["b" /* appDeleted */]()
                            : __WEBPACK_IMPORTED_MODULE_3__error__["c" /* canceled */]();
                        reject(err);
                    }
                    else {
                        var err = __WEBPACK_IMPORTED_MODULE_3__error__["o" /* retryLimitExceeded */]();
                        reject(err);
                    }
                }
            }
        }
        if (this.canceled_) {
            backoffDone(false, new RequestEndStatus(false, null, true));
        }
        else {
            this.backoffId_ = __WEBPACK_IMPORTED_MODULE_2__backoff__["a" /* start */](doTheRequest, backoffDone, this.timeout_);
        }
    };
    /** @inheritDoc */
    NetworkRequest.prototype.getPromise = function () {
        return this.promise_;
    };
    /** @inheritDoc */
    NetworkRequest.prototype.cancel = function (appDelete) {
        this.canceled_ = true;
        this.appDelete_ = appDelete || false;
        if (this.backoffId_ !== null) {
            __WEBPACK_IMPORTED_MODULE_2__backoff__["b" /* stop */](this.backoffId_);
        }
        if (this.pendingXhr_ !== null) {
            this.pendingXhr_.abort();
        }
    };
    NetworkRequest.prototype.isRetryStatusCode_ = function (status) {
        // The codes for which to retry came from this page:
        // https://cloud.google.com/storage/docs/exponential-backoff
        var isFiveHundredCode = status >= 500 && status < 600;
        var extraRetryCodes = [
            // Request Timeout: web server didn't receive full request in time.
            408,
            // Too Many Requests: you're getting rate-limited, basically.
            429
        ];
        var isExtraRetryCode = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* contains */](extraRetryCodes, status);
        var isRequestSpecificRetryCode = __WEBPACK_IMPORTED_MODULE_1__array__["b" /* contains */](this.additionalRetryCodes_, status);
        return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest;
}());
/**
 * A collection of information about the result of a network request.
 * @param opt_canceled Defaults to false.
 * @struct
 */
var RequestEndStatus = /** @class */ (function () {
    function RequestEndStatus(wasSuccessCode, xhr, opt_canceled) {
        this.wasSuccessCode = wasSuccessCode;
        this.xhr = xhr;
        this.canceled = !!opt_canceled;
    }
    return RequestEndStatus;
}());

function addAuthHeader_(headers, authToken) {
    if (authToken !== null && authToken.length > 0) {
        headers['Authorization'] = 'Firebase ' + authToken;
    }
}
function addVersionHeader_(headers) {
    var number = typeof __WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"] !== 'undefined' ? __WEBPACK_IMPORTED_MODULE_0__firebase_app__["default"].SDK_VERSION : 'AppManager';
    headers['X-Firebase-Storage-Version'] = 'webjs/' + number;
}
/**
 * @template T
 */
function makeRequest(requestInfo, authToken, pool) {
    var queryPart = __WEBPACK_IMPORTED_MODULE_7__url__["c" /* makeQueryString */](requestInfo.urlParams);
    var url = requestInfo.url + queryPart;
    var headers = __WEBPACK_IMPORTED_MODULE_4__object__["a" /* clone */](requestInfo.headers);
    addAuthHeader_(headers, authToken);
    addVersionHeader_(headers);
    return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}

//# sourceMappingURL=request.js.map


/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = start;
/* harmony export (immutable) */ __webpack_exports__["b"] = stop;
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param f May be invoked
 *     before the function returns.
 * @param callback Get all the arguments passed to the function
 *     passed to f, including the initial boolean.
 */
function start(f, callback, timeout) {
    // TODO(andysoto): make this code cleaner (probably refactor into an actual
    // type instead of a bunch of functions with state shared in the closure)
    var waitSeconds = 1;
    // Would type this as "number" but that doesn't work for Node so ¯\_(ツ)_/¯
    var timeoutId = null;
    var hitTimeout = false;
    var cancelState = 0;
    function canceled() {
        return cancelState === 2;
    }
    var triggeredCallback = false;
    function triggerCallback() {
        if (!triggeredCallback) {
            triggeredCallback = true;
            callback.apply(null, arguments);
        }
    }
    function callWithDelay(millis) {
        timeoutId = setTimeout(function () {
            timeoutId = null;
            f(handler, canceled());
        }, millis);
    }
    function handler(success) {
        var var_args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            var_args[_i - 1] = arguments[_i];
        }
        if (triggeredCallback) {
            return;
        }
        if (success) {
            triggerCallback.apply(null, arguments);
            return;
        }
        var mustStop = canceled() || hitTimeout;
        if (mustStop) {
            triggerCallback.apply(null, arguments);
            return;
        }
        if (waitSeconds < 64) {
            /* TODO(andysoto): don't back off so quickly if we know we're offline. */
            waitSeconds *= 2;
        }
        var waitMillis;
        if (cancelState === 1) {
            cancelState = 2;
            waitMillis = 0;
        }
        else {
            waitMillis = (waitSeconds + Math.random()) * 1000;
        }
        callWithDelay(waitMillis);
    }
    var stopped = false;
    function stop(wasTimeout) {
        if (stopped) {
            return;
        }
        stopped = true;
        if (triggeredCallback) {
            return;
        }
        if (timeoutId !== null) {
            if (!wasTimeout) {
                cancelState = 2;
            }
            clearTimeout(timeoutId);
            callWithDelay(0);
        }
        else {
            if (!wasTimeout) {
                cancelState = 1;
            }
        }
    }
    callWithDelay(0);
    setTimeout(function () {
        hitTimeout = true;
        stop(true);
    }, timeout);
    return stop;
}
/**
 * Stops the retry loop from repeating.
 * If the function is currently "in between" retries, it is invoked immediately
 * with the second parameter as "true". Otherwise, it will be invoked once more
 * after the current invocation finishes iff the current invocation would have
 * triggered another retry.
 */
function stop(id) {
    id(false);
}

//# sourceMappingURL=backoff.js.map


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(163);

__webpack_require__(166);

__webpack_require__(168);

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(164);

var _d = __webpack_require__(165);

var _d2 = _interopRequireDefault(_d);

var _app = __webpack_require__(40);

var firebase = _interopRequireWildcard(_app);

__webpack_require__(41);

__webpack_require__(81);

__webpack_require__(136);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Global data vars

var nodes, lastNodeId, links;

var nodesMap = {};

// FIREBASE SYNC

// <-- write data
var synUISync = document.querySelector('.syn-ui-sync');
var userId;

firebase.auth().onAuthStateChanged(function (user) {
  if (user) {
    userId = firebase.auth().currentUser.uid;
  } else {}
});

synUISync.addEventListener('click', function (e) {
  firebase.database().ref().child(userId).set({
    nodes: nodes,
    lastNodeId: lastNodeId,
    links: links
  });
});
// -->

// <-- read data

var dbRef = firebase.database().ref();

// get nodes and links from db and init force layout
dbRef.once('value').then(function (snapshot) {

  // get nodes
  nodes = snapshot.child(userId + "/nodes").val();
  lastNodeId = snapshot.child(userId + "/lastNodeId").val();
  links = snapshot.child(userId + "/links").val();

  // if there are no nodes (first time login) – init starter data
  if (nodes === null) {
    nodes = [{ id: 0, reflexive: false }, { id: 1, reflexive: false }, { id: 2, reflexive: false }];

    lastNodeId = 2;

    links = [{
      source: nodes[0],
      target: nodes[1],
      left: false,
      right: true
    }, {
      source: nodes[1],
      target: nodes[2],
      left: false,
      right: true
    }];
  } else {

    // Ivo's fix for mapping the right nodes to links
    for (var n in nodes) {
      nodesMap[nodes[n].id] = nodes[n];
    }

    var tempLinks = [];

    for (var l in links) {
      tempLinks.push({
        source: nodesMap[links[l].source.id],
        target: nodesMap[links[l].target.id]
      });
    }

    // TODO: looped tempLinks override left & right key-values, thus arrows are lost
    links = tempLinks;

    // links appears to be an object, despite it being an array
    console.log(typeof links === 'undefined' ? 'undefined' : _typeof(links));
  }

  // init force layout
  forceInit();

  // -->
});

// d3 force layout core (app core)
function forceInit() {

  // set up the SVG
  var width = window.innerWidth,
      height = window.innerHeight;

  var zoom = _d2.default.behavior.zoom().scaleExtent([0.25, 1]).on("zoom", zoomed);

  var body = _d2.default.select('body').call(zoom);

  var fullNode = document.querySelector('.full-node');

  var svg = _d2.default.select('body').append('svg:svg').attr('oncontextmenu', 'return false;').attr('width', width).attr('height', height).classed('canvas', true);

  var container = _d2.default.select('svg').append("svg:g").attr('width', width).attr('height', height).classed('container', true);

  var currentSynColor = '#4A90E2';

  var filter = svg.append("defs").append("filter").attr("id", "blur").append("feGaussianBlur").attr("stdDeviation", 5);

  // set up initial nodes and links
  //  - nodes are known by 'id', not by index in array.
  //  - reflexive edges are indicated on the node (as a bold black circle).
  //  - links are always source < target; edge directions are set by 'left' and 'right'.

  // init D3 force layout
  var force = _d2.default.layout.force().nodes(nodes).links(links).size([width, height]).linkDistance(550).charge(-500).on('tick', tick).start();
  window.force = force;
  window.links = links;

  var drag = force.drag().on("dragstart", dragstart);

  // define arrow markers for graph links
  svg.append('svg:defs').append('svg:marker').attr('id', 'end-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 6).attr('markerWidth', 4).attr('markerHeight', 4).attr('orient', 'auto').append('svg:path').attr('d', 'M0,-5L10,0L0,5').attr('fill', currentSynColor).style('cursor', '-webkit-grabbing');

  svg.append('svg:defs').append('svg:marker').attr('id', 'start-arrow').attr('viewBox', '0 -5 10 10').attr('refX', 4).attr('markerWidth', 4).attr('markerHeight', 4).attr('orient', 'auto').append('svg:path').attr('d', 'M10,-5L0,0L10,5').attr('fill', currentSynColor);

  // line displayed when dragging new nodes
  var drag_line = container.append('svg:path').attr('class', 'link dragline hidden').attr('d', 'M0,0L0,0');

  // handles to link and node element groups
  var path = container.append('svg:g').selectAll('path'),
      circle = container.append('svg:g').selectAll('g');

  // fix mouse coordinates transform issue
  var zoomTranslateX = 0;
  var zoomTranslateY = 0;
  var zoomScale = 1;

  // mouse event vars
  var selected_node = null,
      selected_link = null,
      mousedown_link = null,
      mousedown_node = null,
      mouseup_node = null;

  function resetMouseVars() {
    mousedown_node = null;
    mouseup_node = null;
    mousedown_link = null;
  }

  // update force layout (called automatically each iteration)
  function tick() {
    // draw directed edges with proper padding from node centers
    path.attr('d', function (d) {
      var deltaX = d.target.x - d.source.x,
          deltaY = d.target.y - d.source.y,
          dist = Math.sqrt(deltaX * deltaX + deltaY * deltaY),
          normX = deltaX / dist,
          normY = deltaY / dist,
          sourcePadding = d.left ? 32 : 0,
          targetPadding = d.right ? 32 : 0,
          sourceX = d.source.x + sourcePadding * normX,
          sourceY = d.source.y + sourcePadding * normY,
          targetX = d.target.x - targetPadding * normX,
          targetY = d.target.y - targetPadding * normY;
      return 'M' + sourceX + ',' + sourceY + 'L' + targetX + ',' + targetY;
    });

    circle.attr('transform', function (d) {
      return 'translate(' + d.x + ',' + d.y + ')';
    });

    restart();
  }

  // update graph (called when needed)
  function restart() {

    // path (link) group
    path = path.data(links);

    // update existing links
    path.classed('selected', function (d) {
      return d === selected_link;
    }).style('marker-start', function (d) {
      return d.left ? 'url(#start-arrow)' : '';
    }).style('marker-end', function (d) {
      return d.right ? 'url(#end-arrow)' : '';
    });

    // add new links
    path.enter().append('svg:path').attr('class', 'link').classed('selected', function (d) {
      return d === selected_link;
    }).style('marker-start', function (d) {
      return d.left ? 'url(#start-arrow)' : '';
    }).style('marker-end', function (d) {
      return d.right ? 'url(#end-arrow)' : '';
    }).on('mousedown', function (d) {
      if (_d2.default.event.ctrlKey) return;

      // select link
      mousedown_link = d;
      if (mousedown_link === selected_link) selected_link = null;else selected_link = mousedown_link;
      selected_node = null;
      restart();
    });

    // remove old links
    path.exit().remove();

    // circle (node) group
    // NB: the function arg is crucial here! nodes are known by id, not by index!
    circle = circle.data(nodes, function (d) {
      return d.id;
    });

    // update existing nodes (reflexive & selected visual states)
    circle.selectAll('circle').classed('reflexive', function (d) {
      return d.reflexive;
    });

    // create syn group
    var synGroup = circle.enter().append('svg:g').call(drag)
    // future interaction
    // .on('click', synExpand)
    .on('mousedown', function () {
      _d2.default.event.stopPropagation();
    }).classed('syn', true);

    function createSyn() {

      var cardWidth = 186,
          cardHeight = 100;

      var cardOffsetX = -cardWidth - 15,
          cardOffsetY = -cardHeight - 15;

      var cardExpander = synGroup.append('svg:rect').attr('height', 190).attr('width', 290).attr('x', -270).attr('y', -160).attr('fill', 'rgba(0,0,0,0)');

      var shadowCard = synGroup.append('svg:rect').attr('fill', 'rgba(0, 17, 49, 0.1)').attr('width', 194).attr('height', 108).attr('ry', 12).attr('rx', 12).attr('x', cardOffsetX - 4).attr('y', cardOffsetY - 4).classed('card-shadow', true);

      var cardNodeShadow = synGroup.append('svg:circle').attr('r', 10).attr('cx', 0).attr('cy', 0).style('fill', currentSynColor).classed('card-node-shadow', true);

      var card = synGroup.append('svg:rect').attr('fill', 'rgba(255,255,255,1').attr('width', cardWidth).attr('height', cardHeight).attr('x', cardOffsetX).attr('y', cardOffsetY).attr('rx', 10).attr('ry', 10).classed('card', true);

      var cardHTMLWrap = synGroup.append('svg:foreignObject').attr('width', cardWidth).attr('height', cardHeight).attr('x', cardOffsetX).attr('y', cardOffsetY).classed('card-html-wrap', true);

      var cardInput = cardHTMLWrap.append('xhtml:textarea').attr('type', 'text').attr('spellcheck', false).classed('card-input', true);

      var cardCorner = synGroup.append('svg:rect').attr('width', 11).attr('height', 11).attr('x', -26).attr('y', -26).attr('fill', '#fff');

      var cardAction = synGroup.append('svg:rect').attr('width', 25).attr('height', 25).attr('fill', currentSynColor).attr('x', -215).attr('y', -105).classed('card-action', true).on('click', synExpand);

      var cardActionCircle = synGroup.append('svg:circle').attr('r', 12).attr('cx', -255).attr('cy', -140).attr('fill', '#FF5E9C').classed('card-action-circle', true);

      var cardActionSquare = synGroup.append('svg:rect').attr('width', 9).attr('height', 9).attr('x', -200).attr('y', -150).attr('fill', '#ffffff').classed('card-action-square', true);

      // document.querySelector('.card-input').value = localStorage.getItem("nodeValue");

      var cardNode = synGroup.append('svg:circle').attr('class', 'card-node').attr('r', 10).attr('cx', 0).attr('cy', 0).style('fill', '#35649C').on('mouseover', function (d) {
        if (!mousedown_node || d === mousedown_node) return;
      }).on('mouseout', function (d) {
        if (!mousedown_node || d === mousedown_node) return;
      }).on('mousedown', function (d) {
        if (_d2.default.event.ctrlKey) return;
        _d2.default.event.stopPropagation();

        // select node
        mousedown_node = d;
        if (mousedown_node === selected_node) selected_node = null;else selected_node = mousedown_node;
        selected_link = null;

        // reposition drag line

        drag_line.style('marker-end', 'url(#end-arrow)').classed('hidden', false).attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + mousedown_node.x + ',' + mousedown_node.y);
      }).on('mouseup', function (d) {
        if (!mousedown_node) return;

        // needed by FF
        drag_line.classed('hidden', true).style('marker-end', '');

        // check for drag-to-self
        mouseup_node = d;
        if (mouseup_node === mousedown_node) {
          resetMouseVars();return;
        }

        // unenlarge target node
        _d2.default.select(this).attr('transform', '');

        // add link to graph (update if exists)
        // NB: links are strictly source < target; arrows separately specified by booleans
        var source, target, direction;
        if (mousedown_node.id < mouseup_node.id) {
          source = mousedown_node;
          target = mouseup_node;
          direction = 'right';
        } else {
          source = mouseup_node;
          target = mousedown_node;
          direction = 'left';
        }

        var link;
        link = links.filter(function (l) {
          return l.source === source && l.target === target;
        })[0];

        if (link) {
          link[direction] = true;
        } else {
          link = { source: source, target: target, left: false, right: false };
          link[direction] = true;
          links.push(link);
        }

        // select new link
        selected_link = link;
        selected_node = null;

        restart();
      });
      ;

      function synExpand(d) {

        var cardExpandedWidth = 380,
            cardExpandedHeight = 260;

        var currentCardAction = _d2.default.select(this);

        _d2.default.selectAll(".syn").attr("filter", "url(#blur)").attr("fill-opacity", 0.9);

        var currentSyn = _d2.default.select(this.parentNode).classed('syn-expanded', true).attr("filter", false).attr("fill-opacity", 1);

        var currentCard = currentSyn.select('.syn .card').attr('x', -(cardExpandedWidth + 15)).attr('y', -(cardExpandedHeight + 15)).attr('width', cardExpandedWidth).attr('height', cardExpandedHeight);

        var currentCardHTMLWrap = currentSyn.select('.syn .card-html-wrap').attr('x', -(cardExpandedWidth + 15)).attr('y', -(cardExpandedHeight + 15)).attr('width', cardExpandedWidth).attr('height', cardExpandedHeight);

        var currentAction = currentSyn.select('.syn .card-action').attr('width', 50).attr('height', 50).attr('x', -455).attr('y', -260).attr('rx', 50).attr('ry', 50).on('click', synCollapse);

        var saveGroup = currentSyn.append('svg:g').classed('card-save', true).attr('transform', 'translate(-443, -248) scale(1)').on('click', synCollapse);

        var saveRect1 = saveGroup.append('svg:rect').attr('fill', '#ffffff').attr('x', 0).attr('y', 0).attr('width', 26).attr('height', 26).attr('rx', 3);

        var saveRect2 = saveGroup.append('svg:rect').attr('fill', '#4A90E2').attr('opacity', 0.65).attr('x', 3).attr('y', 12).attr('width', 20).attr('height', 11).attr('rx', 2);

        var savePath = saveGroup.append('svg:path').attr('d', 'M9,0 L23,0 L23,6 L23,6 C23,7.1045695 22.1045695,8 21,8 L11,8 L11,8 C9.8954305,8 9,7.1045695 9,6 L9,0 Z').attr('fill', '#4A90E2').attr('opacity', '0.65');

        var saveRect3 = saveGroup.append('svg:rect').attr('fill', '#ffffff').attr('x', 18).attr('y', 1).attr('width', 3).attr('height', 6).attr('rx', 1.5);

        var saveRect4 = saveGroup.append('svg:rect').attr('fill', '#4A90E2').attr('opacity', 0.65).attr('x', 3).attr('y', 3).attr('width', 3).attr('height', 3).attr('rx', 1.5);

        function synCollapse(d) {

          var currentValue = this.parentNode.querySelector('.card-input').value;

          // why stringfy here?
          // var currentNode = JSON.stringify(nodes[d.id]);

          var currentNode = nodes[d.id];

          // push content to node
          var currentNodeValue = currentNode.content = currentValue;

          // console.log(currentNode)
          // console.log(nodes)
          // console.log(currentNodeValue)

          localStorage.setItem("nodeValue", currentNodeValue);

          //

          currentSyn = _d2.default.select(this.parentNode).classed('syn-expanded', false);

          _d2.default.selectAll(".syn").attr("filter", false).attr("fill-opacity", 1);

          saveGroup.remove();

          currentCard.attr('width', cardWidth).attr('height', cardHeight).attr('x', cardOffsetX).attr('y', cardOffsetY);

          currentCardHTMLWrap.attr('width', cardWidth).attr('height', cardHeight).attr('x', cardOffsetX).attr('y', cardOffsetY);

          currentCardAction.attr('width', 25).attr('height', 25).attr('fill', currentSynColor).attr('x', -215).attr('y', -105).attr('rx', 0).attr('ry', 0).classed('card-action', true).on('click', synExpand);
        }
      }
    }
    createSyn();

    // remove old nodes
    circle.exit().remove();

    // set the graph in motion

    // localStorage.setItem('links', JSON.stringify(links));
    // localStorage.setItem('nodes', JSON.stringify(nodes));

    force.start();
  }

  function mousedown() {
    // prevent I-bar on drag
    _d2.default.event.preventDefault();

    svg.classed('active', true);

    if (_d2.default.event.ctrlKey || mousedown_node || mousedown_link) return;
  }

  function mousemove(e) {

    // scale clusterfuck mouse fix
    var adjustedMouseX = (_d2.default.mouse(this)[0] - zoomTranslateX) / zoomScale;
    var adjustedMouseY = (_d2.default.mouse(this)[1] - zoomTranslateY) / zoomScale;

    if (!mousedown_node) return;

    // update drag line
    drag_line.attr('d', 'M' + mousedown_node.x + ',' + mousedown_node.y + 'L' + adjustedMouseX + ',' + adjustedMouseY);
  }

  function mouseup() {
    if (mousedown_node) {
      // hide drag line
      drag_line.classed('hidden', true).style('marker-end', '');
    }

    svg.classed('active', false);

    // clear mouse event vars
    resetMouseVars();
  }

  function rightclick() {

    // zoom / scale fix
    var adjustedMouseX = (_d2.default.mouse(this)[0] - zoomTranslateX) / zoomScale;
    var adjustedMouseY = (_d2.default.mouse(this)[1] - zoomTranslateY) / zoomScale;

    // insert a new node at mouse position
    var node = {
      id: ++lastNodeId,
      reflexive: false
      // fixed: true
    };
    node.x = adjustedMouseX;
    node.y = adjustedMouseY;
    nodes.push(node);

    restart();
  }

  function spliceLinksForNode(node) {
    var toSplice = links.filter(function (l) {
      return l.source === node || l.target === node;
    });
    toSplice.map(function (l) {
      links.splice(links.indexOf(l), 1);
    });
  }

  function zoomed() {

    container.attr("transform", "translate(" + _d2.default.event.translate + ")scale(" + _d2.default.event.scale + ")");

    // fix mouse position offset by transform
    zoomTranslateX = _d2.default.event.translate[0];
    zoomTranslateY = _d2.default.event.translate[1];

    zoomScale = _d2.default.event.scale;
  }

  function dragstart(d) {
    _d2.default.select(this).classed("fixed", d.fixed = true);
  }

  // app starts here
  svg.on('mousedown', mousedown).on('mousemove', mousemove).on('mouseup', mouseup).on('contextmenu', rightclick);

  restart();
}

/***/ }),
/* 164 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
  var d3 = {
    version: "3.5.13"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(167);

var _app = __webpack_require__(40);

var firebase = _interopRequireWildcard(_app);

__webpack_require__(41);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// <-- sign out module
var auth = firebase.auth();
var synUILogout = document.querySelector('.syn-ui-logout');

auth.onAuthStateChanged(function (firebaseUser) {
    if (firebaseUser) {
        console.log('logged-in');
    } else {
        window.location = './login.html';
    }
});

synUILogout.addEventListener('click', function (e) {
    auth.signOut();
});

// -->

/***/ }),
/* 167 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(169);

/***/ }),
/* 169 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZmJjMGM4MjRmNGM5Y2UwNTJmNjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL0NoaWxkcmVuTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3R5cGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9lcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9PcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9wcm9taXNlX2V4dGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9DaGFuZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvS2V5SW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL25vZGVGcm9tSlNPTi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3Rhc2tlbnVtcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL0xlYWZOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9Tb3J0ZWRNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9DYWNoZU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL21vZGVscy9lcnJvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvY29uc3RhbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9SZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL0RhdGFTbmFwc2hvdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvSW1tdXRhYmxlVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL0luZGV4ZWRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdGF0cy9TdGF0c01hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2FyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9tZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2F1dGgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2Fzc2VydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2NyeXB0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL29iai5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvRGF0YWJhc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL2xpYnMvcGFyc2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvUmVwb0luZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL29uRGlzY29ubmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvUXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL3NuYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvSW5kZXhNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2NoaWxkU2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9jb21wYXJhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvaW5kZXhlcy9QYXRoSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL1NlcnZlclZhbHVlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1NwYXJzZVNuYXBzaG90VHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvQ291bnRlZFNldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9PdmVyd3JpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TeW5jUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1ZpZXdDYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0YXRzL1N0YXRzTGlzdGVuZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9QZXJzaXN0ZW50Q29ubmVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvRXZlbnRFbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL0Nvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvcmVhbHRpbWUvQnJvd3NlclBvbGxDb25uZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL1dlYlNvY2tldENvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TZXJ2ZXJBY3Rpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9maWx0ZXIvUmFuZ2VkRmlsdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9jb250cm9sbGVycy9jb250cm9sbGVyLWludGVyZmFjZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvbW9kZWxzL2ZjbS1kZXRhaWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvbm90aWZpY2F0aW9uLXBlcm1pc3Npb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL21vZGVscy93b3JrZXItcGFnZS1tZXNzYWdlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24veGhyaW8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9yZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vYmxvYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3JlcXVlc3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9kYXRhYmFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3BvbHlmaWxsL2Rpc3QvZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vc3JjL3BvbHlmaWxscy9wcm9taXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9zcmMvc2hpbXMvZmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3BvbHlmaWxsL2Rpc3QvZXNtL3NyYy9zaGltcy9maW5kSW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hcHAvZGlzdC9lc20vc3JjL2ZpcmViYXNlQXBwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZGVlcENvcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9kZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2Vudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZXJyb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvand0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9zaGExLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3N1YnNjcmliZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3ZhbGlkYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy91dGY4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXV0aC9kaXN0L2F1dGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0b3JhZ2UvRE9NU3RvcmFnZVdyYXBwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdG9yYWdlL01lbW9yeVN0b3JhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1RyYW5zYWN0aW9uUmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9OZXh0UHVzaElkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TeW5jVHJlZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9BY2tVc2VyV3JpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9vcGVyYXRpb24vTGlzdGVuQ29tcGxldGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9vcGVyYXRpb24vTWVyZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1ZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1ZpZXdQcm9jZXNzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NoaWxkQ2hhbmdlQWNjdW11bGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NvbXBsZXRlQ2hpbGRTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0V2ZW50R2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvV3JpdGVUcmVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvQ29tcG91bmRXcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1NuYXBzaG90SG9sZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvQXV0aFRva2VuUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdGF0cy9TdGF0c0NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdGF0cy9TdGF0c1JlcG9ydGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9FdmVudFF1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9WaXNpYmlsaXR5TW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9UcmFuc3BvcnRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL3BvbGxpbmcvUGFja2V0UmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZWFkb25seVJlc3RDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1F1ZXJ5UGFyYW1zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9maWx0ZXIvTGltaXRlZEZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1JlcG9fdHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS91dGlsL1RyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL2ludGVybmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS90ZXN0X2FjY2Vzcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9maXJlYmFzZS1jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9tZXNzYWdpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL2NvbnRyb2xsZXJzL3dpbmRvdy1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvdG9rZW4tbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvaGVscGVycy9hcnJheS1idWZmZXItdG8tYmFzZTY0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvZGVmYXVsdC1zdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvY29udHJvbGxlcnMvc3ctY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmlyZWJhc2Uvc3RvcmFnZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi94aHJpb3Bvb2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi94aHJpb19uZXR3b3JrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vanNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2ZzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vcmVxdWVzdGluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy90YXNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy90YXNrc25hcHNob3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL3NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9hdXRod3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2ZhaWxyZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vcmVxdWVzdG1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9iYWNrb2ZmLmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9zeW5hcHNlLWNvcmUvc3luYXBzZS1jb3JlLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3N5bmFwc2UtY29yZS9zeW5hcHNlLWNvcmUuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZDMvZDMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc3luYXBzZS11aS9zeW5hcHNlLXVpLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3N5bmFwc2UtdWkvc3luYXBzZS11aS5zY3NzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL3N5bmFwc2Utc3luYy9zeW5hcHNlLXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvc3luYXBzZS1zeW5jL3N5bmFwc2Utc3luYy5zY3NzIl0sIm5hbWVzIjpbImZpcmViYXNlIiwiY29uZmlnIiwiYXBpS2V5IiwiYXV0aERvbWFpbiIsImRhdGFiYXNlVVJMIiwicHJvamVjdElkIiwic3RvcmFnZUJ1Y2tldCIsIm1lc3NhZ2luZ1NlbmRlcklkIiwiaW5pdGlhbGl6ZUFwcCIsIm5vZGVzIiwibGFzdE5vZGVJZCIsImxpbmtzIiwibm9kZXNNYXAiLCJzeW5VSVN5bmMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ1c2VySWQiLCJhdXRoIiwib25BdXRoU3RhdGVDaGFuZ2VkIiwidXNlciIsImN1cnJlbnRVc2VyIiwidWlkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImRhdGFiYXNlIiwicmVmIiwiY2hpbGQiLCJzZXQiLCJkYlJlZiIsIm9uY2UiLCJ0aGVuIiwic25hcHNob3QiLCJ2YWwiLCJpZCIsInJlZmxleGl2ZSIsInNvdXJjZSIsInRhcmdldCIsImxlZnQiLCJyaWdodCIsIm4iLCJ0ZW1wTGlua3MiLCJsIiwicHVzaCIsImNvbnNvbGUiLCJsb2ciLCJmb3JjZUluaXQiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsInpvb20iLCJiZWhhdmlvciIsInNjYWxlRXh0ZW50Iiwib24iLCJ6b29tZWQiLCJib2R5Iiwic2VsZWN0IiwiY2FsbCIsImZ1bGxOb2RlIiwic3ZnIiwiYXBwZW5kIiwiYXR0ciIsImNsYXNzZWQiLCJjb250YWluZXIiLCJjdXJyZW50U3luQ29sb3IiLCJmaWx0ZXIiLCJmb3JjZSIsImxheW91dCIsInNpemUiLCJsaW5rRGlzdGFuY2UiLCJjaGFyZ2UiLCJ0aWNrIiwic3RhcnQiLCJkcmFnIiwiZHJhZ3N0YXJ0Iiwic3R5bGUiLCJkcmFnX2xpbmUiLCJwYXRoIiwic2VsZWN0QWxsIiwiY2lyY2xlIiwiem9vbVRyYW5zbGF0ZVgiLCJ6b29tVHJhbnNsYXRlWSIsInpvb21TY2FsZSIsInNlbGVjdGVkX25vZGUiLCJzZWxlY3RlZF9saW5rIiwibW91c2Vkb3duX2xpbmsiLCJtb3VzZWRvd25fbm9kZSIsIm1vdXNldXBfbm9kZSIsInJlc2V0TW91c2VWYXJzIiwiZCIsImRlbHRhWCIsIngiLCJkZWx0YVkiLCJ5IiwiZGlzdCIsIk1hdGgiLCJzcXJ0Iiwibm9ybVgiLCJub3JtWSIsInNvdXJjZVBhZGRpbmciLCJ0YXJnZXRQYWRkaW5nIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInJlc3RhcnQiLCJkYXRhIiwiZW50ZXIiLCJldmVudCIsImN0cmxLZXkiLCJleGl0IiwicmVtb3ZlIiwic3luR3JvdXAiLCJzdG9wUHJvcGFnYXRpb24iLCJjcmVhdGVTeW4iLCJjYXJkV2lkdGgiLCJjYXJkSGVpZ2h0IiwiY2FyZE9mZnNldFgiLCJjYXJkT2Zmc2V0WSIsImNhcmRFeHBhbmRlciIsInNoYWRvd0NhcmQiLCJjYXJkTm9kZVNoYWRvdyIsImNhcmQiLCJjYXJkSFRNTFdyYXAiLCJjYXJkSW5wdXQiLCJjYXJkQ29ybmVyIiwiY2FyZEFjdGlvbiIsInN5bkV4cGFuZCIsImNhcmRBY3Rpb25DaXJjbGUiLCJjYXJkQWN0aW9uU3F1YXJlIiwiY2FyZE5vZGUiLCJkaXJlY3Rpb24iLCJsaW5rIiwiY2FyZEV4cGFuZGVkV2lkdGgiLCJjYXJkRXhwYW5kZWRIZWlnaHQiLCJjdXJyZW50Q2FyZEFjdGlvbiIsImN1cnJlbnRTeW4iLCJwYXJlbnROb2RlIiwiY3VycmVudENhcmQiLCJjdXJyZW50Q2FyZEhUTUxXcmFwIiwiY3VycmVudEFjdGlvbiIsInN5bkNvbGxhcHNlIiwic2F2ZUdyb3VwIiwic2F2ZVJlY3QxIiwic2F2ZVJlY3QyIiwic2F2ZVBhdGgiLCJzYXZlUmVjdDMiLCJzYXZlUmVjdDQiLCJjdXJyZW50VmFsdWUiLCJ2YWx1ZSIsImN1cnJlbnROb2RlIiwiY3VycmVudE5vZGVWYWx1ZSIsImNvbnRlbnQiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibW91c2Vkb3duIiwicHJldmVudERlZmF1bHQiLCJtb3VzZW1vdmUiLCJlIiwiYWRqdXN0ZWRNb3VzZVgiLCJtb3VzZSIsImFkanVzdGVkTW91c2VZIiwibW91c2V1cCIsInJpZ2h0Y2xpY2siLCJub2RlIiwic3BsaWNlTGlua3NGb3JOb2RlIiwidG9TcGxpY2UiLCJtYXAiLCJzcGxpY2UiLCJpbmRleE9mIiwidHJhbnNsYXRlIiwic2NhbGUiLCJmaXhlZCIsInN5blVJTG9n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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNPO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDdE5BO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2xDO0FBQ0E7OztBQUdBOzs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsTUFBTTtBQUNqQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsc0JBQXNCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixXQUFXLE1BQU07QUFDakIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLHNIQUFzSCx1QkFBdUIsRUFBRTtBQUMvSTtBQUNBO0FBQ0EsOEdBQThHLDhCQUE4QixHQUFHLDhDQUE4QztBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdCQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN4REE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxhQUFhO0FBQzVCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNPO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdElBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUM5S0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDekNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDaEJBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsK0JBQStCLHFDQUFxQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLGVBQWUsRUFBRSxFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QWUsa0JBQWtCO0FBQ2pDO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCOztBQUUvQjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tCO0FBQ2xCO0FBQ21CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUI7QUFDdkI7QUFDcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7OztBQzlPQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDOURBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ087O0FBRVI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTztBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNqQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpREFBaUQs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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7OztBQ3pMRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7Ozs7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBCO0FBQ2tDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWEsRUFBRTtBQUNoRCxtQ0FBbUMsOEJBQThCLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHVCQUF1QixFQUFFO0FBQ2pFLGFBQWE7QUFDYjtBQUNBLDRFQUE0RSw4QkFBOEIsRUFBRTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrQkFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGFBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0IsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQSx5Q0FBeUMsTUFBTTtBQUMvQywyQ0FBMkMsTUFBTTtBQUNqRCx5Q0FBeUMsTUFBTTtBQUMvQyxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxNQUFNO0FBQzdDO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRkFBaUY7QUFDaEcsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDN0RBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsMEJBQTBCLE1BQU0sSUFBSTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHlCQUF5QjtBQUN4RztBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUNuRix5QkFBeUIsdURBQXVEO0FBQ2hGO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7Ozs7OztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDdERBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVCQUF1QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZUFBZSxXQUFXO0FBQzFCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7Ozs7Ozs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOzs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Z0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7Ozs7Ozs7O0FDclpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2QkFBNkI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ087O0FBRVI7Ozs7Ozs7OztBQ3JJQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQzlEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRCO0FBQ1Q7QUFDWTtBQUNGO0FBQzdCO0FBQ0E7QUFDNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsOENBQThDLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDRCQUE0QjtBQUNwRSwrQkFBK0IsbUJBQW1CO0FBQ2xELG1DQUFtQyx1QkFBdUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7O0FDampCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNPOztBQUVSOzs7Ozs7OztBQ3hDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7O0FDL0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQjtBQUNIO0FBQ25CO0FBQ0E7QUFDb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNPO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ3NCO0FBQ0g7QUFDbkI7QUFDcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBLENBQUM7QUFDTzs7QUFFUjs7Ozs7Ozs7OztBQ3RCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ087O0FBRVI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ087QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUMzTkE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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MUQ7QUFFSCxDOzs7Ozs7QUM1dEJELHlDOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsS0FBSztBQUNMLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLFNBQVM7QUFDdkYsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHdFQUF3RTtBQUN4RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQsc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDLHlEQUF5RCxTQUFTO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsU0FBUztBQUM5Qyw0RUFBNEUsVUFBVTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDLGdFQUFnRSxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQyx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHdDQUF3QztBQUM5RjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUZBQWlGO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDZCQUE2QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELE9BQU87QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QixvRUFBb0UsT0FBTztBQUMzRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMseUJBQXlCLDhCQUE4QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0EsK0NBQStDO0FBQy9DLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsOEJBQThCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDhCQUE4QjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxPQUFPLDJEQUEyRCxpQkFBaUIsT0FBTztBQUNuSjtBQUNBLHlEQUF5RCxPQUFPLDJEQUEyRCxpQkFBaUIsT0FBTztBQUNuSjtBQUNBLG1EQUFtRCxPQUFPLG1EQUFtRCxpQkFBaUIsT0FBTztBQUNySTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLG1CQUFtQixP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Q0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDhFQUE4RSxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNLHFCQUFxQixPQUFPO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsZ0JBQWdCLFFBQVEsc0JBQXNCLE9BQU87QUFDckQ7QUFDQSxtQkFBbUIsY0FBYztBQUNqQyw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIscUJBQXFCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0EseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUMseURBQXlELFNBQVM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMEJBQTBCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQUE7QUFBQTtBQUFBO0FBQUEscUdBQTJFLDRFQUE0RTtBQUN2SixDQUFDLEc7Ozs7Ozs7OztBQ2gxU0Q7O0FBQ0E7O0lBQVl6RyxROztBQUNaOzs7O0FBRUE7QUFDQSxJQUFJaUIsT0FBT2pCLFNBQVNpQixJQUFULEVBQVg7QUFDQSxJQUFJNEosY0FBYy9KLFNBQVNDLGFBQVQsQ0FBdUIsZ0JBQXZCLENBQWxCOztBQUVBRSxLQUFLQyxrQkFBTCxDQUF3Qix3QkFBZ0I7QUFDcEMsUUFBSTRKLFlBQUosRUFBa0I7QUFDZHBJLGdCQUFRQyxHQUFSLENBQVksV0FBWjtBQUVILEtBSEQsTUFJSztBQUNERyxlQUFPaUksUUFBUCxHQUFrQixjQUFsQjtBQUNIO0FBQ0osQ0FSRDs7QUFVQUYsWUFBWXZKLGdCQUFaLENBQTZCLE9BQTdCLEVBQXNDLGFBQUs7QUFDdkNMLFNBQUsrSixPQUFMO0FBQ0gsQ0FGRDs7QUFJQSxNOzs7Ozs7QUN0QkEseUM7Ozs7Ozs7OztBQ0FBLHlCOzs7Ozs7QUNBQSx5QyIsImZpbGUiOiJpbmRleF9idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxNjIpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGZiYzBjODI0ZjRjOWNlMDUyZjY3IiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9hc3NlcnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2NyeXB0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9jb25zdGFudHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2RlZXBDb3B5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9kZWZlcnJlZFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvZW52aXJvbm1lbnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL2Vycm9yc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvanNvblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zcmMvand0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9vYmpcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3F1ZXJ5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9zaGExXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3NyYy9zdWJzY3JpYmVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3ZhbGlkYXRpb25cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3JjL3V0ZjhcIikpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNCA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzUgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF82ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuLi9zdG9yYWdlL3N0b3JhZ2VcIik7XG52YXIgdXRpbF83ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxseS11bmlxdWUgSUQgKGdlbmVyYXRlZCBieSBqdXN0IGluY3JlbWVudGluZyB1cCBmcm9tIDAgZWFjaCB0aW1lIGl0cyBjYWxsZWQpLlxuICogQHR5cGUge2Z1bmN0aW9uKCk6IG51bWJlcn0gR2VuZXJhdGVkIElELlxuICovXG5leHBvcnRzLkxVSURHZW5lcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlkKys7XG4gICAgfTtcbn0pKCk7XG4vKipcbiAqIFNoYTEgaGFzaCBvZiB0aGUgaW5wdXQgc3RyaW5nXG4gKiBAcGFyYW0geyFzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGhhc2hcbiAqIEByZXR1cm4geyFzdHJpbmd9IFRoZSByZXN1bHRpbmcgaGFzaFxuICovXG5leHBvcnRzLnNoYTEgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHV0ZjhCeXRlcyA9IHV0aWxfNS5zdHJpbmdUb0J5dGVBcnJheShzdHIpO1xuICAgIHZhciBzaGExID0gbmV3IHV0aWxfNC5TaGExKCk7XG4gICAgc2hhMS51cGRhdGUodXRmOEJ5dGVzKTtcbiAgICB2YXIgc2hhMUJ5dGVzID0gc2hhMS5kaWdlc3QoKTtcbiAgICByZXR1cm4gdXRpbF8zLmJhc2U2NC5lbmNvZGVCeXRlQXJyYXkoc2hhMUJ5dGVzKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBidWlsZExvZ01lc3NhZ2VfID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBtZXNzYWdlID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJfYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YXJfYXJnc1tpXSkgfHxcbiAgICAgICAgICAgICh2YXJfYXJnc1tpXSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YXJfYXJnc1tpXSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFyX2FyZ3NbaV0ubGVuZ3RoID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYnVpbGRMb2dNZXNzYWdlXy5hcHBseShudWxsLCB2YXJfYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhcl9hcmdzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbWVzc2FnZSArPSB1dGlsXzYuc3RyaW5naWZ5KHZhcl9hcmdzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gdmFyX2FyZ3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSAnICc7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlO1xufTtcbi8qKlxuICogVXNlIHRoaXMgZm9yIGFsbCBkZWJ1ZyBtZXNzYWdlcyBpbiBGaXJlYmFzZS5cbiAqIEB0eXBlIHs/ZnVuY3Rpb24oc3RyaW5nKX1cbiAqL1xuZXhwb3J0cy5sb2dnZXIgPSBudWxsO1xuLyoqXG4gKiBGbGFnIHRvIGNoZWNrIGZvciBsb2cgYXZhaWxhYmlsaXR5IG9uIGZpcnN0IGxvZyBtZXNzYWdlXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBmaXJzdExvZ18gPSB0cnVlO1xuLyoqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgRmlyZWJhc2UuZW5hYmxlTG9nZ2luZyAoZGVmaW5lZCBoZXJlIHRvIGJyZWFrIGRlcGVuZGVuY2llcylcbiAqIEBwYXJhbSB7Ym9vbGVhbnw/ZnVuY3Rpb24oc3RyaW5nKX0gbG9nZ2VyXyBBIGZsYWcgdG8gdHVybiBvbiBsb2dnaW5nLCBvciBhIGN1c3RvbSBsb2dnZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHBlcnNpc3RlbnQgV2hldGhlciBvciBub3QgdG8gcGVyc2lzdCBsb2dnaW5nIHNldHRpbmdzIGFjcm9zcyByZWZyZXNoZXNcbiAqL1xuZXhwb3J0cy5lbmFibGVMb2dnaW5nID0gZnVuY3Rpb24gKGxvZ2dlcl8sIHBlcnNpc3RlbnQpIHtcbiAgICB1dGlsXzEuYXNzZXJ0KCFwZXJzaXN0ZW50IHx8IChsb2dnZXJfID09PSB0cnVlIHx8IGxvZ2dlcl8gPT09IGZhbHNlKSwgXCJDYW4ndCB0dXJuIG9uIGN1c3RvbSBsb2dnZXJzIHBlcnNpc3RlbnRseS5cIik7XG4gICAgaWYgKGxvZ2dlcl8gPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGV4cG9ydHMubG9nZ2VyID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb25zb2xlLmxvZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJRSBkb2VzIHRoaXMuXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5sb2dnZXIgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJzaXN0ZW50KVxuICAgICAgICAgICAgc3RvcmFnZV8xLlNlc3Npb25TdG9yYWdlLnNldCgnbG9nZ2luZ19lbmFibGVkJywgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsb2dnZXJfID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGV4cG9ydHMubG9nZ2VyID0gbG9nZ2VyXztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV4cG9ydHMubG9nZ2VyID0gbnVsbDtcbiAgICAgICAgc3RvcmFnZV8xLlNlc3Npb25TdG9yYWdlLnJlbW92ZSgnbG9nZ2luZ19lbmFibGVkJyk7XG4gICAgfVxufTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7Li4uKHN0cmluZ3xBcmd1bWVudHMpfSB2YXJfYXJnc1xuICovXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoZmlyc3RMb2dfID09PSB0cnVlKSB7XG4gICAgICAgIGZpcnN0TG9nXyA9IGZhbHNlO1xuICAgICAgICBpZiAoZXhwb3J0cy5sb2dnZXIgPT09IG51bGwgJiYgc3RvcmFnZV8xLlNlc3Npb25TdG9yYWdlLmdldCgnbG9nZ2luZ19lbmFibGVkJykgPT09IHRydWUpXG4gICAgICAgICAgICBleHBvcnRzLmVuYWJsZUxvZ2dpbmcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChleHBvcnRzLmxvZ2dlcikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkobnVsbCwgdmFyX2FyZ3MpO1xuICAgICAgICBleHBvcnRzLmxvZ2dlcihtZXNzYWdlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHByZWZpeFxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uWypdKX1cbiAqL1xuZXhwb3J0cy5sb2dXcmFwcGVyID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRzLmxvZy5hcHBseSh2b2lkIDAsIFtwcmVmaXhdLmNvbmNhdCh2YXJfYXJncykpO1xuICAgIH07XG59O1xuLyoqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0cy5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXJfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0ZJUkVCQVNFIElOVEVSTkFMIEVSUk9SOiAnICsgYnVpbGRMb2dNZXNzYWdlXy5hcHBseSh2b2lkIDAsIHZhcl9hcmdzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLmVycm9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQHBhcmFtIHsuLi5zdHJpbmd9IHZhcl9hcmdzXG4gKi9cbmV4cG9ydHMuZmF0YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIG1lc3NhZ2UgPSBidWlsZExvZ01lc3NhZ2VfLmFwcGx5KHZvaWQgMCwgdmFyX2FyZ3MpO1xuICAgIHRocm93IG5ldyBFcnJvcignRklSRUJBU0UgRkFUQUwgRVJST1I6ICcgKyBtZXNzYWdlKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAqL1xuZXhwb3J0cy53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnRklSRUJBU0UgV0FSTklORzogJyArIGJ1aWxkTG9nTWVzc2FnZV8uYXBwbHkodm9pZCAwLCB2YXJfYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZS53YXJuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgY29udGFpbmluZyBwYWdlIHVzZXMgaHR0cHMuIENhbGxlZCB3aGVuIGEgY2FsbCB0byBuZXcgRmlyZWJhc2VcbiAqIGRvZXMgbm90IHVzZSBodHRwcy5cbiAqL1xuZXhwb3J0cy53YXJuSWZQYWdlSXNTZWN1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQmUgdmVyeSBjYXJlZnVsIGFjY2Vzc2luZyBicm93c2VyIGdsb2JhbHMuIFdobyBrbm93cyB3aGF0IG1heSBvciBtYXkgbm90IGV4aXN0LlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cubG9jYXRpb24gJiZcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnByb3RvY29sICYmXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbC5pbmRleE9mKCdodHRwczonKSAhPT0gLTEpIHtcbiAgICAgICAgZXhwb3J0cy53YXJuKCdJbnNlY3VyZSBGaXJlYmFzZSBhY2Nlc3MgZnJvbSBhIHNlY3VyZSBwYWdlLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIGh0dHBzIGluIGNhbGxzIHRvIG5ldyBGaXJlYmFzZSgpLicpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7IVN0cmluZ30gbWV0aG9kTmFtZVxuICovXG5leHBvcnRzLndhcm5BYm91dFVuc3VwcG9ydGVkTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICBleHBvcnRzLndhcm4obWV0aG9kTmFtZSArXG4gICAgICAgICcgaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IGNoYW5nZSBzb29uLiAgJyArXG4gICAgICAgICdQbGVhc2UgZG8gbm90IHVzZS4nKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBkYXRhIGlzIE5hTiwgb3IgKy8tIEluZmluaXR5LlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzSW52YWxpZEpTT05OdW1iZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInICYmXG4gICAgICAgIChkYXRhICE9IGRhdGEgfHwgLy8gTmFOXG4gICAgICAgICAgICBkYXRhID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgICAgICAgICAgZGF0YSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqL1xuZXhwb3J0cy5leGVjdXRlV2hlbkRPTVJlYWR5ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgaWYgKHV0aWxfNy5pc05vZGVTZGsoKSB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNb2RlbGVkIGFmdGVyIGpRdWVyeS4gVHJ5IERPTUNvbnRlbnRMb2FkZWQgYW5kIG9ucmVhZHlzdGF0ZWNoYW5nZSAod2hpY2hcbiAgICAgICAgLy8gZmlyZSBiZWZvcmUgb25sb2FkKSwgYnV0IGZhbGwgYmFjayB0byBvbmxvYWQuXG4gICAgICAgIHZhciBjYWxsZWRfMSA9IGZhbHNlO1xuICAgICAgICB2YXIgd3JhcHBlZEZuXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHdyYXBwZWRGbl8xLCBNYXRoLmZsb29yKDEwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWxsZWRfMSkge1xuICAgICAgICAgICAgICAgIGNhbGxlZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHdyYXBwZWRGbl8xLCBmYWxzZSk7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBvbmxvYWQuXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHdyYXBwZWRGbl8xLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgIC8vIElFLlxuICAgICAgICAgICAgZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlZEZuXzEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gb25sb2FkLlxuICAgICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbmxvYWQnLCB3cmFwcGVkRm5fMSk7XG4gICAgICAgICAgICAvLyBqUXVlcnkgaGFzIGFuIGV4dHJhIGhhY2sgZm9yIElFIHRoYXQgd2UgY291bGQgZW1wbG95IChiYXNlZCBvblxuICAgICAgICAgICAgLy8gaHR0cDovL2phdmFzY3JpcHQubndib3guY29tL0lFQ29udGVudExvYWRlZC8pIEJ1dCBpdCBsb29rcyByZWFsbHkgb2xkLlxuICAgICAgICAgICAgLy8gSSdtIGhvcGluZyB3ZSBkb24ndCBuZWVkIGl0LlxuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogTWluaW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBiZWZvcmUgYW55IHZhbGlkIG5hbWVzXG4gKiBAdHlwZSB7IXN0cmluZ31cbiAqL1xuZXhwb3J0cy5NSU5fTkFNRSA9ICdbTUlOX05BTUVdJztcbi8qKlxuICogTWF4aW11bSBrZXkgbmFtZS4gSW52YWxpZCBmb3IgYWN0dWFsIGRhdGEsIHVzZWQgYXMgYSBtYXJrZXIgdG8gc29ydCBhYm92ZSBhbnkgdmFsaWQgbmFtZXNcbiAqIEB0eXBlIHshc3RyaW5nfVxuICovXG5leHBvcnRzLk1BWF9OQU1FID0gJ1tNQVhfTkFNRV0nO1xuLyoqXG4gKiBDb21wYXJlcyB2YWxpZCBGaXJlYmFzZSBrZXkgbmFtZXMsIHBsdXMgbWluIGFuZCBtYXggbmFtZVxuICogQHBhcmFtIHshc3RyaW5nfSBhXG4gKiBAcGFyYW0geyFzdHJpbmd9IGJcbiAqIEByZXR1cm4geyFudW1iZXJ9XG4gKi9cbmV4cG9ydHMubmFtZUNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChhID09PSBleHBvcnRzLk1JTl9OQU1FIHx8IGIgPT09IGV4cG9ydHMuTUFYX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChiID09PSBleHBvcnRzLk1JTl9OQU1FIHx8IGEgPT09IGV4cG9ydHMuTUFYX05BTUUpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYUFzSW50ID0gZXhwb3J0cy50cnlQYXJzZUludChhKSwgYkFzSW50ID0gZXhwb3J0cy50cnlQYXJzZUludChiKTtcbiAgICAgICAgaWYgKGFBc0ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGJBc0ludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhQXNJbnQgLSBiQXNJbnQgPT0gMCA/IGEubGVuZ3RoIC0gYi5sZW5ndGggOiBhQXNJbnQgLSBiQXNJbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYkFzSW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhIDwgYiA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7IXN0cmluZ30gYVxuICogQHBhcmFtIHshc3RyaW5nfSBiXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBjb21wYXJpc29uIHJlc3VsdC5cbiAqL1xuZXhwb3J0cy5zdHJpbmdDb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0cy5yZXF1aXJlS2V5ID0gZnVuY3Rpb24gKGtleSwgb2JqKSB7XG4gICAgaWYgKG9iaiAmJiBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBrZXkgKCcgKyBrZXkgKyAnKSBpbiBvYmplY3Q6ICcgKyB1dGlsXzYuc3RyaW5naWZ5KG9iaikpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuT2JqZWN0VG9VbmlxdWVLZXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8IG9iaiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHV0aWxfNi5zdHJpbmdpZnkob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgIGtleXMucHVzaChrKTtcbiAgICB9XG4gICAgLy8gRXhwb3J0IGFzIGpzb24sIGJ1dCB3aXRoIHRoZSBrZXlzIHNvcnRlZC5cbiAgICBrZXlzLnNvcnQoKTtcbiAgICB2YXIga2V5ID0gJ3snO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMClcbiAgICAgICAgICAgIGtleSArPSAnLCc7XG4gICAgICAgIGtleSArPSB1dGlsXzYuc3RyaW5naWZ5KGtleXNbaV0pO1xuICAgICAgICBrZXkgKz0gJzonO1xuICAgICAgICBrZXkgKz0gZXhwb3J0cy5PYmplY3RUb1VuaXF1ZUtleShvYmpba2V5c1tpXV0pO1xuICAgIH1cbiAgICBrZXkgKz0gJ30nO1xuICAgIHJldHVybiBrZXk7XG59O1xuLyoqXG4gKiBTcGxpdHMgYSBzdHJpbmcgaW50byBhIG51bWJlciBvZiBzbWFsbGVyIHNlZ21lbnRzIG9mIG1heGltdW0gc2l6ZVxuICogQHBhcmFtIHshc3RyaW5nfSBzdHIgVGhlIHN0cmluZ1xuICogQHBhcmFtIHshbnVtYmVyfSBzZWdzaXplIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFycyBpbiB0aGUgc3RyaW5nLlxuICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IFRoZSBzdHJpbmcsIHNwbGl0IGludG8gYXBwcm9wcmlhdGVseS1zaXplZCBjaHVua3NcbiAqL1xuZXhwb3J0cy5zcGxpdFN0cmluZ0J5U2l6ZSA9IGZ1bmN0aW9uIChzdHIsIHNlZ3NpemUpIHtcbiAgICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAobGVuIDw9IHNlZ3NpemUpIHtcbiAgICAgICAgcmV0dXJuIFtzdHJdO1xuICAgIH1cbiAgICB2YXIgZGF0YVNlZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbjsgYyArPSBzZWdzaXplKSB7XG4gICAgICAgIGlmIChjICsgc2Vnc2l6ZSA+IGxlbikge1xuICAgICAgICAgICAgZGF0YVNlZ3MucHVzaChzdHIuc3Vic3RyaW5nKGMsIGxlbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YVNlZ3MucHVzaChzdHIuc3Vic3RyaW5nKGMsIGMgKyBzZWdzaXplKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFTZWdzO1xufTtcbi8qKlxuICogQXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChrZXksIHZhbHVlKSBwYWlyIGluIGFuIG9iamVjdCBvclxuICogYXBwbHkgYSBmdW5jdGlvbiB0byBlYWNoIChpbmRleCwgdmFsdWUpIHBhaXIgaW4gYW4gYXJyYXlcbiAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oPywgPyl9IGZuIFRoZSBmdW5jdGlvbiB0byBhcHBseVxuICovXG5leHBvcnRzLmVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZuKGksIG9ialtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbiB0aGUgY29udmVyc2lvbiBvZiBjb2RlIHdlIHJlbW92ZWQgdGhlIGdvb2cub2JqZWN0LmZvckVhY2hcbiAgICAgICAgICogZnVuY3Rpb24gd2hpY2ggZGlkIGEgdmFsdWUsa2V5IGNhbGxiYWNrLiBXZSBzdGFuZGFyZGl6ZWQgb25cbiAgICAgICAgICogYSBzaW5nbGUgaW1wbCB0aGF0IGRvZXMgYSBrZXksIHZhbHVlIGNhbGxiYWNrLiBTbyB3ZSBpbnZlcnRcbiAgICAgICAgICogdG8gbm90IGhhdmUgdG8gdG91Y2ggdGhlIGBlYWNoYCBjb2RlIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdXRpbF8yLmZvckVhY2gob2JqLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHsgcmV0dXJuIGZuKHZhbCwga2V5KTsgfSk7XG4gICAgfVxufTtcbi8qKlxuICogTGlrZSBnb29nLmJpbmQsIGJ1dCBkb2Vzbid0IGJvdGhlciB0byBjcmVhdGUgYSBjbG9zdXJlIGlmIG9wdF9jb250ZXh0IGlzIG51bGwvdW5kZWZpbmVkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez9PYmplY3Q9fSBjb250ZXh0IE9wdGlvbmFsIGNvbnRleHQgdG8gYmluZCB0by5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCopfVxuICovXG5leHBvcnRzLmJpbmRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID8gY2FsbGJhY2suYmluZChjb250ZXh0KSA6IGNhbGxiYWNrO1xufTtcbi8qKlxuICogQm9ycm93ZWQgZnJvbSBodHRwOi8vaGcuc2Vjb25kbGlmZS5jb20vbGxzZC9zcmMvdGlwL2pzL3R5cGVkYXJyYXkuanMgKE1JVCBMaWNlbnNlKVxuICogSSBtYWRlIG9uZSBtb2RpZmljYXRpb24gYXQgdGhlIGVuZCBhbmQgcmVtb3ZlZCB0aGUgTmFOIC8gSW5maW5pdHlcbiAqIGhhbmRsaW5nIChzaW5jZSBpdCBzZWVtZWQgYnJva2VuIFtjYXVzZWQgYW4gb3ZlcmZsb3ddIGFuZCB3ZSBkb24ndCBuZWVkIGl0KS4gIFNlZSBNSkwgY29tbWVudHMuXG4gKiBAcGFyYW0geyFudW1iZXJ9IHYgQSBkb3VibGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5kb3VibGVUb0lFRUU3NTRTdHJpbmcgPSBmdW5jdGlvbiAodikge1xuICAgIHV0aWxfMS5hc3NlcnQoIWV4cG9ydHMuaXNJbnZhbGlkSlNPTk51bWJlcih2KSwgJ0ludmFsaWQgSlNPTiBudW1iZXInKTsgLy8gTUpMXG4gICAgdmFyIGViaXRzID0gMTEsIGZiaXRzID0gNTI7XG4gICAgdmFyIGJpYXMgPSAoMSA8PCAoZWJpdHMgLSAxKSkgLSAxLCBzLCBlLCBmLCBsbiwgaSwgYml0cywgc3RyO1xuICAgIC8vIENvbXB1dGUgc2lnbiwgZXhwb25lbnQsIGZyYWN0aW9uXG4gICAgLy8gU2tpcCBOYU4gLyBJbmZpbml0eSBoYW5kbGluZyAtLU1KTC5cbiAgICBpZiAodiA9PT0gMCkge1xuICAgICAgICBlID0gMDtcbiAgICAgICAgZiA9IDA7XG4gICAgICAgIHMgPSAxIC8gdiA9PT0gLUluZmluaXR5ID8gMSA6IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzID0gdiA8IDA7XG4gICAgICAgIHYgPSBNYXRoLmFicyh2KTtcbiAgICAgICAgaWYgKHYgPj0gTWF0aC5wb3coMiwgMSAtIGJpYXMpKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemVkXG4gICAgICAgICAgICBsbiA9IE1hdGgubWluKE1hdGguZmxvb3IoTWF0aC5sb2codikgLyBNYXRoLkxOMiksIGJpYXMpO1xuICAgICAgICAgICAgZSA9IGxuICsgYmlhcztcbiAgICAgICAgICAgIGYgPSBNYXRoLnJvdW5kKHYgKiBNYXRoLnBvdygyLCBmYml0cyAtIGxuKSAtIE1hdGgucG93KDIsIGZiaXRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZW5vcm1hbGl6ZWRcbiAgICAgICAgICAgIGUgPSAwO1xuICAgICAgICAgICAgZiA9IE1hdGgucm91bmQodiAvIE1hdGgucG93KDIsIDEgLSBiaWFzIC0gZmJpdHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQYWNrIHNpZ24sIGV4cG9uZW50LCBmcmFjdGlvblxuICAgIGJpdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBmYml0czsgaTsgaSAtPSAxKSB7XG4gICAgICAgIGJpdHMucHVzaChmICUgMiA/IDEgOiAwKTtcbiAgICAgICAgZiA9IE1hdGguZmxvb3IoZiAvIDIpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBlYml0czsgaTsgaSAtPSAxKSB7XG4gICAgICAgIGJpdHMucHVzaChlICUgMiA/IDEgOiAwKTtcbiAgICAgICAgZSA9IE1hdGguZmxvb3IoZSAvIDIpO1xuICAgIH1cbiAgICBiaXRzLnB1c2gocyA/IDEgOiAwKTtcbiAgICBiaXRzLnJldmVyc2UoKTtcbiAgICBzdHIgPSBiaXRzLmpvaW4oJycpO1xuICAgIC8vIFJldHVybiB0aGUgZGF0YSBhcyBhIGhleCBzdHJpbmcuIC0tTUpMXG4gICAgdmFyIGhleEJ5dGVTdHJpbmcgPSAnJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkgKz0gOCkge1xuICAgICAgICB2YXIgaGV4Qnl0ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHIoaSwgOCksIDIpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKGhleEJ5dGUubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgaGV4Qnl0ZSA9ICcwJyArIGhleEJ5dGU7XG4gICAgICAgIGhleEJ5dGVTdHJpbmcgPSBoZXhCeXRlU3RyaW5nICsgaGV4Qnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhleEJ5dGVTdHJpbmcudG9Mb3dlckNhc2UoKTtcbn07XG4vKipcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgQ2hyb21lIGNvbnRlbnQgc2NyaXB0ICh3aGljaCBleGVjdXRlcyBpbiBhblxuICogaXNvbGF0ZWQgZW52aXJvbm1lbnQgd2hlcmUgbG9uZy1wb2xsaW5nIGRvZXNuJ3Qgd29yaykuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgd2luZG93WydjaHJvbWUnXSAmJlxuICAgICAgICB3aW5kb3dbJ2Nocm9tZSddWydleHRlbnNpb24nXSAmJlxuICAgICAgICAhL15jaHJvbWUvLnRlc3Qod2luZG93LmxvY2F0aW9uLmhyZWYpKTtcbn07XG4vKipcbiAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlJ3JlIGluIGEgV2luZG93cyA4IFN0b3JlIGFwcC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNXaW5kb3dzU3RvcmVBcHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIGNvdXBsZSBXaW5SVCBnbG9iYWxzXG4gICAgcmV0dXJuIHR5cGVvZiBXaW5kb3dzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgV2luZG93cy5VSSA9PT0gJ29iamVjdCc7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIHNlcnZlciBlcnJvciBjb2RlIHRvIGEgSmF2YXNjcmlwdCBFcnJvclxuICogQHBhcmFtIHshc3RyaW5nfSBjb2RlXG4gKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG5leHBvcnRzLmVycm9yRm9yU2VydmVyQ29kZSA9IGZ1bmN0aW9uIChjb2RlLCBxdWVyeSkge1xuICAgIHZhciByZWFzb24gPSAnVW5rbm93biBFcnJvcic7XG4gICAgaWYgKGNvZGUgPT09ICd0b29fYmlnJykge1xuICAgICAgICByZWFzb24gPVxuICAgICAgICAgICAgJ1RoZSBkYXRhIHJlcXVlc3RlZCBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgJyArXG4gICAgICAgICAgICAgICAgJ3RoYXQgY2FuIGJlIGFjY2Vzc2VkIHdpdGggYSBzaW5nbGUgcmVxdWVzdC4nO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09ICdwZXJtaXNzaW9uX2RlbmllZCcpIHtcbiAgICAgICAgcmVhc29uID0gXCJDbGllbnQgZG9lc24ndCBoYXZlIHBlcm1pc3Npb24gdG8gYWNjZXNzIHRoZSBkZXNpcmVkIGRhdGEuXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICByZWFzb24gPSAnVGhlIHNlcnZpY2UgaXMgdW5hdmFpbGFibGUnO1xuICAgIH1cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoY29kZSArICcgYXQgJyArIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKSArICc6ICcgKyByZWFzb24pO1xuICAgIGVycm9yLmNvZGUgPSBjb2RlLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbi8qKlxuICogVXNlZCB0byB0ZXN0IGZvciBpbnRlZ2VyLWxvb2tpbmcgc3RyaW5nc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuSU5URUdFUl9SRUdFWFBfID0gbmV3IFJlZ0V4cCgnXi0/XFxcXGR7MSwxMH0kJyk7XG4vKipcbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgYSAzMi1iaXQgaW50ZWdlciwgcmV0dXJuIGl0LiAgRWxzZSByZXR1cm4gbnVsbC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHs/bnVtYmVyfVxuICovXG5leHBvcnRzLnRyeVBhcnNlSW50ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChleHBvcnRzLklOVEVHRVJfUkVHRVhQXy50ZXN0KHN0cikpIHtcbiAgICAgICAgdmFyIGludFZhbCA9IE51bWJlcihzdHIpO1xuICAgICAgICBpZiAoaW50VmFsID49IC0yMTQ3NDgzNjQ4ICYmIGludFZhbCA8PSAyMTQ3NDgzNjQ3KSB7XG4gICAgICAgICAgICByZXR1cm4gaW50VmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogSGVscGVyIHRvIHJ1biBzb21lIGNvZGUgYnV0IGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCByZS10aHJvdyB0aGVtIGxhdGVyLlxuICogVXNlZnVsIGZvciBwcmV2ZW50aW5nIHVzZXIgY2FsbGJhY2tzIGZyb20gYnJlYWtpbmcgaW50ZXJuYWwgY29kZS5cbiAqXG4gKiBSZS10aHJvd2luZyB0aGUgZXhjZXB0aW9uIGZyb20gYSBzZXRUaW1lb3V0IGlzIGEgbGl0dGxlIGV2aWwsIGJ1dCBpdCdzIHZlcnlcbiAqIGNvbnZlbmllbnQgKHdlIGRvbid0IGhhdmUgdG8gdHJ5IHRvIGZpZ3VyZSBvdXQgd2hlbiBpcyBhIHNhZmUgcG9pbnQgdG9cbiAqIHJlLXRocm93IGl0KSwgYW5kIHRoZSBiZWhhdmlvciBzZWVtcyByZWFzb25hYmxlOlxuICpcbiAqICogSWYgeW91IGFyZW4ndCBwYXVzaW5nIG9uIGV4Y2VwdGlvbnMsIHlvdSBnZXQgYW4gZXJyb3IgaW4gdGhlIGNvbnNvbGUgd2l0aFxuICogICB0aGUgY29ycmVjdCBzdGFjayB0cmFjZS5cbiAqICogSWYgeW91J3JlIHBhdXNpbmcgb24gYWxsIGV4Y2VwdGlvbnMsIHRoZSBkZWJ1Z2dlciB3aWxsIHBhdXNlIG9uIHlvdXJcbiAqICAgZXhjZXB0aW9uIGFuZCB0aGVuIGFnYWluIHdoZW4gd2UgcmV0aHJvdyBpdC5cbiAqICogSWYgeW91J3JlIG9ubHkgcGF1c2luZyBvbiB1bmNhdWdodCBleGNlcHRpb25zLCB0aGUgZGVidWdnZXIgd2lsbCBvbmx5IHBhdXNlXG4gKiAgIG9uIHVzIHJlLXRocm93aW5nIGl0LlxuICpcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuIFRoZSBjb2RlIHRvIGd1YXJkLlxuICovXG5leHBvcnRzLmV4Y2VwdGlvbkd1YXJkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUmUtdGhyb3cgZXhjZXB0aW9uIHdoZW4gaXQncyBzYWZlLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEl0IHVzZWQgdG8gYmUgdGhhdCBcInRocm93IGVcIiB3b3VsZCByZXN1bHQgaW4gYSBnb29kIGNvbnNvbGUgZXJyb3Igd2l0aFxuICAgICAgICAgICAgLy8gcmVsZXZhbnQgY29udGV4dCwgYnV0IGFzIG9mIENocm9tZSAzOSwgeW91IGp1c3QgZ2V0IHRoZSBmaXJlYmFzZS5qc1xuICAgICAgICAgICAgLy8gZmlsZS9saW5lIG51bWJlciB3aGVyZSB3ZSByZS10aHJvdyBpdCwgd2hpY2ggaXMgdXNlbGVzcy4gU28gd2UgbG9nXG4gICAgICAgICAgICAvLyBlLnN0YWNrIGV4cGxpY2l0bHkuXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBlLnN0YWNrIHx8ICcnO1xuICAgICAgICAgICAgZXhwb3J0cy53YXJuKCdFeGNlcHRpb24gd2FzIHRocm93biBieSB1c2VyIGNhbGxiYWNrLicsIHN0YWNrKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xuICAgIH1cbn07XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBzYWZlbHkgY2FsbCBvcHRfY2FsbGJhY2sgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy4gIEl0OlxuICogMS4gVHVybnMgaW50byBhIG5vLW9wIGlmIG9wdF9jYWxsYmFjayBpcyBudWxsIG9yIHVuZGVmaW5lZC5cbiAqIDIuIFdyYXBzIHRoZSBjYWxsIGluc2lkZSBleGNlcHRpb25HdWFyZCB0byBwcmV2ZW50IGV4Y2VwdGlvbnMgZnJvbSBicmVha2luZyBvdXIgc3RhdGUuXG4gKlxuICogQHBhcmFtIHs/RnVuY3Rpb249fSBjYWxsYmFjayBPcHRpb25hbCBvbkNvbXBsZXRlIGNhbGxiYWNrLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBcmJpdHJhcnkgYXJncyB0byBiZSBwYXNzZWQgdG8gb3B0X29uQ29tcGxldGVcbiAqL1xuZXhwb3J0cy5jYWxsVXNlckNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXhwb3J0cy5leGNlcHRpb25HdWFyZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIHZhcl9hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB3ZSB0aGluayB3ZSdyZSBjdXJyZW50bHkgYmVpbmcgY3Jhd2xlZC5cbiAqL1xuZXhwb3J0cy5iZWluZ0NyYXdsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHVzZXJBZ2VudCA9ICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB3aW5kb3dbJ25hdmlnYXRvciddICYmXG4gICAgICAgIHdpbmRvd1snbmF2aWdhdG9yJ11bJ3VzZXJBZ2VudCddKSB8fFxuICAgICAgICAnJztcbiAgICAvLyBGb3Igbm93IHdlIHdoaXRlbGlzdCB0aGUgbW9zdCBwb3B1bGFyIGNyYXdsZXJzLiAgV2Ugc2hvdWxkIHJlZmluZSB0aGlzIHRvIGJlIHRoZSBzZXQgb2YgY3Jhd2xlcnMgd2VcbiAgICAvLyBiZWxpZXZlIHRvIHN1cHBvcnQgSmF2YVNjcmlwdC9BSkFYIHJlbmRlcmluZy5cbiAgICAvLyBOT1RFOiBHb29nbGUgV2VibWFzdGVyIFRvb2xzIGRvZXNuJ3QgcmVhbGx5IGJlbG9uZywgYnV0IHRoZWlyIFwiVGhpcyBpcyBob3cgYSB2aXNpdG9yIHRvIHlvdXIgd2Vic2l0ZVxuICAgIC8vIHdvdWxkIGhhdmUgc2VlbiB0aGUgcGFnZVwiIGlzIGZsYWt5IGlmIHdlIGRvbid0IHRyZWF0IGl0IGFzIGEgY3Jhd2xlci5cbiAgICByZXR1cm4gKHVzZXJBZ2VudC5zZWFyY2goL2dvb2dsZWJvdHxnb29nbGUgd2VibWFzdGVyIHRvb2xzfGJpbmdib3R8eWFob28hIHNsdXJwfGJhaWR1c3BpZGVyfHlhbmRleGJvdHxkdWNrZHVja2JvdC9pKSA+PSAwKTtcbn07XG4vKipcbiAqIEV4cG9ydCBhIHByb3BlcnR5IG9mIGFuIG9iamVjdCB1c2luZyBhIGdldHRlciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCk6ICp9IGZuR2V0XG4gKi9cbmV4cG9ydHMuZXhwb3J0UHJvcEdldHRlciA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIGZuR2V0KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgeyBnZXQ6IGZuR2V0IH0pO1xufTtcbi8qKlxuICogU2FtZSBhcyBzZXRUaW1lb3V0KCkgZXhjZXB0IG9uIE5vZGUuSlMgaXQgd2lsbCAvbm90LyBwcmV2ZW50IHRoZSBwcm9jZXNzIGZyb20gZXhpdGluZy5cbiAqXG4gKiBJdCBpcyByZW1vdmVkIHdpdGggY2xlYXJUaW1lb3V0KCkgYXMgbm9ybWFsLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIHJ1bi5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIE1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBydW5uaW5nLlxuICogQHJldHVybiB7bnVtYmVyfE9iamVjdH0gVGhlIHNldFRpbWVvdXQoKSByZXR1cm4gdmFsdWUuXG4gKi9cbmV4cG9ydHMuc2V0VGltZW91dE5vbkJsb2NraW5nID0gZnVuY3Rpb24gKGZuLCB0aW1lKSB7XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCB0aW1lKTtcbiAgICBpZiAodHlwZW9mIHRpbWVvdXQgPT09ICdvYmplY3QnICYmIHRpbWVvdXRbJ3VucmVmJ10pIHtcbiAgICAgICAgdGltZW91dFsndW5yZWYnXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZW91dDtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC91dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBBbiBpbW11dGFibGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIHBhcnNlZCBwYXRoLiAgSXQncyBpbW11dGFibGUgc28gdGhhdCB5b3VcbiAqIGNhbiBwYXNzIHRoZW0gYXJvdW5kIHRvIG90aGVyIGZ1bmN0aW9ucyB3aXRob3V0IHdvcnJ5aW5nIGFib3V0IHRoZW0gY2hhbmdpbmdcbiAqIGl0LlxuICovXG52YXIgUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gcGF0aE9yU3RyaW5nIFBhdGggc3RyaW5nIHRvIHBhcnNlLFxuICAgICAqICAgICAgb3IgYW5vdGhlciBwYXRoLCBvciB0aGUgcmF3IHRva2VucyBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcGllY2VOdW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQYXRoKHBhdGhPclN0cmluZywgcGllY2VOdW0pIHtcbiAgICAgICAgaWYgKHBpZWNlTnVtID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRoaXMucGllY2VzXyA9IHBhdGhPclN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGVtcHR5IHBpZWNlcy5cbiAgICAgICAgICAgIHZhciBjb3B5VG8gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWVjZXNfW2NvcHlUb10gPSB0aGlzLnBpZWNlc19baV07XG4gICAgICAgICAgICAgICAgICAgIGNvcHlUbysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGllY2VzXy5sZW5ndGggPSBjb3B5VG87XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBpZWNlc18gPSBwYXRoT3JTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnBpZWNlTnVtXyA9IHBpZWNlTnVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYXRoLCBcIkVtcHR5XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpbmdsZXRvbiB0byByZXByZXNlbnQgYW4gZW1wdHkgcGF0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAY29uc3RcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKCcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUGF0aC5wcm90b3R5cGUuZ2V0RnJvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc19bdGhpcy5waWVjZU51bV9dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGllY2VzXy5sZW5ndGggLSB0aGlzLnBpZWNlTnVtXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLnBvcEZyb250ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGllY2VOdW0gPSB0aGlzLnBpZWNlTnVtXztcbiAgICAgICAgaWYgKHBpZWNlTnVtIDwgdGhpcy5waWVjZXNfLmxlbmd0aCkge1xuICAgICAgICAgICAgcGllY2VOdW0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgodGhpcy5waWVjZXNfLCBwaWVjZU51bSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmdldEJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA8IHRoaXMucGllY2VzXy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5waWVjZXNfW3RoaXMucGllY2VzXy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSAnJylcbiAgICAgICAgICAgICAgICBwYXRoU3RyaW5nICs9ICcvJyArIHRoaXMucGllY2VzX1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyB8fCAnLyc7XG4gICAgfTtcbiAgICBQYXRoLnByb3RvdHlwZS50b1VybEVuY29kZWRTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMucGllY2VzX1tpXSAhPT0gJycpXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArPSAnLycgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRoaXMucGllY2VzX1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoU3RyaW5nIHx8ICcvJztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNoYWxsb3cgY29weSBvZiB0aGUgcGFydHMgb2YgdGhlIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcj19IGJlZ2luXG4gICAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgUGF0aC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoYmVnaW4pIHtcbiAgICAgICAgaWYgKGJlZ2luID09PSB2b2lkIDApIHsgYmVnaW4gPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlc18uc2xpY2UodGhpcy5waWVjZU51bV8gKyBiZWdpbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/UGF0aH1cbiAgICAgKi9cbiAgICBQYXRoLnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBwaWVjZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMucGllY2VOdW1fOyBpIDwgdGhpcy5waWVjZXNfLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aChwaWVjZXMsIDApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8IVBhdGh9IGNoaWxkUGF0aE9ialxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aE9iaikge1xuICAgICAgICB2YXIgcGllY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLnBpZWNlTnVtXzsgaSA8IHRoaXMucGllY2VzXy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBpZWNlcy5wdXNoKHRoaXMucGllY2VzX1tpXSk7XG4gICAgICAgIGlmIChjaGlsZFBhdGhPYmogaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRQYXRoT2JqLnBpZWNlTnVtXzsgaSA8IGNoaWxkUGF0aE9iai5waWVjZXNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGllY2VzLnB1c2goY2hpbGRQYXRoT2JqLnBpZWNlc19baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkUGllY2VzID0gY2hpbGRQYXRoT2JqLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkUGllY2VzW2ldLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKGNoaWxkUGllY2VzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgocGllY2VzLCAwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlcmUgYXJlIG5vIHNlZ21lbnRzIGluIHRoaXMgcGF0aFxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpZWNlTnVtXyA+PSB0aGlzLnBpZWNlc18ubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gb3V0ZXJQYXRoXG4gICAgICogQHBhcmFtIHshUGF0aH0gaW5uZXJQYXRoXG4gICAgICogQHJldHVybiB7IVBhdGh9IFRoZSBwYXRoIGZyb20gb3V0ZXJQYXRoIHRvIGlubmVyUGF0aFxuICAgICAqL1xuICAgIFBhdGgucmVsYXRpdmVQYXRoID0gZnVuY3Rpb24gKG91dGVyUGF0aCwgaW5uZXJQYXRoKSB7XG4gICAgICAgIHZhciBvdXRlciA9IG91dGVyUGF0aC5nZXRGcm9udCgpLCBpbm5lciA9IGlubmVyUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAob3V0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbm5lclBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3V0ZXIgPT09IGlubmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5yZWxhdGl2ZVBhdGgob3V0ZXJQYXRoLnBvcEZyb250KCksIGlubmVyUGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSU5URVJOQUwgRVJST1I6IGlubmVyUGF0aCAoJyArXG4gICAgICAgICAgICAgICAgaW5uZXJQYXRoICtcbiAgICAgICAgICAgICAgICAnKSBpcyBub3Qgd2l0aGluICcgK1xuICAgICAgICAgICAgICAgICdvdXRlclBhdGggKCcgK1xuICAgICAgICAgICAgICAgIG91dGVyUGF0aCArXG4gICAgICAgICAgICAgICAgJyknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gbGVmdFxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJpZ2h0XG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtMSwgMCwgMSBpZiBsZWZ0IGlzIGxlc3MsIGVxdWFsLCBvciBncmVhdGVyIHRoYW4gdGhlIHJpZ2h0LlxuICAgICAqL1xuICAgIFBhdGguY29tcGFyZVBhdGhzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHZhciBsZWZ0S2V5cyA9IGxlZnQuc2xpY2UoKTtcbiAgICAgICAgdmFyIHJpZ2h0S2V5cyA9IHJpZ2h0LnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdEtleXMubGVuZ3RoICYmIGkgPCByaWdodEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjbXAgPSB1dGlsXzEubmFtZUNvbXBhcmUobGVmdEtleXNbaV0sIHJpZ2h0S2V5c1tpXSk7XG4gICAgICAgICAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlZnRLZXlzLmxlbmd0aCA9PT0gcmlnaHRLZXlzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gbGVmdEtleXMubGVuZ3RoIDwgcmlnaHRLZXlzLmxlbmd0aCA/IC0xIDogMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQYXRofSBvdGhlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgcGF0aHMgYXJlIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5nZXRMZW5ndGgoKSAhPT0gb3RoZXIuZ2V0TGVuZ3RoKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5waWVjZU51bV8sIGogPSBvdGhlci5waWVjZU51bV87IGkgPD0gdGhpcy5waWVjZXNfLmxlbmd0aDsgaSsrLCBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpZWNlc19baV0gIT09IG90aGVyLnBpZWNlc19bal0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHBhdGggaXMgYSBwYXJlbnQgKG9yIHRoZSBzYW1lIGFzKSBvdGhlclxuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5waWVjZU51bV87XG4gICAgICAgIHZhciBqID0gb3RoZXIucGllY2VOdW1fO1xuICAgICAgICBpZiAodGhpcy5nZXRMZW5ndGgoKSA+IG90aGVyLmdldExlbmd0aCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLnBpZWNlc18ubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waWVjZXNfW2ldICE9PSBvdGhlci5waWVjZXNfW2pdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGg7XG59KCkpOyAvLyBlbmQgUGF0aFxuZXhwb3J0cy5QYXRoID0gUGF0aDtcbi8qKlxuICogRHluYW1pYyAobXV0YWJsZSkgcGF0aCB1c2VkIHRvIGNvdW50IHBhdGggbGVuZ3Rocy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gZWZmaWNpZW50bHkgY2hlY2sgcGF0aHMgZm9yIHZhbGlkXG4gKiBsZW5ndGggKGluIFVURjggYnl0ZXMpIGFuZCBkZXB0aCAodXNlZCBpbiBwYXRoIHZhbGlkYXRpb24pLlxuICpcbiAqIFRocm93cyBFcnJvciBleGNlcHRpb24gaWYgcGF0aCBpcyBldmVyIGludmFsaWQuXG4gKlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBwYXRoIGFsd2F5cyBiZWdpbnMgd2l0aCAnLycuXG4gKi9cbnZhciBWYWxpZGF0aW9uUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIEluaXRpYWwgUGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhfIFByZWZpeCBmb3IgYW55IGVycm9yIG1lc3NhZ2VzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25QYXRoKHBhdGgsIGVycm9yUHJlZml4Xykge1xuICAgICAgICB0aGlzLmVycm9yUHJlZml4XyA9IGVycm9yUHJlZml4XztcbiAgICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICAgICAgdGhpcy5wYXJ0c18gPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSBJbml0aWFsaXplIHRvIG51bWJlciBvZiAnLycgY2hhcnMgbmVlZGVkIGluIHBhdGguICovXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gPSBNYXRoLm1heCgxLCB0aGlzLnBhcnRzXy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGFydHNfLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IHV0aWxfMi5zdHJpbmdMZW5ndGgodGhpcy5wYXJ0c19baV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZhbGlkYXRpb25QYXRoLCBcIk1BWF9QQVRIX0RFUFRIXCIsIHtcbiAgICAgICAgLyoqIEBjb25zdCB7bnVtYmVyfSBNYXhpbXVtIGtleSBkZXB0aC4gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWYWxpZGF0aW9uUGF0aCwgXCJNQVhfUEFUSF9MRU5HVEhfQllURVNcIiwge1xuICAgICAgICAvKiogQGNvbnN0IHtudW1iZXJ9IE1heGltdW0gbnVtYmVyIG9mIChVVEY4KSBieXRlcyBpbiBhIEZpcmViYXNlIHBhdGguICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDc2ODtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZCAqL1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIC8vIENvdW50IHRoZSBuZWVkZWQgJy8nXG4gICAgICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGhfICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJ0c18ucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gKz0gdXRpbF8yLnN0cmluZ0xlbmd0aChjaGlsZCk7XG4gICAgICAgIHRoaXMuY2hlY2tWYWxpZF8oKTtcbiAgICB9O1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsYXN0ID0gdGhpcy5wYXJ0c18ucG9wKCk7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gLT0gdXRpbF8yLnN0cmluZ0xlbmd0aChsYXN0KTtcbiAgICAgICAgLy8gVW4tY291bnQgdGhlIHByZXZpb3VzICcvJ1xuICAgICAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoXyAtPSAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBWYWxpZGF0aW9uUGF0aC5wcm90b3R5cGUuY2hlY2tWYWxpZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVMZW5ndGhfID4gVmFsaWRhdGlvblBhdGguTUFYX1BBVEhfTEVOR1RIX0JZVEVTKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGhpcy5lcnJvclByZWZpeF8gK1xuICAgICAgICAgICAgICAgICdoYXMgYSBrZXkgcGF0aCBsb25nZXIgdGhhbiAnICtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9MRU5HVEhfQllURVMgK1xuICAgICAgICAgICAgICAgICcgYnl0ZXMgKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aF8gK1xuICAgICAgICAgICAgICAgICcpLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcnRzXy5sZW5ndGggPiBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9ERVBUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuZXJyb3JQcmVmaXhfICtcbiAgICAgICAgICAgICAgICAncGF0aCBzcGVjaWZpZWQgZXhjZWVkcyB0aGUgbWF4aW11bSBkZXB0aCB0aGF0IGNhbiBiZSB3cml0dGVuICgnICtcbiAgICAgICAgICAgICAgICBWYWxpZGF0aW9uUGF0aC5NQVhfUEFUSF9ERVBUSCArXG4gICAgICAgICAgICAgICAgJykgb3Igb2JqZWN0IGNvbnRhaW5zIGEgY3ljbGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy50b0Vycm9yU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgZm9yIHVzZSBpbiBlcnJvciBtZXNzYWdlcyAtIHVzZXMgJy4nIG5vdGF0aW9uIGZvciBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIFZhbGlkYXRpb25QYXRoLnByb3RvdHlwZS50b0Vycm9yU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJ0c18ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJpbiBwcm9wZXJ0eSAnXCIgKyB0aGlzLnBhcnRzXy5qb2luKCcuJykgKyBcIidcIjtcbiAgICB9O1xuICAgIHJldHVybiBWYWxpZGF0aW9uUGF0aDtcbn0oKSk7XG5leHBvcnRzLlZhbGlkYXRpb25QYXRoID0gVmFsaWRhdGlvblBhdGg7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9QYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSW5kZXhfMSA9IHJlcXVpcmUoXCIuL0luZGV4XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3V0aWxcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4uL05vZGVcIik7XG52YXIgTGVhZk5vZGVfMSA9IHJlcXVpcmUoXCIuLi9MZWFmTm9kZVwiKTtcbnZhciBub2RlRnJvbUpTT047XG52YXIgTUFYX05PREU7XG5mdW5jdGlvbiBzZXROb2RlRnJvbUpTT04odmFsKSB7XG4gICAgbm9kZUZyb21KU09OID0gdmFsO1xufVxuZXhwb3J0cy5zZXROb2RlRnJvbUpTT04gPSBzZXROb2RlRnJvbUpTT047XG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xuICAgIE1BWF9OT0RFID0gdmFsO1xufVxuZXhwb3J0cy5zZXRNYXhOb2RlID0gc2V0TWF4Tm9kZTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SW5kZXh9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgUHJpb3JpdHlJbmRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJpb3JpdHlJbmRleCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmlvcml0eUluZGV4KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBhUHJpb3JpdHkgPSBhLm5vZGUuZ2V0UHJpb3JpdHkoKTtcbiAgICAgICAgdmFyIGJQcmlvcml0eSA9IGIubm9kZS5nZXRQcmlvcml0eSgpO1xuICAgICAgICB2YXIgaW5kZXhDbXAgPSBhUHJpb3JpdHkuY29tcGFyZVRvKGJQcmlvcml0eSk7XG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5uYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUuaXNEZWZpbmVkT24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFByaW9yaXR5SW5kZXgucHJvdG90eXBlLmluZGV4ZWRWYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAob2xkTm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICByZXR1cm4gIW9sZE5vZGUuZ2V0UHJpb3JpdHkoKS5lcXVhbHMobmV3Tm9kZS5nZXRQcmlvcml0eSgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUHJpb3JpdHlJbmRleC5wcm90b3R5cGUubWluUG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVfMS5OYW1lZE5vZGUuTUlOO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQcmlvcml0eUluZGV4LnByb3RvdHlwZS5tYXhQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUodXRpbF8xLk1BWF9OQU1FLCBuZXcgTGVhZk5vZGVfMS5MZWFmTm9kZSgnW1BSSU9SSVRZLVBPU1RdJywgTUFYX05PREUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBQcmlvcml0eUluZGV4LnByb3RvdHlwZS5tYWtlUG9zdCA9IGZ1bmN0aW9uIChpbmRleFZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHZhciBwcmlvcml0eU5vZGUgPSBub2RlRnJvbUpTT04oaW5kZXhWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZV8xLk5hbWVkTm9kZShuYW1lLCBuZXcgTGVhZk5vZGVfMS5MZWFmTm9kZSgnW1BSSU9SSVRZLVBPU1RdJywgcHJpb3JpdHlOb2RlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcbiAgICAgKi9cbiAgICBQcmlvcml0eUluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcucHJpb3JpdHknO1xuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5SW5kZXg7XG59KEluZGV4XzEuSW5kZXgpKTtcbmV4cG9ydHMuUHJpb3JpdHlJbmRleCA9IFByaW9yaXR5SW5kZXg7XG5leHBvcnRzLlBSSU9SSVRZX0lOREVYID0gbmV3IFByaW9yaXR5SW5kZXgoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpb3JpdHlJbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xudmFyIFNvcnRlZE1hcF8xID0gcmVxdWlyZShcIi4uL3V0aWwvU29ydGVkTWFwXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuL05vZGVcIik7XG52YXIgc25hcF8xID0gcmVxdWlyZShcIi4vc25hcFwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgS2V5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4ZXMvS2V5SW5kZXhcIik7XG52YXIgSW5kZXhNYXBfMSA9IHJlcXVpcmUoXCIuL0luZGV4TWFwXCIpO1xudmFyIExlYWZOb2RlXzEgPSByZXF1aXJlKFwiLi9MZWFmTm9kZVwiKTtcbnZhciBjb21wYXJhdG9yc18xID0gcmVxdWlyZShcIi4vY29tcGFyYXRvcnNcIik7XG4vLyBUT0RPOiBGb3IgbWVtb3J5IHNhdmluZ3MsIGRvbid0IHN0b3JlIHByaW9yaXR5Tm9kZV8gaWYgaXQncyBlbXB0eS5cbnZhciBFTVBUWV9OT0RFO1xuLyoqXG4gKiBDaGlsZHJlbk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBpbnRlcm5hbCBub2RlcyBpbiBhIERhdGFTbmFwc2hvdFxuICogKGkuZS4gbm9kZXMgd2l0aCBjaGlsZHJlbikuICBJdCBpbXBsZW1lbnRzIE5vZGUgYW5kIHN0b3JlcyB0aGVcbiAqIGxpc3Qgb2YgY2hpbGRyZW4gaW4gdGhlIGNoaWxkcmVuIHByb3BlcnR5LCBzb3J0ZWQgYnkgY2hpbGQgbmFtZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlfVxuICovXG52YXIgQ2hpbGRyZW5Ob2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshU29ydGVkTWFwLjxzdHJpbmcsICFOb2RlPn0gY2hpbGRyZW5fIExpc3Qgb2YgY2hpbGRyZW5cbiAgICAgKiBvZiB0aGlzIG5vZGUuLlxuICAgICAqIEBwYXJhbSB7P05vZGV9IHByaW9yaXR5Tm9kZV8gVGhlIHByaW9yaXR5IG9mIHRoaXMgbm9kZSAoYXMgYSBzbmFwc2hvdCBub2RlKS5cbiAgICAgKiBAcGFyYW0geyFJbmRleE1hcH0gaW5kZXhNYXBfXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ2hpbGRyZW5Ob2RlKGNoaWxkcmVuXywgcHJpb3JpdHlOb2RlXywgaW5kZXhNYXBfKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5fID0gY2hpbGRyZW5fO1xuICAgICAgICB0aGlzLnByaW9yaXR5Tm9kZV8gPSBwcmlvcml0eU5vZGVfO1xuICAgICAgICB0aGlzLmluZGV4TWFwXyA9IGluZGV4TWFwXztcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTm90ZTogVGhlIG9ubHkgcmVhc29uIHdlIGFsbG93IG51bGwgcHJpb3JpdHkgaXMgZm9yIEVNUFRZX05PREUsIHNpbmNlIHdlIGNhbid0IHVzZVxuICAgICAgICAgKiBFTVBUWV9OT0RFIGFzIHRoZSBwcmlvcml0eSBvZiBFTVBUWV9OT0RFLiAgV2UgbWlnaHQgd2FudCB0byBjb25zaWRlciBtYWtpbmcgRU1QVFlfTk9ERSBpdHMgb3duXG4gICAgICAgICAqIGNsYXNzIGluc3RlYWQgb2YgYW4gZW1wdHkgQ2hpbGRyZW5Ob2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMucHJpb3JpdHlOb2RlXykge1xuICAgICAgICAgICAgc25hcF8xLnZhbGlkYXRlUHJpb3JpdHlOb2RlKHRoaXMucHJpb3JpdHlOb2RlXyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydCghdGhpcy5wcmlvcml0eU5vZGVfIHx8IHRoaXMucHJpb3JpdHlOb2RlXy5pc0VtcHR5KCksICdBbiBlbXB0eSBub2RlIGNhbm5vdCBoYXZlIGEgcHJpb3JpdHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2hpbGRyZW5Ob2RlLCBcIkVNUFRZX05PREVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoRU1QVFlfTk9ERSB8fFxuICAgICAgICAgICAgICAgIChFTVBUWV9OT0RFID0gbmV3IENoaWxkcmVuTm9kZShuZXcgU29ydGVkTWFwXzEuU29ydGVkTWFwKGNvbXBhcmF0b3JzXzEuTkFNRV9DT01QQVJBVE9SKSwgbnVsbCwgSW5kZXhNYXBfMS5JbmRleE1hcC5EZWZhdWx0KSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmlzTGVhZk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW9yaXR5Tm9kZV8gfHwgRU1QVFlfTk9ERTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUudXBkYXRlUHJpb3JpdHkgPSBmdW5jdGlvbiAobmV3UHJpb3JpdHlOb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IHByaW9yaXRpZXMgb24gZW1wdHkgbm9kZXNcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGUodGhpcy5jaGlsZHJlbl8sIG5ld1ByaW9yaXR5Tm9kZSwgdGhpcy5pbmRleE1hcF8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldEltbWVkaWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpb3JpdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkID09PSBudWxsID8gRU1QVFlfTk9ERSA6IGNoaWxkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIGZyb250ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW1tZWRpYXRlQ2hpbGQoZnJvbnQpLmdldENoaWxkKHBhdGgucG9wRnJvbnQoKSk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkTmFtZSkgIT09IG51bGw7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnVwZGF0ZUltbWVkaWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQobmV3Q2hpbGROb2RlLCAnV2Ugc2hvdWxkIGFsd2F5cyBiZSBwYXNzaW5nIHNuYXBzaG90IG5vZGVzJyk7XG4gICAgICAgIGlmIChjaGlsZE5hbWUgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQcmlvcml0eShuZXdDaGlsZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5hbWVkTm9kZSA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkTmFtZSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMCwgbmV3SW5kZXhNYXAgPSB2b2lkIDAsIG5ld1ByaW9yaXR5ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLnJlbW92ZShjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgIG5ld0luZGV4TWFwID0gdGhpcy5pbmRleE1hcF8ucmVtb3ZlRnJvbUluZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5fLmluc2VydChjaGlsZE5hbWUsIG5ld0NoaWxkTm9kZSk7XG4gICAgICAgICAgICAgICAgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRUb0luZGV4ZXMobmFtZWROb2RlLCB0aGlzLmNoaWxkcmVuXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdQcmlvcml0eSA9IG5ld0NoaWxkcmVuLmlzRW1wdHkoKSA/IEVNUFRZX05PREUgOiB0aGlzLnByaW9yaXR5Tm9kZV87XG4gICAgICAgICAgICByZXR1cm4gbmV3IENoaWxkcmVuTm9kZShuZXdDaGlsZHJlbiwgbmV3UHJpb3JpdHksIG5ld0luZGV4TWFwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgdmFyIGZyb250ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHBhdGguZ2V0RnJvbnQoKSAhPT0gJy5wcmlvcml0eScgfHwgcGF0aC5nZXRMZW5ndGgoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xuICAgICAgICAgICAgdmFyIG5ld0ltbWVkaWF0ZUNoaWxkID0gdGhpcy5nZXRJbW1lZGlhdGVDaGlsZChmcm9udCkudXBkYXRlQ2hpbGQocGF0aC5wb3BGcm9udCgpLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIG5ld0ltbWVkaWF0ZUNoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8uaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5udW1DaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmNvdW50KCk7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChleHBvcnRGb3JtYXQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgdmFyIG51bUtleXMgPSAwLCBtYXhLZXkgPSAwLCBhbGxJbnRlZ2VyS2V5cyA9IHRydWU7XG4gICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IGNoaWxkTm9kZS52YWwoZXhwb3J0Rm9ybWF0KTtcbiAgICAgICAgICAgIG51bUtleXMrKztcbiAgICAgICAgICAgIGlmIChhbGxJbnRlZ2VyS2V5cyAmJiBDaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIG1heEtleSA9IE1hdGgubWF4KG1heEtleSwgTnVtYmVyKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxsSW50ZWdlcktleXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZXhwb3J0Rm9ybWF0ICYmIGFsbEludGVnZXJLZXlzICYmIG1heEtleSA8IDIgKiBudW1LZXlzKSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRvIGFycmF5LlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKVxuICAgICAgICAgICAgICAgIGFycmF5W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBvYmpbJy5wcmlvcml0eSddID0gdGhpcy5nZXRQcmlvcml0eSgpLnZhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0b0hhc2hfMSA9ICcnO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgIHRvSGFzaF8xICs9XG4gICAgICAgICAgICAgICAgICAgICdwcmlvcml0eTonICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBfMS5wcmlvcml0eUhhc2hUZXh0KHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzonO1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoa2V5LCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRIYXNoID0gY2hpbGROb2RlLmhhc2goKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRIYXNoICE9PSAnJylcbiAgICAgICAgICAgICAgICAgICAgdG9IYXNoXzEgKz0gJzonICsga2V5ICsgJzonICsgY2hpbGRIYXNoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxhenlIYXNoXyA9IHRvSGFzaF8xID09PSAnJyA/ICcnIDogdXRpbF8yLnNoYTEodG9IYXNoXzEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICB2YXIgcHJlZGVjZXNzb3IgPSBpZHguZ2V0UHJlZGVjZXNzb3JLZXkobmV3IE5vZGVfMS5OYW1lZE5vZGUoY2hpbGROYW1lLCBjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgIHJldHVybiBwcmVkZWNlc3NvciA/IHByZWRlY2Vzc29yLm5hbWUgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmdldFByZWRlY2Vzc29yS2V5KGNoaWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0Rmlyc3RDaGlsZE5hbWUgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgdmFyIG1pbktleSA9IGlkeC5taW5LZXkoKTtcbiAgICAgICAgICAgIHJldHVybiBtaW5LZXkgJiYgbWluS2V5Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbl8ubWluS2V5KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/TmFtZWROb2RlfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0Rmlyc3RDaGlsZCA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIG1pbktleSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZE5hbWUoaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKG1pbktleSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKG1pbktleSwgdGhpcy5jaGlsZHJlbl8uZ2V0KG1pbktleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGluZGV4LCByZXR1cm4gdGhlIGtleSBuYW1lIG9mIHRoZSBsYXJnZXN0IHZhbHVlIHdlIGhhdmUsIGFjY29yZGluZyB0byB0aGF0IGluZGV4XG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRMYXN0Q2hpbGROYW1lID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZXNvbHZlSW5kZXhfKGluZGV4RGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChpZHgpIHtcbiAgICAgICAgICAgIHZhciBtYXhLZXkgPSBpZHgubWF4S2V5KCk7XG4gICAgICAgICAgICByZXR1cm4gbWF4S2V5ICYmIG1heEtleS5uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLm1heEtleSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHJldHVybiB7P05hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldExhc3RDaGlsZCA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIG1heEtleSA9IHRoaXMuZ2V0TGFzdENoaWxkTmFtZShpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAobWF4S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUobWF4S2V5LCB0aGlzLmNoaWxkcmVuXy5nZXQobWF4S2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgYWN0aW9uKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXgpO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4Lmlub3JkZXJUcmF2ZXJzYWwoZnVuY3Rpb24gKHdyYXBwZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbih3cmFwcGVkTm9kZS5uYW1lLCB3cmFwcGVkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5fLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4ge1NvcnRlZE1hcEl0ZXJhdG9yfVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWluUG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IHN0YXJ0UG9zdFxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwSXRlcmF0b3J9XG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5nZXRJdGVyYXRvckZyb20gPSBmdW5jdGlvbiAoc3RhcnRQb3N0LCBpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVzb2x2ZUluZGV4XyhpbmRleERlZmluaXRpb24pO1xuICAgICAgICBpZiAoaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWR4LmdldEl0ZXJhdG9yRnJvbShzdGFydFBvc3QsIGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGtleTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRJdGVyYXRvckZyb20oc3RhcnRQb3N0Lm5hbWUsIE5vZGVfMS5OYW1lZE5vZGUuV3JhcCk7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9IG51bGwgJiYgaW5kZXhEZWZpbml0aW9uLmNvbXBhcmUobmV4dCwgc3RhcnRQb3N0KSA8IDApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4geyFTb3J0ZWRNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldFJldmVyc2VJdGVyYXRvciA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmV2ZXJzZUl0ZXJhdG9yRnJvbShpbmRleERlZmluaXRpb24ubWF4UG9zdCgpLCBpbmRleERlZmluaXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBlbmRQb3N0XG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4geyFTb3J0ZWRNYXBJdGVyYXRvcn1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmdldFJldmVyc2VJdGVyYXRvckZyb20gPSBmdW5jdGlvbiAoZW5kUG9zdCwgaW5kZXhEZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlc29sdmVJbmRleF8oaW5kZXhEZWZpbml0aW9uKTtcbiAgICAgICAgaWYgKGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkeC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB0aGlzLmNoaWxkcmVuXy5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKGVuZFBvc3QubmFtZSwgTm9kZV8xLk5hbWVkTm9kZS5XcmFwKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IucGVlaygpO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgIT0gbnVsbCAmJiBpbmRleERlZmluaXRpb24uY29tcGFyZShuZXh0LCBlbmRQb3N0KSA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLnBlZWsoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkgfHwgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciA9PT0gZXhwb3J0cy5NQVhfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhbm90aGVyIG5vZGUgd2l0aCBjaGlsZHJlbi5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUud2l0aEluZGV4ID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICBpZiAoaW5kZXhEZWZpbml0aW9uID09PSBLZXlJbmRleF8xLktFWV9JTkRFWCB8fFxuICAgICAgICAgICAgdGhpcy5pbmRleE1hcF8uaGFzSW5kZXgoaW5kZXhEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXhNYXAgPSB0aGlzLmluZGV4TWFwXy5hZGRJbmRleChpbmRleERlZmluaXRpb24sIHRoaXMuY2hpbGRyZW5fKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlKHRoaXMuY2hpbGRyZW5fLCB0aGlzLnByaW9yaXR5Tm9kZV8sIG5ld0luZGV4TWFwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUucHJvdG90eXBlLmlzSW5kZXhlZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IEtleUluZGV4XzEuS0VZX0lOREVYIHx8IHRoaXMuaW5kZXhNYXBfLmhhc0luZGV4KGluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRyZW5Ob2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvdGhlckNoaWxkcmVuTm9kZSA9IG90aGVyO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmdldFByaW9yaXR5KCkuZXF1YWxzKG90aGVyQ2hpbGRyZW5Ob2RlLmdldFByaW9yaXR5KCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jaGlsZHJlbl8uY291bnQoKSA9PT0gb3RoZXJDaGlsZHJlbk5vZGUuY2hpbGRyZW5fLmNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0l0ZXIgPSB0aGlzLmdldEl0ZXJhdG9yKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVySXRlciA9IG90aGVyQ2hpbGRyZW5Ob2RlLmdldEl0ZXJhdG9yKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCk7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNDdXJyZW50ID0gdGhpc0l0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIHZhciBvdGhlckN1cnJlbnQgPSBvdGhlckl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzQ3VycmVudCAmJiBvdGhlckN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNDdXJyZW50Lm5hbWUgIT09IG90aGVyQ3VycmVudC5uYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpc0N1cnJlbnQubm9kZS5lcXVhbHMob3RoZXJDdXJyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc0N1cnJlbnQgPSB0aGlzSXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIG90aGVyQ3VycmVudCA9IG90aGVySXRlci5nZXROZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQ3VycmVudCA9PT0gbnVsbCAmJiBvdGhlckN1cnJlbnQgPT09IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTb3J0ZWRNYXAgb3JkZXJlZCBieSBpbmRleCwgb3IgbnVsbCBpZiB0aGUgZGVmYXVsdCAoYnkta2V5KSBvcmRlcmluZyBjYW4gYmUgdXNlZFxuICAgICAqIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleERlZmluaXRpb25cbiAgICAgKiBAcmV0dXJuIHs/U29ydGVkTWFwLjxOYW1lZE5vZGUsIE5vZGU+fVxuICAgICAqL1xuICAgIENoaWxkcmVuTm9kZS5wcm90b3R5cGUucmVzb2x2ZUluZGV4XyA9IGZ1bmN0aW9uIChpbmRleERlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGluZGV4RGVmaW5pdGlvbiA9PT0gS2V5SW5kZXhfMS5LRVlfSU5ERVgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhNYXBfLmdldChpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgKi9cbiAgICBDaGlsZHJlbk5vZGUuSU5URUdFUl9SRUdFWFBfID0gL14oMHxbMS05XVxcZCopJC87XG4gICAgcmV0dXJuIENoaWxkcmVuTm9kZTtcbn0oKSk7XG5leHBvcnRzLkNoaWxkcmVuTm9kZSA9IENoaWxkcmVuTm9kZTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7Q2hpbGRyZW5Ob2RlfVxuICogQHByaXZhdGVcbiAqL1xudmFyIE1heE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1heE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBTb3J0ZWRNYXBfMS5Tb3J0ZWRNYXAoY29tcGFyYXRvcnNfMS5OQU1FX0NPTVBBUkFUT1IpLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgSW5kZXhNYXBfMS5JbmRleE1hcC5EZWZhdWx0KSB8fCB0aGlzO1xuICAgIH1cbiAgICBNYXhOb2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXhOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgLy8gTm90IHRoYXQgd2UgZXZlcnkgY29tcGFyZSBpdCwgYnV0IE1BWF9OT0RFIGlzIG9ubHkgZXZlciBlcXVhbCB0byBpdHNlbGZcbiAgICAgICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xuICAgIH07XG4gICAgTWF4Tm9kZS5wcm90b3R5cGUuZ2V0UHJpb3JpdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTWF4Tm9kZS5wcm90b3R5cGUuZ2V0SW1tZWRpYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lKSB7XG4gICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICB9O1xuICAgIE1heE5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBNYXhOb2RlO1xufShDaGlsZHJlbk5vZGUpKTtcbmV4cG9ydHMuTWF4Tm9kZSA9IE1heE5vZGU7XG4vKipcbiAqIE1hcmtlciB0aGF0IHdpbGwgc29ydCBoaWdoZXIgdGhhbiBhbnkgb3RoZXIgc25hcHNob3QuXG4gKiBAdHlwZSB7IU1BWF9OT0RFfVxuICogQGNvbnN0XG4gKi9cbmV4cG9ydHMuTUFYX05PREUgPSBuZXcgTWF4Tm9kZSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTm9kZV8xLk5hbWVkTm9kZSwge1xuICAgIE1JTjoge1xuICAgICAgICB2YWx1ZTogbmV3IE5vZGVfMS5OYW1lZE5vZGUodXRpbF8yLk1JTl9OQU1FLCBDaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSlcbiAgICB9LFxuICAgIE1BWDoge1xuICAgICAgICB2YWx1ZTogbmV3IE5vZGVfMS5OYW1lZE5vZGUodXRpbF8yLk1BWF9OQU1FLCBleHBvcnRzLk1BWF9OT0RFKVxuICAgIH1cbn0pO1xuLyoqXG4gKiBSZWZlcmVuY2UgRXh0ZW5zaW9uc1xuICovXG5LZXlJbmRleF8xLktleUluZGV4Ll9fRU1QVFlfTk9ERSA9IENoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuTGVhZk5vZGVfMS5MZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yID0gQ2hpbGRyZW5Ob2RlO1xuc25hcF8xLnNldE1heE5vZGUoZXhwb3J0cy5NQVhfTk9ERSk7XG5Qcmlvcml0eUluZGV4XzEuc2V0TWF4Tm9kZShleHBvcnRzLk1BWF9OT0RFKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hpbGRyZW5Ob2RlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvQ2hpbGRyZW5Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIE5hbWVkTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOYW1lZE5vZGUobmFtZSwgbm9kZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcmV0dXJuIHtOYW1lZE5vZGV9XG4gICAgICovXG4gICAgTmFtZWROb2RlLldyYXAgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IE5hbWVkTm9kZShuYW1lLCBub2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBOYW1lZE5vZGU7XG59KCkpO1xuZXhwb3J0cy5OYW1lZE5vZGUgPSBOYW1lZE5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vZGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9Ob2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQHJldHVybiBGYWxzZSBpZiB0aGUgb2JqZWN0IGlzIHVuZGVmaW5lZCBvciBudWxsLCB0cnVlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGVmKHApIHtcbiAgICByZXR1cm4gcCAhPSBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzSnVzdERlZihwKSB7XG4gICAgcmV0dXJuIHAgIT09IHZvaWQgMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gdHlwZW9mIHAgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOb25OdWxsT2JqZWN0KHApIHtcbiAgICByZXR1cm4gaXNPYmplY3QocCkgJiYgcCAhPT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05vbkFycmF5T2JqZWN0KHApIHtcbiAgICByZXR1cm4gaXNPYmplY3QocCkgJiYgIUFycmF5LmlzQXJyYXkocCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcocCkge1xuICAgIHJldHVybiB0eXBlb2YgcCA9PT0gJ3N0cmluZycgfHwgcCBpbnN0YW5jZW9mIFN0cmluZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwID09PSAnbnVtYmVyJyB8fCBwIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTmF0aXZlQmxvYihwKSB7XG4gICAgcmV0dXJuIGlzTmF0aXZlQmxvYkRlZmluZWQoKSAmJiBwIGluc3RhbmNlb2YgQmxvYjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05hdGl2ZUJsb2JEZWZpbmVkKCkge1xuICAgIHJldHVybiB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vdHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBjb25maWdPcHRpb24gfSBmcm9tICcuL2NvbnN0YW50cyc7XG52YXIgRmlyZWJhc2VTdG9yYWdlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyZWJhc2VTdG9yYWdlRXJyb3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmNvZGVfID0gcHJlcGVuZENvZGUoY29kZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZV8gPSAnRmlyZWJhc2UgU3RvcmFnZTogJyArIG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc2VydmVyUmVzcG9uc2VfID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lXyA9ICdGaXJlYmFzZUVycm9yJztcbiAgICB9XG4gICAgRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLmNvZGVQcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlO1xuICAgIH07XG4gICAgRmlyZWJhc2VTdG9yYWdlRXJyb3IucHJvdG90eXBlLmNvZGVFcXVhbHMgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gcHJlcGVuZENvZGUoY29kZSkgPT09IHRoaXMuY29kZVByb3AoKTtcbiAgICB9O1xuICAgIEZpcmViYXNlU3RvcmFnZUVycm9yLnByb3RvdHlwZS5zZXJ2ZXJSZXNwb25zZVByb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlclJlc3BvbnNlXztcbiAgICB9O1xuICAgIEZpcmViYXNlU3RvcmFnZUVycm9yLnByb3RvdHlwZS5zZXRTZXJ2ZXJSZXNwb25zZVByb3AgPSBmdW5jdGlvbiAoc2VydmVyUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJSZXNwb25zZV8gPSBzZXJ2ZXJSZXNwb25zZTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUsIFwiY29kZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29kZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlYmFzZVN0b3JhZ2VFcnJvci5wcm90b3R5cGUsIFwic2VydmVyUmVzcG9uc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZlclJlc3BvbnNlXztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIEZpcmViYXNlU3RvcmFnZUVycm9yO1xufSgpKTtcbmV4cG9ydCB7IEZpcmViYXNlU3RvcmFnZUVycm9yIH07XG5leHBvcnQgdmFyIGVycm9ycyA9IHt9O1xuZXhwb3J0IHZhciBDb2RlID0ge1xuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIGFsbCBwbGF0Zm9ybXNcbiAgICBVTktOT1dOOiAndW5rbm93bicsXG4gICAgT0JKRUNUX05PVF9GT1VORDogJ29iamVjdC1ub3QtZm91bmQnLFxuICAgIEJVQ0tFVF9OT1RfRk9VTkQ6ICdidWNrZXQtbm90LWZvdW5kJyxcbiAgICBQUk9KRUNUX05PVF9GT1VORDogJ3Byb2plY3Qtbm90LWZvdW5kJyxcbiAgICBRVU9UQV9FWENFRURFRDogJ3F1b3RhLWV4Y2VlZGVkJyxcbiAgICBVTkFVVEhFTlRJQ0FURUQ6ICd1bmF1dGhlbnRpY2F0ZWQnLFxuICAgIFVOQVVUSE9SSVpFRDogJ3VuYXV0aG9yaXplZCcsXG4gICAgUkVUUllfTElNSVRfRVhDRUVERUQ6ICdyZXRyeS1saW1pdC1leGNlZWRlZCcsXG4gICAgSU5WQUxJRF9DSEVDS1NVTTogJ2ludmFsaWQtY2hlY2tzdW0nLFxuICAgIENBTkNFTEVEOiAnY2FuY2VsZWQnLFxuICAgIC8vIEpTIHNwZWNpZmljXG4gICAgSU5WQUxJRF9FVkVOVF9OQU1FOiAnaW52YWxpZC1ldmVudC1uYW1lJyxcbiAgICBJTlZBTElEX1VSTDogJ2ludmFsaWQtdXJsJyxcbiAgICBJTlZBTElEX0RFRkFVTFRfQlVDS0VUOiAnaW52YWxpZC1kZWZhdWx0LWJ1Y2tldCcsXG4gICAgTk9fREVGQVVMVF9CVUNLRVQ6ICduby1kZWZhdWx0LWJ1Y2tldCcsXG4gICAgQ0FOTk9UX1NMSUNFX0JMT0I6ICdjYW5ub3Qtc2xpY2UtYmxvYicsXG4gICAgU0VSVkVSX0ZJTEVfV1JPTkdfU0laRTogJ3NlcnZlci1maWxlLXdyb25nLXNpemUnLFxuICAgIE5PX0RPV05MT0FEX1VSTDogJ25vLWRvd25sb2FkLXVybCcsXG4gICAgSU5WQUxJRF9BUkdVTUVOVDogJ2ludmFsaWQtYXJndW1lbnQnLFxuICAgIElOVkFMSURfQVJHVU1FTlRfQ09VTlQ6ICdpbnZhbGlkLWFyZ3VtZW50LWNvdW50JyxcbiAgICBBUFBfREVMRVRFRDogJ2FwcC1kZWxldGVkJyxcbiAgICBJTlZBTElEX1JPT1RfT1BFUkFUSU9OOiAnaW52YWxpZC1yb290LW9wZXJhdGlvbicsXG4gICAgSU5WQUxJRF9GT1JNQVQ6ICdpbnZhbGlkLWZvcm1hdCcsXG4gICAgSU5URVJOQUxfRVJST1I6ICdpbnRlcm5hbC1lcnJvcidcbn07XG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZENvZGUoY29kZSkge1xuICAgIHJldHVybiAnc3RvcmFnZS8nICsgY29kZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgIHZhciBtZXNzYWdlID0gJ0FuIHVua25vd24gZXJyb3Igb2NjdXJyZWQsIHBsZWFzZSBjaGVjayB0aGUgZXJyb3IgcGF5bG9hZCBmb3IgJyArXG4gICAgICAgICdzZXJ2ZXIgcmVzcG9uc2UuJztcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuVU5LTk9XTiwgbWVzc2FnZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0Tm90Rm91bmQocGF0aCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoQ29kZS5PQkpFQ1RfTk9UX0ZPVU5ELCBcIk9iamVjdCAnXCIgKyBwYXRoICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWNrZXROb3RGb3VuZChidWNrZXQpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuQlVDS0VUX05PVF9GT1VORCwgXCJCdWNrZXQgJ1wiICsgYnVja2V0ICsgXCInIGRvZXMgbm90IGV4aXN0LlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9qZWN0Tm90Rm91bmQocHJvamVjdCkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoQ29kZS5QUk9KRUNUX05PVF9GT1VORCwgXCJQcm9qZWN0ICdcIiArIHByb2plY3QgKyBcIicgZG9lcyBub3QgZXhpc3QuXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHF1b3RhRXhjZWVkZWQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLlFVT1RBX0VYQ0VFREVELCBcIlF1b3RhIGZvciBidWNrZXQgJ1wiICtcbiAgICAgICAgYnVja2V0ICtcbiAgICAgICAgXCInIGV4Y2VlZGVkLCBwbGVhc2UgdmlldyBxdW90YSBvbiBcIiArXG4gICAgICAgICdodHRwczovL2ZpcmViYXNlLmdvb2dsZS5jb20vcHJpY2luZy8uJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5hdXRoZW50aWNhdGVkKCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1VzZXIgaXMgbm90IGF1dGhlbnRpY2F0ZWQsIHBsZWFzZSBhdXRoZW50aWNhdGUgdXNpbmcgRmlyZWJhc2UgJyArXG4gICAgICAgICdBdXRoZW50aWNhdGlvbiBhbmQgdHJ5IGFnYWluLic7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLlVOQVVUSEVOVElDQVRFRCwgbWVzc2FnZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW5hdXRob3JpemVkKHBhdGgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuVU5BVVRIT1JJWkVELCBcIlVzZXIgZG9lcyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyAnXCIgKyBwYXRoICsgXCInLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXRyeUxpbWl0RXhjZWVkZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLlJFVFJZX0xJTUlUX0VYQ0VFREVELCAnTWF4IHJldHJ5IHRpbWUgZm9yIG9wZXJhdGlvbiBleGNlZWRlZCwgcGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkQ2hlY2tzdW0ocGF0aCwgY2hlY2tzdW0sIGNhbGN1bGF0ZWQpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuSU5WQUxJRF9DSEVDS1NVTSwgXCJVcGxvYWRlZC9kb3dubG9hZGVkIG9iamVjdCAnXCIgK1xuICAgICAgICBwYXRoICtcbiAgICAgICAgXCInIGhhcyBjaGVja3N1bSAnXCIgK1xuICAgICAgICBjaGVja3N1bSArXG4gICAgICAgIFwiJyB3aGljaCBkb2VzIG5vdCBtYXRjaCAnXCIgK1xuICAgICAgICBjYWxjdWxhdGVkICtcbiAgICAgICAgXCInLiBQbGVhc2UgcmV0cnkgdGhlIHVwbG9hZC9kb3dubG9hZC5cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsZWQoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLkNBTkNFTEVELCAnVXNlciBjYW5jZWxlZCB0aGUgdXBsb2FkL2Rvd25sb2FkLicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRFdmVudE5hbWUobmFtZSkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoQ29kZS5JTlZBTElEX0VWRU5UX05BTUUsIFwiSW52YWxpZCBldmVudCBuYW1lICdcIiArIG5hbWUgKyBcIicuXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRVcmwodXJsKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLklOVkFMSURfVVJMLCBcIkludmFsaWQgVVJMICdcIiArIHVybCArIFwiJy5cIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0KSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLklOVkFMSURfREVGQVVMVF9CVUNLRVQsIFwiSW52YWxpZCBkZWZhdWx0IGJ1Y2tldCAnXCIgKyBidWNrZXQgKyBcIicuXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vRGVmYXVsdEJ1Y2tldCgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuTk9fREVGQVVMVF9CVUNLRVQsICdObyBkZWZhdWx0IGJ1Y2tldCAnICtcbiAgICAgICAgXCJmb3VuZC4gRGlkIHlvdSBzZXQgdGhlICdcIiArXG4gICAgICAgIGNvbmZpZ09wdGlvbiArXG4gICAgICAgIFwiJyBwcm9wZXJ0eSB3aGVuIGluaXRpYWxpemluZyB0aGUgYXBwP1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYW5ub3RTbGljZUJsb2IoKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLkNBTk5PVF9TTElDRV9CTE9CLCAnQ2Fubm90IHNsaWNlIGJsb2IgZm9yIHVwbG9hZC4gUGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2VydmVyRmlsZVdyb25nU2l6ZSgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuU0VSVkVSX0ZJTEVfV1JPTkdfU0laRSwgJ1NlcnZlciByZWNvcmRlZCBpbmNvcnJlY3QgdXBsb2FkIGZpbGUgc2l6ZSwgcGxlYXNlIHJldHJ5IHRoZSB1cGxvYWQuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9Eb3dubG9hZFVSTCgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuTk9fRE9XTkxPQURfVVJMLCAnVGhlIGdpdmVuIGZpbGUgZG9lcyBub3QgaGF2ZSBhbnkgZG93bmxvYWQgVVJMcy4nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkQXJndW1lbnQoaW5kZXgsIGZuTmFtZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoQ29kZS5JTlZBTElEX0FSR1VNRU5ULCAnSW52YWxpZCBhcmd1bWVudCBpbiBgJyArIGZuTmFtZSArICdgIGF0IGluZGV4ICcgKyBpbmRleCArICc6ICcgKyBtZXNzYWdlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkQXJndW1lbnRDb3VudChhcmdNaW4sIGFyZ01heCwgZm5OYW1lLCByZWFsKSB7XG4gICAgdmFyIGNvdW50UGFydDtcbiAgICB2YXIgcGx1cmFsO1xuICAgIGlmIChhcmdNaW4gPT09IGFyZ01heCkge1xuICAgICAgICBjb3VudFBhcnQgPSBhcmdNaW47XG4gICAgICAgIHBsdXJhbCA9IGFyZ01pbiA9PT0gMSA/ICdhcmd1bWVudCcgOiAnYXJndW1lbnRzJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvdW50UGFydCA9ICdiZXR3ZWVuICcgKyBhcmdNaW4gKyAnIGFuZCAnICsgYXJnTWF4O1xuICAgICAgICBwbHVyYWwgPSAnYXJndW1lbnRzJztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLklOVkFMSURfQVJHVU1FTlRfQ09VTlQsICdJbnZhbGlkIGFyZ3VtZW50IGNvdW50IGluIGAnICtcbiAgICAgICAgZm5OYW1lICtcbiAgICAgICAgJ2A6IEV4cGVjdGVkICcgK1xuICAgICAgICBjb3VudFBhcnQgK1xuICAgICAgICAnICcgK1xuICAgICAgICBwbHVyYWwgK1xuICAgICAgICAnLCByZWNlaXZlZCAnICtcbiAgICAgICAgcmVhbCArXG4gICAgICAgICcuJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXBwRGVsZXRlZCgpIHtcbiAgICByZXR1cm4gbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuQVBQX0RFTEVURUQsICdUaGUgRmlyZWJhc2UgYXBwIHdhcyBkZWxldGVkLicpO1xufVxuLyoqXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgb3BlcmF0aW9uIHRoYXQgd2FzIGludmFsaWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkUm9vdE9wZXJhdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBGaXJlYmFzZVN0b3JhZ2VFcnJvcihDb2RlLklOVkFMSURfUk9PVF9PUEVSQVRJT04sIFwiVGhlIG9wZXJhdGlvbiAnXCIgK1xuICAgICAgICBuYW1lICtcbiAgICAgICAgXCInIGNhbm5vdCBiZSBwZXJmb3JtZWQgb24gYSByb290IHJlZmVyZW5jZSwgY3JlYXRlIGEgbm9uLXJvb3QgXCIgK1xuICAgICAgICBcInJlZmVyZW5jZSB1c2luZyBjaGlsZCwgc3VjaCBhcyAuY2hpbGQoJ2ZpbGUucG5nJykuXCIpO1xufVxuLyoqXG4gKiBAcGFyYW0gZm9ybWF0IFRoZSBmb3JtYXQgdGhhdCB3YXMgbm90IHZhbGlkLlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGZvcm1hdCB2aW9sYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkRm9ybWF0KGZvcm1hdCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgRmlyZWJhc2VTdG9yYWdlRXJyb3IoQ29kZS5JTlZBTElEX0ZPUk1BVCwgXCJTdHJpbmcgZG9lcyBub3QgbWF0Y2ggZm9ybWF0ICdcIiArIGZvcm1hdCArIFwiJzogXCIgKyBtZXNzYWdlKTtcbn1cbi8qKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIGRlc2NyaWJpbmcgdGhlIGludGVybmFsIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgbmV3IEZpcmViYXNlU3RvcmFnZUVycm9yKENvZGUuSU5URVJOQUxfRVJST1IsICdJbnRlcm5hbCBlcnJvcjogJyArIG1lc3NhZ2UpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9lcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgeyBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSB9IGZyb20gJy4vc3JjL2ZpcmViYXNlQXBwJztcbmV4cG9ydCB2YXIgZmlyZWJhc2UgPSBjcmVhdGVGaXJlYmFzZU5hbWVzcGFjZSgpO1xuZXhwb3J0IGRlZmF1bHQgZmlyZWJhc2U7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYXBwL2Rpc3QvZXNtL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNCA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBrZXlzXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5JTlZBTElEX0tFWV9SRUdFWF8gPSAvW1xcW1xcXS4jJFxcL1xcdTAwMDAtXFx1MDAxRlxcdTAwN0ZdLztcbi8qKlxuICogVHJ1ZSBmb3IgaW52YWxpZCBGaXJlYmFzZSBwYXRocy5cbiAqIEFsbG93cyAnLycgaW4gcGF0aHMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5JTlZBTElEX1BBVEhfUkVHRVhfID0gL1tcXFtcXF0uIyRcXHUwMDAwLVxcdTAwMUZcXHUwMDdGXS87XG4vKipcbiAqIE1heGltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gYWxsb3cgaW4gbGVhZiB2YWx1ZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuTUFYX0xFQUZfU0laRV8gPSAxMCAqIDEwMjQgKiAxMDI0O1xuLyoqXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5Lmxlbmd0aCAhPT0gMCAmJiAhZXhwb3J0cy5JTlZBTElEX0tFWV9SRUdFWF8udGVzdChrZXkpKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBwYXRoU3RyaW5nID09PSAnc3RyaW5nJyAmJlxuICAgICAgICBwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgICAhZXhwb3J0cy5JTlZBTElEX1BBVEhfUkVHRVhfLnRlc3QocGF0aFN0cmluZykpO1xufTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFJvb3RQYXRoU3RyaW5nID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICBpZiAocGF0aFN0cmluZykge1xuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmlzVmFsaWRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBwcmlvcml0eVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpb3JpdHkgPSBmdW5jdGlvbiAocHJpb3JpdHkpIHtcbiAgICByZXR1cm4gKHByaW9yaXR5ID09PSBudWxsIHx8XG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgJiYgIXV0aWxfMi5pc0ludmFsaWRKU09OTnVtYmVyKHByaW9yaXR5KSkgfHxcbiAgICAgICAgKHByaW9yaXR5ICYmIHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgdXRpbF8xLmNvbnRhaW5zKHByaW9yaXR5LCAnLnN2JykpKTtcbn07XG4vKipcbiAqIFByZS12YWxpZGF0ZSBhIGRhdHVtIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byBGaXJlYmFzZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBvcHRpb25hbFxuICovXG5leHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGRhdGEsIHBhdGgsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIGRhdGEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZURhdGEodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSwgZGF0YSwgcGF0aCk7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZSBhIGRhdGEgb2JqZWN0IGNsaWVudC1zaWRlIGJlZm9yZSBzZW5kaW5nIHRvIHNlcnZlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JQcmVmaXhcbiAqIEBwYXJhbSB7Kn0gZGF0YVxuICogQHBhcmFtIHshUGF0aHwhVmFsaWRhdGlvblBhdGh9IHBhdGhfXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZURhdGEgPSBmdW5jdGlvbiAoZXJyb3JQcmVmaXgsIGRhdGEsIHBhdGhfKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoXyBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoID8gbmV3IFBhdGhfMS5WYWxpZGF0aW9uUGF0aChwYXRoXywgZXJyb3JQcmVmaXgpIDogcGF0aF87XG4gICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgdW5kZWZpbmVkICcgKyBwYXRoLnRvRXJyb3JTdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgJ2NvbnRhaW5zIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICBwYXRoLnRvRXJyb3JTdHJpbmcoKSArXG4gICAgICAgICAgICAnIHdpdGggY29udGVudHMgPSAnICtcbiAgICAgICAgICAgIGRhdGEudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmICh1dGlsXzIuaXNJbnZhbGlkSlNPTk51bWJlcihkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggKyAnY29udGFpbnMgJyArIGRhdGEudG9TdHJpbmcoKSArICcgJyArIHBhdGgudG9FcnJvclN0cmluZygpKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgbWF4IGxlYWYgc2l6ZSwgYnV0IHRyeSB0byBhdm9pZCB0aGUgdXRmOCBjb252ZXJzaW9uIGlmIHdlIGNhbi5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRhdGEubGVuZ3RoID4gZXhwb3J0cy5NQVhfTEVBRl9TSVpFXyAvIDMgJiZcbiAgICAgICAgdXRpbF80LnN0cmluZ0xlbmd0aChkYXRhKSA+IGV4cG9ydHMuTUFYX0xFQUZfU0laRV8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICdjb250YWlucyBhIHN0cmluZyBncmVhdGVyIHRoYW4gJyArXG4gICAgICAgICAgICBleHBvcnRzLk1BWF9MRUFGX1NJWkVfICtcbiAgICAgICAgICAgICcgdXRmOCBieXRlcyAnICtcbiAgICAgICAgICAgIHBhdGgudG9FcnJvclN0cmluZygpICtcbiAgICAgICAgICAgIFwiICgnXCIgK1xuICAgICAgICAgICAgZGF0YS5zdWJzdHJpbmcoMCwgNTApICtcbiAgICAgICAgICAgIFwiLi4uJylcIik7XG4gICAgfVxuICAgIC8vIFRPRE8gPSBQZXJmID0gQ29uc2lkZXIgY29tYmluaW5nIHRoZSByZWN1cnNpdmUgdmFsaWRhdGlvbiBvZiBrZXlzIGludG8gTm9kZUZyb21KU09OXG4gICAgLy8gdG8gc2F2ZSBleHRyYSB3YWxraW5nIG9mIGxhcmdlIG9iamVjdHMuXG4gICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBoYXNEb3RWYWx1ZV8xID0gZmFsc2UsIGhhc0FjdHVhbENoaWxkXzEgPSBmYWxzZTtcbiAgICAgICAgdXRpbF8xLmZvckVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICcudmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgaGFzRG90VmFsdWVfMSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICcucHJpb3JpdHknICYmIGtleSAhPT0gJy5zdicpIHtcbiAgICAgICAgICAgICAgICBoYXNBY3R1YWxDaGlsZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cG9ydHMuaXNWYWxpZEtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIGFuIGludmFsaWQga2V5ICgnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgudG9FcnJvclN0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcuICBLZXlzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICBleHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGhhc0RvdFZhbHVlXzEgJiYgaGFzQWN0dWFsQ2hpbGRfMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICAgICAnIGNvbnRhaW5zIFwiLnZhbHVlXCIgY2hpbGQgJyArXG4gICAgICAgICAgICAgICAgcGF0aC50b0Vycm9yU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICcgaW4gYWRkaXRpb24gdG8gYWN0dWFsIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUHJlLXZhbGlkYXRlIHBhdGhzIHBhc3NlZCBpbiB0aGUgZmlyZWJhc2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yUHJlZml4XG4gKiBAcGFyYW0ge0FycmF5PCFQYXRoPn0gbWVyZ2VQYXRoc1xuICovXG5leHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VNZXJnZVBhdGhzID0gZnVuY3Rpb24gKGVycm9yUHJlZml4LCBtZXJnZVBhdGhzKSB7XG4gICAgdmFyIGksIGN1clBhdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IG1lcmdlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VyUGF0aCA9IG1lcmdlUGF0aHNbaV07XG4gICAgICAgIHZhciBrZXlzID0gY3VyUGF0aC5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChrZXlzW2pdID09PSAnLnByaW9yaXR5JyAmJiBqID09PSBrZXlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyAucHJpb3JpdHkgaXMgT0tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFleHBvcnRzLmlzVmFsaWRLZXkoa2V5c1tqXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgICAnY29udGFpbnMgYW4gaW52YWxpZCBrZXkgKCcgK1xuICAgICAgICAgICAgICAgICAgICBrZXlzW2pdICtcbiAgICAgICAgICAgICAgICAgICAgJykgaW4gcGF0aCAnICtcbiAgICAgICAgICAgICAgICAgICAgY3VyUGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgJy4gS2V5cyBtdXN0IGJlIG5vbi1lbXB0eSBzdHJpbmdzICcgK1xuICAgICAgICAgICAgICAgICAgICAnYW5kIGNhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIi9cIiwgXCJbXCIsIG9yIFwiXVwiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2hlY2sgdGhhdCB1cGRhdGUga2V5cyBhcmUgbm90IGRlc2NlbmRhbnRzIG9mIGVhY2ggb3RoZXIuXG4gICAgLy8gV2UgcmVseSBvbiB0aGUgcHJvcGVydHkgdGhhdCBzb3J0aW5nIGd1YXJhbnRlZXMgdGhhdCBhbmNlc3RvcnMgY29tZVxuICAgIC8vIHJpZ2h0IGJlZm9yZSBkZXNjZW5kYW50cy5cbiAgICBtZXJnZVBhdGhzLnNvcnQoUGF0aF8xLlBhdGguY29tcGFyZVBhdGhzKTtcbiAgICB2YXIgcHJldlBhdGggPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXJnZVBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1clBhdGggPSBtZXJnZVBhdGhzW2ldO1xuICAgICAgICBpZiAocHJldlBhdGggIT09IG51bGwgJiYgcHJldlBhdGguY29udGFpbnMoY3VyUGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW5zIGEgcGF0aCAnICtcbiAgICAgICAgICAgICAgICBwcmV2UGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAnIHRoYXQgaXMgYW5jZXN0b3Igb2YgYW5vdGhlciBwYXRoICcgK1xuICAgICAgICAgICAgICAgIGN1clBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldlBhdGggPSBjdXJQYXRoO1xuICAgIH1cbn07XG4vKipcbiAqIHByZS12YWxpZGF0ZSBhbiBvYmplY3QgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIGZpcmViYXNlIGZ1bmN0aW9uIChcbiAqIG11c3QgYmUgYW4gb2JqZWN0IC0gZS5nLiBmb3IgZmlyZWJhc2UudXBkYXRlKCkpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmd1bWVudE51bWJlclxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZU1lcmdlRGF0YUFyZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBkYXRhLCBwYXRoLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBkYXRhID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgZXJyb3JQcmVmaXggPSB1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpO1xuICAgIGlmICghKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB8fCBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclByZWZpeCArICcgbXVzdCBiZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2hpbGRyZW4gdG8gcmVwbGFjZS4nKTtcbiAgICB9XG4gICAgdmFyIG1lcmdlUGF0aHMgPSBbXTtcbiAgICB1dGlsXzEuZm9yRWFjaChkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY3VyUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChrZXkpO1xuICAgICAgICBleHBvcnRzLnZhbGlkYXRlRmlyZWJhc2VEYXRhKGVycm9yUHJlZml4LCB2YWx1ZSwgcGF0aC5jaGlsZChjdXJQYXRoKSk7XG4gICAgICAgIGlmIChjdXJQYXRoLmdldEJhY2soKSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkUHJpb3JpdHkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4ICtcbiAgICAgICAgICAgICAgICAgICAgXCJjb250YWlucyBhbiBpbnZhbGlkIHZhbHVlIGZvciAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBjdXJQYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICBcIicsIHdoaWNoIG11c3QgYmUgYSB2YWxpZCBcIiArXG4gICAgICAgICAgICAgICAgICAgICdGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsIHNlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VQYXRocy5wdXNoKGN1clBhdGgpO1xuICAgIH0pO1xuICAgIGV4cG9ydHMudmFsaWRhdGVGaXJlYmFzZU1lcmdlUGF0aHMoZXJyb3JQcmVmaXgsIG1lcmdlUGF0aHMpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBwcmlvcml0eSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgcHJpb3JpdHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh1dGlsXzIuaXNJbnZhbGlkSlNPTk51bWJlcihwcmlvcml0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdpcyAnICtcbiAgICAgICAgICAgIHByaW9yaXR5LnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgJywgYnV0IG11c3QgYmUgYSB2YWxpZCBGaXJlYmFzZSBwcmlvcml0eSAoYSBzdHJpbmcsIGZpbml0ZSBudW1iZXIsICcgK1xuICAgICAgICAgICAgJ3NlcnZlciB2YWx1ZSwgb3IgbnVsbCkuJyk7XG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIGFsbG93IGltcG9ydGluZyBkYXRhIHdpdGggYSAuc3YuXG4gICAgaWYgKCFleHBvcnRzLmlzVmFsaWRQcmlvcml0eShwcmlvcml0eSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgRmlyZWJhc2UgcHJpb3JpdHkgJyArXG4gICAgICAgICAgICAnKGEgc3RyaW5nLCBmaW5pdGUgbnVtYmVyLCBzZXJ2ZXIgdmFsdWUsIG9yIG51bGwpLicpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVFdmVudFR5cGUgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZXZlbnRUeXBlLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBldmVudFR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHN3aXRjaCAoZXZlbnRUeXBlKSB7XG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfYWRkZWQnOlxuICAgICAgICBjYXNlICdjaGlsZF9yZW1vdmVkJzpcbiAgICAgICAgY2FzZSAnY2hpbGRfY2hhbmdlZCc6XG4gICAgICAgIGNhc2UgJ2NoaWxkX21vdmVkJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZXZlbnQgdHlwZSA9IFwidmFsdWVcIiwgXCJjaGlsZF9hZGRlZFwiLCBcImNoaWxkX3JlbW92ZWRcIiwgJyArXG4gICAgICAgICAgICAgICAgJ1wiY2hpbGRfY2hhbmdlZFwiLCBvciBcImNoaWxkX21vdmVkXCIuJyk7XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVLZXkgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwga2V5LCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkS2V5KGtleSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICd3YXMgYW4gaW52YWxpZCBrZXkgPSBcIicgK1xuICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICdcIi4gIEZpcmViYXNlIGtleXMgbXVzdCBiZSBub24tZW1wdHkgc3RyaW5ncyBhbmQgJyArXG4gICAgICAgICAgICAnY2FuXFwndCBjb250YWluIFwiLlwiLCBcIiNcIiwgXCIkXCIsIFwiL1wiLCBcIltcIiwgb3IgXCJdXCIpLicpO1xufTtcbmV4cG9ydHMudmFsaWRhdGVQYXRoU3RyaW5nID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIHBhdGhTdHJpbmcgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghZXhwb3J0cy5pc1ZhbGlkUGF0aFN0cmluZyhwYXRoU3RyaW5nKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgJ3dhcyBhbiBpbnZhbGlkIHBhdGggPSBcIicgK1xuICAgICAgICAgICAgcGF0aFN0cmluZyArXG4gICAgICAgICAgICAnXCIuIFBhdGhzIG11c3QgYmUgbm9uLWVtcHR5IHN0cmluZ3MgYW5kICcgK1xuICAgICAgICAgICAgJ2NhblxcJ3QgY29udGFpbiBcIi5cIiwgXCIjXCIsIFwiJFwiLCBcIltcIiwgb3IgXCJdXCInKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlUm9vdFBhdGhTdHJpbmcgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGF0aFN0cmluZywgb3B0aW9uYWwpIHtcbiAgICBpZiAocGF0aFN0cmluZykge1xuICAgICAgICAvLyBBbGxvdyAnLy5pbmZvLycgYXQgdGhlIGJlZ2lubmluZy5cbiAgICAgICAgcGF0aFN0cmluZyA9IHBhdGhTdHJpbmcucmVwbGFjZSgvXlxcLypcXC5pbmZvKFxcL3wkKS8sICcvJyk7XG4gICAgfVxuICAgIGV4cG9ydHMudmFsaWRhdGVQYXRoU3RyaW5nKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIHBhdGhTdHJpbmcsIG9wdGlvbmFsKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlV3JpdGFibGVQYXRoID0gZnVuY3Rpb24gKGZuTmFtZSwgcGF0aCkge1xuICAgIGlmIChwYXRoLmdldEZyb250KCkgPT09ICcuaW5mbycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiIGZhaWxlZCA9IENhbid0IG1vZGlmeSBkYXRhIHVuZGVyIC8uaW5mby9cIik7XG4gICAgfVxufTtcbmV4cG9ydHMudmFsaWRhdGVVcmwgPSBmdW5jdGlvbiAoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgcGFyc2VkVXJsKSB7XG4gICAgLy8gVE9ETyA9IFZhbGlkYXRlIHNlcnZlciBiZXR0ZXIuXG4gICAgdmFyIHBhdGhTdHJpbmcgPSBwYXJzZWRVcmwucGF0aC50b1N0cmluZygpO1xuICAgIGlmICghKHR5cGVvZiBwYXJzZWRVcmwucmVwb0luZm8uaG9zdCA9PT0gJ3N0cmluZycpIHx8XG4gICAgICAgIHBhcnNlZFVybC5yZXBvSW5mby5ob3N0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAhZXhwb3J0cy5pc1ZhbGlkS2V5KHBhcnNlZFVybC5yZXBvSW5mby5uYW1lc3BhY2UpIHx8XG4gICAgICAgIChwYXRoU3RyaW5nLmxlbmd0aCAhPT0gMCAmJiAhZXhwb3J0cy5pc1ZhbGlkUm9vdFBhdGhTdHJpbmcocGF0aFN0cmluZykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgZmFsc2UpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZmlyZWJhc2UgVVJMIGFuZCAnICtcbiAgICAgICAgICAgICd0aGUgcGF0aCBjYW5cXCd0IGNvbnRhaW4gXCIuXCIsIFwiI1wiLCBcIiRcIiwgXCJbXCIsIG9yIFwiXVwiLicpO1xuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlQ3JlZGVudGlhbCA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBjcmVkLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBjcmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoISh0eXBlb2YgY3JlZCA9PT0gJ3N0cmluZycpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGNyZWRlbnRpYWwgKGEgc3RyaW5nKS4nKTtcbn07XG5leHBvcnRzLnZhbGlkYXRlQm9vbGVhbiA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBib29sLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiBib29sID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgKyAnbXVzdCBiZSBhIGJvb2xlYW4uJyk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBzdHJpbmcsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmIHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCEodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLicpO1xuICAgIH1cbn07XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9iaiwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgb2JqID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIShvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIG9iamVjdC4nKTtcbiAgICB9XG59O1xuZXhwb3J0cy52YWxpZGF0ZU9iamVjdENvbnRhaW5zS2V5ID0gZnVuY3Rpb24gKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9iaiwga2V5LCBvcHRpb25hbCwgb3B0X3R5cGUpIHtcbiAgICB2YXIgb2JqZWN0Q29udGFpbnNLZXkgPSBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdXRpbF8xLmNvbnRhaW5zKG9iaiwga2V5KTtcbiAgICBpZiAoIW9iamVjdENvbnRhaW5zS2V5KSB7XG4gICAgICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxfMy5lcnJvclByZWZpeChmbk5hbWUsIGFyZ3VtZW50TnVtYmVyLCBvcHRpb25hbCkgK1xuICAgICAgICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgICAgICAgIGtleSArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdF90eXBlKSB7XG4gICAgICAgIHZhciB2YWwgPSB1dGlsXzEuc2FmZUdldChvYmosIGtleSk7XG4gICAgICAgIGlmICgob3B0X3R5cGUgPT09ICdudW1iZXInICYmICEodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnc3RyaW5nJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Jvb2xlYW4nICYmICEodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSkgfHxcbiAgICAgICAgICAgIChvcHRfdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB8fFxuICAgICAgICAgICAgKG9wdF90eXBlID09PSAnb2JqZWN0JyAmJiAhKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSAmJiB2YWwpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAgICAgICAgICdjb250YWlucyBpbnZhbGlkIHZhbHVlIGZvciBrZXkgXCInICtcbiAgICAgICAgICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiIChtdXN0IGJlIG9mIHR5cGUgXCInICtcbiAgICAgICAgICAgICAgICAgICAgb3B0X3R5cGUgK1xuICAgICAgICAgICAgICAgICAgICAnXCIpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbF8zLmVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAgICAgICAgICdtdXN0IGNvbnRhaW4gdGhlIGtleSBcIicgK1xuICAgICAgICAgICAgICAgICAgICBrZXkgK1xuICAgICAgICAgICAgICAgICAgICAnXCIgd2l0aCB0eXBlIFwiJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdF90eXBlICtcbiAgICAgICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvdmFsaWRhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqXG4gKiBAZW51bVxuICovXG52YXIgT3BlcmF0aW9uVHlwZTtcbihmdW5jdGlvbiAoT3BlcmF0aW9uVHlwZSkge1xuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIk9WRVJXUklURVwiXSA9IDBdID0gXCJPVkVSV1JJVEVcIjtcbiAgICBPcGVyYXRpb25UeXBlW09wZXJhdGlvblR5cGVbXCJNRVJHRVwiXSA9IDFdID0gXCJNRVJHRVwiO1xuICAgIE9wZXJhdGlvblR5cGVbT3BlcmF0aW9uVHlwZVtcIkFDS19VU0VSX1dSSVRFXCJdID0gMl0gPSBcIkFDS19VU0VSX1dSSVRFXCI7XG4gICAgT3BlcmF0aW9uVHlwZVtPcGVyYXRpb25UeXBlW1wiTElTVEVOX0NPTVBMRVRFXCJdID0gM10gPSBcIkxJU1RFTl9DT01QTEVURVwiO1xufSkoT3BlcmF0aW9uVHlwZSA9IGV4cG9ydHMuT3BlcmF0aW9uVHlwZSB8fCAoZXhwb3J0cy5PcGVyYXRpb25UeXBlID0ge30pKTtcbi8qKlxuICogQHBhcmFtIHtib29sZWFufSBmcm9tVXNlclxuICogQHBhcmFtIHtib29sZWFufSBmcm9tU2VydmVyXG4gKiBAcGFyYW0gez9zdHJpbmd9IHF1ZXJ5SWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdGFnZ2VkXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9wZXJhdGlvblNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb25Tb3VyY2UoZnJvbVVzZXIsIGZyb21TZXJ2ZXIsIHF1ZXJ5SWQsIHRhZ2dlZCkge1xuICAgICAgICB0aGlzLmZyb21Vc2VyID0gZnJvbVVzZXI7XG4gICAgICAgIHRoaXMuZnJvbVNlcnZlciA9IGZyb21TZXJ2ZXI7XG4gICAgICAgIHRoaXMucXVlcnlJZCA9IHF1ZXJ5SWQ7XG4gICAgICAgIHRoaXMudGFnZ2VkID0gdGFnZ2VkO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KCF0YWdnZWQgfHwgZnJvbVNlcnZlciwgJ1RhZ2dlZCBxdWVyaWVzIG11c3QgYmUgZnJvbSBzZXJ2ZXIuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHshT3BlcmF0aW9uU291cmNlfVxuICAgICAqL1xuICAgIE9wZXJhdGlvblNvdXJjZS5Vc2VyID0gbmV3IE9wZXJhdGlvblNvdXJjZShcbiAgICAvKmZyb21Vc2VyPSovIHRydWUsIGZhbHNlLCBudWxsLCBcbiAgICAvKnRhZ2dlZD0qLyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogQGNvbnN0XG4gICAgICogQHR5cGUgeyFPcGVyYXRpb25Tb3VyY2V9XG4gICAgICovXG4gICAgT3BlcmF0aW9uU291cmNlLlNlcnZlciA9IG5ldyBPcGVyYXRpb25Tb3VyY2UoZmFsc2UsIFxuICAgIC8qZnJvbVNlcnZlcj0qLyB0cnVlLCBudWxsLCBcbiAgICAvKnRhZ2dlZD0qLyBmYWxzZSk7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5SWRcbiAgICAgKiBAcmV0dXJuIHshT3BlcmF0aW9uU291cmNlfVxuICAgICAqL1xuICAgIE9wZXJhdGlvblNvdXJjZS5mb3JTZXJ2ZXJUYWdnZWRRdWVyeSA9IGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgT3BlcmF0aW9uU291cmNlKGZhbHNlLCBcbiAgICAgICAgLypmcm9tU2VydmVyPSovIHRydWUsIHF1ZXJ5SWQsIFxuICAgICAgICAvKnRhZ2dlZD0qLyB0cnVlKTtcbiAgICB9O1xuICAgIHJldHVybiBPcGVyYXRpb25Tb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5PcGVyYXRpb25Tb3VyY2UgPSBPcGVyYXRpb25Tb3VyY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wZXJhdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9vcGVyYXRpb24vT3BlcmF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgSW1wbGVtZW50cyB0aGUgcHJvbWlzZSBhYnN0cmFjdGlvbiBpbnRlcmZhY2UgZm9yIGV4dGVybmFsXG4gKiAocHVibGljIFNESykgcGFja2FnaW5nLCB3aGljaCBqdXN0IHBhc3NlcyB0aHJvdWdoIHRvIHRoZSBmaXJlYmFzZS1hcHAgaW1wbC5cbiAqL1xuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigoZnVuY3Rpb24oVCk6IHZvaWQpLFxuICogICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oIUVycm9yKTogdm9pZCkpfSByZXNvbHZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZShyZXNvbHZlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlcik7XG59XG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVqZWN0KGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZV9leHRlcm5hbC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9wcm9taXNlX2V4dGVybmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAc3RydWN0XG4gKiBAcGFyYW0geyFzdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGVcbiAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90Tm9kZSBUaGUgZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBjaGlsZE5hbWUgVGhlIG5hbWUgZm9yIHRoaXMgY2hpbGQsIGlmIGl0J3MgYSBjaGlsZCBldmVudFxuICogQHBhcmFtIHtOb2RlPX0gb2xkU25hcCBVc2VkIGZvciBpbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBvZiBjaGlsZCBjaGFuZ2VkIGV2ZW50c1xuICogQHBhcmFtIHtzdHJpbmc9fSBwcmV2TmFtZSBUaGUgbmFtZSBmb3IgdGhlIHByZXZpb3VzIGNoaWxkLCBpZiBhcHBsaWNhYmxlXG4gKi9cbnZhciBDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbmdlKHR5cGUsIHNuYXBzaG90Tm9kZSwgY2hpbGROYW1lLCBvbGRTbmFwLCBwcmV2TmFtZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnNuYXBzaG90Tm9kZSA9IHNuYXBzaG90Tm9kZTtcbiAgICAgICAgdGhpcy5jaGlsZE5hbWUgPSBjaGlsZE5hbWU7XG4gICAgICAgIHRoaXMub2xkU25hcCA9IG9sZFNuYXA7XG4gICAgICAgIHRoaXMucHJldk5hbWUgPSBwcmV2TmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqL1xuICAgIENoYW5nZS52YWx1ZUNoYW5nZSA9IGZ1bmN0aW9uIChzbmFwc2hvdCkge1xuICAgICAgICByZXR1cm4gbmV3IENoYW5nZShDaGFuZ2UuVkFMVUUsIHNuYXBzaG90KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UuY2hpbGRBZGRlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX0FEREVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHshQ2hhbmdlfVxuICAgICAqL1xuICAgIENoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2UgPSBmdW5jdGlvbiAoY2hpbGRLZXksIHNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9SRU1PVkVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gbmV3U25hcHNob3RcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBvbGRTbmFwc2hvdFxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICovXG4gICAgQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgbmV3U25hcHNob3QsIG9sZFNuYXBzaG90KSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhbmdlKENoYW5nZS5DSElMRF9DSEFOR0VELCBuZXdTbmFwc2hvdCwgY2hpbGRLZXksIG9sZFNuYXBzaG90KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBzaG90XG4gICAgICogQHJldHVybiB7IUNoYW5nZX1cbiAgICAgKi9cbiAgICBDaGFuZ2UuY2hpbGRNb3ZlZENoYW5nZSA9IGZ1bmN0aW9uIChjaGlsZEtleSwgc25hcHNob3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGFuZ2UoQ2hhbmdlLkNISUxEX01PVkVELCBzbmFwc2hvdCwgY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLy9ldmVudCB0eXBlc1xuICAgIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIGFkZGVkICovXG4gICAgQ2hhbmdlLkNISUxEX0FEREVEID0gJ2NoaWxkX2FkZGVkJztcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSBjaGlsZCByZW1vdmVkICovXG4gICAgQ2hhbmdlLkNISUxEX1JFTU9WRUQgPSAnY2hpbGRfcmVtb3ZlZCc7XG4gICAgLyoqIEV2ZW50IHR5cGUgZm9yIGEgY2hpbGQgY2hhbmdlZCAqL1xuICAgIENoYW5nZS5DSElMRF9DSEFOR0VEID0gJ2NoaWxkX2NoYW5nZWQnO1xuICAgIC8qKiBFdmVudCB0eXBlIGZvciBhIGNoaWxkIG1vdmVkICovXG4gICAgQ2hhbmdlLkNISUxEX01PVkVEID0gJ2NoaWxkX21vdmVkJztcbiAgICAvKiogRXZlbnQgdHlwZSBmb3IgYSB2YWx1ZSBjaGFuZ2UgKi9cbiAgICBDaGFuZ2UuVkFMVUUgPSAndmFsdWUnO1xuICAgIHJldHVybiBDaGFuZ2U7XG59KCkpO1xuZXhwb3J0cy5DaGFuZ2UgPSBDaGFuZ2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYW5nZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NoYW5nZS5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnRhaW5zIG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCBvYmplY3RzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMob2JqLCBwcm9wKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2gob2JqLCBmKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoY29udGFpbnMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBmKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgZm9yRWFjaChvYmosIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICBjW2tleV0gPSB2YWw7XG4gICAgfSk7XG4gICAgcmV0dXJuIGM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSW5kZXhfMSA9IHJlcXVpcmUoXCIuL0luZGV4XCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIF9fRU1QVFlfTk9ERTtcbnZhciBLZXlJbmRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS2V5SW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS2V5SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEtleUluZGV4LCBcIl9fRU1QVFlfTk9ERVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fRU1QVFlfTk9ERTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBfX0VNUFRZX05PREUgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgS2V5SW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdXRpbF8xLm5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgS2V5SW5kZXgucHJvdG90eXBlLmlzRGVmaW5lZE9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgLy8gV2UgY291bGQgcHJvYmFibHkgcmV0dXJuIHRydWUgaGVyZSAoc2luY2UgZXZlcnkgbm9kZSBoYXMgYSBrZXkpLCBidXQgaXQncyBuZXZlciBjYWxsZWRcbiAgICAgICAgLy8gc28ganVzdCBsZWF2aW5nIHVuaW1wbGVtZW50ZWQgZm9yIG5vdy5cbiAgICAgICAgdGhyb3cgdXRpbF8yLmFzc2VydGlvbkVycm9yKCdLZXlJbmRleC5pc0RlZmluZWRPbiBub3QgZXhwZWN0ZWQgdG8gYmUgY2FsbGVkLicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gVGhlIGtleSBmb3IgYSBub2RlIG5ldmVyIGNoYW5nZXMuXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5taW5Qb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTm9kZV8xLk5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS5tYXhQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCByZWFsbHkgYmUgY3JlYXRlZCBvbmNlIGFuZCBjYWNoZWQgaW4gYSBzdGF0aWMgcHJvcGVydHksIGJ1dFxuICAgICAgICAvLyBOYW1lZE5vZGUgaXNuJ3QgZGVmaW5lZCB5ZXQsIHNvIEkgY2FuJ3QgdXNlIGl0IGluIGEgc3RhdGljLiAgQmxlaC5cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKHV0aWxfMS5NQVhfTkFNRSwgX19FTVBUWV9OT0RFKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBLZXlJbmRleC5wcm90b3R5cGUubWFrZVBvc3QgPSBmdW5jdGlvbiAoaW5kZXhWYWx1ZSwgbmFtZSkge1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KHR5cGVvZiBpbmRleFZhbHVlID09PSAnc3RyaW5nJywgJ0tleUluZGV4IGluZGV4VmFsdWUgbXVzdCBhbHdheXMgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIC8vIFdlIGp1c3QgdXNlIGVtcHR5IG5vZGUsIGJ1dCBpdCdsbCBuZXZlciBiZSBjb21wYXJlZCwgc2luY2Ugb3VyIGNvbXBhcmF0b3Igb25seSBsb29rcyBhdCBuYW1lLlxuICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUoaW5kZXhWYWx1ZSwgX19FTVBUWV9OT0RFKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFzdHJpbmd9IFN0cmluZyByZXByZXNlbnRhdGlvbiBmb3IgaW5jbHVzaW9uIGluIGEgcXVlcnkgc3BlY1xuICAgICAqL1xuICAgIEtleUluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcua2V5JztcbiAgICB9O1xuICAgIHJldHVybiBLZXlJbmRleDtcbn0oSW5kZXhfMS5JbmRleCkpO1xuZXhwb3J0cy5LZXlJbmRleCA9IEtleUluZGV4O1xuZXhwb3J0cy5LRVlfSU5ERVggPSBuZXcgS2V5SW5kZXgoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S2V5SW5kZXguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBMZWFmTm9kZV8xID0gcmVxdWlyZShcIi4vTGVhZk5vZGVcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZVwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGNoaWxkU2V0XzEgPSByZXF1aXJlKFwiLi9jaGlsZFNldFwiKTtcbnZhciBjb21wYXJhdG9yc18xID0gcmVxdWlyZShcIi4vY29tcGFyYXRvcnNcIik7XG52YXIgSW5kZXhNYXBfMSA9IHJlcXVpcmUoXCIuL0luZGV4TWFwXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciBVU0VfSElOWkUgPSB0cnVlO1xuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc25hcHNob3Qgbm9kZSByZXByZXNlbnRpbmcgdGhlIHBhc3NlZCBKU09OIGFuZCByZXR1cm5zIGl0LlxuICogQHBhcmFtIHsqfSBqc29uIEpTT04gdG8gY3JlYXRlIGEgbm9kZSBmb3IuXG4gKiBAcGFyYW0gez9zdHJpbmd8P251bWJlcj19IHByaW9yaXR5IE9wdGlvbmFsIHByaW9yaXR5IHRvIHVzZS4gIFRoaXMgd2lsbCBiZSBpZ25vcmVkIGlmIHRoZVxuICogcGFzc2VkIEpTT04gY29udGFpbnMgYSAucHJpb3JpdHkgcHJvcGVydHkuXG4gKiBAcmV0dXJuIHshTm9kZX1cbiAqL1xuZnVuY3Rpb24gbm9kZUZyb21KU09OKGpzb24sIHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSBudWxsOyB9XG4gICAgaWYgKGpzb24gPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcucHJpb3JpdHknIGluIGpzb24pIHtcbiAgICAgICAgcHJpb3JpdHkgPSBqc29uWycucHJpb3JpdHknXTtcbiAgICB9XG4gICAgdXRpbF8yLmFzc2VydChwcmlvcml0eSA9PT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgcHJpb3JpdHkgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiBwcmlvcml0eSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgKHR5cGVvZiBwcmlvcml0eSA9PT0gJ29iamVjdCcgJiYgJy5zdicgaW4gcHJpb3JpdHkpLCAnSW52YWxpZCBwcmlvcml0eSB0eXBlIGZvdW5kOiAnICsgdHlwZW9mIHByaW9yaXR5KTtcbiAgICBpZiAodHlwZW9mIGpzb24gPT09ICdvYmplY3QnICYmICcudmFsdWUnIGluIGpzb24gJiYganNvblsnLnZhbHVlJ10gIT09IG51bGwpIHtcbiAgICAgICAganNvbiA9IGpzb25bJy52YWx1ZSddO1xuICAgIH1cbiAgICAvLyBWYWxpZCBsZWFmIG5vZGVzIGluY2x1ZGUgbm9uLW9iamVjdHMgb3Igc2VydmVyLXZhbHVlIHdyYXBwZXIgb2JqZWN0c1xuICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ29iamVjdCcgfHwgJy5zdicgaW4ganNvbikge1xuICAgICAgICB2YXIganNvbkxlYWYgPSBqc29uO1xuICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUoanNvbkxlYWYsIG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgIH1cbiAgICBpZiAoIShqc29uIGluc3RhbmNlb2YgQXJyYXkpICYmIFVTRV9ISU5aRSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5fMSA9IFtdO1xuICAgICAgICB2YXIgY2hpbGRyZW5IYXZlUHJpb3JpdHlfMSA9IGZhbHNlO1xuICAgICAgICB2YXIgaGluemVKc29uT2JqXzEgPSBqc29uO1xuICAgICAgICB1dGlsXzEuZm9yRWFjaChoaW56ZUpzb25PYmpfMSwgZnVuY3Rpb24gKGtleSwgY2hpbGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCBrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgbWV0YWRhdGEgbm9kZXNcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGhpbnplSnNvbk9ial8xW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkhhdmVQcmlvcml0eV8xID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuSGF2ZVByaW9yaXR5XzEgfHwgIWNoaWxkTm9kZS5nZXRQcmlvcml0eSgpLmlzRW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5fMS5wdXNoKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoaWxkcmVuXzEubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRTZXQgPSBjaGlsZFNldF8xLmJ1aWxkQ2hpbGRTZXQoY2hpbGRyZW5fMSwgY29tcGFyYXRvcnNfMS5OQU1FX09OTFlfQ09NUEFSQVRPUiwgZnVuY3Rpb24gKG5hbWVkTm9kZSkgeyByZXR1cm4gbmFtZWROb2RlLm5hbWU7IH0sIGNvbXBhcmF0b3JzXzEuTkFNRV9DT01QQVJBVE9SKTtcbiAgICAgICAgaWYgKGNoaWxkcmVuSGF2ZVByaW9yaXR5XzEpIHtcbiAgICAgICAgICAgIHZhciBzb3J0ZWRDaGlsZFNldCA9IGNoaWxkU2V0XzEuYnVpbGRDaGlsZFNldChjaGlsZHJlbl8xLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVguZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlKGNoaWxkU2V0LCBub2RlRnJvbUpTT04ocHJpb3JpdHkpLCBuZXcgSW5kZXhNYXBfMS5JbmRleE1hcCh7ICcucHJpb3JpdHknOiBzb3J0ZWRDaGlsZFNldCB9LCB7ICcucHJpb3JpdHknOiBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVggfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUoY2hpbGRTZXQsIG5vZGVGcm9tSlNPTihwcmlvcml0eSksIEluZGV4TWFwXzEuSW5kZXhNYXAuRGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBub2RlXzEgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgdmFyIGpzb25PYmpfMSA9IGpzb247XG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKGpzb25PYmpfMSwgZnVuY3Rpb24gKGtleSwgY2hpbGREYXRhKSB7XG4gICAgICAgICAgICBpZiAodXRpbF8xLmNvbnRhaW5zKGpzb25PYmpfMSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3Vic3RyaW5nKDAsIDEpICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1ldGFkYXRhIG5vZGVzLlxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gbm9kZUZyb21KU09OKGNoaWxkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuaXNMZWFmTm9kZSgpIHx8ICFjaGlsZE5vZGUuaXNFbXB0eSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZV8xID0gbm9kZV8xLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGtleSwgY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZV8xLnVwZGF0ZVByaW9yaXR5KG5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgIH1cbn1cbmV4cG9ydHMubm9kZUZyb21KU09OID0gbm9kZUZyb21KU09OO1xuUHJpb3JpdHlJbmRleF8xLnNldE5vZGVGcm9tSlNPTihub2RlRnJvbUpTT04pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlRnJvbUpTT04uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9ub2RlRnJvbUpTT04uanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIGVycm9yc0V4cG9ydHMgZnJvbSAnLi9lcnJvcic7XG5leHBvcnQgdmFyIFN0cmluZ0Zvcm1hdCA9IHtcbiAgICBSQVc6ICdyYXcnLFxuICAgIEJBU0U2NDogJ2Jhc2U2NCcsXG4gICAgQkFTRTY0VVJMOiAnYmFzZTY0dXJsJyxcbiAgICBEQVRBX1VSTDogJ2RhdGFfdXJsJ1xufTtcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRWYWxpZGF0b3Ioc3RyaW5nRm9ybWF0KSB7XG4gICAgc3dpdGNoIChzdHJpbmdGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuUkFXOlxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjQ6XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkJBU0U2NFVSTDpcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuREFUQV9VUkw6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgb25lIG9mIHRoZSBldmVudCB0eXBlczogWycgK1xuICAgICAgICAgICAgICAgIFN0cmluZ0Zvcm1hdC5SQVcgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIFN0cmluZ0Zvcm1hdC5CQVNFNjQgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkwgK1xuICAgICAgICAgICAgICAgICcsICcgK1xuICAgICAgICAgICAgICAgIFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCArXG4gICAgICAgICAgICAgICAgJ10uJztcbiAgICB9XG59XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFN0cmluZ0RhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5nRGF0YShkYXRhLCBvcHRfY29udGVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IG9wdF9jb250ZW50VHlwZSB8fCBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nRGF0YTtcbn0oKSk7XG5leHBvcnQgeyBTdHJpbmdEYXRhIH07XG5leHBvcnQgZnVuY3Rpb24gZGF0YUZyb21TdHJpbmcoZm9ybWF0LCBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5SQVc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEodXRmOEJ5dGVzXyhzdHJpbmcpKTtcbiAgICAgICAgY2FzZSBTdHJpbmdGb3JtYXQuQkFTRTY0OlxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0RhdGEoYmFzZTY0Qnl0ZXNfKGZvcm1hdCwgc3RyaW5nKSk7XG4gICAgICAgIGNhc2UgU3RyaW5nRm9ybWF0LkRBVEFfVVJMOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdEYXRhKGRhdGFVUkxCeXRlc18oc3RyaW5nKSwgZGF0YVVSTENvbnRlbnRUeXBlXyhzdHJpbmcpKTtcbiAgICB9XG4gICAgLy8gYXNzZXJ0KGZhbHNlKTtcbiAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLnVua25vd24oKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dGY4Qnl0ZXNfKHN0cmluZykge1xuICAgIHZhciBiID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMTI3KSB7XG4gICAgICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYyA8PSAyMDQ3KSB7XG4gICAgICAgICAgICAgICAgYi5wdXNoKDE5MiB8IChjID4+IDYpLCAxMjggfCAoYyAmIDYzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKGMgJiA2NDUxMikgPT0gNTUyOTYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWxpZCA9IGkgPCBzdHJpbmcubGVuZ3RoIC0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDY0NTEyKSA9PSA1NjMyMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBzdXJyb2dhdGUgd2Fzbid0IHRoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKDIzOSwgMTkxLCAxODkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsbyA9IHN0cmluZy5jaGFyQ29kZUF0KCsraSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gNjU1MzYgfCAoKGhpICYgMTAyMykgPDwgMTApIHwgKGxvICYgMTAyMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjQwIHwgKGMgPj4gMTgpLCAxMjggfCAoKGMgPj4gMTIpICYgNjMpLCAxMjggfCAoKGMgPj4gNikgJiA2MyksIDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjICYgNjQ1MTIpID09IDU2MzIwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGxvdyBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goMjI0IHwgKGMgPj4gMTIpLCAxMjggfCAoKGMgPj4gNikgJiA2MyksIDEyOCB8IChjICYgNjMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYik7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyY2VudEVuY29kZWRCeXRlc18oc3RyaW5nKSB7XG4gICAgdmFyIGRlY29kZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZVVSSUNvbXBvbmVudChzdHJpbmcpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRGb3JtYXQoU3RyaW5nRm9ybWF0LkRBVEFfVVJMLCAnTWFsZm9ybWVkIGRhdGEgVVJMLicpO1xuICAgIH1cbiAgICByZXR1cm4gdXRmOEJ5dGVzXyhkZWNvZGVkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRCeXRlc18oZm9ybWF0LCBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjQ6IHtcbiAgICAgICAgICAgIHZhciBoYXNNaW51cyA9IHN0cmluZy5pbmRleE9mKCctJykgIT09IC0xO1xuICAgICAgICAgICAgdmFyIGhhc1VuZGVyID0gc3RyaW5nLmluZGV4T2YoJ18nKSAhPT0gLTE7XG4gICAgICAgICAgICBpZiAoaGFzTWludXMgfHwgaGFzVW5kZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW52YWxpZENoYXIgPSBoYXNNaW51cyA/ICctJyA6ICdfJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRDaGFyICtcbiAgICAgICAgICAgICAgICAgICAgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjR1cmwgZW5jb2RlZD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFN0cmluZ0Zvcm1hdC5CQVNFNjRVUkw6IHtcbiAgICAgICAgICAgIHZhciBoYXNQbHVzID0gc3RyaW5nLmluZGV4T2YoJysnKSAhPT0gLTE7XG4gICAgICAgICAgICB2YXIgaGFzU2xhc2ggPSBzdHJpbmcuaW5kZXhPZignLycpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChoYXNQbHVzIHx8IGhhc1NsYXNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGludmFsaWRDaGFyID0gaGFzUGx1cyA/ICcrJyA6ICcvJztcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRGb3JtYXQoZm9ybWF0LCBcIkludmFsaWQgY2hhcmFjdGVyICdcIiArIGludmFsaWRDaGFyICsgXCInIGZvdW5kOiBpcyBpdCBiYXNlNjQgZW5jb2RlZD9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSgvLS9nLCAnKycpLnJlcGxhY2UoL18vZywgJy8nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBieXRlcztcbiAgICB0cnkge1xuICAgICAgICBieXRlcyA9IGF0b2Ioc3RyaW5nKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkRm9ybWF0KGZvcm1hdCwgJ0ludmFsaWQgY2hhcmFjdGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIHZhciBhcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogQHN0cnVjdFxuICovXG52YXIgRGF0YVVSTFBhcnRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFVUkxQYXJ0cyhkYXRhVVJMKSB7XG4gICAgICAgIHRoaXMuYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGRhdGFVUkwubWF0Y2goL15kYXRhOihbXixdKyk/LC8pO1xuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkRm9ybWF0KFN0cmluZ0Zvcm1hdC5EQVRBX1VSTCwgXCJNdXN0IGJlIGZvcm1hdHRlZCAnZGF0YTpbPG1lZGlhdHlwZT5dWztiYXNlNjRdLDxkYXRhPlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWlkZGxlID0gbWF0Y2hlc1sxXSB8fCBudWxsO1xuICAgICAgICBpZiAobWlkZGxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZTY0ID0gZW5kc1dpdGgobWlkZGxlLCAnO2Jhc2U2NCcpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHRoaXMuYmFzZTY0XG4gICAgICAgICAgICAgICAgPyBtaWRkbGUuc3Vic3RyaW5nKDAsIG1pZGRsZS5sZW5ndGggLSAnO2Jhc2U2NCcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIDogbWlkZGxlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdCA9IGRhdGFVUkwuc3Vic3RyaW5nKGRhdGFVUkwuaW5kZXhPZignLCcpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBEYXRhVVJMUGFydHM7XG59KCkpO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGFVUkxCeXRlc18oc3RyaW5nKSB7XG4gICAgdmFyIHBhcnRzID0gbmV3IERhdGFVUkxQYXJ0cyhzdHJpbmcpO1xuICAgIGlmIChwYXJ0cy5iYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NEJ5dGVzXyhTdHJpbmdGb3JtYXQuQkFTRTY0LCBwYXJ0cy5yZXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwZXJjZW50RW5jb2RlZEJ5dGVzXyhwYXJ0cy5yZXN0KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZGF0YVVSTENvbnRlbnRUeXBlXyhzdHJpbmcpIHtcbiAgICB2YXIgcGFydHMgPSBuZXcgRGF0YVVSTFBhcnRzKHN0cmluZyk7XG4gICAgcmV0dXJuIHBhcnRzLmNvbnRlbnRUeXBlO1xufVxuZnVuY3Rpb24gZW5kc1dpdGgocywgZW5kKSB7XG4gICAgdmFyIGxvbmdFbm91Z2ggPSBzLmxlbmd0aCA+PSBlbmQubGVuZ3RoO1xuICAgIGlmICghbG9uZ0Vub3VnaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzLnN1YnN0cmluZyhzLmxlbmd0aCAtIGVuZC5sZW5ndGgpID09PSBlbmQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCB2YXIgVGFza0V2ZW50ID0ge1xuICAgIC8qKiBUcmlnZ2VyZWQgd2hlbmV2ZXIgdGhlIHRhc2sgY2hhbmdlcyBvciBwcm9ncmVzcyBpcyB1cGRhdGVkLiAqL1xuICAgIFNUQVRFX0NIQU5HRUQ6ICdzdGF0ZV9jaGFuZ2VkJ1xufTtcbmV4cG9ydCB2YXIgSW50ZXJuYWxUYXNrU3RhdGUgPSB7XG4gICAgUlVOTklORzogJ3J1bm5pbmcnLFxuICAgIFBBVVNJTkc6ICdwYXVzaW5nJyxcbiAgICBQQVVTRUQ6ICdwYXVzZWQnLFxuICAgIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbiAgICBDQU5DRUxJTkc6ICdjYW5jZWxpbmcnLFxuICAgIENBTkNFTEVEOiAnY2FuY2VsZWQnLFxuICAgIEVSUk9SOiAnZXJyb3InXG59O1xuZXhwb3J0IHZhciBUYXNrU3RhdGUgPSB7XG4gICAgLyoqIFRoZSB0YXNrIGlzIGN1cnJlbnRseSB0cmFuc2ZlcnJpbmcgZGF0YS4gKi9cbiAgICBSVU5OSU5HOiAncnVubmluZycsXG4gICAgLyoqIFRoZSB0YXNrIHdhcyBwYXVzZWQgYnkgdGhlIHVzZXIuICovXG4gICAgUEFVU0VEOiAncGF1c2VkJyxcbiAgICAvKiogVGhlIHRhc2sgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBTVUNDRVNTOiAnc3VjY2VzcycsXG4gICAgLyoqIFRoZSB0YXNrIHdhcyBjYW5jZWxlZC4gKi9cbiAgICBDQU5DRUxFRDogJ2NhbmNlbGVkJyxcbiAgICAvKiogVGhlIHRhc2sgZmFpbGVkIHdpdGggYW4gZXJyb3IuICovXG4gICAgRVJST1I6ICdlcnJvcidcbn07XG5leHBvcnQgZnVuY3Rpb24gdGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIEludGVybmFsVGFza1N0YXRlLlJVTk5JTkc6XG4gICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORzpcbiAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkc6XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLlJVTk5JTkc7XG4gICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgcmV0dXJuIFRhc2tTdGF0ZS5QQVVTRUQ7XG4gICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuU1VDQ0VTUztcbiAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxFRDpcbiAgICAgICAgICAgIHJldHVybiBUYXNrU3RhdGUuQ0FOQ0VMRUQ7XG4gICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuRVJST1I6XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gVGFza1N0YXRlLkVSUk9SO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFza2VudW1zLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3Rhc2tlbnVtcy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRE9NU3RvcmFnZVdyYXBwZXJfMSA9IHJlcXVpcmUoXCIuL0RPTVN0b3JhZ2VXcmFwcGVyXCIpO1xudmFyIE1lbW9yeVN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuL01lbW9yeVN0b3JhZ2VcIik7XG4vKipcbiAqIEhlbHBlciB0byBjcmVhdGUgYSBET01TdG9yYWdlV3JhcHBlciBvciBlbHNlIGZhbGwgYmFjayB0byBNZW1vcnlTdG9yYWdlLlxuICogVE9ETzogT25jZSBNZW1vcnlTdG9yYWdlIGFuZCBET01TdG9yYWdlV3JhcHBlciBoYXZlIGEgc2hhcmVkIGludGVyZmFjZSB0aGlzIG1ldGhvZCBhbm5vdGF0aW9uIHNob3VsZCBjaGFuZ2VcbiAqIHRvIHJlZmxlY3QgdGhpcyB0eXBlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRvbVN0b3JhZ2VOYW1lIE5hbWUgb2YgdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBvYmplY3RcbiAqICAgKGUuZy4gJ2xvY2FsU3RvcmFnZScgb3IgJ3Nlc3Npb25TdG9yYWdlJykuXG4gKiBAcmV0dXJuIHs/fSBUdXJuaW5nIG9mZiB0eXBlIGluZm9ybWF0aW9uIHVudGlsIGEgY29tbW9uIGludGVyZmFjZSBpcyBkZWZpbmVkLlxuICovXG52YXIgY3JlYXRlU3RvcmFnZWZvciA9IGZ1bmN0aW9uIChkb21TdG9yYWdlTmFtZSkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIE5PVEU6IGp1c3QgYWNjZXNzaW5nIFwibG9jYWxTdG9yYWdlXCIgb3IgXCJ3aW5kb3dbJ2xvY2FsU3RvcmFnZSddXCIgbWF5IHRocm93IGEgc2VjdXJpdHkgZXhjZXB0aW9uLFxuICAgICAgICAvLyBzbyBpdCBtdXN0IGJlIGluc2lkZSB0aGUgdHJ5L2NhdGNoLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB0ZXN0IGNhY2hlLiBKdXN0IGJlY2F1c2UgaXQncyBoZXJlIGRvZXNuJ3QgbWVhbiBpdCB3b3Jrc1xuICAgICAgICAgICAgdmFyIGRvbVN0b3JhZ2UgPSB3aW5kb3dbZG9tU3RvcmFnZU5hbWVdO1xuICAgICAgICAgICAgZG9tU3RvcmFnZS5zZXRJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcsICdjYWNoZScpO1xuICAgICAgICAgICAgZG9tU3RvcmFnZS5yZW1vdmVJdGVtKCdmaXJlYmFzZTpzZW50aW5lbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBET01TdG9yYWdlV3JhcHBlcl8xLkRPTVN0b3JhZ2VXcmFwcGVyKGRvbVN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICAvLyBGYWlsZWQgdG8gY3JlYXRlIHdyYXBwZXIuICBKdXN0IHJldHVybiBpbi1tZW1vcnkgc3RvcmFnZS5cbiAgICAvLyBUT0RPOiBsb2c/XG4gICAgcmV0dXJuIG5ldyBNZW1vcnlTdG9yYWdlXzEuTWVtb3J5U3RvcmFnZSgpO1xufTtcbi8qKiBBIHN0b3JhZ2Ugb2JqZWN0IHRoYXQgbGFzdHMgYWNyb3NzIHNlc3Npb25zICovXG5leHBvcnRzLlBlcnNpc3RlbnRTdG9yYWdlID0gY3JlYXRlU3RvcmFnZWZvcignbG9jYWxTdG9yYWdlJyk7XG4vKiogQSBzdG9yYWdlIG9iamVjdCB0aGF0IG9ubHkgbGFzdHMgb25lIHNlc3Npb24gKi9cbmV4cG9ydHMuU2Vzc2lvblN0b3JhZ2UgPSBjcmVhdGVTdG9yYWdlZm9yKCdzZXNzaW9uU3RvcmFnZScpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdG9yYWdlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0b3JhZ2Uvc3RvcmFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBST1RPQ09MX1ZFUlNJT04gPSAnNSc7XG5leHBvcnRzLlZFUlNJT05fUEFSQU0gPSAndic7XG5leHBvcnRzLlRSQU5TUE9SVF9TRVNTSU9OX1BBUkFNID0gJ3MnO1xuZXhwb3J0cy5SRUZFUkVSX1BBUkFNID0gJ3InO1xuZXhwb3J0cy5GT1JHRV9SRUYgPSAnZic7XG5leHBvcnRzLkZPUkdFX0RPTUFJTiA9ICdmaXJlYmFzZWlvLmNvbSc7XG5leHBvcnRzLkxBU1RfU0VTU0lPTl9QQVJBTSA9ICdscyc7XG5leHBvcnRzLldFQlNPQ0tFVCA9ICd3ZWJzb2NrZXQnO1xuZXhwb3J0cy5MT05HX1BPTExJTkcgPSAnbG9uZ19wb2xsaW5nJztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29uc3RhbnRzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9Db25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi9Ob2RlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3V0aWxcIik7XG4vKipcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEluZGV4ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZGV4KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbighTmFtZWROb2RlLCAhTmFtZWROb2RlKTpudW1iZXJ9IEEgc3RhbmRhbG9uZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvclxuICAgICAqIHRoaXMgaW5kZXhcbiAgICAgKi9cbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0Q29tcGFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZS5iaW5kKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBiZWZvcmUgYW5kIGFmdGVyIHZhbHVlIGZvciBhIG5vZGUsIGRldGVybWluZSBpZiB0aGUgaW5kZXhlZCB2YWx1ZSBoYXMgY2hhbmdlZC4gRXZlbiBpZiB0aGV5IGFyZSBkaWZmZXJlbnQsXG4gICAgICogaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBjaGFuZ2VzIGFyZSBpc29sYXRlZCB0byBwYXJ0cyBvZiB0aGUgc25hcHNob3QgdGhhdCBhcmUgbm90IGluZGV4ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBvbGROb2RlXG4gICAgICogQHBhcmFtIHshTm9kZX0gbmV3Tm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBvcnRpb24gb2YgdGhlIHNuYXBzaG90IGJlaW5nIGluZGV4ZWQgY2hhbmdlZCBiZXR3ZWVuIG9sZE5vZGUgYW5kIG5ld05vZGVcbiAgICAgKi9cbiAgICBJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHZhciBvbGRXcmFwcGVkID0gbmV3IE5vZGVfMS5OYW1lZE5vZGUodXRpbF8xLk1JTl9OQU1FLCBvbGROb2RlKTtcbiAgICAgICAgdmFyIG5ld1dyYXBwZWQgPSBuZXcgTm9kZV8xLk5hbWVkTm9kZSh1dGlsXzEuTUlOX05BTUUsIG5ld05vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlKG9sZFdyYXBwZWQsIG5ld1dyYXBwZWQpICE9PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX0gYSBub2RlIHdyYXBwZXIgdGhhdCB3aWxsIHNvcnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXG4gICAgICogYW55IG90aGVyIG5vZGUgd3JhcHBlciwgdXNpbmcgdGhpcyBpbmRleFxuICAgICAqL1xuICAgIEluZGV4LnByb3RvdHlwZS5taW5Qb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTm9kZV8xLk5hbWVkTm9kZS5NSU47XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXg7XG59KCkpO1xuZXhwb3J0cy5JbmRleCA9IEluZGV4O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvSW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xudmFyIHNuYXBfMSA9IHJlcXVpcmUoXCIuL3NuYXBcIik7XG52YXIgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvcjtcbi8qKlxuICogTGVhZk5vZGUgaXMgYSBjbGFzcyBmb3Igc3RvcmluZyBsZWFmIG5vZGVzIGluIGEgRGF0YVNuYXBzaG90LiAgSXRcbiAqIGltcGxlbWVudHMgTm9kZSBhbmQgc3RvcmVzIHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSAoYSBzdHJpbmcsXG4gKiBudW1iZXIsIG9yIGJvb2xlYW4pIGFjY2Vzc2libGUgdmlhIGdldFZhbHVlKCkuXG4gKi9cbnZhciBMZWFmTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAaW1wbGVtZW50cyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyEoc3RyaW5nfG51bWJlcnxib29sZWFufE9iamVjdCl9IHZhbHVlXyBUaGUgdmFsdWUgdG8gc3RvcmUgaW4gdGhpcyBsZWFmIG5vZGUuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvYmplY3QgdHlwZSBpcyBwb3NzaWJsZSBpbiB0aGUgZXZlbnQgb2YgYSBkZWZlcnJlZCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7IU5vZGU9fSBwcmlvcml0eU5vZGVfIFRoZSBwcmlvcml0eSBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGVhZk5vZGUodmFsdWVfLCBwcmlvcml0eU5vZGVfKSB7XG4gICAgICAgIGlmIChwcmlvcml0eU5vZGVfID09PSB2b2lkIDApIHsgcHJpb3JpdHlOb2RlXyA9IExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERTsgfVxuICAgICAgICB0aGlzLnZhbHVlXyA9IHZhbHVlXztcbiAgICAgICAgdGhpcy5wcmlvcml0eU5vZGVfID0gcHJpb3JpdHlOb2RlXztcbiAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSBudWxsO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMudmFsdWVfICE9PSB1bmRlZmluZWQgJiYgdGhpcy52YWx1ZV8gIT09IG51bGwsIFwiTGVhZk5vZGUgc2hvdWxkbid0IGJlIGNyZWF0ZWQgd2l0aCBudWxsL3VuZGVmaW5lZCB2YWx1ZS5cIik7XG4gICAgICAgIHNuYXBfMS52YWxpZGF0ZVByaW9yaXR5Tm9kZSh0aGlzLnByaW9yaXR5Tm9kZV8pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTGVhZk5vZGUsIFwiX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3I7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3RvciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmlzTGVhZk5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmlvcml0eU5vZGVfO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLnVwZGF0ZVByaW9yaXR5ID0gZnVuY3Rpb24gKG5ld1ByaW9yaXR5Tm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlKHRoaXMudmFsdWVfLCBuZXdQcmlvcml0eU5vZGUpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmdldEltbWVkaWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICAvLyBIYWNrIHRvIHRyZWF0IHByaW9yaXR5IGFzIGEgcmVndWxhciBjaGlsZFxuICAgICAgICBpZiAoY2hpbGROYW1lID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aC5nZXRGcm9udCgpID09PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJpb3JpdHlOb2RlXztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmhhc0NoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgaWYgKGNoaWxkTmFtZSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVByaW9yaXR5KG5ld0NoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBjaGlsZE5hbWUgIT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBMZWFmTm9kZS5fX2NoaWxkcmVuTm9kZUNvbnN0cnVjdG9yLkVNUFRZX05PREUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpLnVwZGF0ZVByaW9yaXR5KHRoaXMucHJpb3JpdHlOb2RlXyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChwYXRoLCBuZXdDaGlsZE5vZGUpIHtcbiAgICAgICAgdmFyIGZyb250ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICBpZiAoZnJvbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3Q2hpbGROb2RlLmlzRW1wdHkoKSAmJiBmcm9udCAhPT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChmcm9udCAhPT0gJy5wcmlvcml0eScgfHwgcGF0aC5nZXRMZW5ndGgoKSA9PT0gMSwgJy5wcmlvcml0eSBtdXN0IGJlIHRoZSBsYXN0IHRva2VuIGluIGEgcGF0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlSW1tZWRpYXRlQ2hpbGQoZnJvbnQsIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IuRU1QVFlfTk9ERS51cGRhdGVDaGlsZChwYXRoLnBvcEZyb250KCksIG5ld0NoaWxkTm9kZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLm51bUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgsIGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoZXhwb3J0Rm9ybWF0KSB7XG4gICAgICAgIGlmIChleHBvcnRGb3JtYXQgJiYgIXRoaXMuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICcudmFsdWUnOiB0aGlzLmdldFZhbHVlKCksXG4gICAgICAgICAgICAgICAgJy5wcmlvcml0eSc6IHRoaXMuZ2V0UHJpb3JpdHkoKS52YWwoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sYXp5SGFzaF8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0b0hhc2ggPSAnJztcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmlvcml0eU5vZGVfLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICB0b0hhc2ggKz1cbiAgICAgICAgICAgICAgICAgICAgJ3ByaW9yaXR5OicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc25hcF8xLnByaW9yaXR5SGFzaFRleHQodGhpcy5wcmlvcml0eU5vZGVfLnZhbCgpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnOic7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcbiAgICAgICAgICAgIHRvSGFzaCArPSB0eXBlICsgJzonO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IHV0aWxfMi5kb3VibGVUb0lFRUU3NTRTdHJpbmcodGhpcy52YWx1ZV8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9IYXNoICs9IHRoaXMudmFsdWVfO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYXp5SGFzaF8gPSB1dGlsXzIuc2hhMSh0b0hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhenlIYXNoXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBsZWFmIG5vZGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fHN0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gVGhlIHZhbHVlIG9mIHRoZSBub2RlLlxuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciA9PT0gTGVhZk5vZGUuX19jaGlsZHJlbk5vZGVDb25zdHJ1Y3Rvci5FTVBUWV9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlciBpbnN0YW5jZW9mIExlYWZOb2RlLl9fY2hpbGRyZW5Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQob3RoZXIuaXNMZWFmTm9kZSgpLCAnVW5rbm93biBub2RlIHR5cGUnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUb0xlYWZOb2RlXyhvdGhlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmlzb24gc3BlY2lmaWNhbGx5IGZvciB0d28gbGVhZiBub2Rlc1xuICAgICAqIEBwYXJhbSB7IUxlYWZOb2RlfSBvdGhlckxlYWZcbiAgICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmNvbXBhcmVUb0xlYWZOb2RlXyA9IGZ1bmN0aW9uIChvdGhlckxlYWYpIHtcbiAgICAgICAgdmFyIG90aGVyTGVhZlR5cGUgPSB0eXBlb2Ygb3RoZXJMZWFmLnZhbHVlXztcbiAgICAgICAgdmFyIHRoaXNMZWFmVHlwZSA9IHR5cGVvZiB0aGlzLnZhbHVlXztcbiAgICAgICAgdmFyIG90aGVySW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2Yob3RoZXJMZWFmVHlwZSk7XG4gICAgICAgIHZhciB0aGlzSW5kZXggPSBMZWFmTm9kZS5WQUxVRV9UWVBFX09SREVSLmluZGV4T2YodGhpc0xlYWZUeXBlKTtcbiAgICAgICAgdXRpbF8xLmFzc2VydChvdGhlckluZGV4ID49IDAsICdVbmtub3duIGxlYWYgdHlwZTogJyArIG90aGVyTGVhZlR5cGUpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXNJbmRleCA+PSAwLCAnVW5rbm93biBsZWFmIHR5cGU6ICcgKyB0aGlzTGVhZlR5cGUpO1xuICAgICAgICBpZiAob3RoZXJJbmRleCA9PT0gdGhpc0luZGV4KSB7XG4gICAgICAgICAgICAvLyBTYW1lIHR5cGUsIGNvbXBhcmUgdmFsdWVzXG4gICAgICAgICAgICBpZiAodGhpc0xlYWZUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIERlZmVycmVkIHZhbHVlIG5vZGVzIGFyZSBhbGwgZXF1YWwsIGJ1dCB3ZSBzaG91bGQgYWxzbyBuZXZlciBnZXQgdG8gdGhpcyBwb2ludC4uLlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgd29ya3MgYmVjYXVzZSB0cnVlID4gZmFsc2UsIGFsbCBvdGhlcnMgYXJlIG51bWJlciBvciBzdHJpbmcgY29tcGFyaXNvbnNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8gPCBvdGhlckxlYWYudmFsdWVfKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy52YWx1ZV8gPT09IG90aGVyTGVhZi52YWx1ZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc0luZGV4IC0gb3RoZXJJbmRleDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMZWFmTm9kZS5wcm90b3R5cGUud2l0aEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGVhZk5vZGUucHJvdG90eXBlLmlzSW5kZXhlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExlYWZOb2RlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbmhlcml0RG9jXG4gICAgICAgICAqL1xuICAgICAgICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgdmFyIG90aGVyTGVhZiA9IG90aGVyO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhbHVlXyA9PT0gb3RoZXJMZWFmLnZhbHVlXyAmJlxuICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHlOb2RlXy5lcXVhbHMob3RoZXJMZWFmLnByaW9yaXR5Tm9kZV8pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHNvcnQgb3JkZXIgZm9yIGNvbXBhcmluZyBsZWFmIG5vZGVzIG9mIGRpZmZlcmVudCB0eXBlcy4gSWYgdHdvIGxlYWYgbm9kZXMgaGF2ZVxuICAgICAqIHRoZSBzYW1lIHR5cGUsIHRoZSBjb21wYXJpc29uIGZhbGxzIGJhY2sgdG8gdGhlaXIgdmFsdWVcbiAgICAgKiBAdHlwZSB7QXJyYXkuPCFzdHJpbmc+fVxuICAgICAqIEBjb25zdFxuICAgICAqL1xuICAgIExlYWZOb2RlLlZBTFVFX1RZUEVfT1JERVIgPSBbJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdzdHJpbmcnXTtcbiAgICByZXR1cm4gTGVhZk5vZGU7XG59KCkpO1xuZXhwb3J0cy5MZWFmTm9kZSA9IExlYWZOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MZWFmTm9kZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL0xlYWZOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQW4gaXRlcmF0b3Igb3ZlciBhbiBMTFJCTm9kZS5cbiAqL1xudmFyIFNvcnRlZE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBLLCBWLCBUXG4gICAgICogQHBhcmFtIHtMTFJCTm9kZXxMTFJCRW1wdHlOb2RlfSBub2RlIE5vZGUgdG8gaXRlcmF0ZS5cbiAgICAgKiBAcGFyYW0gez9LfSBzdGFydEtleVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oSywgSyk6IG51bWJlcn0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZXZlcnNlXyBXaGV0aGVyIG9yIG5vdCB0byBpdGVyYXRlIGluIHJldmVyc2VcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbihLLCBWKTpUKT19IHJlc3VsdEdlbmVyYXRvcl9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTb3J0ZWRNYXBJdGVyYXRvcihub2RlLCBzdGFydEtleSwgY29tcGFyYXRvciwgaXNSZXZlcnNlXywgcmVzdWx0R2VuZXJhdG9yXykge1xuICAgICAgICBpZiAocmVzdWx0R2VuZXJhdG9yXyA9PT0gdm9pZCAwKSB7IHJlc3VsdEdlbmVyYXRvcl8gPSBudWxsOyB9XG4gICAgICAgIHRoaXMuaXNSZXZlcnNlXyA9IGlzUmV2ZXJzZV87XG4gICAgICAgIHRoaXMucmVzdWx0R2VuZXJhdG9yXyA9IHJlc3VsdEdlbmVyYXRvcl87XG4gICAgICAgIC8qKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7QXJyYXkuPCFMTFJCTm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vZGVTdGFja18gPSBbXTtcbiAgICAgICAgdmFyIGNtcCA9IDE7XG4gICAgICAgIHdoaWxlICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlO1xuICAgICAgICAgICAgY21wID0gc3RhcnRLZXkgPyBjb21wYXJhdG9yKG5vZGUua2V5LCBzdGFydEtleSkgOiAxO1xuICAgICAgICAgICAgLy8gZmxpcCB0aGUgY29tcGFyaXNvbiBpZiB3ZSdyZSBnb2luZyBpbiByZXZlcnNlXG4gICAgICAgICAgICBpZiAoaXNSZXZlcnNlXylcbiAgICAgICAgICAgICAgICBjbXAgKj0gLTE7XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBsZXNzIHRoYW4gb3VyIHN0YXJ0IGtleS4gaWdub3JlIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNSZXZlcnNlXykge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub2RlIGlzIGV4YWN0bHkgZXF1YWwgdG8gb3VyIHN0YXJ0IGtleS4gUHVzaCBpdCBvbiB0aGUgc3RhY2ssIGJ1dCBzdG9wIGl0ZXJhdGluZztcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbm9kZSBpcyBncmVhdGVyIHRoYW4gb3VyIHN0YXJ0IGtleSwgYWRkIGl0IHRvIHRoZSBzdGFjayBhbmQgbW92ZSB0byB0aGUgbmV4dCBvbmVcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVTdGFja18ucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgU29ydGVkTWFwSXRlcmF0b3IucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVTdGFja18ubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlU3RhY2tfLnBvcCgpO1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICBpZiAodGhpcy5yZXN1bHRHZW5lcmF0b3JfKVxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRHZW5lcmF0b3JfKG5vZGUua2V5LCBub2RlLnZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzdWx0ID0geyBrZXk6IG5vZGUua2V5LCB2YWx1ZTogbm9kZS52YWx1ZSB9O1xuICAgICAgICBpZiAodGhpcy5pc1JldmVyc2VfKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZVN0YWNrXy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB3aGlsZSAoIW5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlU3RhY2tfLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU29ydGVkTWFwSXRlcmF0b3IucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVTdGFja18ubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFNvcnRlZE1hcEl0ZXJhdG9yLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlU3RhY2tfLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVN0YWNrX1t0aGlzLm5vZGVTdGFja18ubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdEdlbmVyYXRvcl8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdEdlbmVyYXRvcl8obm9kZS5rZXksIG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgdmFsdWU6IG5vZGUudmFsdWUgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNvcnRlZE1hcEl0ZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuU29ydGVkTWFwSXRlcmF0b3IgPSBTb3J0ZWRNYXBJdGVyYXRvcjtcbi8qKlxuICogUmVwcmVzZW50cyBhIG5vZGUgaW4gYSBMZWZ0LWxlYW5pbmcgUmVkLUJsYWNrIHRyZWUuXG4gKi9cbnZhciBMTFJCTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAdGVtcGxhdGUgSywgVlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBLZXkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0geyFWfSB2YWx1ZSBWYWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IGNvbG9yIFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cbiAgICAgKiBAcGFyYW0gez8oTExSQk5vZGV8TExSQkVtcHR5Tm9kZSk9fSBsZWZ0IExlZnQgY2hpbGQuXG4gICAgICogQHBhcmFtIHs/KExMUkJOb2RlfExMUkJFbXB0eU5vZGUpPX0gcmlnaHQgUmlnaHQgY2hpbGQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTExSQk5vZGUoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvciAhPSBudWxsID8gY29sb3IgOiBMTFJCTm9kZS5SRUQ7XG4gICAgICAgIHRoaXMubGVmdCA9XG4gICAgICAgICAgICBsZWZ0ICE9IG51bGwgPyBsZWZ0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XG4gICAgICAgIHRoaXMucmlnaHQgPVxuICAgICAgICAgICAgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogU29ydGVkTWFwLkVNUFRZX05PREU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IG5vZGUsIG9wdGlvbmFsbHkgcmVwbGFjaW5nIHBpZWNlcyBvZiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P0t9IGtleSBOZXcga2V5IGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0gez9WfSB2YWx1ZSBOZXcgdmFsdWUgZm9yIHRoZSBub2RlLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7P2Jvb2xlYW59IGNvbG9yIE5ldyBjb2xvciBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHs/TExSQk5vZGV8TExSQkVtcHR5Tm9kZX0gbGVmdCBOZXcgbGVmdCBjaGlsZCBmb3IgdGhlIG5vZGUsIG9yIG51bGwuXG4gICAgICogQHBhcmFtIHs/TExSQk5vZGV8TExSQkVtcHR5Tm9kZX0gcmlnaHQgTmV3IHJpZ2h0IGNoaWxkIGZvciB0aGUgbm9kZSwgb3IgbnVsbC5cbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IFRoZSBub2RlIGNvcHkuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgTExSQk5vZGUoa2V5ICE9IG51bGwgPyBrZXkgOiB0aGlzLmtleSwgdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogdGhpcy52YWx1ZSwgY29sb3IgIT0gbnVsbCA/IGNvbG9yIDogdGhpcy5jb2xvciwgbGVmdCAhPSBudWxsID8gbGVmdCA6IHRoaXMubGVmdCwgcmlnaHQgIT0gbnVsbCA/IHJpZ2h0IDogdGhpcy5yaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0LmNvdW50KCkgKyAxICsgdGhpcy5yaWdodC5jb3VudCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighSywgIVYpOip9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiAgIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgcmV0dXJuZWQgYnkgYWN0aW9uLCBvciB0aGUgbGFzdCBmYWxzZXlcbiAgICAgKiAgIHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvblxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5pbm9yZGVyVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gKHRoaXMubGVmdC5pbm9yZGVyVHJhdmVyc2FsKGFjdGlvbikgfHxcbiAgICAgICAgICAgIGFjdGlvbih0aGlzLmtleSwgdGhpcy52YWx1ZSkgfHxcbiAgICAgICAgICAgIHRoaXMucmlnaHQuaW5vcmRlclRyYXZlcnNhbChhY3Rpb24pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiByZXZlcnNlIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighT2JqZWN0LCAhT2JqZWN0KX0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaFxuICAgICAqIG5vZGUuICBJZiBpdCByZXR1cm5zIHRydWUsIHRyYXZlcnNhbCBpcyBhYm9ydGVkLlxuICAgICAqIEByZXR1cm4geyp9IFRydWUgaWYgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5yZXZlcnNlVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gKHRoaXMucmlnaHQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pIHx8XG4gICAgICAgICAgICBhY3Rpb24odGhpcy5rZXksIHRoaXMudmFsdWUpIHx8XG4gICAgICAgICAgICB0aGlzLmxlZnQucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBtaW5pbXVtIG5vZGUgaW4gdGhlIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUubWluXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5taW5fKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFLfSBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLm1pbktleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluXygpLmtleTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFLfSBUaGUgbWF4aW11bSBrZXkgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLm1heEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucmlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5tYXhLZXkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGtleSBLZXkgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gdmFsdWUgVmFsdWUgdG8gaW5zZXJ0LlxuICAgICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIHdpdGggdGhlIGtleS92YWx1ZSBhZGRlZC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGNtcCwgbjtcbiAgICAgICAgbiA9IHRoaXM7XG4gICAgICAgIGNtcCA9IGNvbXBhcmF0b3Ioa2V5LCBuLmtleSk7XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5pbnNlcnQoa2V5LCB2YWx1ZSwgY29tcGFyYXRvciksIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCB2YWx1ZSwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG51bGwsIG4ucmlnaHQuaW5zZXJ0KGtleSwgdmFsdWUsIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfExMUkJFbXB0eU5vZGV9IE5ldyB0cmVlLCB3aXRoIHRoZSBtaW5pbXVtIGtleSByZW1vdmVkLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5yZW1vdmVNaW5fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sZWZ0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gdGhpcztcbiAgICAgICAgaWYgKCFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKVxuICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnRfKCk7XG4gICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbi5sZWZ0LnJlbW92ZU1pbl8oKSwgbnVsbCk7XG4gICAgICAgIHJldHVybiBuLmZpeFVwXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtDb21wYXJhdG9yfSBjb21wYXJhdG9yIENvbXBhcmF0b3IuXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfExMUkJFbXB0eU5vZGV9IE5ldyB0cmVlLCB3aXRoIHRoZSBzcGVjaWZpZWQgaXRlbSByZW1vdmVkLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgIHZhciBuLCBzbWFsbGVzdDtcbiAgICAgICAgbiA9IHRoaXM7XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbi5rZXkpIDwgMCkge1xuICAgICAgICAgICAgaWYgKCFuLmxlZnQuaXNFbXB0eSgpICYmICFuLmxlZnQuaXNSZWRfKCkgJiYgIW4ubGVmdC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZExlZnRfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuID0gbi5jb3B5KG51bGwsIG51bGwsIG51bGwsIG4ubGVmdC5yZW1vdmUoa2V5LCBjb21wYXJhdG9yKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpKVxuICAgICAgICAgICAgICAgIG4gPSBuLnJvdGF0ZVJpZ2h0XygpO1xuICAgICAgICAgICAgaWYgKCFuLnJpZ2h0LmlzRW1wdHkoKSAmJiAhbi5yaWdodC5pc1JlZF8oKSAmJiAhbi5yaWdodC5sZWZ0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ubW92ZVJlZFJpZ2h0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuLmtleSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobi5yaWdodC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNvcnRlZE1hcC5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc21hbGxlc3QgPSBuLnJpZ2h0Lm1pbl8oKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4uY29weShzbWFsbGVzdC5rZXksIHNtYWxsZXN0LnZhbHVlLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZU1pbl8oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4uY29weShudWxsLCBudWxsLCBudWxsLCBudWxsLCBuLnJpZ2h0LnJlbW92ZShrZXksIGNvbXBhcmF0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbi5maXhVcF8oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGlzIGEgUkVEIG5vZGUuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmlzUmVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUgYWZ0ZXIgcGVyZm9ybWluZyBhbnkgbmVlZGVkIHJvdGF0aW9ucy5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuZml4VXBfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXM7XG4gICAgICAgIGlmIChuLnJpZ2h0LmlzUmVkXygpICYmICFuLmxlZnQuaXNSZWRfKCkpXG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xuICAgICAgICBpZiAobi5sZWZ0LmlzUmVkXygpICYmIG4ubGVmdC5sZWZ0LmlzUmVkXygpKVxuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XG4gICAgICAgIGlmIChuLmxlZnQuaXNSZWRfKCkgJiYgbi5yaWdodC5pc1JlZF8oKSlcbiAgICAgICAgICAgIG4gPSBuLmNvbG9yRmxpcF8oKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIGFmdGVyIG1vdmVSZWRMZWZ0LlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5tb3ZlUmVkTGVmdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb2xvckZsaXBfKCk7XG4gICAgICAgIGlmIChuLnJpZ2h0LmxlZnQuaXNSZWRfKCkpIHtcbiAgICAgICAgICAgIG4gPSBuLmNvcHkobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbi5yaWdodC5yb3RhdGVSaWdodF8oKSk7XG4gICAgICAgICAgICBuID0gbi5yb3RhdGVMZWZ0XygpO1xuICAgICAgICAgICAgbiA9IG4uY29sb3JGbGlwXygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHshTExSQk5vZGV9IE5ldyB0cmVlLCBhZnRlciBtb3ZlUmVkUmlnaHQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLm1vdmVSZWRSaWdodF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb2xvckZsaXBfKCk7XG4gICAgICAgIGlmIChuLmxlZnQubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgbiA9IG4ucm90YXRlUmlnaHRfKCk7XG4gICAgICAgICAgICBuID0gbi5jb2xvckZsaXBfKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIGFmdGVyIHJvdGF0ZUxlZnQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLnJvdGF0ZUxlZnRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmwgPSB0aGlzLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuUkVELCBudWxsLCB0aGlzLnJpZ2h0LmxlZnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG5sLCBudWxsKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgcm90YXRlUmlnaHQuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLnJvdGF0ZVJpZ2h0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5yID0gdGhpcy5jb3B5KG51bGwsIG51bGwsIExMUkJOb2RlLlJFRCwgdGhpcy5sZWZ0LnJpZ2h0LCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsIHRoaXMuY29sb3IsIG51bGwsIG5yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7IUxMUkJOb2RlfSBOZXcgdHJlZSwgYWZ0ZXIgY29sb3JGbGlwLlxuICAgICAqL1xuICAgIExMUkJOb2RlLnByb3RvdHlwZS5jb2xvckZsaXBfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdC5jb3B5KG51bGwsIG51bGwsICF0aGlzLmxlZnQuY29sb3IsIG51bGwsIG51bGwpO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0LmNvcHkobnVsbCwgbnVsbCwgIXRoaXMucmlnaHQuY29sb3IsIG51bGwsIG51bGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIG51bGwsICF0aGlzLmNvbG9yLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgdGVzdGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbGwgaXMgd2VsbC5cbiAgICAgKi9cbiAgICBMTFJCTm9kZS5wcm90b3R5cGUuY2hlY2tNYXhEZXB0aF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBibGFja0RlcHRoID0gdGhpcy5jaGVja18oKTtcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KDIuMCwgYmxhY2tEZXB0aCkgPD0gdGhpcy5jb3VudCgpICsgMTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBOb3Qgc3VyZSB3aGF0IHRoaXMgcmV0dXJucyBleGFjdGx5LiA6LSkuXG4gICAgICovXG4gICAgTExSQk5vZGUucHJvdG90eXBlLmNoZWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJsYWNrRGVwdGg7XG4gICAgICAgIGlmICh0aGlzLmlzUmVkXygpICYmIHRoaXMubGVmdC5pc1JlZF8oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWQgbm9kZSBoYXMgcmVkIGNoaWxkKCcgKyB0aGlzLmtleSArICcsJyArIHRoaXMudmFsdWUgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJpZ2h0LmlzUmVkXygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JpZ2h0IGNoaWxkIG9mICgnICsgdGhpcy5rZXkgKyAnLCcgKyB0aGlzLnZhbHVlICsgJykgaXMgcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxhY2tEZXB0aCA9IHRoaXMubGVmdC5jaGVja18oKTtcbiAgICAgICAgaWYgKGJsYWNrRGVwdGggIT09IHRoaXMucmlnaHQuY2hlY2tfKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxhY2sgZGVwdGhzIGRpZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJsYWNrRGVwdGggKyAodGhpcy5pc1JlZF8oKSA/IDAgOiAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTExSQk5vZGUuUkVEID0gdHJ1ZTtcbiAgICBMTFJCTm9kZS5CTEFDSyA9IGZhbHNlO1xuICAgIHJldHVybiBMTFJCTm9kZTtcbn0oKSk7XG5leHBvcnRzLkxMUkJOb2RlID0gTExSQk5vZGU7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZW1wdHkgbm9kZSAoYSBsZWFmIG5vZGUgaW4gdGhlIFJlZC1CbGFjayBUcmVlKS5cbiAqL1xudmFyIExMUkJFbXB0eU5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTExSQkVtcHR5Tm9kZSgpIHtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFMTFJCRW1wdHlOb2RlfSBUaGUgbm9kZSBjb3B5LlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY29sb3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkvdmFsdWUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFLfSBrZXkgS2V5IHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7IVZ9IHZhbHVlIFZhbHVlIHRvIGJlIGFkZGVkLlxuICAgICAqIEBwYXJhbSB7Q29tcGFyYXRvcn0gY29tcGFyYXRvciBDb21wYXJhdG9yLlxuICAgICAqIEByZXR1cm4geyFMTFJCTm9kZX0gTmV3IHRyZWUsIHdpdGggaXRlbSBhZGRlZC5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IExMUkJOb2RlKGtleSwgdmFsdWUsIG51bGwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIHRyZWUsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBUaGUga2V5IHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0ge0NvbXBhcmF0b3J9IGNvbXBhcmF0b3IgQ29tcGFyYXRvci5cbiAgICAgKiBAcmV0dXJuIHshTExSQkVtcHR5Tm9kZX0gTmV3IHRyZWUsIHdpdGggaXRlbSByZW1vdmVkLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB0b3RhbCBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIHRyZWUuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgdHJlZSBpbiBrZXkgb3JkZXIgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZ1bmN0aW9uXG4gICAgICogZm9yIGVhY2ggbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUssICFWKToqfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoXG4gICAgICogbm9kZS4gIElmIGl0IHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0cmF2ZXJzYWwgd2FzIGFib3J0ZWQuXG4gICAgICovXG4gICAgTExSQkVtcHR5Tm9kZS5wcm90b3R5cGUuaW5vcmRlclRyYXZlcnNhbCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2VzIHRoZSB0cmVlIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgICAqIGZvciBlYWNoIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFLLCAhVil9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2hcbiAgICAgKiBub2RlLiAgSWYgaXQgcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRyYXZlcnNhbCB3YXMgYWJvcnRlZC5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5yZXZlcnNlVHJhdmVyc2FsID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudWxsfVxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLm1pbktleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudWxsfVxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLm1heEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTm90IHN1cmUgd2hhdCB0aGlzIHJldHVybnMgZXhhY3RseS4gOi0pLlxuICAgICAqL1xuICAgIExMUkJFbXB0eU5vZGUucHJvdG90eXBlLmNoZWNrXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBub2RlIGlzIHJlZC5cbiAgICAgKi9cbiAgICBMTFJCRW1wdHlOb2RlLnByb3RvdHlwZS5pc1JlZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHJldHVybiBMTFJCRW1wdHlOb2RlO1xufSgpKTtcbmV4cG9ydHMuTExSQkVtcHR5Tm9kZSA9IExMUkJFbXB0eU5vZGU7XG4vKipcbiAqIEFuIGltbXV0YWJsZSBzb3J0ZWQgbWFwIGltcGxlbWVudGF0aW9uLCBiYXNlZCBvbiBhIExlZnQtbGVhbmluZyBSZWQtQmxhY2tcbiAqIHRyZWUuXG4gKi9cbnZhciBTb3J0ZWRNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIEssIFZcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEssIEspOm51bWJlcn0gY29tcGFyYXRvcl8gS2V5IGNvbXBhcmF0b3IuXG4gICAgICogQHBhcmFtIHtMTFJCTm9kZT19IHJvb3RfIChPcHRpb25hbCkgUm9vdCBub2RlIGZvciB0aGUgbWFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNvcnRlZE1hcChjb21wYXJhdG9yXywgcm9vdF8pIHtcbiAgICAgICAgaWYgKHJvb3RfID09PSB2b2lkIDApIHsgcm9vdF8gPSBTb3J0ZWRNYXAuRU1QVFlfTk9ERTsgfVxuICAgICAgICB0aGlzLmNvbXBhcmF0b3JfID0gY29tcGFyYXRvcl87XG4gICAgICAgIHRoaXMucm9vdF8gPSByb290XztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hcCwgd2l0aCB0aGUgc3BlY2lmaWVkIGtleS92YWx1ZSBhZGRlZCBvciByZXBsYWNlZC5cbiAgICAgKiAoVE9ETzogV2Ugc2hvdWxkIHBlcmhhcHMgcmVuYW1lIHRoaXMgbWV0aG9kIHRvICdwdXQnKVxuICAgICAqXG4gICAgICogQHBhcmFtIHshS30ga2V5IEtleSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcGFyYW0geyFWfSB2YWx1ZSBWYWx1ZSB0byBiZSBhZGRlZC5cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwLjxLLCBWPn0gTmV3IG1hcCwgd2l0aCBpdGVtIGFkZGVkLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXAodGhpcy5jb21wYXJhdG9yXywgdGhpcy5yb290X1xuICAgICAgICAgICAgLmluc2VydChrZXksIHZhbHVlLCB0aGlzLmNvbXBhcmF0b3JfKVxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXAsIHdpdGggdGhlIHNwZWNpZmllZCBrZXkgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBUaGUga2V5IHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHshU29ydGVkTWFwLjxLLCBWPn0gTmV3IG1hcCwgd2l0aCBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwKHRoaXMuY29tcGFyYXRvcl8sIHRoaXMucm9vdF9cbiAgICAgICAgICAgIC5yZW1vdmUoa2V5LCB0aGlzLmNvbXBhcmF0b3JfKVxuICAgICAgICAgICAgLmNvcHkobnVsbCwgbnVsbCwgTExSQk5vZGUuQkxBQ0ssIG51bGwsIG51bGwpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBub2RlIHdpdGggdGhlIGdpdmVuIGtleSwgb3IgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUt9IGtleSBUaGUga2V5IHRvIGxvb2sgdXAuXG4gICAgICogQHJldHVybiB7P1Z9IFRoZSB2YWx1ZSBvZiB0aGUgbm9kZSB3aXRoIHRoZSBnaXZlbiBrZXksIG9yIG51bGwgaWYgdGhlXG4gICAgICoga2V5IGRvZXNuJ3QgZXhpc3QuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBjbXA7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5yb290XztcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5IG9mIHRoZSBpdGVtICpiZWZvcmUqIHRoZSBzcGVjaWZpZWQga2V5LCBvciBudWxsIGlmIGtleSBpcyB0aGUgZmlyc3QgaXRlbS5cbiAgICAgKiBAcGFyYW0ge0t9IGtleSBUaGUga2V5IHRvIGZpbmQgdGhlIHByZWRlY2Vzc29yIG9mXG4gICAgICogQHJldHVybiB7P0t9IFRoZSBwcmVkZWNlc3NvciBrZXkuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5nZXRQcmVkZWNlc3NvcktleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIGNtcCwgbm9kZSA9IHRoaXMucm9vdF8sIHJpZ2h0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKCFub2RlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY21wID0gdGhpcy5jb21wYXJhdG9yXyhrZXksIG5vZGUua2V5KTtcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUubGVmdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCFub2RlLnJpZ2h0LmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJpZ2h0UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodFBhcmVudC5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmlyc3QgaXRlbS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgICAgICAgICAgICByaWdodFBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gZmluZCBwcmVkZWNlc3NvciBrZXkgZm9yIGEgbm9uZXhpc3RlbnQga2V5LiAgV2hhdCBnaXZlcz8nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1hcCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIG51bWJlciBvZiBub2RlcyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmNvdW50KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/S30gVGhlIG1pbmltdW0ga2V5IGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgU29ydGVkTWFwLnByb3RvdHlwZS5taW5LZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLm1pbktleSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P0t9IFRoZSBtYXhpbXVtIGtleSBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUubWF4S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5tYXhLZXkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIGtleSBvcmRlciBhbmQgY2FsbHMgdGhlIHNwZWNpZmllZCBhY3Rpb24gZnVuY3Rpb25cbiAgICAgKiBmb3IgZWFjaCBrZXkvdmFsdWUgcGFpci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUssICFWKToqfSBhY3Rpb24gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAgICogZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIuICBJZiBhY3Rpb24gcmV0dXJucyB0cnVlLCB0cmF2ZXJzYWwgaXMgYWJvcnRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgZmlyc3QgdHJ1dGh5IHZhbHVlIHJldHVybmVkIGJ5IGFjdGlvbiwgb3IgdGhlIGxhc3QgZmFsc2V5XG4gICAgICogICB2YWx1ZSByZXR1cm5lZCBieSBhY3Rpb25cbiAgICAgKi9cbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmlub3JkZXJUcmF2ZXJzYWwgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RfLmlub3JkZXJUcmF2ZXJzYWwoYWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyB0aGUgbWFwIGluIHJldmVyc2Uga2V5IG9yZGVyIGFuZCBjYWxscyB0aGUgc3BlY2lmaWVkIGFjdGlvbiBmdW5jdGlvblxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighT2JqZWN0LCAhT2JqZWN0KX0gYWN0aW9uIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAqIGZvciBlYWNoIGtleS92YWx1ZSBwYWlyLiAgSWYgYWN0aW9uIHJldHVybnMgdHJ1ZSwgdHJhdmVyc2FsIGlzIGFib3J0ZWQuXG4gICAgICogQHJldHVybiB7Kn0gVHJ1ZSBpZiB0aGUgdHJhdmVyc2FsIHdhcyBhYm9ydGVkLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUucmV2ZXJzZVRyYXZlcnNhbCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdF8ucmV2ZXJzZVRyYXZlcnNhbChhY3Rpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvdmVyIHRoZSBTb3J0ZWRNYXAuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbihLLCBWKTpUKT19IHJlc3VsdEdlbmVyYXRvclxuICAgICAqIEByZXR1cm4ge1NvcnRlZE1hcEl0ZXJhdG9yLjxLLCBWLCBUPn0gVGhlIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5wcm90b3R5cGUuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAocmVzdWx0R2VuZXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwSXRlcmF0b3IodGhpcy5yb290XywgbnVsbCwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XG4gICAgfTtcbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldEl0ZXJhdG9yRnJvbSA9IGZ1bmN0aW9uIChrZXksIHJlc3VsdEdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcEl0ZXJhdG9yKHRoaXMucm9vdF8sIGtleSwgdGhpcy5jb21wYXJhdG9yXywgZmFsc2UsIHJlc3VsdEdlbmVyYXRvcik7XG4gICAgfTtcbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldFJldmVyc2VJdGVyYXRvckZyb20gPSBmdW5jdGlvbiAoa2V5LCByZXN1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBrZXksIHRoaXMuY29tcGFyYXRvcl8sIHRydWUsIHJlc3VsdEdlbmVyYXRvcik7XG4gICAgfTtcbiAgICBTb3J0ZWRNYXAucHJvdG90eXBlLmdldFJldmVyc2VJdGVyYXRvciA9IGZ1bmN0aW9uIChyZXN1bHRHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3J0ZWRNYXBJdGVyYXRvcih0aGlzLnJvb3RfLCBudWxsLCB0aGlzLmNvbXBhcmF0b3JfLCB0cnVlLCByZXN1bHRHZW5lcmF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWx3YXlzIHVzZSB0aGUgc2FtZSBlbXB0eSBub2RlLCB0byByZWR1Y2UgbWVtb3J5LlxuICAgICAqIEBjb25zdFxuICAgICAqL1xuICAgIFNvcnRlZE1hcC5FTVBUWV9OT0RFID0gbmV3IExMUkJFbXB0eU5vZGUoKTtcbiAgICByZXR1cm4gU29ydGVkTWFwO1xufSgpKTtcbmV4cG9ydHMuU29ydGVkTWFwID0gU29ydGVkTWFwO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Tb3J0ZWRNYXAuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9Tb3J0ZWRNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNlcnZlclZhbHVlc18xID0gcmVxdWlyZShcIi4vdXRpbC9TZXJ2ZXJWYWx1ZXNcIik7XG52YXIgbm9kZUZyb21KU09OXzEgPSByZXF1aXJlKFwiLi9zbmFwL25vZGVGcm9tSlNPTlwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi91dGlsL1BhdGhcIik7XG52YXIgU3BhcnNlU25hcHNob3RUcmVlXzEgPSByZXF1aXJlKFwiLi9TcGFyc2VTbmFwc2hvdFRyZWVcIik7XG52YXIgU3luY1RyZWVfMSA9IHJlcXVpcmUoXCIuL1N5bmNUcmVlXCIpO1xudmFyIFNuYXBzaG90SG9sZGVyXzEgPSByZXF1aXJlKFwiLi9TbmFwc2hvdEhvbGRlclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBBdXRoVG9rZW5Qcm92aWRlcl8xID0gcmVxdWlyZShcIi4vQXV0aFRva2VuUHJvdmlkZXJcIik7XG52YXIgU3RhdHNNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9zdGF0cy9TdGF0c01hbmFnZXJcIik7XG52YXIgU3RhdHNSZXBvcnRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHMvU3RhdHNSZXBvcnRlclwiKTtcbnZhciBTdGF0c0xpc3RlbmVyXzEgPSByZXF1aXJlKFwiLi9zdGF0cy9TdGF0c0xpc3RlbmVyXCIpO1xudmFyIEV2ZW50UXVldWVfMSA9IHJlcXVpcmUoXCIuL3ZpZXcvRXZlbnRRdWV1ZVwiKTtcbnZhciBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4vUGVyc2lzdGVudENvbm5lY3Rpb25cIik7XG52YXIgUmVhZG9ubHlSZXN0Q2xpZW50XzEgPSByZXF1aXJlKFwiLi9SZWFkb25seVJlc3RDbGllbnRcIik7XG52YXIgRGF0YWJhc2VfMSA9IHJlcXVpcmUoXCIuLi9hcGkvRGF0YWJhc2VcIik7XG52YXIgSU5URVJSVVBUX1JFQVNPTiA9ICdyZXBvX2ludGVycnVwdCc7XG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBkYXRhIHJlcG9zaXRvcnkuXG4gKi9cbnZhciBSZXBvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb19cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVzdENsaWVudFxuICAgICAqIEBwYXJhbSB7IUZpcmViYXNlQXBwfSBhcHBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSZXBvKHJlcG9JbmZvXywgZm9yY2VSZXN0Q2xpZW50LCBhcHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLmRhdGFVcGRhdGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RhdHNMaXN0ZW5lcl8gPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWVfID0gbmV3IEV2ZW50UXVldWVfMS5FdmVudFF1ZXVlKCk7XG4gICAgICAgIHRoaXMubmV4dFdyaXRlSWRfID0gMTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfID0gbnVsbDtcbiAgICAgICAgLy8gQSBsaXN0IG9mIGRhdGEgcGllY2VzIGFuZCBwYXRocyB0byBiZSBzZXQgd2hlbiB0aGlzIGNsaWVudCBkaXNjb25uZWN0cy5cbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gbmV3IFNwYXJzZVNuYXBzaG90VHJlZV8xLlNwYXJzZVNuYXBzaG90VHJlZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogVGhpcyBzaG91bGQgYmUgQHByaXZhdGUgYnV0IGl0J3MgdXNlZCBieSB0ZXN0X2FjY2Vzcy5qcyBhbmQgaW50ZXJuYWwuanNcbiAgICAgICAgICogQHR5cGUgez9QZXJzaXN0ZW50Q29ubmVjdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fID0gbnVsbDtcbiAgICAgICAgLyoqIEB0eXBlIHshQXV0aFRva2VuUHJvdmlkZXJ9ICovXG4gICAgICAgIHZhciBhdXRoVG9rZW5Qcm92aWRlciA9IG5ldyBBdXRoVG9rZW5Qcm92aWRlcl8xLkF1dGhUb2tlblByb3ZpZGVyKGFwcCk7XG4gICAgICAgIHRoaXMuc3RhdHNfID0gU3RhdHNNYW5hZ2VyXzEuU3RhdHNNYW5hZ2VyLmdldENvbGxlY3Rpb24ocmVwb0luZm9fKTtcbiAgICAgICAgaWYgKGZvcmNlUmVzdENsaWVudCB8fCB1dGlsXzIuYmVpbmdDcmF3bGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyXyA9IG5ldyBSZWFkb25seVJlc3RDbGllbnRfMS5SZWFkb25seVJlc3RDbGllbnQodGhpcy5yZXBvSW5mb18sIHRoaXMub25EYXRhVXBkYXRlXy5iaW5kKHRoaXMpLCBhdXRoVG9rZW5Qcm92aWRlcik7XG4gICAgICAgICAgICAvLyBNaW5vciBoYWNrOiBGaXJlIG9uQ29ubmVjdCBpbW1lZGlhdGVseSwgc2luY2UgdGhlcmUncyBubyBhY3R1YWwgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNvbm5lY3RTdGF0dXNfLmJpbmQodGhpcywgdHJ1ZSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF1dGhPdmVycmlkZSA9IGFwcC5vcHRpb25zWydkYXRhYmFzZUF1dGhWYXJpYWJsZU92ZXJyaWRlJ107XG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSBhdXRoT3ZlcnJpZGVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXV0aE92ZXJyaWRlICE9PSAndW5kZWZpbmVkJyAmJiBhdXRoT3ZlcnJpZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF1dGhPdmVycmlkZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG9iamVjdHMgYXJlIHN1cHBvcnRlZCBmb3Igb3B0aW9uIGRhdGFiYXNlQXV0aFZhcmlhYmxlT3ZlcnJpZGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLnN0cmluZ2lmeShhdXRoT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXV0aE92ZXJyaWRlIHByb3ZpZGVkOiAnICsgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8gPSBuZXcgUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbih0aGlzLnJlcG9JbmZvXywgdGhpcy5vbkRhdGFVcGRhdGVfLmJpbmQodGhpcyksIHRoaXMub25Db25uZWN0U3RhdHVzXy5iaW5kKHRoaXMpLCB0aGlzLm9uU2VydmVySW5mb1VwZGF0ZV8uYmluZCh0aGlzKSwgYXV0aFRva2VuUHJvdmlkZXIsIGF1dGhPdmVycmlkZSk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8gPSB0aGlzLnBlcnNpc3RlbnRDb25uZWN0aW9uXztcbiAgICAgICAgfVxuICAgICAgICBhdXRoVG9rZW5Qcm92aWRlci5hZGRUb2tlbkNoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgX3RoaXMuc2VydmVyXy5yZWZyZXNoQXV0aFRva2VuKHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIG11bHRpcGxlIFJlcG9zIGZvciB0aGUgc2FtZSByZXBvSW5mbyAoaS5lLiB0aGVyZSBhcmUgbXVsdGlwbGUgRmlyZWJhc2UuQ29udGV4dHMgYmVpbmcgdXNlZCksXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBjcmVhdGUgb25lIFN0YXRzUmVwb3J0ZXIuICBBcyBzdWNoLCB3ZSdsbCByZXBvcnQgc3RhdHMgb3ZlciB0aGUgZmlyc3QgUmVwbyBjcmVhdGVkLlxuICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXJfID0gU3RhdHNNYW5hZ2VyXzEuU3RhdHNNYW5hZ2VyLmdldE9yQ3JlYXRlUmVwb3J0ZXIocmVwb0luZm9fLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgU3RhdHNSZXBvcnRlcl8xLlN0YXRzUmVwb3J0ZXIoX3RoaXMuc3RhdHNfLCBfdGhpcy5zZXJ2ZXJfKTsgfSk7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zX2luaXRfKCk7XG4gICAgICAgIC8vIFVzZWQgZm9yIC5pbmZvLlxuICAgICAgICB0aGlzLmluZm9EYXRhXyA9IG5ldyBTbmFwc2hvdEhvbGRlcl8xLlNuYXBzaG90SG9sZGVyKCk7XG4gICAgICAgIHRoaXMuaW5mb1N5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZV8xLlN5bmNUcmVlKHtcbiAgICAgICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBmdW5jdGlvbiAocXVlcnksIHRhZywgY3VycmVudEhhc2hGbiwgb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvRXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5pbmZvRGF0YV8uZ2V0Tm9kZShxdWVyeS5wYXRoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHBvc3NpYmx5IGEgaGFjaywgYnV0IHdlIGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgLmluZm8gZW5kcG9pbnRzLiBXZSBkb24ndCByYWlzZSBudWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIG9uIGluaXRpYWwgZGF0YS4uLlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb0V2ZW50cyA9IF90aGlzLmluZm9TeW5jVHJlZV8uYXBwbHlTZXJ2ZXJPdmVyd3JpdGUocXVlcnkucGF0aCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZSgnb2snKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvRXZlbnRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0b3BMaXN0ZW5pbmc6IGZ1bmN0aW9uICgpIHsgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVJbmZvXygnY29ubmVjdGVkJywgZmFsc2UpO1xuICAgICAgICB0aGlzLnNlcnZlclN5bmNUcmVlXyA9IG5ldyBTeW5jVHJlZV8xLlN5bmNUcmVlKHtcbiAgICAgICAgICAgIHN0YXJ0TGlzdGVuaW5nOiBmdW5jdGlvbiAocXVlcnksIHRhZywgY3VycmVudEhhc2hGbiwgb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlcnZlcl8ubGlzdGVuKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIGZ1bmN0aW9uIChzdGF0dXMsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IG9uQ29tcGxldGUoc3RhdHVzLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChxdWVyeS5wYXRoLCBldmVudHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIE5vIHN5bmNocm9ub3VzIGV2ZW50cyBmb3IgbmV0d29yay1iYWNrZWQgc3luYyB0cmVlc1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbiAocXVlcnksIHRhZykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlcnZlcl8udW5saXN0ZW4ocXVlcnksIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICBUaGUgVVJMIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJvb3Qgb2YgdGhpcyBGaXJlYmFzZS5cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5yZXBvSW5mb18uc2VjdXJlID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJykgKyB0aGlzLnJlcG9JbmZvXy5ob3N0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFzdHJpbmd9IFRoZSBuYW1lc3BhY2UgcmVwcmVzZW50ZWQgYnkgdGhlIHJlcG8uXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwb0luZm9fLm5hbWVzcGFjZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcywgdGFraW5nIHRoZSBzZXJ2ZXIgb2Zmc2V0IGludG8gYWNjb3VudCBpZiB3ZSBoYXZlIG9uZS5cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5zZXJ2ZXJUaW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0Tm9kZSA9IHRoaXMuaW5mb0RhdGFfLmdldE5vZGUobmV3IFBhdGhfMS5QYXRoKCcuaW5mby9zZXJ2ZXJUaW1lT2Zmc2V0JykpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0Tm9kZS52YWwoKSB8fCAwO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBvZmZzZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBTZXJ2ZXJWYWx1ZXMgdXNpbmcgc29tZSB2YXJpYWJsZXMgZnJvbSB0aGUgcmVwbyBvYmplY3QuXG4gICAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5nZW5lcmF0ZVNlcnZlclZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNlcnZlclZhbHVlc18xLmdlbmVyYXRlV2l0aFZhbHVlcyh7XG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRoaXMuc2VydmVyVGltZSgpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IHJlYWx0aW1lIHdoZW4gd2UgZ2V0IG5ldyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc01lcmdlXG4gICAgICogQHBhcmFtIHs/bnVtYmVyfSB0YWdcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkRhdGFVcGRhdGVfID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIGlzTWVyZ2UsIHRhZykge1xuICAgICAgICAvLyBGb3IgdGVzdGluZy5cbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlQ291bnQrKztcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZyk7XG4gICAgICAgIGRhdGEgPSB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja19cbiAgICAgICAgICAgID8gdGhpcy5pbnRlcmNlcHRTZXJ2ZXJEYXRhQ2FsbGJhY2tfKHBhdGhTdHJpbmcsIGRhdGEpXG4gICAgICAgICAgICA6IGRhdGE7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgaWYgKGlzTWVyZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnZ2VkQ2hpbGRyZW4gPSB1dGlsXzMubWFwKGRhdGEsIGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihyYXcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VGFnZ2VkUXVlcnlNZXJnZShwYXRoLCB0YWdnZWRDaGlsZHJlbiwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0YWdnZWRTbmFwID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKGRhdGEpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VGFnZ2VkUXVlcnlPdmVyd3JpdGUocGF0aCwgdGFnZ2VkU25hcCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01lcmdlKSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZENoaWxkcmVuID0gdXRpbF8zLm1hcChkYXRhLCBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihyYXcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVNlcnZlck1lcmdlKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgc25hcCA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihkYXRhKTtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5U2VydmVyT3ZlcndyaXRlKHBhdGgsIHNuYXApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhZmZlY3RlZFBhdGggPSBwYXRoO1xuICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgYSBsaXN0ZW5lciBvdXRzdGFuZGluZyBmb3IgZWFjaCB0cmFuc2FjdGlvbiwgcmVjZWl2aW5nIGFueSBldmVudHNcbiAgICAgICAgICAgIC8vIGlzIGEgcHJveHkgZm9yIHNvbWUgY2hhbmdlIGhhdmluZyBvY2N1cnJlZC5cbiAgICAgICAgICAgIGFmZmVjdGVkUGF0aCA9IHRoaXMucmVydW5UcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChhZmZlY3RlZFBhdGgsIGV2ZW50cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBUaGlzIHNob3VsZCBiZSBAcHJpdmF0ZSBidXQgaXQncyB1c2VkIGJ5IHRlc3RfYWNjZXNzLmpzIGFuZCBpbnRlcm5hbC5qc1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCFzdHJpbmcsICopOip9IGNhbGxiYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5pbnRlcmNlcHRTZXJ2ZXJEYXRhXyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludGVyY2VwdFNlcnZlckRhdGFDYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IWJvb2xlYW59IGNvbm5lY3RTdGF0dXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uQ29ubmVjdFN0YXR1c18gPSBmdW5jdGlvbiAoY29ubmVjdFN0YXR1cykge1xuICAgICAgICB0aGlzLnVwZGF0ZUluZm9fKCdjb25uZWN0ZWQnLCBjb25uZWN0U3RhdHVzKTtcbiAgICAgICAgaWYgKGNvbm5lY3RTdGF0dXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bk9uRGlzY29ubmVjdEV2ZW50c18oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSB1cGRhdGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vblNlcnZlckluZm9VcGRhdGVfID0gZnVuY3Rpb24gKHVwZGF0ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbF8yLmVhY2godXBkYXRlcywgZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUluZm9fKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUudXBkYXRlSW5mb18gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aF8xLlBhdGgoJy8uaW5mby8nICsgcGF0aFN0cmluZyk7XG4gICAgICAgIHZhciBuZXdOb2RlID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbmZvRGF0YV8udXBkYXRlU25hcHNob3QocGF0aCwgbmV3Tm9kZSk7XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8uYXBwbHlTZXJ2ZXJPdmVyd3JpdGUocGF0aCwgbmV3Tm9kZSk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBldmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLmdldE5leHRXcml0ZUlkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFdyaXRlSWRfKys7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWxcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8bnVsbH0gbmV3UHJpb3JpdHlcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwYXRoLCBuZXdWYWwsIG5ld1ByaW9yaXR5LCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nXygnc2V0Jywge1xuICAgICAgICAgICAgcGF0aDogcGF0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbCxcbiAgICAgICAgICAgIHByaW9yaXR5OiBuZXdQcmlvcml0eVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVE9ETzogT3B0aW1pemUgdGhpcyBiZWhhdmlvciB0byBlaXRoZXIgKGEpIHN0b3JlIGZsYWcgdG8gc2tpcCByZXNvbHZpbmcgd2hlcmUgcG9zc2libGUgYW5kIC8gb3JcbiAgICAgICAgLy8gKGIpIHN0b3JlIHVucmVzb2x2ZWQgcGF0aHMgb24gSlNPTiBwYXJzZVxuICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04obmV3VmFsLCBuZXdQcmlvcml0eSk7XG4gICAgICAgIHZhciBuZXdOb2RlID0gU2VydmVyVmFsdWVzXzEucmVzb2x2ZURlZmVycmVkVmFsdWVTbmFwc2hvdChuZXdOb2RlVW5yZXNvbHZlZCwgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgdmFyIHdyaXRlSWQgPSB0aGlzLmdldE5leHRXcml0ZUlkXygpO1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlVc2VyT3ZlcndyaXRlKHBhdGgsIG5ld05vZGUsIHdyaXRlSWQsIHRydWUpO1xuICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gICAgICAgIHRoaXMuc2VydmVyXy5wdXQocGF0aC50b1N0cmluZygpLCBuZXdOb2RlVW5yZXNvbHZlZC52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9IHN0YXR1cyA9PT0gJ29rJztcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHV0aWxfMi53YXJuKCdzZXQgYXQgJyArIHBhdGggKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xlYXJFdmVudHMgPSBfdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHdyaXRlSWQsICFzdWNjZXNzKTtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgY2xlYXJFdmVudHMpO1xuICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhZmZlY3RlZFBhdGggPSB0aGlzLmFib3J0VHJhbnNhY3Rpb25zXyhwYXRoKTtcbiAgICAgICAgdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKGFmZmVjdGVkUGF0aCwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY2hpbGRyZW5Ub01lcmdlXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocGF0aCwgY2hpbGRyZW5Ub01lcmdlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nXygndXBkYXRlJywgeyBwYXRoOiBwYXRoLnRvU3RyaW5nKCksIHZhbHVlOiBjaGlsZHJlblRvTWVyZ2UgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggb3VyIGV4aXN0aW5nIGRhdGEgYW5kIG1lcmdlIGVhY2ggY2hpbGQgaW50byBpdC5cbiAgICAgICAgdmFyIGVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlcnZlclZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVTZXJ2ZXJWYWx1ZXMoKTtcbiAgICAgICAgdmFyIGNoYW5nZWRDaGlsZHJlbiA9IHt9O1xuICAgICAgICB1dGlsXzMuZm9yRWFjaChjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChjaGFuZ2VkS2V5LCBjaGFuZ2VkVmFsdWUpIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04oY2hhbmdlZFZhbHVlKTtcbiAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbltjaGFuZ2VkS2V5XSA9IFNlcnZlclZhbHVlc18xLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIHNlcnZlclZhbHVlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVtcHR5KSB7XG4gICAgICAgICAgICB2YXIgd3JpdGVJZF8xID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVVzZXJNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWRfMSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50UXVldWVfLnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcl8ubWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSBzdGF0dXMgPT09ICdvayc7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMi53YXJuKCd1cGRhdGUgYXQgJyArIHBhdGggKyAnIGZhaWxlZDogJyArIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjbGVhckV2ZW50cyA9IF90aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUod3JpdGVJZF8xLCAhc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkUGF0aCA9IGNsZWFyRXZlbnRzLmxlbmd0aCA+IDAgPyBfdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18ocGF0aCkgOiBwYXRoO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgoYWZmZWN0ZWRQYXRoLCBjbGVhckV2ZW50cyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXRpbF8zLmZvckVhY2goY2hpbGRyZW5Ub01lcmdlLCBmdW5jdGlvbiAoY2hhbmdlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gX3RoaXMuYWJvcnRUcmFuc2FjdGlvbnNfKHBhdGguY2hpbGQoY2hhbmdlZFBhdGgpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18oYWZmZWN0ZWRQYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2UgcXVldWVkIHRoZSBldmVudHMgYWJvdmUsIHNvIGp1c3QgZmx1c2ggdGhlIHF1ZXVlIGhlcmVcbiAgICAgICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChwYXRoLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzIubG9nKFwidXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCAnb2snKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhbGwgb2YgdGhlIGNoYW5nZXMgc3RvcmVkIHVwIGluIHRoZSBvbkRpc2Nvbm5lY3RfIHRyZWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5ydW5PbkRpc2Nvbm5lY3RFdmVudHNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdEV2ZW50cycpO1xuICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICB2YXIgcmVzb2x2ZWRPbkRpc2Nvbm5lY3RUcmVlID0gU2VydmVyVmFsdWVzXzEucmVzb2x2ZURlZmVycmVkVmFsdWVUcmVlKHRoaXMub25EaXNjb25uZWN0Xywgc2VydmVyVmFsdWVzKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICByZXNvbHZlZE9uRGlzY29ubmVjdFRyZWUuZm9yRWFjaFRyZWUoUGF0aF8xLlBhdGguRW1wdHksIGZ1bmN0aW9uIChwYXRoLCBzbmFwKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KF90aGlzLnNlcnZlclN5bmNUcmVlXy5hcHBseVNlcnZlck92ZXJ3cml0ZShwYXRoLCBzbmFwKSk7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRQYXRoID0gX3RoaXMuYWJvcnRUcmFuc2FjdGlvbnNfKHBhdGgpO1xuICAgICAgICAgICAgX3RoaXMucmVydW5UcmFuc2FjdGlvbnNfKGFmZmVjdGVkUGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBuZXcgU3BhcnNlU25hcHNob3RUcmVlXzEuU3BhcnNlU25hcHNob3RUcmVlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChQYXRoXzEuUGF0aC5FbXB0eSwgZXZlbnRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/RXJyb3IsICo9KX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFJlcG8ucHJvdG90eXBlLm9uRGlzY29ubmVjdENhbmNlbCA9IGZ1bmN0aW9uIChwYXRoLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2VydmVyXy5vbkRpc2Nvbm5lY3RDYW5jZWwocGF0aC50b1N0cmluZygpLCBmdW5jdGlvbiAoc3RhdHVzLCBlcnJvclJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRGlzY29ubmVjdF8uZm9yZ2V0KHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCBzdGF0dXMsIGVycm9yUmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25EaXNjb25uZWN0U2V0ID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdOb2RlID0gbm9kZUZyb21KU09OXzEubm9kZUZyb21KU09OKHZhbHVlKTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJfLm9uRGlzY29ubmVjdFB1dChwYXRoLnRvU3RyaW5nKCksIG5ld05vZGUudmFsKC8qZXhwb3J0PSovIHRydWUpLCBmdW5jdGlvbiAoc3RhdHVzLCBlcnJvclJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ29rJykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRGlzY29ubmVjdF8ucmVtZW1iZXIocGF0aCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jYWxsT25Db21wbGV0ZUNhbGxiYWNrKG9uQ29tcGxldGUsIHN0YXR1cywgZXJyb3JSZWFzb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBwcmlvcml0eVxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBvbkNvbXBsZXRlXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUub25EaXNjb25uZWN0U2V0V2l0aFByaW9yaXR5ID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBwcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTih2YWx1ZSwgcHJpb3JpdHkpO1xuICAgICAgICB0aGlzLnNlcnZlcl8ub25EaXNjb25uZWN0UHV0KHBhdGgudG9TdHJpbmcoKSwgbmV3Tm9kZS52YWwoLypleHBvcnQ9Ki8gdHJ1ZSksIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25EaXNjb25uZWN0Xy5yZW1lbWJlcihwYXRoLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sob25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7Kn0gY2hpbGRyZW5Ub01lcmdlXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oP0Vycm9yLCAqPSl9IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RVcGRhdGUgPSBmdW5jdGlvbiAocGF0aCwgY2hpbGRyZW5Ub01lcmdlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1dGlsXzMuaXNFbXB0eShjaGlsZHJlblRvTWVyZ2UpKSB7XG4gICAgICAgICAgICB1dGlsXzIubG9nKFwib25EaXNjb25uZWN0KCkudXBkYXRlKCkgY2FsbGVkIHdpdGggZW1wdHkgZGF0YS4gIERvbid0IGRvIGFueXRoaW5nLlwiKTtcbiAgICAgICAgICAgIHRoaXMuY2FsbE9uQ29tcGxldGVDYWxsYmFjayhvbkNvbXBsZXRlLCAnb2snKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlcl8ub25EaXNjb25uZWN0TWVyZ2UocGF0aC50b1N0cmluZygpLCBjaGlsZHJlblRvTWVyZ2UsIGZ1bmN0aW9uIChzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8zLmZvckVhY2goY2hpbGRyZW5Ub01lcmdlLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkTm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkRpc2Nvbm5lY3RfLnJlbWVtYmVyKHBhdGguY2hpbGQoY2hpbGROYW1lKSwgbmV3Q2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmNhbGxPbkNvbXBsZXRlQ2FsbGJhY2sob25Db21wbGV0ZSwgc3RhdHVzLCBlcnJvclJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUuYWRkRXZlbnRDYWxsYmFja0ZvclF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgZXZlbnRzO1xuICAgICAgICBpZiAocXVlcnkucGF0aC5nZXRGcm9udCgpID09PSAnLmluZm8nKSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8uYWRkRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFkZEV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0F0UGF0aChxdWVyeS5wYXRoLCBldmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHs/RXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICovXG4gICAgUmVwby5wcm90b3R5cGUucmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICAvLyBUaGVzZSBhcmUgZ3VhcmFudGVlZCBub3QgdG8gcmFpc2UgZXZlbnRzLCBzaW5jZSB3ZSdyZSBub3QgcGFzc2luZyBpbiBhIGNhbmNlbEVycm9yLiBIb3dldmVyLCB3ZSBjYW4gZnV0dXJlLXByb29mXG4gICAgICAgIC8vIGEgbGl0dGxlIGJpdCBieSBoYW5kbGluZyB0aGUgcmV0dXJuIHZhbHVlcyBhbnl3YXlzLlxuICAgICAgICB2YXIgZXZlbnRzO1xuICAgICAgICBpZiAocXVlcnkucGF0aC5nZXRGcm9udCgpID09PSAnLmluZm8nKSB7XG4gICAgICAgICAgICBldmVudHMgPSB0aGlzLmluZm9TeW5jVHJlZV8ucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0F0UGF0aChxdWVyeS5wYXRoLCBldmVudHMpO1xuICAgIH07XG4gICAgUmVwby5wcm90b3R5cGUuaW50ZXJydXB0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fLmludGVycnVwdChJTlRFUlJVUFRfUkVBU09OKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwby5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcbiAgICAgICAgICAgIHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fLnJlc3VtZShJTlRFUlJVUFRfUkVBU09OKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVwby5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbiAoc2hvd0RlbHRhKSB7XG4gICAgICAgIGlmIChzaG93RGVsdGEgPT09IHZvaWQgMCkgeyBzaG93RGVsdGEgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgc3RhdHM7XG4gICAgICAgIGlmIChzaG93RGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0c0xpc3RlbmVyXylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRzTGlzdGVuZXJfID0gbmV3IFN0YXRzTGlzdGVuZXJfMS5TdGF0c0xpc3RlbmVyKHRoaXMuc3RhdHNfKTtcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0c0xpc3RlbmVyXy5nZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRzID0gdGhpcy5zdGF0c18uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvbmdlc3ROYW1lID0gT2JqZWN0LmtleXMoc3RhdHMpLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoY3VycmVudFZhbHVlLmxlbmd0aCwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICB1dGlsXzMuZm9yRWFjaChzdGF0cywgZnVuY3Rpb24gKHN0YXQsIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBwYWQgc3RhdCBuYW1lcyB0byBiZSB0aGUgc2FtZSBsZW5ndGggKHBsdXMgMiBleHRyYSBzcGFjZXMpLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXQubGVuZ3RoOyBpIDwgbG9uZ2VzdE5hbWUgKyAyOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdCArPSAnICc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdGF0ICsgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlcG8ucHJvdG90eXBlLnN0YXRzSW5jcmVtZW50Q291bnRlciA9IGZ1bmN0aW9uIChtZXRyaWMpIHtcbiAgICAgICAgdGhpcy5zdGF0c18uaW5jcmVtZW50Q291bnRlcihtZXRyaWMpO1xuICAgICAgICB0aGlzLnN0YXRzUmVwb3J0ZXJfLmluY2x1ZGVTdGF0KG1ldHJpYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5sb2dfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5wZXJzaXN0ZW50Q29ubmVjdGlvbl8pIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMucGVyc2lzdGVudENvbm5lY3Rpb25fLmlkICsgJzonO1xuICAgICAgICB9XG4gICAgICAgIHV0aWxfMi5sb2cuYXBwbHkodm9pZCAwLCBbcHJlZml4XS5jb25jYXQodmFyX2FyZ3MpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgKj0pfSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gc3RhdHVzXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0gZXJyb3JSZWFzb25cbiAgICAgKi9cbiAgICBSZXBvLnByb3RvdHlwZS5jYWxsT25Db21wbGV0ZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBzdGF0dXMsIGVycm9yUmVhc29uKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdXRpbF8yLmV4Y2VwdGlvbkd1YXJkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09ICdvaycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IChzdGF0dXMgfHwgJ2Vycm9yJykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBjb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JSZWFzb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICc6ICcgKyBlcnJvclJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVwby5wcm90b3R5cGUsIFwiZGF0YWJhc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YWJhc2UgfHwgKHRoaXMuX19kYXRhYmFzZSA9IG5ldyBEYXRhYmFzZV8xLkRhdGFiYXNlKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFJlcG87XG59KCkpO1xuZXhwb3J0cy5SZXBvID0gUmVwbztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwby5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBjYWNoZSBub2RlIG9ubHkgc3RvcmVzIGNvbXBsZXRlIGNoaWxkcmVuLiBBZGRpdGlvbmFsbHkgaXQgaG9sZHMgYSBmbGFnIHdoZXRoZXIgdGhlIG5vZGUgY2FuIGJlIGNvbnNpZGVyZWQgZnVsbHlcbiAqIGluaXRpYWxpemVkIGluIHRoZSBzZW5zZSB0aGF0IHdlIGtub3cgYXQgb25lIHBvaW50IGluIHRpbWUgdGhpcyByZXByZXNlbnRlZCBhIHZhbGlkIHN0YXRlIG9mIHRoZSB3b3JsZCwgZS5nLlxuICogaW5pdGlhbGl6ZWQgd2l0aCBkYXRhIGZyb20gdGhlIHNlcnZlciwgb3IgYSBjb21wbGV0ZSBvdmVyd3JpdGUgYnkgdGhlIGNsaWVudC4gVGhlIGZpbHRlcmVkIGZsYWcgYWxzbyB0cmFja3NcbiAqIHdoZXRoZXIgYSBub2RlIHBvdGVudGlhbGx5IGhhZCBjaGlsZHJlbiByZW1vdmVkIGR1ZSB0byBhIGZpbHRlci5cbiAqL1xudmFyIENhY2hlTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlX1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZnVsbHlJbml0aWFsaXplZF9cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlcmVkX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhY2hlTm9kZShub2RlXywgZnVsbHlJbml0aWFsaXplZF8sIGZpbHRlcmVkXykge1xuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XG4gICAgICAgIHRoaXMuZnVsbHlJbml0aWFsaXplZF8gPSBmdWxseUluaXRpYWxpemVkXztcbiAgICAgICAgdGhpcy5maWx0ZXJlZF8gPSBmaWx0ZXJlZF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgd2FzIGZ1bGx5IGluaXRpYWxpemVkIHdpdGggZWl0aGVyIHNlcnZlciBkYXRhIG9yIGEgY29tcGxldGUgb3ZlcndyaXRlIGJ5IHRoZSBjbGllbnRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuaXNGdWxseUluaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxseUluaXRpYWxpemVkXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIG5vZGUgaXMgcG90ZW50aWFsbHkgbWlzc2luZyBjaGlsZHJlbiBkdWUgdG8gYSBmaWx0ZXIgYXBwbGllZCB0byB0aGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ2FjaGVOb2RlLnByb3RvdHlwZS5pc0ZpbHRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJlZF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDYWNoZU5vZGUucHJvdG90eXBlLmlzQ29tcGxldGVGb3JQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSAmJiAhdGhpcy5maWx0ZXJlZF87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuaXNDb21wbGV0ZUZvckNoaWxkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmlzRnVsbHlJbml0aWFsaXplZCgpICYmICF0aGlzLmZpbHRlcmVkXykgfHwgdGhpcy5ub2RlXy5oYXNDaGlsZChrZXkpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIENhY2hlTm9kZS5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV87XG4gICAgfTtcbiAgICByZXR1cm4gQ2FjaGVOb2RlO1xufSgpKTtcbmV4cG9ydHMuQ2FjaGVOb2RlID0gQ2FjaGVOb2RlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZU5vZGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9DYWNoZU5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBDT0RFUyA9IHtcbiAgICBBVkFJTEFCTEVfSU5fV0lORE9XOiAnb25seS1hdmFpbGFibGUtaW4td2luZG93JyxcbiAgICBBVkFJTEFCTEVfSU5fU1c6ICdvbmx5LWF2YWlsYWJsZS1pbi1zdycsXG4gICAgU0hPVUxEX0JFX0lOSEVSSVRFRDogJ3Nob3VsZC1iZS1vdmVycmlkZW4nLFxuICAgIEJBRF9TRU5ERVJfSUQ6ICdiYWQtc2VuZGVyLWlkJyxcbiAgICBJTkNPUlJFQ1RfR0NNX1NFTkRFUl9JRDogJ2luY29ycmVjdC1nY20tc2VuZGVyLWlkJyxcbiAgICBQRVJNSVNTSU9OX0RFRkFVTFQ6ICdwZXJtaXNzaW9uLWRlZmF1bHQnLFxuICAgIFBFUk1JU1NJT05fQkxPQ0tFRDogJ3Blcm1pc3Npb24tYmxvY2tlZCcsXG4gICAgVU5TVVBQT1JURURfQlJPV1NFUjogJ3Vuc3VwcG9ydGVkLWJyb3dzZXInLFxuICAgIE5PVElGSUNBVElPTlNfQkxPQ0tFRDogJ25vdGlmaWNhdGlvbnMtYmxvY2tlZCcsXG4gICAgRkFJTEVEX0RFRkFVTFRfUkVHSVNUUkFUSU9OOiAnZmFpbGVkLXNlcnZpY2V3b3JrZXItcmVnaXN0cmF0aW9uJyxcbiAgICBTV19SRUdJU1RSQVRJT05fRVhQRUNURUQ6ICdzdy1yZWdpc3RyYXRpb24tZXhwZWN0ZWQnLFxuICAgIEdFVF9TVUJTQ1JJUFRJT05fRkFJTEVEOiAnZ2V0LXN1YnNjcmlwdGlvbi1mYWlsZWQnLFxuICAgIElOVkFMSURfU0FWRURfVE9LRU46ICdpbnZhbGlkLXNhdmVkLXRva2VuJyxcbiAgICBTV19SRUdfUkVEVU5EQU5UOiAnc3ctcmVnLXJlZHVuZGFudCcsXG4gICAgVE9LRU5fU1VCU0NSSUJFX0ZBSUxFRDogJ3Rva2VuLXN1YnNjcmliZS1mYWlsZWQnLFxuICAgIFRPS0VOX1NVQlNDUklCRV9OT19UT0tFTjogJ3Rva2VuLXN1YnNjcmliZS1uby10b2tlbicsXG4gICAgVE9LRU5fU1VCU0NSSUJFX05PX1BVU0hfU0VUOiAndG9rZW4tc3Vic2NyaWJlLW5vLXB1c2gtc2V0JyxcbiAgICBVU0VfU1dfQkVGT1JFX0dFVF9UT0tFTjogJ3VzZS1zdy1iZWZvcmUtZ2V0LXRva2VuJyxcbiAgICBJTlZBTElEX0RFTEVURV9UT0tFTjogJ2ludmFsaWQtZGVsZXRlLXRva2VuJyxcbiAgICBERUxFVEVfVE9LRU5fTk9UX0ZPVU5EOiAnZGVsZXRlLXRva2VuLW5vdC1mb3VuZCcsXG4gICAgREVMRVRFX1NDT1BFX05PVF9GT1VORDogJ2RlbGV0ZS1zY29wZS1ub3QtZm91bmQnLFxuICAgIEJHX0hBTkRMRVJfRlVOQ1RJT05fRVhQRUNURUQ6ICdiZy1oYW5kbGVyLWZ1bmN0aW9uLWV4cGVjdGVkJyxcbiAgICBOT19XSU5ET1dfQ0xJRU5UX1RPX01TRzogJ25vLXdpbmRvdy1jbGllbnQtdG8tbXNnJyxcbiAgICBVTkFCTEVfVE9fUkVTVUJTQ1JJQkU6ICd1bmFibGUtdG8tcmVzdWJzY3JpYmUnLFxuICAgIE5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkU6ICduby1mY20tdG9rZW4tZm9yLXJlc3Vic2NyaWJlJyxcbiAgICBGQUlMRURfVE9fREVMRVRFX1RPS0VOOiAnZmFpbGVkLXRvLWRlbGV0ZS10b2tlbicsXG4gICAgTk9fU1dfSU5fUkVHOiAnbm8tc3ctaW4tcmVnJyxcbiAgICBCQURfU0NPUEU6ICdiYWQtc2NvcGUnLFxuICAgIEJBRF9WQVBJRF9LRVk6ICdiYWQtdmFwaWQta2V5JyxcbiAgICBCQURfU1VCU0NSSVBUSU9OOiAnYmFkLXN1YnNjcmlwdGlvbicsXG4gICAgQkFEX1RPS0VOOiAnYmFkLXRva2VuJyxcbiAgICBCQURfUFVTSF9TRVQ6ICdiYWQtcHVzaC1zZXQnLFxuICAgIEZBSUxFRF9ERUxFVEVfVkFQSURfS0VZOiAnZmFpbGVkLWRlbGV0ZS12YXBpZC1rZXknXG59O1xudmFyIEVSUk9SX01BUCA9IChfYSA9IHt9LFxuICAgIF9hW0NPREVTLkFWQUlMQUJMRV9JTl9XSU5ET1ddID0gJ1RoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBpbiBhIFdpbmRvdyBjb250ZXh0LicsXG4gICAgX2FbQ09ERVMuQVZBSUxBQkxFX0lOX1NXXSA9ICdUaGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgaW4gYSBzZXJ2aWNlIHdvcmtlciAnICsgJ2NvbnRleHQuJyxcbiAgICBfYVtDT0RFUy5TSE9VTERfQkVfSU5IRVJJVEVEXSA9ICdUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGVuIGJ5ICcgKyAnZXh0ZW5kZWQgY2xhc3Nlcy4nLFxuICAgIF9hW0NPREVTLkJBRF9TRU5ERVJfSURdID0gXCJQbGVhc2UgZW5zdXJlIHRoYXQgJ21lc3NhZ2luZ1NlbmRlcklkJyBpcyBzZXQgXCIgK1xuICAgICAgICAnY29ycmVjdGx5IGluIHRoZSBvcHRpb25zIHBhc3NlZCBpbnRvIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKS4nLFxuICAgIF9hW0NPREVTLlBFUk1JU1NJT05fREVGQVVMVF0gPSAnVGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zIHdlcmUgbm90IGdyYW50ZWQgYW5kICcgKyAnZGlzbWlzc2VkIGluc3RlYWQuJyxcbiAgICBfYVtDT0RFUy5QRVJNSVNTSU9OX0JMT0NLRURdID0gJ1RoZSByZXF1aXJlZCBwZXJtaXNzaW9ucyB3ZXJlIG5vdCBncmFudGVkIGFuZCAnICsgJ2Jsb2NrZWQgaW5zdGVhZC4nLFxuICAgIF9hW0NPREVTLlVOU1VQUE9SVEVEX0JST1dTRVJdID0gXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBBUEkncyBcIiArXG4gICAgICAgICdyZXF1aXJlZCB0byB1c2UgdGhlIGZpcmViYXNlIFNESy4nLFxuICAgIF9hW0NPREVTLk5PVElGSUNBVElPTlNfQkxPQ0tFRF0gPSAnTm90aWZpY2F0aW9ucyBoYXZlIGJlZW4gYmxvY2tlZC4nLFxuICAgIF9hW0NPREVTLkZBSUxFRF9ERUZBVUxUX1JFR0lTVFJBVElPTl0gPSAnV2UgYXJlIHVuYWJsZSB0byByZWdpc3RlciB0aGUgJyArXG4gICAgICAgICdkZWZhdWx0IHNlcnZpY2Ugd29ya2VyLiB7JGJyb3dzZXJFcnJvck1lc3NhZ2V9JyxcbiAgICBfYVtDT0RFUy5TV19SRUdJU1RSQVRJT05fRVhQRUNURURdID0gJ0Egc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHdhcyB0aGUgJyArICdleHBlY3RlZCBpbnB1dC4nLFxuICAgIF9hW0NPREVTLkdFVF9TVUJTQ1JJUFRJT05fRkFJTEVEXSA9ICdUaGVyZSB3YXMgYW4gZXJyb3Igd2hlbiB0cnlpbmcgdG8gZ2V0ICcgK1xuICAgICAgICAnYW55IGV4aXN0aW5nIFB1c2ggU3Vic2NyaXB0aW9ucy4nLFxuICAgIF9hW0NPREVTLklOVkFMSURfU0FWRURfVE9LRU5dID0gJ1VuYWJsZSB0byBhY2Nlc3MgZGV0YWlscyBvZiB0aGUgc2F2ZWQgdG9rZW4uJyxcbiAgICBfYVtDT0RFUy5TV19SRUdfUkVEVU5EQU5UXSA9ICdUaGUgc2VydmljZSB3b3JrZXIgYmVpbmcgdXNlZCBmb3IgcHVzaCB3YXMgbWFkZSAnICsgJ3JlZHVuZGFudC4nLFxuICAgIF9hW0NPREVTLlRPS0VOX1NVQlNDUklCRV9GQUlMRURdID0gJ0EgcHJvYmxlbSBvY2N1cmVkIHdoaWxlIHN1YnNjcmliaW5nIHRoZSAnICsgJ3VzZXIgdG8gRkNNOiB7JG1lc3NhZ2V9JyxcbiAgICBfYVtDT0RFUy5UT0tFTl9TVUJTQ1JJQkVfTk9fVE9LRU5dID0gJ0ZDTSByZXR1cm5lZCBubyB0b2tlbiB3aGVuIHN1YnNjcmliaW5nICcgKyAndGhlIHVzZXIgdG8gcHVzaC4nLFxuICAgIF9hW0NPREVTLlRPS0VOX1NVQlNDUklCRV9OT19QVVNIX1NFVF0gPSAnRkNNIHJldHVybmVkIGFuIGludmFsaWQgcmVzcG9uc2UgJyArICd3aGVuIGdldHRpbmcgYW4gRkNNIHRva2VuLicsXG4gICAgX2FbQ09ERVMuVVNFX1NXX0JFRk9SRV9HRVRfVE9LRU5dID0gJ1lvdSBtdXN0IGNhbGwgdXNlU2VydmljZVdvcmtlcigpIGJlZm9yZSAnICtcbiAgICAgICAgJ2NhbGxpbmcgZ2V0VG9rZW4oKSB0byBlbnN1cmUgeW91ciBzZXJ2aWNlIHdvcmtlciBpcyB1c2VkLicsXG4gICAgX2FbQ09ERVMuSU5WQUxJRF9ERUxFVEVfVE9LRU5dID0gJ1lvdSBtdXN0IHBhc3MgYSB2YWxpZCB0b2tlbiBpbnRvICcgK1xuICAgICAgICAnZGVsZXRlVG9rZW4oKSwgaS5lLiB0aGUgdG9rZW4gZnJvbSBnZXRUb2tlbigpLicsXG4gICAgX2FbQ09ERVMuREVMRVRFX1RPS0VOX05PVF9GT1VORF0gPSAnVGhlIGRlbGV0aW9uIGF0dGVtcHQgZm9yIHRva2VuIGNvdWxkIG5vdCAnICtcbiAgICAgICAgJ2JlIHBlcmZvcm1lZCBhcyB0aGUgdG9rZW4gd2FzIG5vdCBmb3VuZC4nLFxuICAgIF9hW0NPREVTLkRFTEVURV9TQ09QRV9OT1RfRk9VTkRdID0gJ1RoZSBkZWxldGlvbiBhdHRlbXB0IGZvciBzZXJ2aWNlIHdvcmtlciAnICtcbiAgICAgICAgJ3Njb3BlIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgYXMgdGhlIHNjb3BlIHdhcyBub3QgZm91bmQuJyxcbiAgICBfYVtDT0RFUy5CR19IQU5ETEVSX0ZVTkNUSU9OX0VYUEVDVEVEXSA9ICdUaGUgaW5wdXQgdG8gJyArICdzZXRCYWNrZ3JvdW5kTWVzc2FnZUhhbmRsZXIoKSBtdXN0IGJlIGEgZnVuY3Rpb24uJyxcbiAgICBfYVtDT0RFUy5OT19XSU5ET1dfQ0xJRU5UX1RPX01TR10gPSAnQW4gYXR0ZW1wdCB3YXMgbWFkZSB0byBtZXNzYWdlIGEgJyArICdub24tZXhpc3RhbnQgd2luZG93IGNsaWVudC4nLFxuICAgIF9hW0NPREVTLlVOQUJMRV9UT19SRVNVQlNDUklCRV0gPSAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIHJlLXN1YnNjcmliaW5nICcgK1xuICAgICAgICAndGhlIEZDTSB0b2tlbiBmb3IgcHVzaCBtZXNzYWdpbmcuIFdpbGwgaGF2ZSB0byByZXN1YnNjcmliZSB0aGUgJyArXG4gICAgICAgICd1c2VyIG9uIG5leHQgdmlzaXQuIHskbWVzc2FnZX0nLFxuICAgIF9hW0NPREVTLk5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkVdID0gJ0NvdWxkIG5vdCBmaW5kIGFuIEZDTSB0b2tlbiAnICtcbiAgICAgICAgJ2FuZCBhcyBhIHJlc3VsdCwgdW5hYmxlIHRvIHJlc3Vic2NyaWJlLiBXaWxsIGhhdmUgdG8gcmVzdWJzY3JpYmUgdGhlICcgK1xuICAgICAgICAndXNlciBvbiBuZXh0IHZpc2l0LicsXG4gICAgX2FbQ09ERVMuRkFJTEVEX1RPX0RFTEVURV9UT0tFTl0gPSAnVW5hYmxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudGx5IHNhdmVkIHRva2VuLicsXG4gICAgX2FbQ09ERVMuTk9fU1dfSU5fUkVHXSA9ICdFdmVuIHRob3VnaCB0aGUgc2VydmljZSB3b3JrZXIgcmVnaXN0cmF0aW9uIHdhcyAnICtcbiAgICAgICAgJ3N1Y2Nlc3NmdWwsIHRoZXJlIHdhcyBhIHByb2JsZW0gYWNjZXNzaW5nIHRoZSBzZXJ2aWNlIHdvcmtlciBpdHNlbGYuJyxcbiAgICBfYVtDT0RFUy5JTkNPUlJFQ1RfR0NNX1NFTkRFUl9JRF0gPSBcIlBsZWFzZSBjaGFuZ2UgeW91ciB3ZWIgYXBwIG1hbmlmZXN0J3MgXCIgK1xuICAgICAgICBcIidnY21fc2VuZGVyX2lkJyB2YWx1ZSB0byAnMTAzOTUzODAwNTA3JyB0byB1c2UgRmlyZWJhc2UgbWVzc2FnaW5nLlwiLFxuICAgIF9hW0NPREVTLkJBRF9TQ09QRV0gPSAnVGhlIHNlcnZpY2Ugd29ya2VyIHNjb3BlIG11c3QgYmUgYSBzdHJpbmcgd2l0aCBhdCAnICtcbiAgICAgICAgJ2xlYXN0IG9uZSBjaGFyYWN0ZXIuJyxcbiAgICBfYVtDT0RFUy5CQURfVkFQSURfS0VZXSA9ICdUaGUgcHVibGljIFZBUElEIGtleSBtdXN0IGJlIGEgc3RyaW5nIHdpdGggYXQgJyArICdsZWFzdCBvbmUgY2hhcmFjdGVyLicsXG4gICAgX2FbQ09ERVMuQkFEX1NVQlNDUklQVElPTl0gPSAnVGhlIHN1YnNjcmlwdGlvbiBtdXN0IGJlIGEgdmFsaWQgJyArICdQdXNoU3Vic2NyaXB0aW9uLicsXG4gICAgX2FbQ09ERVMuQkFEX1RPS0VOXSA9ICdUaGUgRkNNIFRva2VuIHVzZWQgZm9yIHN0b3JhZ2UgLyBsb29rdXAgd2FzIG5vdCAnICtcbiAgICAgICAgJ2EgdmFsaWQgdG9rZW4gc3RyaW5nLicsXG4gICAgX2FbQ09ERVMuQkFEX1BVU0hfU0VUXSA9ICdUaGUgRkNNIHB1c2ggc2V0IHVzZWQgZm9yIHN0b3JhZ2UgLyBsb29rdXAgd2FzIG5vdCAnICtcbiAgICAgICAgJ25vdCBhIHZhbGlkIHB1c2ggc2V0IHN0cmluZy4nLFxuICAgIF9hW0NPREVTLkZBSUxFRF9ERUxFVEVfVkFQSURfS0VZXSA9ICdUaGUgVkFQSUQga2V5IGNvdWxkIG5vdCBiZSBkZWxldGVkLicsXG4gICAgX2EpO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvZGVzOiBDT0RFUyxcbiAgICBtYXA6IEVSUk9SX01BUFxufTtcbnZhciBfYTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvbW9kZWxzL2Vycm9ycy5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IENvbnN0YW50cyB1c2VkIGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIGxpYnJhcnkuXG4gKi9cbi8qKlxuICogRG9tYWluIGFuZCBzY2hlbWUgZm9yIEFQSSBjYWxscy5cbiAqL1xuZXhwb3J0IHZhciBkb21haW5CYXNlID0gJ2h0dHBzOi8vZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tJztcbi8qKlxuICogRG9tYWluIGFuZCBzY2hlbWUgZm9yIG9iamVjdCBkb3dubG9hZHMuXG4gKi9cbmV4cG9ydCB2YXIgZG93bmxvYWRCYXNlID0gJ2h0dHBzOi8vZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tJztcbi8qKlxuICogQmFzZSBVUkwgZm9yIG5vbi11cGxvYWQgY2FsbHMgdG8gdGhlIEFQSS5cbiAqL1xuZXhwb3J0IHZhciBhcGlCYXNlVXJsID0gJy92MCc7XG4vKipcbiAqIEJhc2UgVVJMIGZvciB1cGxvYWQgY2FsbHMgdG8gdGhlIEFQSS5cbiAqL1xuZXhwb3J0IHZhciBhcGlVcGxvYWRCYXNlVXJsID0gJy92MCc7XG5leHBvcnQgZnVuY3Rpb24gc2V0RG9tYWluQmFzZShkb21haW5CYXNlKSB7XG4gICAgZG9tYWluQmFzZSA9IGRvbWFpbkJhc2U7XG59XG5leHBvcnQgdmFyIGNvbmZpZ09wdGlvbiA9ICdzdG9yYWdlQnVja2V0Jztcbi8qKlxuICogMSBtaW51dGVcbiAqL1xuZXhwb3J0IHZhciBzaG9ydE1heE9wZXJhdGlvblJldHJ5VGltZSA9IDEgKiA2MCAqIDEwMDA7XG4vKipcbiAqIDIgbWludXRlc1xuICovXG5leHBvcnQgdmFyIGRlZmF1bHRNYXhPcGVyYXRpb25SZXRyeVRpbWUgPSAyICogNjAgKiAxMDAwO1xuLyoqXG4gKiAxMCBtaW51dGVzXG4gKi9cbmV4cG9ydCB2YXIgZGVmYXVsdE1heFVwbG9hZFJldHJ5VGltZSA9IDEwICogNjAgKiAxMDA7XG4vKipcbiAqIFRoaXMgaXMgdGhlIHZhbHVlIG9mIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLCB3aGljaCBpcyBub3Qgd2VsbCBzdXBwb3J0ZWRcbiAqIGVub3VnaCBmb3IgdXMgdG8gdXNlIGl0IGRpcmVjdGx5LlxuICovXG5leHBvcnQgdmFyIG1pblNhZmVJbnRlZ2VyID0gLTkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBGdW5jdGlvbmFsaXR5IHJlbGF0ZWQgdG8gdGhlIHBhcnNpbmcvY29tcG9zaXRpb24gb2YgYnVja2V0L1xuICogb2JqZWN0IGxvY2F0aW9uLlxuICovXG5pbXBvcnQgKiBhcyBlcnJvcnNFeHBvcnRzIGZyb20gJy4vZXJyb3InO1xuLyoqXG4gKiBAc3RydWN0XG4gKi9cbnZhciBMb2NhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhdGlvbihidWNrZXQsIHBhdGgpIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucGF0aF8gPSBwYXRoO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTG9jYXRpb24ucHJvdG90eXBlLCBcInBhdGhcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGhfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuZnVsbFNlcnZlclVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvby8nICsgZW5jb2RlKHRoaXMucGF0aCk7XG4gICAgfTtcbiAgICBMb2NhdGlvbi5wcm90b3R5cGUuYnVja2V0T25seVNlcnZlclVybCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuICcvYi8nICsgZW5jb2RlKHRoaXMuYnVja2V0KSArICcvbyc7XG4gICAgfTtcbiAgICBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMgPSBmdW5jdGlvbiAoYnVja2V0U3RyaW5nKSB7XG4gICAgICAgIHZhciBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1Y2tldExvY2F0aW9uID0gTG9jYXRpb24ubWFrZUZyb21VcmwoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTm90IHZhbGlkIFVSTCwgdXNlIGFzLWlzLiBUaGlzIGxldHMgeW91IHB1dCBiYXJlIGJ1Y2tldCBuYW1lcyBpblxuICAgICAgICAgICAgLy8gY29uZmlnLlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2NhdGlvbihidWNrZXRTdHJpbmcsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVja2V0TG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBidWNrZXRMb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZERlZmF1bHRCdWNrZXQoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9jYXRpb24ubWFrZUZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciBidWNrZXREb21haW4gPSAnKFtBLVphLXowLTkuXFxcXC1dKyknO1xuICAgICAgICBmdW5jdGlvbiBnc01vZGlmeShsb2MpIHtcbiAgICAgICAgICAgIGlmIChsb2MucGF0aC5jaGFyQXQobG9jLnBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgICAgICAgICAgIGxvYy5wYXRoXyA9IGxvYy5wYXRoXy5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdzUGF0aCA9ICcoLyguKikpPyQnO1xuICAgICAgICB2YXIgcGF0aCA9ICcoLyhbXj8jXSopLiopPyQnO1xuICAgICAgICB2YXIgZ3NSZWdleCA9IG5ldyBSZWdFeHAoJ15nczovLycgKyBidWNrZXREb21haW4gKyBnc1BhdGgsICdpJyk7XG4gICAgICAgIHZhciBnc0luZGljZXMgPSB7IGJ1Y2tldDogMSwgcGF0aDogMyB9O1xuICAgICAgICBmdW5jdGlvbiBodHRwTW9kaWZ5KGxvYykge1xuICAgICAgICAgICAgbG9jLnBhdGhfID0gZGVjb2RlVVJJQ29tcG9uZW50KGxvYy5wYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9ICd2W0EtWmEtejAtOV9dKyc7XG4gICAgICAgIHZhciBodHRwUmVnZXggPSBuZXcgUmVnRXhwKCdeaHR0cHM/Oi8vZmlyZWJhc2VzdG9yYWdlXFxcXC5nb29nbGVhcGlzXFxcXC5jb20vJyArXG4gICAgICAgICAgICB2ZXJzaW9uICtcbiAgICAgICAgICAgICcvYi8nICtcbiAgICAgICAgICAgIGJ1Y2tldERvbWFpbiArXG4gICAgICAgICAgICAnL28nICtcbiAgICAgICAgICAgIHBhdGgsICdpJyk7XG4gICAgICAgIHZhciBodHRwSW5kaWNlcyA9IHsgYnVja2V0OiAxLCBwYXRoOiAzIH07XG4gICAgICAgIHZhciBncm91cHMgPSBbXG4gICAgICAgICAgICB7IHJlZ2V4OiBnc1JlZ2V4LCBpbmRpY2VzOiBnc0luZGljZXMsIHBvc3RNb2RpZnk6IGdzTW9kaWZ5IH0sXG4gICAgICAgICAgICB7IHJlZ2V4OiBodHRwUmVnZXgsIGluZGljZXM6IGh0dHBJbmRpY2VzLCBwb3N0TW9kaWZ5OiBodHRwTW9kaWZ5IH1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICAgICAgICAgIHZhciBjYXB0dXJlcyA9IGdyb3VwLnJlZ2V4LmV4ZWModXJsKTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBidWNrZXRWYWx1ZSA9IGNhcHR1cmVzW2dyb3VwLmluZGljZXMuYnVja2V0XTtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aFZhbHVlID0gY2FwdHVyZXNbZ3JvdXAuaW5kaWNlcy5wYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhdGhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoVmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24oYnVja2V0VmFsdWUsIHBhdGhWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZ3JvdXAucG9zdE1vZGlmeShsb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZFVybCh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBMb2NhdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBMb2NhdGlvbiB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IEZpcmViYXNlIGNvbnN0YW50cy4gIFNvbWUgb2YgdGhlc2UgKEBkZWZpbmVzKSBjYW4gYmUgb3ZlcnJpZGRlbiBhdCBjb21waWxlLXRpbWUuXG4gKi9cbmV4cG9ydHMuQ09OU1RBTlRTID0ge1xuICAgIC8qKlxuICAgICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBpcyB0aGUgY2xpZW50IE5vZGUuanMgU0RLLlxuICAgICAqL1xuICAgIE5PREVfQ0xJRU5UOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgaXMgdGhlIEFkbWluIE5vZGUuanMgU0RLLlxuICAgICAqL1xuICAgIE5PREVfQURNSU46IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEZpcmViYXNlIFNESyBWZXJzaW9uXG4gICAgICovXG4gICAgU0RLX1ZFUlNJT046ICcke0pTQ09SRV9WRVJTSU9OfSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9jb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgb25EaXNjb25uZWN0XzEgPSByZXF1aXJlKFwiLi9vbkRpc2Nvbm5lY3RcIik7XG52YXIgVHJhbnNhY3Rpb25SZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyYW5zYWN0aW9uUmVzdWx0XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdXRpbFwiKTtcbnZhciBOZXh0UHVzaElkXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL05leHRQdXNoSWRcIik7XG52YXIgUXVlcnlfMSA9IHJlcXVpcmUoXCIuL1F1ZXJ5XCIpO1xudmFyIFJlcG9fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL1JlcG9cIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC9QYXRoXCIpO1xudmFyIFF1ZXJ5UGFyYW1zXzEgPSByZXF1aXJlKFwiLi4vY29yZS92aWV3L1F1ZXJ5UGFyYW1zXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFN5bmNQb2ludF8xID0gcmVxdWlyZShcIi4uL2NvcmUvU3luY1BvaW50XCIpO1xudmFyIFJlZmVyZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmZXJlbmNlLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIENhbGwgb3B0aW9uczpcbiAgICAgKiAgIG5ldyBSZWZlcmVuY2UoUmVwbywgUGF0aCkgb3JcbiAgICAgKiAgIG5ldyBSZWZlcmVuY2UodXJsOiBzdHJpbmcsIHN0cmluZ3xSZXBvTWFuYWdlcilcbiAgICAgKlxuICAgICAqIEV4dGVybmFsbHkgLSB0aGlzIGlzIHRoZSBmaXJlYmFzZS5kYXRhYmFzZS5SZWZlcmVuY2UgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVJlcG99IHJlcG9cbiAgICAgKiBAcGFyYW0geyghUGF0aCl9IHBhdGhcbiAgICAgKiBAZXh0ZW5kcyB7UXVlcnl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVmZXJlbmNlKHJlcG8sIHBhdGgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEocmVwbyBpbnN0YW5jZW9mIFJlcG9fMS5SZXBvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUmVmZXJlbmNlKCkgbm8gbG9uZ2VyIHN1cHBvcnRlZCAtIHVzZSBhcHAuZGF0YWJhc2UoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIFF1ZXJ5J3MgY29uc3RydWN0b3IsIHBhc3NpbmcgaW4gdGhlIHJlcG8gYW5kIHBhdGguXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVwbywgcGF0aCwgUXVlcnlQYXJhbXNfMS5RdWVyeVBhcmFtcy5ERUZBVUxULCBmYWxzZSkgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmdldEtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5rZXknLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyEoc3RyaW5nfFBhdGgpfSBwYXRoU3RyaW5nXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS5jaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhTdHJpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBwYXRoU3RyaW5nID0gU3RyaW5nKHBhdGhTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEocGF0aFN0cmluZyBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVJvb3RQYXRoU3RyaW5nKCdSZWZlcmVuY2UuY2hpbGQnLCAxLCBwYXRoU3RyaW5nLCBmYWxzZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUGF0aFN0cmluZygnUmVmZXJlbmNlLmNoaWxkJywgMSwgcGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKHRoaXMucmVwbywgdGhpcy5wYXRoLmNoaWxkKHBhdGhTdHJpbmcpKTtcbiAgICB9O1xuICAgIC8qKiBAcmV0dXJuIHs/UmVmZXJlbmNlfSAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnBhcmVudCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFyZW50UGF0aCA9IHRoaXMucGF0aC5wYXJlbnQoKTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFBhdGggPT09IG51bGwgPyBudWxsIDogbmV3IFJlZmVyZW5jZSh0aGlzLnJlcG8sIHBhcmVudFBhdGgpO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4geyFSZWZlcmVuY2V9ICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJvb3QnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChyZWYuZ2V0UGFyZW50KCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlZiA9IHJlZi5nZXRQYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH07XG4gICAgLyoqIEByZXR1cm4geyFEYXRhYmFzZX0gKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmRhdGFiYXNlUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwby5kYXRhYmFzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbCwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldCcsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXQnLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1JlZmVyZW5jZS5zZXQnLCAxLCBuZXdWYWwsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnNldCcsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBuZXcgdXRpbF8zLkRlZmVycmVkKCk7XG4gICAgICAgIHRoaXMucmVwby5zZXRXaXRoUHJpb3JpdHkodGhpcy5wYXRoLCBuZXdWYWwsIFxuICAgICAgICAvKnByaW9yaXR5PSovIG51bGwsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFQcm9taXNlfVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iamVjdFRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ1JlZmVyZW5jZS51cGRhdGUnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudXBkYXRlJywgdGhpcy5wYXRoKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0VG9NZXJnZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdPYmplY3RUb01lcmdlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdFRvTWVyZ2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3RUb01lcmdlWycnICsgaV0gPSBvYmplY3RUb01lcmdlW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0VG9NZXJnZSA9IG5ld09iamVjdFRvTWVyZ2U7XG4gICAgICAgICAgICB1dGlsXzEud2FybignUGFzc2luZyBhbiBBcnJheSB0byBGaXJlYmFzZS51cGRhdGUoKSBpcyBkZXByZWNhdGVkLiAnICtcbiAgICAgICAgICAgICAgICAnVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgZGF0YSwgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2FuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gJyArXG4gICAgICAgICAgICAgICAgJ29ubHkgdXBkYXRlIHNvbWUgb2YgdGhlIGNoaWxkcmVuLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlTWVyZ2VEYXRhQXJnKCdSZWZlcmVuY2UudXBkYXRlJywgMSwgb2JqZWN0VG9NZXJnZSwgdGhpcy5wYXRoLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2UudXBkYXRlJywgMiwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvLnVwZGF0ZSh0aGlzLnBhdGgsIG9iamVjdFRvTWVyZ2UsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBuZXdWYWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gbmV3UHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRXaXRoUHJpb3JpdHkgPSBmdW5jdGlvbiAobmV3VmFsLCBuZXdQcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIDIsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCB0aGlzLnBhdGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1JlZmVyZW5jZS5zZXRXaXRoUHJpb3JpdHknLCAxLCBuZXdWYWwsIHRoaXMucGF0aCwgZmFsc2UpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVQcmlvcml0eSgnUmVmZXJlbmNlLnNldFdpdGhQcmlvcml0eScsIDIsIG5ld1ByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5JywgMywgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmdldEtleSgpID09PSAnLmxlbmd0aCcgfHwgdGhpcy5nZXRLZXkoKSA9PT0gJy5rZXlzJylcbiAgICAgICAgICAgIHRocm93ICdSZWZlcmVuY2Uuc2V0V2l0aFByaW9yaXR5IGZhaWxlZDogJyArXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRLZXkoKSArXG4gICAgICAgICAgICAgICAgJyBpcyBhIHJlYWQtb25seSBvYmplY3QuJztcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KHRoaXMucGF0aCwgbmV3VmFsLCBuZXdQcmlvcml0eSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnJlbW92ZScsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5yZW1vdmUnLCB0aGlzLnBhdGgpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnJlbW92ZScsIDEsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXQobnVsbCwgb25Db21wbGV0ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCopOip9IHRyYW5zYWN0aW9uVXBkYXRlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oP0Vycm9yLCBib29sZWFuLCA/RGF0YVNuYXBzaG90KSk9fSBvbkNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYXBwbHlMb2NhbGx5XG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS50cmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgYXBwbHlMb2NhbGx5KSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCAxLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2UudHJhbnNhY3Rpb24nLCB0aGlzLnBhdGgpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMSwgdHJhbnNhY3Rpb25VcGRhdGUsIGZhbHNlKTtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQ2FsbGJhY2soJ1JlZmVyZW5jZS50cmFuc2FjdGlvbicsIDIsIG9uQ29tcGxldGUsIHRydWUpO1xuICAgICAgICAvLyBOT1RFOiBhcHBseUxvY2FsbHkgaXMgYW4gaW50ZXJuYWwtb25seSBvcHRpb24gZm9yIG5vdy4gIFdlIG5lZWQgdG8gZGVjaWRlIGlmIHdlIHdhbnQgdG8ga2VlcCBpdCBhbmQgaG93XG4gICAgICAgIC8vIHRvIGV4cG9zZSBpdC5cbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlQm9vbGVhbignUmVmZXJlbmNlLnRyYW5zYWN0aW9uJywgMywgYXBwbHlMb2NhbGx5LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0S2V5KCkgPT09ICcubGVuZ3RoJyB8fCB0aGlzLmdldEtleSgpID09PSAnLmtleXMnKVxuICAgICAgICAgICAgdGhyb3cgJ1JlZmVyZW5jZS50cmFuc2FjdGlvbiBmYWlsZWQ6ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0S2V5KCkgK1xuICAgICAgICAgICAgICAgICcgaXMgYSByZWFkLW9ubHkgb2JqZWN0Lic7XG4gICAgICAgIGlmIChhcHBseUxvY2FsbHkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGFwcGx5TG9jYWxseSA9IHRydWU7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2VDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUobmV3IFRyYW5zYWN0aW9uUmVzdWx0XzEuVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShlcnJvciwgY29tbWl0dGVkLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVwby5zdGFydFRyYW5zYWN0aW9uKHRoaXMucGF0aCwgdHJhbnNhY3Rpb25VcGRhdGUsIHByb21pc2VDb21wbGV0ZSwgYXBwbHlMb2NhbGx5KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8bnVsbH0gcHJpb3JpdHlcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IVByb21pc2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5zZXRQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eSwgb25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVBcmdDb3VudCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgMSwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVdyaXRhYmxlUGF0aCgnUmVmZXJlbmNlLnNldFByaW9yaXR5JywgdGhpcy5wYXRoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlUHJpb3JpdHkoJ1JlZmVyZW5jZS5zZXRQcmlvcml0eScsIDEsIHByaW9yaXR5LCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUNhbGxiYWNrKCdSZWZlcmVuY2Uuc2V0UHJpb3JpdHknLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG8uc2V0V2l0aFByaW9yaXR5KHRoaXMucGF0aC5jaGlsZCgnLnByaW9yaXR5JyksIHByaW9yaXR5LCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9XG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHZhbHVlLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdSZWZlcmVuY2UucHVzaCcsIDAsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ1JlZmVyZW5jZS5wdXNoJywgdGhpcy5wYXRoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhQXJnKCdSZWZlcmVuY2UucHVzaCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICB1dGlsXzIudmFsaWRhdGVDYWxsYmFjaygnUmVmZXJlbmNlLnB1c2gnLCAyLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMucmVwby5zZXJ2ZXJUaW1lKCk7XG4gICAgICAgIHZhciBuYW1lID0gTmV4dFB1c2hJZF8xLm5leHRQdXNoSWQobm93KTtcbiAgICAgICAgLy8gcHVzaCgpIHJldHVybnMgYSBUaGVubmFibGVSZWZlcmVuY2Ugd2hvc2UgcHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhIHJlZ3VsYXIgUmVmZXJlbmNlLlxuICAgICAgICAvLyBXZSB1c2UgY2hpbGQoKSB0byBjcmVhdGUgaGFuZGxlcyB0byB0d28gZGlmZmVyZW50IHJlZmVyZW5jZXMuIFRoZSBmaXJzdCBpcyB0dXJuZWQgaW50byBhXG4gICAgICAgIC8vIFRoZW5uYWJsZVJlZmVyZW5jZSBiZWxvdyBieSBhZGRpbmcgdGhlbigpIGFuZCBjYXRjaCgpIG1ldGhvZHMgYW5kIGlzIHVzZWQgYXMgdGhlXG4gICAgICAgIC8vIHJldHVybiB2YWx1ZSBvZiBwdXNoKCkuIFRoZSBzZWNvbmQgcmVtYWlucyBhIHJlZ3VsYXIgUmVmZXJlbmNlIGFuZCBpcyB1c2VkIGFzIHRoZSBmdWxmaWxsZWRcbiAgICAgICAgLy8gdmFsdWUgb2YgdGhlIGZpcnN0IFRoZW5uYWJsZVJlZmVyZW5jZS5cbiAgICAgICAgdmFyIHRoZW5uYWJsZVB1c2hSZWYgPSB0aGlzLmNoaWxkKG5hbWUpO1xuICAgICAgICB2YXIgcHVzaFJlZiA9IHRoaXMuY2hpbGQobmFtZSk7XG4gICAgICAgIHZhciBwcm9taXNlO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoZW5uYWJsZVB1c2hSZWYuc2V0KHZhbHVlLCBvbkNvbXBsZXRlKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHB1c2hSZWY7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShwdXNoUmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGVubmFibGVQdXNoUmVmLnRoZW4gPSBwcm9taXNlLnRoZW4uYmluZChwcm9taXNlKTtcbiAgICAgICAgdGhlbm5hYmxlUHVzaFJlZi5jYXRjaCA9IHByb21pc2UudGhlbi5iaW5kKHByb21pc2UsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVubmFibGVQdXNoUmVmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU9uRGlzY29ubmVjdH1cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdSZWZlcmVuY2Uub25EaXNjb25uZWN0JywgdGhpcy5wYXRoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBvbkRpc2Nvbm5lY3RfMS5PbkRpc2Nvbm5lY3QodGhpcy5yZXBvLCB0aGlzLnBhdGgpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwiZGF0YWJhc2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFiYXNlUHJvcCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleSgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb290KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBSZWZlcmVuY2U7XG59KFF1ZXJ5XzEuUXVlcnkpKTtcbmV4cG9ydHMuUmVmZXJlbmNlID0gUmVmZXJlbmNlO1xuLyoqXG4gKiBEZWZpbmUgcmVmZXJlbmNlIGNvbnN0cnVjdG9yIGluIHZhcmlvdXMgbW9kdWxlc1xuICpcbiAqIFdlIGFyZSBkb2luZyB0aGlzIGhlcmUgdG8gYXZvaWQgc2V2ZXJhbCBjaXJjdWxhclxuICogZGVwZW5kZW5jeSBpc3N1ZXNcbiAqL1xuUXVlcnlfMS5RdWVyeS5fX3JlZmVyZW5jZUNvbnN0cnVjdG9yID0gUmVmZXJlbmNlO1xuU3luY1BvaW50XzEuU3luY1BvaW50Ll9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSBSZWZlcmVuY2U7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZmVyZW5jZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1JlZmVyZW5jZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL1BhdGhcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4uL2NvcmUvc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGZpcmViYXNlIGRhdGEgc25hcHNob3QuICBJdCB3cmFwcyBhIFNuYXBzaG90Tm9kZSBhbmRcbiAqIHN1cmZhY2VzIHRoZSBwdWJsaWMgbWV0aG9kcyAodmFsLCBmb3JFYWNoLCBldGMuKSB3ZSB3YW50IHRvIGV4cG9zZS5cbiAqL1xudmFyIERhdGFTbmFwc2hvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXyBBIFNuYXBzaG90Tm9kZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7IVJlZmVyZW5jZX0gcmVmXyBUaGUgcmVmIG9mIHRoZSBsb2NhdGlvbiB0aGlzIHNuYXBzaG90IGNhbWUgZnJvbS5cbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhfIFRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIHRoaXMgc25hcHNob3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBEYXRhU25hcHNob3Qobm9kZV8sIHJlZl8sIGluZGV4Xykge1xuICAgICAgICB0aGlzLm5vZGVfID0gbm9kZV87XG4gICAgICAgIHRoaXMucmVmXyA9IHJlZl87XG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIHNuYXBzaG90IGNvbnRlbnRzIGFzIEpTT04uICBSZXR1cm5zIG51bGwgaWYgdGhlIHNuYXBzaG90IGlzXG4gICAgICogZW1wdHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsqfSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBEYXRhU25hcHNob3QgY29udGVudHMsIG9yIG51bGwgaWYgZW1wdHkuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QudmFsJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfLnZhbCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc25hcHNob3QgY29udGVudHMgYXMgSlNPTiwgaW5jbHVkaW5nIHByaW9yaXRpZXMgb2Ygbm9kZS4gIFN1aXRhYmxlIGZvciBleHBvcnRpbmdcbiAgICAgKiB0aGUgZW50aXJlIG5vZGUgY29udGVudHMuXG4gICAgICogQHJldHVybiB7Kn0gSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgRGF0YVNuYXBzaG90IGNvbnRlbnRzLCBvciBudWxsIGlmIGVtcHR5LlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZXhwb3J0VmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmV4cG9ydFZhbCcsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXy52YWwodHJ1ZSk7XG4gICAgfTtcbiAgICAvLyBEbyBub3QgY3JlYXRlIHB1YmxpYyBkb2N1bWVudGF0aW9uLiBUaGlzIGlzIGludGVuZGVkIHRvIG1ha2UgSlNPTiBzZXJpYWxpemF0aW9uIHdvcmsgYnV0IGlzIG90aGVyd2lzZSB1bm5lY2Vzc2FyeVxuICAgIC8vIGZvciBlbmQtdXNlcnNcbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gT3B0aW9uYWwgc3BhY2VyIGFyZ3VtZW50IGlzIHVubmVjZXNzYXJ5IGJlY2F1c2Ugd2UncmUgZGVwZW5kaW5nIG9uIHJlY3Vyc2lvbiByYXRoZXIgdGhhbiBzdHJpbmdpZnlpbmcgdGhlIGNvbnRlbnRcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC50b0pTT04nLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwb3J0VmFsKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHNuYXBzaG90IGNvbnRhaW5zIGEgbm9uLW51bGwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzbmFwc2hvdCBjb250YWlucyBhIG5vbi1udWxsIHZhbHVlLCBvciBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5leGlzdHMnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5vZGVfLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBEYXRhU25hcHNob3Qgb2YgdGhlIHNwZWNpZmllZCBjaGlsZCBub2RlJ3MgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGNoaWxkUGF0aFN0cmluZyBQYXRoIHRvIGEgY2hpbGQuXG4gICAgICogQHJldHVybiB7IURhdGFTbmFwc2hvdH0gRGF0YVNuYXBzaG90IGZvciBjaGlsZCBub2RlLlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuY2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRQYXRoU3RyaW5nKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdEYXRhU25hcHNob3QuY2hpbGQnLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBjaGlsZFBhdGggaXMgYSBzdHJpbmcgKGNhbiBiZSBhIG51bWJlcilcbiAgICAgICAgY2hpbGRQYXRoU3RyaW5nID0gU3RyaW5nKGNoaWxkUGF0aFN0cmluZyk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVBhdGhTdHJpbmcoJ0RhdGFTbmFwc2hvdC5jaGlsZCcsIDEsIGNoaWxkUGF0aFN0cmluZywgZmFsc2UpO1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKGNoaWxkUGF0aFN0cmluZyk7XG4gICAgICAgIHZhciBjaGlsZFJlZiA9IHRoaXMucmVmXy5jaGlsZChjaGlsZFBhdGgpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGFTbmFwc2hvdCh0aGlzLm5vZGVfLmdldENoaWxkKGNoaWxkUGF0aCksIGNoaWxkUmVmLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBzbmFwc2hvdCBjb250YWlucyBhIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY2hpbGRQYXRoU3RyaW5nIFBhdGggdG8gYSBjaGlsZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBjaGlsZCBleGlzdHMuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5oYXNDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZFBhdGhTdHJpbmcpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVQYXRoU3RyaW5nKCdEYXRhU25hcHNob3QuaGFzQ2hpbGQnLCAxLCBjaGlsZFBhdGhTdHJpbmcsIGZhbHNlKTtcbiAgICAgICAgdmFyIGNoaWxkUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChjaGlsZFBhdGhTdHJpbmcpO1xuICAgICAgICByZXR1cm4gIXRoaXMubm9kZV8uZ2V0Q2hpbGQoY2hpbGRQYXRoKS5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmlvcml0eSBvZiB0aGUgb2JqZWN0LCBvciBudWxsIGlmIG5vIHByaW9yaXR5IHdhcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfG51bGx9IFRoZSBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBEYXRhU25hcHNob3QucHJvdG90eXBlLmdldFByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LmdldFByaW9yaXR5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIHR5cGVjYXN0IGhlcmUgYmVjYXVzZSB3ZSBuZXZlciByZXR1cm4gZGVmZXJyZWQgdmFsdWVzIG9yIGludGVybmFsIHByaW9yaXRpZXMgKE1BWF9QUklPUklUWSlcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8uZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGQgbm9kZXMgYW5kIGNhbGxzIHRoZSBzcGVjaWZpZWQgYWN0aW9uIGZvciBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGFjdGlvbiBDYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKiBmb3IgZWFjaCBjaGlsZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGZvckVhY2ggd2FzIGNhbmNlbGVkIGJ5IGFjdGlvbiByZXR1cm5pbmcgdHJ1ZSBmb3JcbiAgICAgKiBvbmUgb2YgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5mb3JFYWNoJywgMSwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKCdEYXRhU25hcHNob3QuZm9yRWFjaCcsIDEsIGFjdGlvbiwgZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5ub2RlXy5pc0xlYWZOb2RlKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSB0aGlzLm5vZGVfO1xuICAgICAgICAvLyBTYW5pdGl6ZSB0aGUgcmV0dXJuIHZhbHVlIHRvIGEgYm9vbGVhbi4gQ2hpbGRyZW5Ob2RlLmZvckVhY2hDaGlsZCBoYXMgYSB3ZWlyZCByZXR1cm4gdHlwZS4uLlxuICAgICAgICByZXR1cm4gISFjaGlsZHJlbk5vZGUuZm9yRWFjaENoaWxkKHRoaXMuaW5kZXhfLCBmdW5jdGlvbiAoa2V5LCBub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uKG5ldyBEYXRhU25hcHNob3Qobm9kZSwgX3RoaXMucmVmXy5jaGlsZChrZXkpLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBEYXRhU25hcHNob3QgaGFzIGNoaWxkcmVuLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERhdGFTbmFwc2hvdCBjb250YWlucyAxIG9yIG1vcmUgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5oYXNDaGlsZHJlbicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5ub2RlXy5pc0xlYWZOb2RlKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5ub2RlXy5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YVNuYXBzaG90LnByb3RvdHlwZSwgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZl8uZ2V0S2V5KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBmb3IgdGhpcyBEYXRhU25hcHNob3QuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgdGhpcyBEYXRhU25hcHNob3QgY29udGFpbnMuXG4gICAgICovXG4gICAgRGF0YVNuYXBzaG90LnByb3RvdHlwZS5udW1DaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ0RhdGFTbmFwc2hvdC5udW1DaGlsZHJlbicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlXy5udW1DaGlsZHJlbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7UmVmZXJlbmNlfSBUaGUgRmlyZWJhc2UgcmVmZXJlbmNlIGZvciB0aGUgbG9jYXRpb24gdGhpcyBzbmFwc2hvdCdzIGRhdGEgY2FtZSBmcm9tLlxuICAgICAqL1xuICAgIERhdGFTbmFwc2hvdC5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnRGF0YVNuYXBzaG90LnJlZicsIDAsIDAsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZfO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFTbmFwc2hvdC5wcm90b3R5cGUsIFwicmVmXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWYoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIERhdGFTbmFwc2hvdDtcbn0oKSk7XG5leHBvcnRzLkRhdGFTbmFwc2hvdCA9IERhdGFTbmFwc2hvdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YVNuYXBzaG90LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvRGF0YVNuYXBzaG90LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTb3J0ZWRNYXBfMSA9IHJlcXVpcmUoXCIuL1NvcnRlZE1hcFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XG4vKipcbiAqIFNpbmdsZXRvbiBlbXB0eSBjaGlsZHJlbiBjb2xsZWN0aW9uLlxuICpcbiAqIEBjb25zdFxuICogQHR5cGUgeyFTb3J0ZWRNYXAuPHN0cmluZywgIUltbXV0YWJsZVRyZWUuPD8+Pn1cbiAqL1xudmFyIEVtcHR5Q2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFlbXB0eUNoaWxkcmVuU2luZ2xldG9uKSB7XG4gICAgICAgIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b24gPSBuZXcgU29ydGVkTWFwXzEuU29ydGVkTWFwKHV0aWxfMS5zdHJpbmdDb21wYXJlKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtcHR5Q2hpbGRyZW5TaW5nbGV0b247XG59O1xuLyoqXG4gKiBBIHRyZWUgd2l0aCBpbW11dGFibGUgZWxlbWVudHMuXG4gKi9cbnZhciBJbW11dGFibGVUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHs/VH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge1NvcnRlZE1hcC48c3RyaW5nLCAhSW1tdXRhYmxlVHJlZS48VD4+PX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBJbW11dGFibGVUcmVlKHZhbHVlLCBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4gPT09IHZvaWQgMCkgeyBjaGlsZHJlbiA9IEVtcHR5Q2hpbGRyZW4oKTsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIVQ+fSBvYmpcbiAgICAgKiBAcmV0dXJuIHshSW1tdXRhYmxlVHJlZS48IVQ+fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIHRyZWUgPSBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICB1dGlsXzIuZm9yRWFjaChvYmosIGZ1bmN0aW9uIChjaGlsZFBhdGgsIGNoaWxkU25hcCkge1xuICAgICAgICAgICAgdHJlZSA9IHRyZWUuc2V0KG5ldyBQYXRoXzEuUGF0aChjaGlsZFBhdGgpLCBjaGlsZFNuYXApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eSBhbmQgdGhlcmUgYXJlIG5vIGNoaWxkcmVuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbnVsbCAmJiB0aGlzLmNoaWxkcmVuLmlzRW1wdHkoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcGF0aCBhbmQgcHJlZGljYXRlLCByZXR1cm4gdGhlIGZpcnN0IG5vZGUgYW5kIHRoZSBwYXRoIHRvIHRoYXQgbm9kZVxuICAgICAqIHdoZXJlIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgICAqXG4gICAgICogVE9ETyBEbyBhIHBlcmYgdGVzdCAtLSBJZiB3ZSdyZSBjcmVhdGluZyBhIGJ1bmNoIG9mIHtwYXRoOiB2YWx1ZTp9IG9iamVjdHNcbiAgICAgKiBvbiB0aGUgd2F5IGJhY2sgb3V0LCBpdCBtYXkgYmUgYmV0dGVyIHRvIHBhc3MgZG93biBhIHBhdGhTb0ZhciBvYmouXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggVGhlIHJlbWFpbmRlciBvZiB0aGUgcGF0aFxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gc2F0aXNmeSB0byByZXR1cm4gYVxuICAgICAqICAgbm9kZVxuICAgICAqIEByZXR1cm4gez97cGF0aDohUGF0aCwgdmFsdWU6IVR9fVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRSb290TW9zdE1hdGNoaW5nUGF0aEFuZFZhbHVlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9IG51bGwgJiYgcHJlZGljYXRlKHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwYXRoOiBQYXRoXzEuUGF0aC5FbXB0eSwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlID0gY2hpbGQuZmluZFJvb3RNb3N0TWF0Y2hpbmdQYXRoQW5kVmFsdWUocmVsYXRpdmVQYXRoLnBvcEZyb250KCksIHByZWRpY2F0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEV4aXN0aW5nUGF0aEFuZFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdWxsUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChmcm9udCkuY2hpbGQoY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHBhdGg6IGZ1bGxQYXRoLCB2YWx1ZTogY2hpbGRFeGlzdGluZ1BhdGhBbmRWYWx1ZS52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCwgaWYgaXQgZXhpc3RzLCB0aGUgc2hvcnRlc3Qgc3VicGF0aCBvZiB0aGUgZ2l2ZW4gcGF0aCB0aGF0IHBvaW50cyBhIGRlZmluZWRcbiAgICAgKiB2YWx1ZSBpbiB0aGUgdHJlZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgICAqIEByZXR1cm4gez97cGF0aDogIVBhdGgsIHZhbHVlOiAhVH19XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kUm9vdE1vc3RNYXRjaGluZ1BhdGhBbmRWYWx1ZShyZWxhdGl2ZVBhdGgsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoXG4gICAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWUuPFQ+fSBUaGUgc3VidHJlZSBhdCB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnN1YnRyZWUgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkVHJlZSA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLnN1YnRyZWUocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byBzZXQgdmFsdWUgYXQuXG4gICAgICogQHBhcmFtIHs/VH0gdG9TZXQgVmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjxUPn0gUmVzdWx0aW5nIHRyZWUuXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgdG9TZXQpIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0b1NldCwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KSB8fCBJbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gY2hpbGQuc2V0KHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpLCB0b1NldCk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmluc2VydChmcm9udCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbW11dGFibGVUcmVlKHRoaXMudmFsdWUsIG5ld0NoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4geyFJbW11dGFibGVUcmVlLjxUPn0gUmVzdWx0aW5nIHRyZWUuXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCkge1xuICAgICAgICBpZiAocmVsYXRpdmVQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEltbXV0YWJsZVRyZWUobnVsbCwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSByZWxhdGl2ZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uZ2V0KGZyb250KTtcbiAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IGNoaWxkLnJlbW92ZShyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnJlbW92ZShmcm9udCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4uaW5zZXJ0KGZyb250LCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsICYmIG5ld0NoaWxkcmVuLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgYSB2YWx1ZSBmcm9tIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcmVsYXRpdmVQYXRoIFBhdGggdG8gZ2V0IHZhbHVlIGZvci5cbiAgICAgKiBAcmV0dXJuIHs/VH0gVmFsdWUgYXQgcGF0aCwgb3IgbnVsbC5cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpO1xuICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmdldChyZWxhdGl2ZVBhdGgucG9wRnJvbnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgc3VidHJlZSBhdCB0aGUgc3BlY2lmaWVkIHBhdGggd2l0aCB0aGUgZ2l2ZW4gbmV3IHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSByZWxhdGl2ZVBhdGggUGF0aCB0byByZXBsYWNlIHN1YnRyZWUgZm9yLlxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWV9IG5ld1RyZWUgTmV3IHRyZWUuXG4gICAgICogQHJldHVybiB7IUltbXV0YWJsZVRyZWV9IFJlc3VsdGluZyB0cmVlLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLnNldFRyZWUgPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBuZXdUcmVlKSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3VHJlZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBmcm9udCA9IHJlbGF0aXZlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbi5nZXQoZnJvbnQpIHx8IEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSBjaGlsZC5zZXRUcmVlKHJlbGF0aXZlUGF0aC5wb3BGcm9udCgpLCBuZXdUcmVlKTtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ucmVtb3ZlKGZyb250KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5pbnNlcnQoZnJvbnQsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1tdXRhYmxlVHJlZSh0aGlzLnZhbHVlLCBuZXdDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgZGVwdGggZmlyc3QgZm9sZCBvbiB0aGlzIHRyZWUuIFRyYW5zZm9ybXMgYSB0cmVlIGludG8gYSBzaW5nbGVcbiAgICAgKiB2YWx1ZSwgZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IG9wZXJhdGVzIG9uIHRoZSBwYXRoIHRvIGEgbm9kZSwgYW4gb3B0aW9uYWxcbiAgICAgKiBjdXJyZW50IHZhbHVlLCBhbmQgYSBtYXAgb2YgY2hpbGQgbmFtZXMgdG8gZm9sZGVkIHN1YnRyZWVzXG4gICAgICogQHRlbXBsYXRlIFZcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFBhdGgsID9ULCBPYmplY3QuPHN0cmluZywgVj4pOlZ9IGZuXG4gICAgICogQHJldHVybiB7Vn1cbiAgICAgKi9cbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5mb2xkID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGRfKFBhdGhfMS5QYXRoLkVtcHR5LCBmbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBwdWJsaWMtZmFjaW5nIGZvbGQoKSBtZXRob2RcbiAgICAgKiBAdGVtcGxhdGUgVlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhTb0ZhclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oUGF0aCwgP1QsIE9iamVjdC48c3RyaW5nLCBWPik6Vn0gZm5cbiAgICAgKiBAcmV0dXJuIHtWfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9sZF8gPSBmdW5jdGlvbiAocGF0aFNvRmFyLCBmbikge1xuICAgICAgICB2YXIgYWNjdW0gPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICBhY2N1bVtjaGlsZEtleV0gPSBjaGlsZFRyZWUuZm9sZF8ocGF0aFNvRmFyLmNoaWxkKGNoaWxkS2V5KSwgZm4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZuKHBhdGhTb0ZhciwgdGhpcy52YWx1ZSwgYWNjdW0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgZmlyc3QgbWF0Y2hpbmcgdmFsdWUgb24gdGhlIGdpdmVuIHBhdGguIFJldHVybiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGYgdG8gaXQuXG4gICAgICogQHRlbXBsYXRlIFZcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKTo/Vn0gZlxuICAgICAqIEByZXR1cm4gez9WfVxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZpbmRPblBhdGggPSBmdW5jdGlvbiAocGF0aCwgZikge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kT25QYXRoXyhwYXRoLCBQYXRoXzEuUGF0aC5FbXB0eSwgZik7XG4gICAgfTtcbiAgICBJbW11dGFibGVUcmVlLnByb3RvdHlwZS5maW5kT25QYXRoXyA9IGZ1bmN0aW9uIChwYXRoVG9Gb2xsb3csIHBhdGhTb0ZhciwgZikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZSA/IGYocGF0aFNvRmFyLCB0aGlzLnZhbHVlKSA6IGZhbHNlO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGhUb0ZvbGxvdy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmcm9udCA9IHBhdGhUb0ZvbGxvdy5nZXRGcm9udCgpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dENoaWxkLmZpbmRPblBhdGhfKHBhdGhUb0ZvbGxvdy5wb3BGcm9udCgpLCBwYXRoU29GYXIuY2hpbGQoZnJvbnQpLCBmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVBhdGgsICFUKX0gZlxuICAgICAqIEByZXR1cm5zIHshSW1tdXRhYmxlVHJlZS48VD59XG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9yZWFjaE9uUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcmVhY2hPblBhdGhfKHBhdGgsIFBhdGhfMS5QYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2hPblBhdGhfID0gZnVuY3Rpb24gKHBhdGhUb0ZvbGxvdywgY3VycmVudFJlbGF0aXZlUGF0aCwgZikge1xuICAgICAgICBpZiAocGF0aFRvRm9sbG93LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGYoY3VycmVudFJlbGF0aXZlUGF0aCwgdGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnJvbnQgPSBwYXRoVG9Gb2xsb3cuZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBuZXh0Q2hpbGQgPSB0aGlzLmNoaWxkcmVuLmdldChmcm9udCk7XG4gICAgICAgICAgICBpZiAobmV4dENoaWxkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRDaGlsZC5mb3JlYWNoT25QYXRoXyhwYXRoVG9Gb2xsb3cucG9wRnJvbnQoKSwgY3VycmVudFJlbGF0aXZlUGF0aC5jaGlsZChmcm9udCksIGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBmb3IgZWFjaCBub2RlIGluIHRoZSB0cmVlIHRoYXQgaGFzIGEgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFQYXRoLCAhVCl9IGYgQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aFxuICAgICAqICAgdGhlIHBhdGggZnJvbSB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0byBhIG5vZGUsIGFuZCB0aGUgdmFsdWUgYXQgdGhhdCBub2RlLlxuICAgICAqICAgQ2FsbGVkIGluIGRlcHRoLWZpcnN0IG9yZGVyLlxuICAgICAqL1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2ggPSBmdW5jdGlvbiAoZikge1xuICAgICAgICB0aGlzLmZvcmVhY2hfKFBhdGhfMS5QYXRoLkVtcHR5LCBmKTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUucHJvdG90eXBlLmZvcmVhY2hfID0gZnVuY3Rpb24gKGN1cnJlbnRSZWxhdGl2ZVBhdGgsIGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgY2hpbGRUcmVlLmZvcmVhY2hfKGN1cnJlbnRSZWxhdGl2ZVBhdGguY2hpbGQoY2hpbGROYW1lKSwgZik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgZihjdXJyZW50UmVsYXRpdmVQYXRoLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgIVQpfSBmXG4gICAgICovXG4gICAgSW1tdXRhYmxlVHJlZS5wcm90b3R5cGUuZm9yZWFjaENoaWxkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGYoY2hpbGROYW1lLCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEltbXV0YWJsZVRyZWUuRW1wdHkgPSBuZXcgSW1tdXRhYmxlVHJlZShudWxsKTtcbiAgICByZXR1cm4gSW1tdXRhYmxlVHJlZTtcbn0oKSk7XG5leHBvcnRzLkltbXV0YWJsZVRyZWUgPSBJbW11dGFibGVUcmVlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbW11dGFibGVUcmVlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvSW1tdXRhYmxlVHJlZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4uL0NoYW5nZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIERvZXNuJ3QgcmVhbGx5IGZpbHRlciBub2RlcyBidXQgYXBwbGllcyBhbiBpbmRleCB0byB0aGUgbm9kZSBhbmQga2VlcHMgdHJhY2sgb2YgYW55IGNoYW5nZXNcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICogQHBhcmFtIHshSW5kZXh9IGluZGV4XG4gKi9cbnZhciBJbmRleGVkRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluZGV4ZWRGaWx0ZXIoaW5kZXhfKSB7XG4gICAgICAgIHRoaXMuaW5kZXhfID0gaW5kZXhfO1xuICAgIH1cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVDaGlsZCA9IGZ1bmN0aW9uIChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChzbmFwLmlzSW5kZXhlZCh0aGlzLmluZGV4XyksICdBIG5vZGUgbXVzdCBiZSBpbmRleGVkIGlmIG9ubHkgYSBjaGlsZCBpcyB1cGRhdGVkJyk7XG4gICAgICAgIHZhciBvbGRDaGlsZCA9IHNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYW55dGhpbmcgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZENoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkuZXF1YWxzKG5ld0NoaWxkLmdldENoaWxkKGFmZmVjdGVkUGF0aCkpKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIGFuIGVkZ2UgY2FzZSB3aGVyZSBhIGNoaWxkIGNhbiBlbnRlciBvciBsZWF2ZSB0aGUgdmlldyBiZWNhdXNlIGFmZmVjdGVkUGF0aCB3YXMgc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIGFmZmVjdGVkUGF0aCB3aWxsIGFwcGVhciBudWxsIGluIGJvdGggdGhlIG9sZCBhbmQgbmV3IHNuYXBzaG90cy4gIFNvIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHRyZWF0aW5nIHRoZXNlIGNhc2VzIGFzIFwibm90aGluZyBjaGFuZ2VkLlwiXG4gICAgICAgICAgICBpZiAob2xkQ2hpbGQuaXNFbXB0eSgpID09IG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFzc2VydCBzaG91bGQgYmUgdmFsaWQsIGJ1dCBpdCdzIGV4cGVuc2l2ZSAoY2FuIGRvbWluYXRlIHBlcmYgdGVzdGluZykgc28gZG9uJ3QgYWN0dWFsbHkgZG8gaXQuXG4gICAgICAgICAgICAgICAgLy9hc3NlcnQob2xkQ2hpbGQuZXF1YWxzKG5ld0NoaWxkKSwgJ09sZCBhbmQgbmV3IHNuYXBzaG90cyBzaG91bGQgYmUgZXF1YWwuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdENoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkUmVtb3ZlZENoYW5nZShrZXksIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHNuYXAuaXNMZWFmTm9kZSgpLCAnQSBjaGlsZCByZW1vdmUgd2l0aG91dCBhbiBvbGQgY2hpbGQgb25seSBtYWtlcyBzZW5zZSBvbiBhIGxlYWYgbm9kZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9sZENoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIG9wdENoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2Uoa2V5LCBuZXdDaGlsZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0Q2hhbmdlQWNjdW11bGF0b3IudHJhY2tDaGlsZENoYW5nZShDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRDaGFuZ2VkQ2hhbmdlKGtleSwgbmV3Q2hpbGQsIG9sZENoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNuYXAuaXNMZWFmTm9kZSgpICYmIG5ld0NoaWxkLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5vZGUgaXMgaW5kZXhlZFxuICAgICAgICAgICAgcmV0dXJuIHNuYXAudXBkYXRlSW1tZWRpYXRlQ2hpbGQoa2V5LCBuZXdDaGlsZCkud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVGdWxsTm9kZSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdTbmFwLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAob3B0Q2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFvbGRTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG9sZFNuYXAuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV3U25hcC5oYXNDaGlsZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRTbmFwLmhhc0NoaWxkKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRDaGlsZCA9IG9sZFNuYXAuZ2V0SW1tZWRpYXRlQ2hpbGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKGNoaWxkTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2Uoa2V5LCBjaGlsZE5vZGUsIG9sZENoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRDaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGtleSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICBpZiAob2xkU25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRTbmFwLnVwZGF0ZVByaW9yaXR5KG5ld1ByaW9yaXR5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBJbmRleGVkRmlsdGVyLnByb3RvdHlwZS5maWx0ZXJzTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgSW5kZXhlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIEluZGV4ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICByZXR1cm4gSW5kZXhlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLkluZGV4ZWRGaWx0ZXIgPSBJbmRleGVkRmlsdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmRleGVkRmlsdGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL0luZGV4ZWRGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFN0YXRzQ29sbGVjdGlvbl8xID0gcmVxdWlyZShcIi4vU3RhdHNDb2xsZWN0aW9uXCIpO1xudmFyIFN0YXRzTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0c01hbmFnZXIoKSB7XG4gICAgfVxuICAgIFN0YXRzTWFuYWdlci5nZXRDb2xsZWN0aW9uID0gZnVuY3Rpb24gKHJlcG9JbmZvKSB7XG4gICAgICAgIHZhciBoYXNoU3RyaW5nID0gcmVwb0luZm8udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25zX1toYXNoU3RyaW5nXSkge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc19baGFzaFN0cmluZ10gPSBuZXcgU3RhdHNDb2xsZWN0aW9uXzEuU3RhdHNDb2xsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGVjdGlvbnNfW2hhc2hTdHJpbmddO1xuICAgIH07XG4gICAgU3RhdHNNYW5hZ2VyLmdldE9yQ3JlYXRlUmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb0luZm8sIGNyZWF0b3JGdW5jdGlvbikge1xuICAgICAgICB2YXIgaGFzaFN0cmluZyA9IHJlcG9JbmZvLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydGVyc19baGFzaFN0cmluZ10gPSBjcmVhdG9yRnVuY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXBvcnRlcnNfW2hhc2hTdHJpbmddO1xuICAgIH07XG4gICAgU3RhdHNNYW5hZ2VyLmNvbGxlY3Rpb25zXyA9IHt9O1xuICAgIFN0YXRzTWFuYWdlci5yZXBvcnRlcnNfID0ge307XG4gICAgcmV0dXJuIFN0YXRzTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRzTWFuYWdlciA9IFN0YXRzTWFuYWdlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdHNNYW5hZ2VyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0YXRzL1N0YXRzTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFJlcG9fMSA9IHJlcXVpcmUoXCIuL1JlcG9cIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vdXRpbC9saWJzL3BhcnNlclwiKTtcbnZhciB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi91dGlsL3ZhbGlkYXRpb25cIik7XG5yZXF1aXJlKFwiLi9SZXBvX3RyYW5zYWN0aW9uXCIpO1xuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xudmFyIERBVEFCQVNFX1VSTF9PUFRJT04gPSAnZGF0YWJhc2VVUkwnO1xudmFyIF9zdGF0aWNJbnN0YW5jZTtcbi8qKlxuICogQ3JlYXRlcyBhbmQgY2FjaGVzIFJlcG8gaW5zdGFuY2VzLlxuICovXG52YXIgUmVwb01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVwb01hbmFnZXIoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7IU9iamVjdC48c3RyaW5nLCBPYmplY3Q8c3RyaW5nLCAhZmIuY29yZS5SZXBvPj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcG9zXyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSwgbmV3IFJlcG9zIHdpbGwgYmUgY3JlYXRlZCB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IChmb3IgdGVzdGluZyBwdXJwb3NlcykuXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VSZXN0Q2xpZW50XyA9IGZhbHNlO1xuICAgIH1cbiAgICBSZXBvTWFuYWdlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfc3RhdGljSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIF9zdGF0aWNJbnN0YW5jZSA9IG5ldyBSZXBvTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3RhdGljSW5zdGFuY2U7XG4gICAgfTtcbiAgICAvLyBUT0RPKGtvc3MpOiBSZW1vdmUgdGhlc2UgZnVuY3Rpb25zIHVubGVzcyB1c2VkIGluIHRlc3RzP1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGFwcE5hbWUgaW4gdGhpcy5yZXBvc18pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGRiVXJsIGluIHRoaXMucmVwb3NfW2FwcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvc19bYXBwTmFtZV1bZGJVcmxdLmludGVycnVwdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZXBvTWFuYWdlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBhcHBOYW1lIGluIHRoaXMucmVwb3NfKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkYlVybCBpbiB0aGlzLnJlcG9zX1thcHBOYW1lXSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3NfW2FwcE5hbWVdW2RiVXJsXS5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBldmVyIGJlIGNhbGxlZCB0byBDUkVBVEUgYSBuZXcgZGF0YWJhc2UgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFGaXJlYmFzZUFwcH0gYXBwXG4gICAgICogQHJldHVybiB7IURhdGFiYXNlfVxuICAgICAqL1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5kYXRhYmFzZUZyb21BcHAgPSBmdW5jdGlvbiAoYXBwLCB1cmwpIHtcbiAgICAgICAgdmFyIGRiVXJsID0gdXJsIHx8IGFwcC5vcHRpb25zW0RBVEFCQVNFX1VSTF9PUFRJT05dO1xuICAgICAgICBpZiAoZGJVcmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXRpbF8yLmZhdGFsKFwiQ2FuJ3QgZGV0ZXJtaW5lIEZpcmViYXNlIERhdGFiYXNlIFVSTC4gIEJlIHN1cmUgdG8gaW5jbHVkZSBcIiArXG4gICAgICAgICAgICAgICAgREFUQUJBU0VfVVJMX09QVElPTiArXG4gICAgICAgICAgICAgICAgJyBvcHRpb24gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmludGlhbGl6ZUFwcCgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWRVcmwgPSBwYXJzZXJfMS5wYXJzZVJlcG9JbmZvKGRiVXJsKTtcbiAgICAgICAgdmFyIHJlcG9JbmZvID0gcGFyc2VkVXJsLnJlcG9JbmZvO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVVcmwoJ0ludmFsaWQgRmlyZWJhc2UgRGF0YWJhc2UgVVJMJywgMSwgcGFyc2VkVXJsKTtcbiAgICAgICAgaWYgKCFwYXJzZWRVcmwucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHV0aWxfMi5mYXRhbCgnRGF0YWJhc2UgVVJMIG11c3QgcG9pbnQgdG8gdGhlIHJvb3Qgb2YgYSBGaXJlYmFzZSBEYXRhYmFzZSAnICtcbiAgICAgICAgICAgICAgICAnKG5vdCBpbmNsdWRpbmcgYSBjaGlsZCBwYXRoKS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwbyA9IHRoaXMuY3JlYXRlUmVwbyhyZXBvSW5mbywgYXBwKTtcbiAgICAgICAgcmV0dXJuIHJlcG8uZGF0YWJhc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHJlcG8gYW5kIG1ha2Ugc3VyZSBpdCBpcyBkaXNjb25uZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFSZXBvfSByZXBvXG4gICAgICovXG4gICAgUmVwb01hbmFnZXIucHJvdG90eXBlLmRlbGV0ZVJlcG8gPSBmdW5jdGlvbiAocmVwbykge1xuICAgICAgICB2YXIgYXBwUmVwb3MgPSB1dGlsXzEuc2FmZUdldCh0aGlzLnJlcG9zXywgcmVwby5hcHAubmFtZSk7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4uLlxuICAgICAgICBpZiAoIWFwcFJlcG9zIHx8IHV0aWxfMS5zYWZlR2V0KGFwcFJlcG9zLCByZXBvLnJlcG9JbmZvXy50b1VSTFN0cmluZygpKSAhPT0gcmVwbykge1xuICAgICAgICAgICAgdXRpbF8yLmZhdGFsKFwiRGF0YWJhc2UgXCIgKyByZXBvLmFwcC5uYW1lICsgXCIoXCIgKyByZXBvLnJlcG9JbmZvXyArIFwiKSBoYXMgYWxyZWFkeSBiZWVuIGRlbGV0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlcG8uaW50ZXJydXB0KCk7XG4gICAgICAgIGRlbGV0ZSBhcHBSZXBvc1tyZXBvLnJlcG9JbmZvXy50b1VSTFN0cmluZygpXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYSByZXBvIGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBhbmQgdGhlbiBjcmVhdGVzIG9uZSB1c2luZyB0aGVcbiAgICAgKiBwcm92aWRlZCBhcHAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm8gVGhlIG1ldGFkYXRhIGFib3V0IHRoZSBSZXBvXG4gICAgICogQHBhcmFtIHshRmlyZWJhc2VBcHB9IGFwcFxuICAgICAqIEByZXR1cm4geyFSZXBvfSBUaGUgUmVwbyBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgc2VydmVyIC8gcmVwb05hbWUuXG4gICAgICovXG4gICAgUmVwb01hbmFnZXIucHJvdG90eXBlLmNyZWF0ZVJlcG8gPSBmdW5jdGlvbiAocmVwb0luZm8sIGFwcCkge1xuICAgICAgICB2YXIgYXBwUmVwb3MgPSB1dGlsXzEuc2FmZUdldCh0aGlzLnJlcG9zXywgYXBwLm5hbWUpO1xuICAgICAgICBpZiAoIWFwcFJlcG9zKSB7XG4gICAgICAgICAgICBhcHBSZXBvcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5yZXBvc19bYXBwLm5hbWVdID0gYXBwUmVwb3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcG8gPSB1dGlsXzEuc2FmZUdldChhcHBSZXBvcywgcmVwb0luZm8udG9VUkxTdHJpbmcoKSk7XG4gICAgICAgIGlmIChyZXBvKSB7XG4gICAgICAgICAgICB1dGlsXzIuZmF0YWwoJ0RhdGFiYXNlIGluaXRpYWxpemVkIG11bHRpcGxlIHRpbWVzLiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBmb3JtYXQgb2YgdGhlIGRhdGFiYXNlIFVSTCBtYXRjaGVzIHdpdGggZWFjaCBkYXRhYmFzZSgpIGNhbGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbyA9IG5ldyBSZXBvXzEuUmVwbyhyZXBvSW5mbywgdGhpcy51c2VSZXN0Q2xpZW50XywgYXBwKTtcbiAgICAgICAgYXBwUmVwb3NbcmVwb0luZm8udG9VUkxTdHJpbmcoKV0gPSByZXBvO1xuICAgICAgICByZXR1cm4gcmVwbztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZvcmNlcyB1cyB0byB1c2UgUmVhZG9ubHlSZXN0Q2xpZW50IGluc3RlYWQgb2YgUGVyc2lzdGVudENvbm5lY3Rpb24gZm9yIG5ldyBSZXBvcy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlUmVzdENsaWVudFxuICAgICAqL1xuICAgIFJlcG9NYW5hZ2VyLnByb3RvdHlwZS5mb3JjZVJlc3RDbGllbnQgPSBmdW5jdGlvbiAoZm9yY2VSZXN0Q2xpZW50KSB7XG4gICAgICAgIHRoaXMudXNlUmVzdENsaWVudF8gPSBmb3JjZVJlc3RDbGllbnQ7XG4gICAgfTtcbiAgICByZXR1cm4gUmVwb01hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5SZXBvTWFuYWdlciA9IFJlcG9NYW5hZ2VyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXBvTWFuYWdlci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgZXJyb3JzRXhwb3J0cyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCAqIGFzIE1ldGFkYXRhVXRpbHMgZnJvbSAnLi9tZXRhZGF0YSc7XG5pbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vdHlwZSc7XG4vKipcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHNwZWNzIEFyZ3VtZW50IHNwZWNzLlxuICogQHBhcmFtIHBhc3NlZCBUaGUgYWN0dWFsIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLlxuICogQHRocm93cyB7ZmJzLkVycm9yfSBJZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUobmFtZSwgc3BlY3MsIHBhc3NlZCkge1xuICAgIHZhciBtaW5BcmdzID0gc3BlY3MubGVuZ3RoO1xuICAgIHZhciBtYXhBcmdzID0gc3BlY3MubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNwZWNzW2ldLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICBtaW5BcmdzID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB2YWxpZExlbmd0aCA9IG1pbkFyZ3MgPD0gcGFzc2VkLmxlbmd0aCAmJiBwYXNzZWQubGVuZ3RoIDw9IG1heEFyZ3M7XG4gICAgaWYgKCF2YWxpZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRBcmd1bWVudENvdW50KG1pbkFyZ3MsIG1heEFyZ3MsIG5hbWUsIHBhc3NlZC5sZW5ndGgpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhc3NlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BlY3NbaV0udmFsaWRhdG9yKHBhc3NlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludmFsaWRBcmd1bWVudChpLCBuYW1lLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnZhbGlkQXJndW1lbnQoaSwgbmFtZSwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIEFyZ1NwZWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnU3BlYyh2YWxpZGF0b3IsIG9wdF9vcHRpb25hbCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIGlmIChzZWxmLm9wdGlvbmFsICYmICF0eXBlLmlzSnVzdERlZihwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRvcihwKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9ICEhb3B0X29wdGlvbmFsO1xuICAgIH1cbiAgICByZXR1cm4gQXJnU3BlYztcbn0oKSk7XG5leHBvcnQgeyBBcmdTcGVjIH07XG5leHBvcnQgZnVuY3Rpb24gYW5kXyh2MSwgdjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdjEocCk7XG4gICAgICAgIHYyKHApO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nU3BlYyhvcHRfdmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpIHtcbiAgICBmdW5jdGlvbiBzdHJpbmdWYWxpZGF0b3IocCkge1xuICAgICAgICBpZiAoIXR5cGUuaXNTdHJpbmcocCkpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBzdHJpbmcuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdmFsaWRhdG9yO1xuICAgIGlmIChvcHRfdmFsaWRhdG9yKSB7XG4gICAgICAgIHZhbGlkYXRvciA9IGFuZF8oc3RyaW5nVmFsaWRhdG9yLCBvcHRfdmFsaWRhdG9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbGlkYXRvciA9IHN0cmluZ1ZhbGlkYXRvcjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvciwgb3B0X29wdGlvbmFsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGxvYWREYXRhU3BlYygpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgdmFsaWQgPSBwIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAgICAgcCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZS5pc05hdGl2ZUJsb2JEZWZpbmVkKCkgJiYgcCBpbnN0YW5jZW9mIEJsb2IpO1xuICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgQmxvYiBvciBGaWxlLic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvcik7XG59XG5leHBvcnQgZnVuY3Rpb24gbWV0YWRhdGFTcGVjKG9wdF9vcHRpb25hbCkge1xuICAgIHJldHVybiBuZXcgQXJnU3BlYyhNZXRhZGF0YVV0aWxzLm1ldGFkYXRhVmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vbk5lZ2F0aXZlTnVtYmVyU3BlYygpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgdmFsaWQgPSB0eXBlLmlzTnVtYmVyKHApICYmIHAgPj0gMDtcbiAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGEgbnVtYmVyIDAgb3IgZ3JlYXRlci4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJnU3BlYyh2YWxpZGF0b3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlT2JqZWN0U3BlYyhvcHRfdmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0b3IocCkge1xuICAgICAgICB2YXIgaXNMb29zZU9iamVjdCA9IHAgPT09IG51bGwgfHwgKHR5cGUuaXNEZWYocCkgJiYgcCBpbnN0YW5jZW9mIE9iamVjdCk7XG4gICAgICAgIGlmICghaXNMb29zZU9iamVjdCkge1xuICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGFuIE9iamVjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRfdmFsaWRhdG9yICE9PSB1bmRlZmluZWQgJiYgb3B0X3ZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0X3ZhbGlkYXRvcihwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEFyZ1NwZWModmFsaWRhdG9yLCBvcHRfb3B0aW9uYWwpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bGxGdW5jdGlvblNwZWMob3B0X29wdGlvbmFsKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdG9yKHApIHtcbiAgICAgICAgdmFyIHZhbGlkID0gcCA9PT0gbnVsbCB8fCB0eXBlLmlzRnVuY3Rpb24ocCk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCBhIEZ1bmN0aW9uLic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcmdTcGVjKHZhbGlkYXRvciwgb3B0X29wdGlvbmFsKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXJncy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9hcmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vanNvbic7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJy4vbG9jYXRpb24nO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICcuL3BhdGgnO1xuaW1wb3J0ICogYXMgdHlwZSBmcm9tICcuL3R5cGUnO1xuaW1wb3J0ICogYXMgVXJsVXRpbHMgZnJvbSAnLi91cmwnO1xuZXhwb3J0IGZ1bmN0aW9uIG5vWGZvcm1fKG1ldGFkYXRhLCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogQHN0cnVjdFxuICovXG52YXIgTWFwcGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBwaW5nKHNlcnZlciwgb3B0X2xvY2FsLCBvcHRfd3JpdGFibGUsIG9wdF94Zm9ybSkge1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5sb2NhbCA9IG9wdF9sb2NhbCB8fCBzZXJ2ZXI7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhIW9wdF93cml0YWJsZTtcbiAgICAgICAgdGhpcy54Zm9ybSA9IG9wdF94Zm9ybSB8fCBub1hmb3JtXztcbiAgICB9XG4gICAgcmV0dXJuIE1hcHBpbmc7XG59KCkpO1xuZXhwb3J0IHsgTWFwcGluZyB9O1xudmFyIG1hcHBpbmdzXyA9IG51bGw7XG5leHBvcnQgZnVuY3Rpb24geGZvcm1QYXRoKGZ1bGxQYXRoKSB7XG4gICAgdmFyIHZhbGlkID0gdHlwZS5pc1N0cmluZyhmdWxsUGF0aCk7XG4gICAgaWYgKCF2YWxpZCB8fCBmdWxsUGF0aC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBmdWxsUGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZ1bGxQYXRoID0gZnVsbFBhdGg7XG4gICAgICAgIHJldHVybiBwYXRoLmxhc3RDb21wb25lbnQoZnVsbFBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBwaW5ncygpIHtcbiAgICBpZiAobWFwcGluZ3NfKSB7XG4gICAgICAgIHJldHVybiBtYXBwaW5nc187XG4gICAgfVxuICAgIHZhciBtYXBwaW5ncyA9IFtdO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2J1Y2tldCcpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdnZW5lcmF0aW9uJykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21ldGFnZW5lcmF0aW9uJykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ25hbWUnLCAnZnVsbFBhdGgnLCB0cnVlKSk7XG4gICAgZnVuY3Rpb24gbWFwcGluZ3NYZm9ybVBhdGgobWV0YWRhdGEsIGZ1bGxQYXRoKSB7XG4gICAgICAgIHJldHVybiB4Zm9ybVBhdGgoZnVsbFBhdGgpO1xuICAgIH1cbiAgICB2YXIgbmFtZU1hcHBpbmcgPSBuZXcgTWFwcGluZygnbmFtZScpO1xuICAgIG5hbWVNYXBwaW5nLnhmb3JtID0gbWFwcGluZ3NYZm9ybVBhdGg7XG4gICAgbWFwcGluZ3MucHVzaChuYW1lTWFwcGluZyk7XG4gICAgLyoqXG4gICAgICogQ29lcmNlcyB0aGUgc2Vjb25kIHBhcmFtIHRvIGEgbnVtYmVyLCBpZiBpdCBpcyBkZWZpbmVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHhmb3JtU2l6ZShtZXRhZGF0YSwgc2l6ZSkge1xuICAgICAgICBpZiAodHlwZS5pc0RlZihzaXplKSkge1xuICAgICAgICAgICAgcmV0dXJuICtzaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNpemVNYXBwaW5nID0gbmV3IE1hcHBpbmcoJ3NpemUnKTtcbiAgICBzaXplTWFwcGluZy54Zm9ybSA9IHhmb3JtU2l6ZTtcbiAgICBtYXBwaW5ncy5wdXNoKHNpemVNYXBwaW5nKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCd0aW1lQ3JlYXRlZCcpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCd1cGRhdGVkJykpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21kNUhhc2gnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY2FjaGVDb250cm9sJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnREaXNwb3NpdGlvbicsIG51bGwsIHRydWUpKTtcbiAgICBtYXBwaW5ncy5wdXNoKG5ldyBNYXBwaW5nKCdjb250ZW50RW5jb2RpbmcnLCBudWxsLCB0cnVlKSk7XG4gICAgbWFwcGluZ3MucHVzaChuZXcgTWFwcGluZygnY29udGVudExhbmd1YWdlJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2NvbnRlbnRUeXBlJywgbnVsbCwgdHJ1ZSkpO1xuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ21ldGFkYXRhJywgJ2N1c3RvbU1ldGFkYXRhJywgdHJ1ZSkpO1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9mIHRva2VucyBpbnRvIGEgbGlzdCBvZiBkb3dubG9hZFxuICAgICAqIFVSTHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24geGZvcm1Ub2tlbnMobWV0YWRhdGEsIHRva2Vucykge1xuICAgICAgICB2YXIgdmFsaWQgPSB0eXBlLmlzU3RyaW5nKHRva2VucykgJiYgdG9rZW5zLmxlbmd0aCA+IDA7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiBvYmplY3RzIGFyZSB1cGxvYWRlZCB0aHJvdWdoIEdDUyBhbmQgcmV0cmlldmVkXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGxpc3QsIHNvIHdlIGRvbid0IHdhbnQgdG8gdGhyb3cgYW4gRXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICAgICAgdmFyIHRva2Vuc0xpc3QgPSB0b2tlbnMuc3BsaXQoJywnKTtcbiAgICAgICAgdmFyIHVybHMgPSB0b2tlbnNMaXN0Lm1hcChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBidWNrZXQgPSBtZXRhZGF0YVsnYnVja2V0J107XG4gICAgICAgICAgICB2YXIgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICAgICAgdmFyIHVybFBhcnQgPSAnL2IvJyArIGVuY29kZShidWNrZXQpICsgJy9vLycgKyBlbmNvZGUocGF0aCk7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IFVybFV0aWxzLm1ha2VEb3dubG9hZFVybCh1cmxQYXJ0KTtcbiAgICAgICAgICAgIHZhciBxdWVyeVN0cmluZyA9IFVybFV0aWxzLm1ha2VRdWVyeVN0cmluZyh7XG4gICAgICAgICAgICAgICAgYWx0OiAnbWVkaWEnLFxuICAgICAgICAgICAgICAgIHRva2VuOiB0b2tlblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYmFzZSArIHF1ZXJ5U3RyaW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVybHM7XG4gICAgfVxuICAgIG1hcHBpbmdzLnB1c2gobmV3IE1hcHBpbmcoJ2Rvd25sb2FkVG9rZW5zJywgJ2Rvd25sb2FkVVJMcycsIGZhbHNlLCB4Zm9ybVRva2VucykpO1xuICAgIG1hcHBpbmdzXyA9IG1hcHBpbmdzO1xuICAgIHJldHVybiBtYXBwaW5nc187XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkUmVmKG1ldGFkYXRhLCBhdXRoV3JhcHBlcikge1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlUmVmKCkge1xuICAgICAgICB2YXIgYnVja2V0ID0gbWV0YWRhdGFbJ2J1Y2tldCddO1xuICAgICAgICB2YXIgcGF0aCA9IG1ldGFkYXRhWydmdWxsUGF0aCddO1xuICAgICAgICB2YXIgbG9jID0gbmV3IExvY2F0aW9uKGJ1Y2tldCwgcGF0aCk7XG4gICAgICAgIHJldHVybiBhdXRoV3JhcHBlci5tYWtlU3RvcmFnZVJlZmVyZW5jZShsb2MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWV0YWRhdGEsICdyZWYnLCB7IGdldDogZ2VuZXJhdGVSZWYgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbVJlc291cmNlKGF1dGhXcmFwcGVyLCByZXNvdXJjZSwgbWFwcGluZ3MpIHtcbiAgICB2YXIgbWV0YWRhdGEgPSB7fTtcbiAgICBtZXRhZGF0YVsndHlwZSddID0gJ2ZpbGUnO1xuICAgIHZhciBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgICBtZXRhZGF0YVttYXBwaW5nLmxvY2FsXSA9IG1hcHBpbmcueGZvcm0obWV0YWRhdGEsIHJlc291cmNlW21hcHBpbmcuc2VydmVyXSk7XG4gICAgfVxuICAgIGFkZFJlZihtZXRhZGF0YSwgYXV0aFdyYXBwZXIpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUmVzb3VyY2VTdHJpbmcoYXV0aFdyYXBwZXIsIHJlc291cmNlU3RyaW5nLCBtYXBwaW5ncykge1xuICAgIHZhciBvYmogPSBqc29uLmpzb25PYmplY3RPck51bGwocmVzb3VyY2VTdHJpbmcpO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZXNvdXJjZSA9IG9iajtcbiAgICByZXR1cm4gZnJvbVJlc291cmNlKGF1dGhXcmFwcGVyLCByZXNvdXJjZSwgbWFwcGluZ3MpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvUmVzb3VyY2VTdHJpbmcobWV0YWRhdGEsIG1hcHBpbmdzKSB7XG4gICAgdmFyIHJlc291cmNlID0ge307XG4gICAgdmFyIGxlbiA9IG1hcHBpbmdzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYXBwaW5nID0gbWFwcGluZ3NbaV07XG4gICAgICAgIGlmIChtYXBwaW5nLndyaXRhYmxlKSB7XG4gICAgICAgICAgICByZXNvdXJjZVttYXBwaW5nLnNlcnZlcl0gPSBtZXRhZGF0YVttYXBwaW5nLmxvY2FsXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzb3VyY2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFkYXRhVmFsaWRhdG9yKHApIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gcCAmJiB0eXBlLmlzT2JqZWN0KHApO1xuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICAgIHRocm93ICdFeHBlY3RlZCBNZXRhZGF0YSBvYmplY3QuJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHApIHtcbiAgICAgICAgdmFyIHZhbCA9IHBba2V5XTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2N1c3RvbU1ldGFkYXRhJykge1xuICAgICAgICAgICAgaWYgKCF0eXBlLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgb2JqZWN0IGZvciBcXCdjdXN0b21NZXRhZGF0YVxcJyBtYXBwaW5nLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZS5pc05vbk51bGxPYmplY3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiTWFwcGluZyBmb3IgJ1wiICsga2V5ICsgXCInIGNhbm5vdCBiZSBhbiBvYmplY3QuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL21ldGFkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRnVuY3Rpb25zIHRvIGNyZWF0ZSBhbmQgbWFuaXB1bGF0ZSBVUkxzIGZvciB0aGUgc2VydmVyIEFQSS5cbiAqL1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gbWFrZU5vcm1hbFVybCh1cmxQYXJ0KSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5kb21haW5CYXNlICsgY29uc3RhbnRzLmFwaUJhc2VVcmwgKyB1cmxQYXJ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VEb3dubG9hZFVybCh1cmxQYXJ0KSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5kb3dubG9hZEJhc2UgKyBjb25zdGFudHMuYXBpQmFzZVVybCArIHVybFBhcnQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbWFrZVVwbG9hZFVybCh1cmxQYXJ0KSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5kb21haW5CYXNlICsgY29uc3RhbnRzLmFwaVVwbG9hZEJhc2VVcmwgKyB1cmxQYXJ0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VRdWVyeVN0cmluZyhwYXJhbXMpIHtcbiAgICB2YXIgZW5jb2RlID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuICAgIHZhciBxdWVyeVBhcnQgPSAnPyc7XG4gICAgb2JqZWN0LmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgdmFyIG5leHRQYXJ0ID0gZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodmFsKTtcbiAgICAgICAgcXVlcnlQYXJ0ID0gcXVlcnlQYXJ0ICsgbmV4dFBhcnQgKyAnJic7XG4gICAgfSk7XG4gICAgLy8gQ2hvcCBvZmYgdGhlIGV4dHJhICcmJyBvciAnPycgb24gdGhlIGVuZFxuICAgIHF1ZXJ5UGFydCA9IHF1ZXJ5UGFydC5zbGljZSgwLCAtMSk7XG4gICAgcmV0dXJuIHF1ZXJ5UGFydDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3VybC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBjb250YWluZWQgaW4gdGhlIGFycmF5IChjb21wYXJlZCB3aXRoID09PSkuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIGVsZW0pIHtcbiAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtKSAhPT0gLTE7XG59XG4vKipcbiAqIFJldHVybnMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0IChlLmcuIGFyZ3VtZW50cykuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYXJyYXlsaWtlKSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycmF5bGlrZSk7XG59XG4vKipcbiAqIFJlbW92ZXMgdGhlIGdpdmVuIGVsZW1lbnQgZnJvbSB0aGUgZ2l2ZW4gYXJyYXksIGlmIGl0IGlzIGNvbnRhaW5lZC5cbiAqIERpcmVjdGx5IG1vZGlmaWVzIHRoZSBwYXNzZWQtaW4gYXJyYXkuXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBlbGVtKSB7XG4gICAgdmFyIGkgPSBhcnJheS5pbmRleE9mKGVsZW0pO1xuICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5yZXF1aXJlKCdAZmlyZWJhc2UvcG9seWZpbGwnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnQGZpcmViYXNlL2FwcCcpLmRlZmF1bHQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hcHAvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxucmVxdWlyZSgnQGZpcmViYXNlL2F1dGgnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2F1dGgvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgYXNzZXJ0aW9uIGlzIGZhbHN5XG4gKiBAcGFyYW0geyp9IGFzc2VydGlvbiBUaGUgYXNzZXJ0aW9uIHRvIGJlIHRlc3RlZCBmb3IgZmFsc2luZXNzXG4gKiBAcGFyYW0geyFzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpZiB0aGUgY2hlY2sgZmFpbHNcbiAqL1xuZXhwb3J0cy5hc3NlcnQgPSBmdW5jdGlvbiAoYXNzZXJ0aW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFhc3NlcnRpb24pIHtcbiAgICAgICAgdGhyb3cgZXhwb3J0cy5hc3NlcnRpb25FcnJvcihtZXNzYWdlKTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZXR1cm5zIGFuIEVycm9yIG9iamVjdCBzdWl0YWJsZSBmb3IgdGhyb3dpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybiB7IUVycm9yfVxuICovXG5leHBvcnRzLmFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdGaXJlYmFzZSBEYXRhYmFzZSAoJyArXG4gICAgICAgIGNvbnN0YW50c18xLkNPTlNUQU5UUy5TREtfVkVSU0lPTiArXG4gICAgICAgICcpIElOVEVSTkFMIEFTU0VSVCBGQUlMRUQ6ICcgK1xuICAgICAgICBtZXNzYWdlKTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9hc3NlcnQuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN0cmluZ1RvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgcCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgd2hpbGUgKGMgPiAyNTUpIHtcbiAgICAgICAgICAgIG91dHB1dFtwKytdID0gYyAmIDI1NTtcbiAgICAgICAgICAgIGMgPj49IDg7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0W3ArK10gPSBjO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgbnVtYmVycyBpbnRvIHRoZSBzdHJpbmcgZ2l2ZW4gYnkgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gKiBjaGFyYWN0ZXJzIHRvIHdoaWNoIHRoZSBudW1iZXJzIGNvcnJlc3BvbmQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJ5dGVzIEFycmF5IG9mIG51bWJlcnMgcmVwcmVzZW50aW5nIGNoYXJhY3RlcnMuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZ2lmaWNhdGlvbiBvZiB0aGUgYXJyYXkuXG4gKi9cbnZhciBieXRlQXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgIHZhciBDSFVOS19TSVpFID0gODE5MjtcbiAgICAvLyBTcGVjaWFsLWNhc2UgdGhlIHNpbXBsZSBjYXNlIGZvciBzcGVlZCdzIHNha2UuXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA8IENIVU5LX1NJWkUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICAgIH1cbiAgICAvLyBUaGUgcmVtYWluaW5nIGxvZ2ljIHNwbGl0cyBjb252ZXJzaW9uIGJ5IGNodW5rcyBzaW5jZVxuICAgIC8vIEZ1bmN0aW9uI2FwcGx5KCkgaGFzIGEgbWF4aW11bSBwYXJhbWV0ZXIgY291bnQuXG4gICAgLy8gU2VlIGRpc2N1c3Npb246IGh0dHA6Ly9nb28uZ2wvTHJXbVo5XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IENIVU5LX1NJWkUpIHtcbiAgICAgICAgdmFyIGNodW5rID0gYnl0ZXMuc2xpY2UoaSwgaSArIENIVU5LX1NJWkUpO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuayk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59O1xuLy8gU3RhdGljIGxvb2t1cCBtYXBzLCBsYXppbHkgcG9wdWxhdGVkIGJ5IGluaXRfKClcbmV4cG9ydHMuYmFzZTY0ID0ge1xuICAgIC8qKlxuICAgICAqIE1hcHMgYnl0ZXMgdG8gY2hhcmFjdGVycy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnl0ZVRvQ2hhck1hcF86IG51bGwsXG4gICAgLyoqXG4gICAgICogTWFwcyBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwXzogbnVsbCxcbiAgICAvKipcbiAgICAgKiBNYXBzIGJ5dGVzIHRvIHdlYnNhZmUgY2hhcmFjdGVycy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnl0ZVRvQ2hhck1hcFdlYlNhZmVfOiBudWxsLFxuICAgIC8qKlxuICAgICAqIE1hcHMgd2Vic2FmZSBjaGFyYWN0ZXJzIHRvIGJ5dGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjaGFyVG9CeXRlTWFwV2ViU2FmZV86IG51bGwsXG4gICAgLyoqXG4gICAgICogT3VyIGRlZmF1bHQgYWxwaGFiZXQsIHNoYXJlZCBiZXR3ZWVuXG4gICAgICogRU5DT0RFRF9WQUxTIGFuZCBFTkNPREVEX1ZBTFNfV0VCU0FGRVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgRU5DT0RFRF9WQUxTX0JBU0U6ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicgKyAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonICsgJzAxMjM0NTY3ODknLFxuICAgIC8qKlxuICAgICAqIE91ciBkZWZhdWx0IGFscGhhYmV0LiBWYWx1ZSA2NCAoPSkgaXMgc3BlY2lhbDsgaXQgbWVhbnMgXCJub3RoaW5nLlwiXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgRU5DT0RFRF9WQUxTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRSArICcrLz0nO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogT3VyIHdlYnNhZmUgYWxwaGFiZXQuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgRU5DT0RFRF9WQUxTX1dFQlNBRkUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkVOQ09ERURfVkFMU19CQVNFICsgJy1fLic7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgYnJvd3NlciBzdXBwb3J0cyB0aGUgYXRvYiBhbmQgYnRvYSBmdW5jdGlvbnMuIFRoaXMgZXh0ZW5zaW9uXG4gICAgICogc3RhcnRlZCBhdCBNb3ppbGxhIGJ1dCBpcyBub3cgaW1wbGVtZW50ZWQgYnkgbWFueSBicm93c2Vycy4gV2UgdXNlIHRoZVxuICAgICAqIEFTU1VNRV8qIHZhcmlhYmxlcyB0byBhdm9pZCBwdWxsaW5nIGluIHRoZSBmdWxsIHVzZXJhZ2VudCBkZXRlY3Rpb24gbGlicmFyeVxuICAgICAqIGJ1dCBzdGlsbCBhbGxvd2luZyB0aGUgc3RhbmRhcmQgcGVyLWJyb3dzZXIgY29tcGlsYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgSEFTX05BVElWRV9TVVBQT1JUOiB0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAvKipcbiAgICAgKiBCYXNlNjQtZW5jb2RlIGFuIGFycmF5IG9mIGJ5dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fFVpbnQ4QXJyYXl9IGlucHV0IEFuIGFycmF5IG9mIGJ5dGVzIChudW1iZXJzIHdpdGhcbiAgICAgKiAgICAgdmFsdWUgaW4gWzAsIDI1NV0pIHRvIGVuY29kZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfd2ViU2FmZSBCb29sZWFuIGluZGljYXRpbmcgd2Ugc2hvdWxkIHVzZSB0aGVcbiAgICAgKiAgICAgYWx0ZXJuYXRpdmUgYWxwaGFiZXQuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZUJ5dGVBcnJheTogZnVuY3Rpb24gKGlucHV0LCBvcHRfd2ViU2FmZSkge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignZW5jb2RlQnl0ZUFycmF5IHRha2VzIGFuIGFycmF5IGFzIGEgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0XygpO1xuICAgICAgICB2YXIgYnl0ZVRvQ2hhck1hcCA9IG9wdF93ZWJTYWZlXG4gICAgICAgICAgICA/IHRoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfXG4gICAgICAgICAgICA6IHRoaXMuYnl0ZVRvQ2hhck1hcF87XG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgdmFyIGJ5dGUxID0gaW5wdXRbaV07XG4gICAgICAgICAgICB2YXIgaGF2ZUJ5dGUyID0gaSArIDEgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYnl0ZTIgPSBoYXZlQnl0ZTIgPyBpbnB1dFtpICsgMV0gOiAwO1xuICAgICAgICAgICAgdmFyIGhhdmVCeXRlMyA9IGkgKyAyIDwgaW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGJ5dGUzID0gaGF2ZUJ5dGUzID8gaW5wdXRbaSArIDJdIDogMDtcbiAgICAgICAgICAgIHZhciBvdXRCeXRlMSA9IGJ5dGUxID4+IDI7XG4gICAgICAgICAgICB2YXIgb3V0Qnl0ZTIgPSAoKGJ5dGUxICYgMHgwMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XG4gICAgICAgICAgICB2YXIgb3V0Qnl0ZTMgPSAoKGJ5dGUyICYgMHgwZikgPDwgMikgfCAoYnl0ZTMgPj4gNik7XG4gICAgICAgICAgICB2YXIgb3V0Qnl0ZTQgPSBieXRlMyAmIDB4M2Y7XG4gICAgICAgICAgICBpZiAoIWhhdmVCeXRlMykge1xuICAgICAgICAgICAgICAgIG91dEJ5dGU0ID0gNjQ7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXZlQnl0ZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0Qnl0ZTMgPSA2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQucHVzaChieXRlVG9DaGFyTWFwW291dEJ5dGUxXSwgYnl0ZVRvQ2hhck1hcFtvdXRCeXRlMl0sIGJ5dGVUb0NoYXJNYXBbb3V0Qnl0ZTNdLCBieXRlVG9DaGFyTWFwW291dEJ5dGU0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEJhc2U2NC1lbmNvZGUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgQSBzdHJpbmcgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF93ZWJTYWZlIElmIHRydWUsIHdlIHNob3VsZCB1c2UgdGhlXG4gICAgICogICAgIGFsdGVybmF0aXZlIGFscGhhYmV0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmNvZGVTdHJpbmc6IGZ1bmN0aW9uIChpbnB1dCwgb3B0X3dlYlNhZmUpIHtcbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIE1vemlsbGEgYnJvd3NlcnMgdGhhdCBpbXBsZW1lbnRcbiAgICAgICAgLy8gYSBuYXRpdmUgYmFzZTY0IGVuY29kZXIgaW4gdGhlIGZvcm0gb2YgXCJidG9hL2F0b2JcIlxuICAgICAgICBpZiAodGhpcy5IQVNfTkFUSVZFX1NVUFBPUlQgJiYgIW9wdF93ZWJTYWZlKSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQnl0ZUFycmF5KHN0cmluZ1RvQnl0ZUFycmF5KGlucHV0KSwgb3B0X3dlYlNhZmUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZVxuICAgICAqICAgICBhbHRlcm5hdGl2ZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGRlY29kZWQgdmFsdWUuXG4gICAgICovXG4gICAgZGVjb2RlU3RyaW5nOiBmdW5jdGlvbiAoaW5wdXQsIG9wdF93ZWJTYWZlKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBNb3ppbGxhIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50XG4gICAgICAgIC8vIGEgbmF0aXZlIGJhc2U2NCBlbmNvZGVyIGluIHRoZSBmb3JtIG9mIFwiYnRvYS9hdG9iXCJcbiAgICAgICAgaWYgKHRoaXMuSEFTX05BVElWRV9TVVBQT1JUICYmICFvcHRfd2ViU2FmZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlQXJyYXlUb1N0cmluZyh0aGlzLmRlY29kZVN0cmluZ1RvQnl0ZUFycmF5KGlucHV0LCBvcHRfd2ViU2FmZSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQmFzZTY0LWRlY29kZSBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEluIGJhc2UtNjQgZGVjb2RpbmcsIGdyb3VwcyBvZiBmb3VyIGNoYXJhY3RlcnMgYXJlIGNvbnZlcnRlZCBpbnRvIHRocmVlXG4gICAgICogYnl0ZXMuICBJZiB0aGUgZW5jb2RlciBkaWQgbm90IGFwcGx5IHBhZGRpbmcsIHRoZSBpbnB1dCBsZW5ndGggbWF5IG5vdFxuICAgICAqIGJlIGEgbXVsdGlwbGUgb2YgNC5cbiAgICAgKlxuICAgICAqIEluIHRoaXMgY2FzZSwgdGhlIGxhc3QgZ3JvdXAgd2lsbCBoYXZlIGZld2VyIHRoYW4gNCBjaGFyYWN0ZXJzLCBhbmRcbiAgICAgKiBwYWRkaW5nIHdpbGwgYmUgaW5mZXJyZWQuICBJZiB0aGUgZ3JvdXAgaGFzIG9uZSBvciB0d28gY2hhcmFjdGVycywgaXQgZGVjb2Rlc1xuICAgICAqIHRvIG9uZSBieXRlLiAgSWYgdGhlIGdyb3VwIGhhcyB0aHJlZSBjaGFyYWN0ZXJzLCBpdCBkZWNvZGVzIHRvIHR3byBieXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBJbnB1dCB0byBkZWNvZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X3dlYlNhZmUgVHJ1ZSBpZiB3ZSBzaG91bGQgdXNlIHRoZSB3ZWItc2FmZSBhbHBoYWJldC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8bnVtYmVyPn0gYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBkZWNvZGVkIHZhbHVlLlxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZ1RvQnl0ZUFycmF5OiBmdW5jdGlvbiAoaW5wdXQsIG9wdF93ZWJTYWZlKSB7XG4gICAgICAgIHRoaXMuaW5pdF8oKTtcbiAgICAgICAgdmFyIGNoYXJUb0J5dGVNYXAgPSBvcHRfd2ViU2FmZVxuICAgICAgICAgICAgPyB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1xuICAgICAgICAgICAgOiB0aGlzLmNoYXJUb0J5dGVNYXBfO1xuICAgICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICAgICAgdmFyIGJ5dGUxID0gY2hhclRvQnl0ZU1hcFtpbnB1dC5jaGFyQXQoaSsrKV07XG4gICAgICAgICAgICB2YXIgaGF2ZUJ5dGUyID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBieXRlMiA9IGhhdmVCeXRlMiA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDA7XG4gICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB2YXIgaGF2ZUJ5dGUzID0gaSA8IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBieXRlMyA9IGhhdmVCeXRlMyA/IGNoYXJUb0J5dGVNYXBbaW5wdXQuY2hhckF0KGkpXSA6IDY0O1xuICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgdmFyIGhhdmVCeXRlNCA9IGkgPCBpbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYnl0ZTQgPSBoYXZlQnl0ZTQgPyBjaGFyVG9CeXRlTWFwW2lucHV0LmNoYXJBdChpKV0gOiA2NDtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGlmIChieXRlMSA9PSBudWxsIHx8IGJ5dGUyID09IG51bGwgfHwgYnl0ZTMgPT0gbnVsbCB8fCBieXRlNCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvdXRCeXRlMSA9IChieXRlMSA8PCAyKSB8IChieXRlMiA+PiA0KTtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKG91dEJ5dGUxKTtcbiAgICAgICAgICAgIGlmIChieXRlMyAhPSA2NCkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRCeXRlMiA9ICgoYnl0ZTIgPDwgNCkgJiAweGYwKSB8IChieXRlMyA+PiAyKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMik7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGU0ICE9IDY0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvdXRCeXRlMyA9ICgoYnl0ZTMgPDwgNikgJiAweGMwKSB8IGJ5dGU0O1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChvdXRCeXRlMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBMYXp5IHN0YXRpYyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbi4gQ2FsbGVkIGJlZm9yZVxuICAgICAqIGFjY2Vzc2luZyBhbnkgb2YgdGhlIHN0YXRpYyBtYXAgdmFyaWFibGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdF86IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ5dGVUb0NoYXJNYXBfKSB7XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfID0ge307XG4gICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlXyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwV2ViU2FmZV8gPSB7fTtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgcXVpY2sgbWFwcGluZ3MgYmFjayBhbmQgZm9ydGgsIHNvIHdlIHByZWNvbXB1dGUgdHdvIG1hcHMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuRU5DT0RFRF9WQUxTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlVG9DaGFyTWFwX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBfW3RoaXMuYnl0ZVRvQ2hhck1hcF9baV1dID0gaTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVUb0NoYXJNYXBXZWJTYWZlX1tpXSA9IHRoaXMuRU5DT0RFRF9WQUxTX1dFQlNBRkUuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhclRvQnl0ZU1hcFdlYlNhZmVfW3RoaXMuYnl0ZVRvQ2hhck1hcFdlYlNhZmVfW2ldXSA9IGk7XG4gICAgICAgICAgICAgICAgLy8gQmUgZm9yZ2l2aW5nIHdoZW4gZGVjb2RpbmcgYW5kIGNvcnJlY3RseSBkZWNvZGUgYm90aCBlbmNvZGluZ3MuXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gdGhpcy5FTkNPREVEX1ZBTFNfQkFTRS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFyVG9CeXRlTWFwX1t0aGlzLkVOQ09ERURfVkFMU19XRUJTQUZFLmNoYXJBdChpKV0gPSBpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJUb0J5dGVNYXBXZWJTYWZlX1t0aGlzLkVOQ09ERURfVkFMUy5jaGFyQXQoaSldID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZW5jb2RpbmdcbiAqIEBwYXJhbSB7IXN0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHshc3RyaW5nfVxuICovXG5leHBvcnRzLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgdXRmOEJ5dGVzID0gc3RyaW5nVG9CeXRlQXJyYXkoc3RyKTtcbiAgICByZXR1cm4gZXhwb3J0cy5iYXNlNjQuZW5jb2RlQnl0ZUFycmF5KHV0ZjhCeXRlcywgdHJ1ZSk7XG59O1xuLyoqXG4gKiBVUkwtc2FmZSBiYXNlNjQgZGVjb2RpbmdcbiAqXG4gKiBOT1RFOiBETyBOT1QgdXNlIHRoZSBnbG9iYWwgYXRvYigpIGZ1bmN0aW9uIC0gaXQgZG9lcyBOT1Qgc3VwcG9ydCB0aGVcbiAqIGJhc2U2NFVybCB2YXJpYW50IGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVG8gYmUgZGVjb2RlZFxuICogQHJldHVybiB7P3N0cmluZ30gRGVjb2RlZCByZXN1bHQsIGlmIHBvc3NpYmxlXG4gKi9cbmV4cG9ydHMuYmFzZTY0RGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmJhc2U2NC5kZWNvZGVTdHJpbmcoc3RyLCB0cnVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignYmFzZTY0RGVjb2RlIGZhaWxlZDogJywgZSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvY3J5cHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBFdmFsdWF0ZXMgYSBKU09OIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBjb250YWluaW5nIEpTT04uXG4gKiBAcmV0dXJuIHsqfSBUaGUgamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgSlNPTi5cbiAqL1xuZnVuY3Rpb24ganNvbkV2YWwoc3RyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbn1cbmV4cG9ydHMuanNvbkV2YWwgPSBqc29uRXZhbDtcbi8qKlxuICogUmV0dXJucyBKU09OIHJlcHJlc2VudGluZyBhIGphdmFzY3JpcHQgb2JqZWN0LlxuICogQHBhcmFtIHsqfSBkYXRhIEphdmFzY3JpcHQgb2JqZWN0IHRvIGJlIHN0cmluZ2lmaWVkLlxuICogQHJldHVybiB7c3RyaW5nfSBUaGUgSlNPTiBjb250ZW50cyBvZiB0aGUgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnkoZGF0YSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2pzb24uanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gU2VlIGh0dHA6Ly93d3cuZGV2dGhvdWdodC5jb20vMjAxMi8wMS8xOC9hbi1vYmplY3QtaXMtbm90LWEtaGFzaC9cbmV4cG9ydHMuY29udGFpbnMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5leHBvcnRzLnNhZmVHZXQgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSlcbiAgICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZC5cbn07XG4vKipcbiAqIEVudW1lcmF0ZXMgdGhlIGtleXMvdmFsdWVzIGluIGFuIG9iamVjdCwgZXhjbHVkaW5nIGtleXMgZGVmaW5lZCBvbiB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7P09iamVjdC48SyxWPn0gb2JqIE9iamVjdCB0byBlbnVtZXJhdGUuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnRzLmZvckVhY2ggPSBmdW5jdGlvbiAob2JqLCBmbikge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgIGZuKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQ29waWVzIGFsbCB0aGUgKG93bikgcHJvcGVydGllcyBmcm9tIG9uZSBvYmplY3QgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqVG9cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqRnJvbVxuICogQHJldHVybiB7IU9iamVjdH0gb2JqVG9cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbiAob2JqVG8sIG9iakZyb20pIHtcbiAgICBleHBvcnRzLmZvckVhY2gob2JqRnJvbSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgb2JqVG9ba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmpUbztcbn07XG4vKipcbiAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBjbG9uZWQgb2JqLlxuICovXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBleHBvcnRzLmV4dGVuZCh7fSwgb2JqKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaGFzIHR5cGVvZiBcIm9iamVjdFwiIGFuZCBpcyBub3QgbnVsbC4gIFVubGlrZSBnb29nLmlzT2JqZWN0KCksIGRvZXMgbm90IHJldHVybiB0cnVlXG4gKiBmb3IgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBvYmogeyp9IEEgcG90ZW50aWFsIG9iamVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGl0J3MgYW4gb2JqZWN0LlxuICovXG5leHBvcnRzLmlzTm9uTnVsbE9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsO1xufTtcbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZXhwb3J0cy5nZXRDb3VudCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcnYgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcnYrKztcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufTtcbmV4cG9ydHMubWFwID0gZnVuY3Rpb24gKG9iaiwgZiwgb3B0X29iaikge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc1trZXldID0gZi5jYWxsKG9wdF9vYmosIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuZXhwb3J0cy5maW5kS2V5ID0gZnVuY3Rpb24gKG9iaiwgZm4sIG9wdF90aGlzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoZm4uY2FsbChvcHRfdGhpcywgb2JqW2tleV0sIGtleSwgb2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbmV4cG9ydHMuZmluZFZhbHVlID0gZnVuY3Rpb24gKG9iaiwgZm4sIG9wdF90aGlzKSB7XG4gICAgdmFyIGtleSA9IGV4cG9ydHMuZmluZEtleShvYmosIGZuLCBvcHRfdGhpcyk7XG4gICAgcmV0dXJuIGtleSAmJiBvYmpba2V5XTtcbn07XG5leHBvcnRzLmdldEFueUtleSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxufTtcbmV4cG9ydHMuZ2V0VmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICByZXNbaSsrXSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcbi8qKlxuICogVGVzdHMgd2hldGhlciBldmVyeSBrZXkvdmFsdWUgcGFpciBpbiBhbiBvYmplY3QgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZFxuICogYnkgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHs/T2JqZWN0LjxLLFY+fSBvYmogT2JqZWN0IHRvIHRlc3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbihLLCBWKX0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBrZXkgYW5kIHZhbHVlLlxuICogQHRlbXBsYXRlIEssVlxuICovXG5leHBvcnRzLmV2ZXJ5ID0gZnVuY3Rpb24gKG9iaiwgZm4pIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGtleSwgb2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL29iai5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC9saWJzL3BhcnNlclwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL1BhdGhcIik7XG52YXIgUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9SZWZlcmVuY2VcIik7XG52YXIgUmVwb18xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb1wiKTtcbnZhciBSZXBvTWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb01hbmFnZXJcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgZmlyZWJhc2UgZGF0YWJhc2UuXG4gKiBAaW1wbGVtZW50cyB7RmlyZWJhc2VTZXJ2aWNlfVxuICovXG52YXIgRGF0YWJhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGJ5IHVzZXJzIG9mIG91ciBwdWJsaWMgQVBJLlxuICAgICAqIEBwYXJhbSB7IVJlcG99IHJlcG9fXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGF0YWJhc2UocmVwb18pIHtcbiAgICAgICAgdGhpcy5yZXBvXyA9IHJlcG9fO1xuICAgICAgICBpZiAoIShyZXBvXyBpbnN0YW5jZW9mIFJlcG9fMS5SZXBvKSkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKFwiRG9uJ3QgY2FsbCBuZXcgRGF0YWJhc2UoKSBkaXJlY3RseSAtIHBsZWFzZSB1c2UgZmlyZWJhc2UuZGF0YWJhc2UoKS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEB0eXBlIHtSZWZlcmVuY2V9ICovXG4gICAgICAgIHRoaXMucm9vdF8gPSBuZXcgUmVmZXJlbmNlXzEuUmVmZXJlbmNlKHJlcG9fLCBQYXRoXzEuUGF0aC5FbXB0eSk7XG4gICAgICAgIHRoaXMuSU5URVJOQUwgPSBuZXcgRGF0YWJhc2VJbnRlcm5hbHModGhpcyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhYmFzZS5wcm90b3R5cGUsIFwiYXBwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBvXy5hcHA7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb3IgdGhlIHBhdGggc3BlY2lmaWVkIGluIG9wdF9wYXRoU3RyaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gcGF0aFN0cmluZ1xuICAgICAqIEByZXR1cm4geyFSZWZlcmVuY2V9IEZpcmViYXNlIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBEYXRhYmFzZS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdyZWYnKTtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ2RhdGFiYXNlLnJlZicsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyAhPT0gdW5kZWZpbmVkID8gdGhpcy5yb290Xy5jaGlsZChwYXRoU3RyaW5nKSA6IHRoaXMucm9vdF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSByb290IG9yIHRoZSBwYXRoIHNwZWNpZmllZCBpbiB1cmwuXG4gICAgICogV2UgdGhyb3cgYSBleGNlcHRpb24gaWYgdGhlIHVybCBpcyBub3QgaW4gdGhlIHNhbWUgZG9tYWluIGFzIHRoZVxuICAgICAqIGN1cnJlbnQgcmVwby5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX0gRmlyZWJhc2UgcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5yZWZGcm9tVVJMID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAvKiogQGNvbnN0IHtzdHJpbmd9ICovXG4gICAgICAgIHZhciBhcGlOYW1lID0gJ2RhdGFiYXNlLnJlZkZyb21VUkwnO1xuICAgICAgICB0aGlzLmNoZWNrRGVsZXRlZF8oYXBpTmFtZSk7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KGFwaU5hbWUsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgcGFyc2VkVVJMID0gcGFyc2VyXzEucGFyc2VSZXBvSW5mbyh1cmwpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVVcmwoYXBpTmFtZSwgMSwgcGFyc2VkVVJMKTtcbiAgICAgICAgdmFyIHJlcG9JbmZvID0gcGFyc2VkVVJMLnJlcG9JbmZvO1xuICAgICAgICBpZiAocmVwb0luZm8uaG9zdCAhPT0gdGhpcy5yZXBvXy5yZXBvSW5mb18uaG9zdCkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKGFwaU5hbWUgK1xuICAgICAgICAgICAgICAgICc6IEhvc3QgbmFtZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBkYXRhYmFzZTogJyArXG4gICAgICAgICAgICAgICAgJyhmb3VuZCAnICtcbiAgICAgICAgICAgICAgICByZXBvSW5mby5ob3N0ICtcbiAgICAgICAgICAgICAgICAnIGJ1dCBleHBlY3RlZCAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9fLnJlcG9JbmZvXy5ob3N0ICtcbiAgICAgICAgICAgICAgICAnKScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZihwYXJzZWRVUkwucGF0aC50b1N0cmluZygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlOYW1lXG4gICAgICovXG4gICAgRGF0YWJhc2UucHJvdG90eXBlLmNoZWNrRGVsZXRlZF8gPSBmdW5jdGlvbiAoYXBpTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5yZXBvXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbF8xLmZhdGFsKCdDYW5ub3QgY2FsbCAnICsgYXBpTmFtZSArICcgb24gYSBkZWxldGVkIGRhdGFiYXNlLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBNYWtlIGluZGl2aWR1YWwgcmVwbyBnbyBvZmZsaW5lLlxuICAgIERhdGFiYXNlLnByb3RvdHlwZS5nb09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMi52YWxpZGF0ZUFyZ0NvdW50KCdkYXRhYmFzZS5nb09mZmxpbmUnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jaGVja0RlbGV0ZWRfKCdnb09mZmxpbmUnKTtcbiAgICAgICAgdGhpcy5yZXBvXy5pbnRlcnJ1cHQoKTtcbiAgICB9O1xuICAgIERhdGFiYXNlLnByb3RvdHlwZS5nb09ubGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8yLnZhbGlkYXRlQXJnQ291bnQoJ2RhdGFiYXNlLmdvT25saW5lJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY2hlY2tEZWxldGVkXygnZ29PbmxpbmUnKTtcbiAgICAgICAgdGhpcy5yZXBvXy5yZXN1bWUoKTtcbiAgICB9O1xuICAgIERhdGFiYXNlLlNlcnZlclZhbHVlID0ge1xuICAgICAgICBUSU1FU1RBTVA6IHtcbiAgICAgICAgICAgICcuc3YnOiAndGltZXN0YW1wJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YWJhc2U7XG59KCkpO1xuZXhwb3J0cy5EYXRhYmFzZSA9IERhdGFiYXNlO1xudmFyIERhdGFiYXNlSW50ZXJuYWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAcGFyYW0geyFEYXRhYmFzZX0gZGF0YWJhc2UgKi9cbiAgICBmdW5jdGlvbiBEYXRhYmFzZUludGVybmFscyhkYXRhYmFzZSkge1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gZGF0YWJhc2U7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fSAqL1xuICAgIERhdGFiYXNlSW50ZXJuYWxzLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UuY2hlY2tEZWxldGVkXygnZGVsZXRlJyk7XG4gICAgICAgIFJlcG9NYW5hZ2VyXzEuUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kZWxldGVSZXBvKHRoaXMuZGF0YWJhc2UucmVwb18pO1xuICAgICAgICB0aGlzLmRhdGFiYXNlLnJlcG9fID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhYmFzZS5yb290XyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YWJhc2UuSU5URVJOQUwgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFiYXNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFiYXNlSW50ZXJuYWxzO1xufSgpKTtcbmV4cG9ydHMuRGF0YWJhc2VJbnRlcm5hbHMgPSBEYXRhYmFzZUludGVybmFscztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YWJhc2UuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9EYXRhYmFzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG52YXIgUmVwb0luZm9fMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXBvSW5mb1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aFN0cmluZykge1xuICAgIHZhciBwYXRoU3RyaW5nRGVjb2RlZCA9ICcnO1xuICAgIHZhciBwaWVjZXMgPSBwYXRoU3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBpZWNlc1tpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcGllY2UgPSBwaWVjZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBpZWNlID0gZGVjb2RlVVJJQ29tcG9uZW50KHBpZWNlLnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHBhdGhTdHJpbmdEZWNvZGVkICs9ICcvJyArIHBpZWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoU3RyaW5nRGVjb2RlZDtcbn1cbi8qKlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZGF0YVVSTFxuICogQHJldHVybiB7e3JlcG9JbmZvOiAhUmVwb0luZm8sIHBhdGg6ICFQYXRofX1cbiAqL1xuZXhwb3J0cy5wYXJzZVJlcG9JbmZvID0gZnVuY3Rpb24gKGRhdGFVUkwpIHtcbiAgICB2YXIgcGFyc2VkVXJsID0gZXhwb3J0cy5wYXJzZVVSTChkYXRhVVJMKSwgbmFtZXNwYWNlID0gcGFyc2VkVXJsLnN1YmRvbWFpbjtcbiAgICBpZiAocGFyc2VkVXJsLmRvbWFpbiA9PT0gJ2ZpcmViYXNlJykge1xuICAgICAgICB1dGlsXzEuZmF0YWwocGFyc2VkVXJsLmhvc3QgK1xuICAgICAgICAgICAgJyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXNlIDxZT1VSIEZJUkVCQVNFPi5maXJlYmFzZWlvLmNvbSBpbnN0ZWFkJyk7XG4gICAgfVxuICAgIC8vIENhdGNoIGNvbW1vbiBlcnJvciBvZiB1bmluaXRpYWxpemVkIG5hbWVzcGFjZSB2YWx1ZS5cbiAgICBpZiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdXRpbF8xLmZhdGFsKCdDYW5ub3QgcGFyc2UgRmlyZWJhc2UgdXJsLiBQbGVhc2UgdXNlIGh0dHBzOi8vPFlPVVIgRklSRUJBU0U+LmZpcmViYXNlaW8uY29tJyk7XG4gICAgfVxuICAgIGlmICghcGFyc2VkVXJsLnNlY3VyZSkge1xuICAgICAgICB1dGlsXzEud2FybklmUGFnZUlzU2VjdXJlKCk7XG4gICAgfVxuICAgIHZhciB3ZWJTb2NrZXRPbmx5ID0gcGFyc2VkVXJsLnNjaGVtZSA9PT0gJ3dzJyB8fCBwYXJzZWRVcmwuc2NoZW1lID09PSAnd3NzJztcbiAgICByZXR1cm4ge1xuICAgICAgICByZXBvSW5mbzogbmV3IFJlcG9JbmZvXzEuUmVwb0luZm8ocGFyc2VkVXJsLmhvc3QsIHBhcnNlZFVybC5zZWN1cmUsIG5hbWVzcGFjZSwgd2ViU29ja2V0T25seSksXG4gICAgICAgIHBhdGg6IG5ldyBQYXRoXzEuUGF0aChwYXJzZWRVcmwucGF0aFN0cmluZylcbiAgICB9O1xufTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZGF0YVVSTFxuICogQHJldHVybiB7e2hvc3Q6IHN0cmluZywgcG9ydDogbnVtYmVyLCBkb21haW46IHN0cmluZywgc3ViZG9tYWluOiBzdHJpbmcsIHNlY3VyZTogYm9vbGVhbiwgc2NoZW1lOiBzdHJpbmcsIHBhdGhTdHJpbmc6IHN0cmluZ319XG4gKi9cbmV4cG9ydHMucGFyc2VVUkwgPSBmdW5jdGlvbiAoZGF0YVVSTCkge1xuICAgIC8vIERlZmF1bHQgdG8gZW1wdHkgc3RyaW5ncyBpbiB0aGUgZXZlbnQgb2YgYSBtYWxmb3JtZWQgc3RyaW5nLlxuICAgIHZhciBob3N0ID0gJycsIGRvbWFpbiA9ICcnLCBzdWJkb21haW4gPSAnJywgcGF0aFN0cmluZyA9ICcnO1xuICAgIC8vIEFsd2F5cyBkZWZhdWx0IHRvIFNTTCwgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQuXG4gICAgdmFyIHNlY3VyZSA9IHRydWUsIHNjaGVtZSA9ICdodHRwcycsIHBvcnQgPSA0NDM7XG4gICAgLy8gRG9uJ3QgZG8gYW55IHZhbGlkYXRpb24gaGVyZS4gVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcuXG4gICAgaWYgKHR5cGVvZiBkYXRhVVJMID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBQYXJzZSBzY2hlbWUuXG4gICAgICAgIHZhciBjb2xvbkluZCA9IGRhdGFVUkwuaW5kZXhPZignLy8nKTtcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcbiAgICAgICAgICAgIHNjaGVtZSA9IGRhdGFVUkwuc3Vic3RyaW5nKDAsIGNvbG9uSW5kIC0gMSk7XG4gICAgICAgICAgICBkYXRhVVJMID0gZGF0YVVSTC5zdWJzdHJpbmcoY29sb25JbmQgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBob3N0IGFuZCBwYXRoLlxuICAgICAgICB2YXIgc2xhc2hJbmQgPSBkYXRhVVJMLmluZGV4T2YoJy8nKTtcbiAgICAgICAgaWYgKHNsYXNoSW5kID09PSAtMSkge1xuICAgICAgICAgICAgc2xhc2hJbmQgPSBkYXRhVVJMLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBob3N0ID0gZGF0YVVSTC5zdWJzdHJpbmcoMCwgc2xhc2hJbmQpO1xuICAgICAgICBwYXRoU3RyaW5nID0gZGVjb2RlUGF0aChkYXRhVVJMLnN1YnN0cmluZyhzbGFzaEluZCkpO1xuICAgICAgICB2YXIgcGFydHMgPSBob3N0LnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBuYW1lc3BhY2VzIHRvIGxvd2VyY2FzZSB0byBzaGFyZSBzdG9yYWdlIC8gY29ubmVjdGlvbi5cbiAgICAgICAgICAgIGRvbWFpbiA9IHBhcnRzWzFdO1xuICAgICAgICAgICAgc3ViZG9tYWluID0gcGFydHNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGRvbWFpbiA9IHBhcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0LCB1c2Ugc2NoZW1lIGZvciBkZXRlcm1pbmluZyBpZiBpdCdzIHNlY3VyZS5cbiAgICAgICAgY29sb25JbmQgPSBob3N0LmluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKGNvbG9uSW5kID49IDApIHtcbiAgICAgICAgICAgIHNlY3VyZSA9IHNjaGVtZSA9PT0gJ2h0dHBzJyB8fCBzY2hlbWUgPT09ICd3c3MnO1xuICAgICAgICAgICAgcG9ydCA9IHBhcnNlSW50KGhvc3Quc3Vic3RyaW5nKGNvbG9uSW5kICsgMSksIDEwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICBwb3J0OiBwb3J0LFxuICAgICAgICBkb21haW46IGRvbWFpbixcbiAgICAgICAgc3ViZG9tYWluOiBzdWJkb21haW4sXG4gICAgICAgIHNlY3VyZTogc2VjdXJlLFxuICAgICAgICBzY2hlbWU6IHNjaGVtZSxcbiAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZ1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9saWJzL3BhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlL3N0b3JhZ2VcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvQ29uc3RhbnRzXCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgaG9sZHMgbWV0YWRhdGEgYWJvdXQgYSBSZXBvIG9iamVjdFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVwb0luZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhvc3QgSG9zdG5hbWUgcG9ydGlvbiBvZiB0aGUgdXJsIGZvciB0aGUgcmVwb1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VjdXJlIFdoZXRoZXIgb3Igbm90IHRoaXMgcmVwbyBpcyBhY2Nlc3NlZCBvdmVyIHNzbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSByZXByZXNlbnRlZCBieSB0aGUgcmVwb1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gd2ViU29ja2V0T25seSBXaGV0aGVyIHRvIHByZWZlciB3ZWJzb2NrZXRzIG92ZXIgYWxsIG90aGVyIHRyYW5zcG9ydHMgKHVzZWQgYnkgTmVzdCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBwZXJzaXN0ZW5jZUtleSBPdmVycmlkZSB0aGUgZGVmYXVsdCBzZXNzaW9uIHBlcnNpc3RlbmNlIHN0b3JhZ2Uga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gUmVwb0luZm8oaG9zdCwgc2VjdXJlLCBuYW1lc3BhY2UsIHdlYlNvY2tldE9ubHksIHBlcnNpc3RlbmNlS2V5KSB7XG4gICAgICAgIGlmIChwZXJzaXN0ZW5jZUtleSA9PT0gdm9pZCAwKSB7IHBlcnNpc3RlbmNlS2V5ID0gJyc7IH1cbiAgICAgICAgdGhpcy5zZWN1cmUgPSBzZWN1cmU7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgICAgICB0aGlzLndlYlNvY2tldE9ubHkgPSB3ZWJTb2NrZXRPbmx5O1xuICAgICAgICB0aGlzLnBlcnNpc3RlbmNlS2V5ID0gcGVyc2lzdGVuY2VLZXk7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3QudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5kb21haW4gPSB0aGlzLmhvc3Quc3Vic3RyKHRoaXMuaG9zdC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2UuZ2V0KCdob3N0OicgKyBob3N0KSB8fCB0aGlzLmhvc3Q7XG4gICAgfVxuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5uZWVkc1F1ZXJ5UGFyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3QgIT09IHRoaXMuaW50ZXJuYWxIb3N0O1xuICAgIH07XG4gICAgUmVwb0luZm8ucHJvdG90eXBlLmlzQ2FjaGVhYmxlSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxIb3N0LnN1YnN0cigwLCAyKSA9PT0gJ3MtJztcbiAgICB9O1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5pc0RlbW9Ib3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21haW4gPT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJztcbiAgICB9O1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS5pc0N1c3RvbUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kb21haW4gIT09ICdmaXJlYmFzZWlvLmNvbScgJiYgdGhpcy5kb21haW4gIT09ICdmaXJlYmFzZWlvLWRlbW8uY29tJyk7XG4gICAgfTtcbiAgICBSZXBvSW5mby5wcm90b3R5cGUudXBkYXRlSG9zdCA9IGZ1bmN0aW9uIChuZXdIb3N0KSB7XG4gICAgICAgIGlmIChuZXdIb3N0ICE9PSB0aGlzLmludGVybmFsSG9zdCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEhvc3QgPSBuZXdIb3N0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDYWNoZWFibGVIb3N0KCkpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdob3N0OicgKyB0aGlzLmhvc3QsIHRoaXMuaW50ZXJuYWxIb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgd2Vic29ja2V0IFVSTCBmb3IgdGhpcyByZXBvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgb2YgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgbGlzdFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVSTCBmb3IgdGhpcyByZXBvXG4gICAgICovXG4gICAgUmVwb0luZm8ucHJvdG90eXBlLmNvbm5lY3Rpb25VUkwgPSBmdW5jdGlvbiAodHlwZSwgcGFyYW1zKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnLCAndHlwZW9mIHR5cGUgbXVzdCA9PSBzdHJpbmcnKTtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0JywgJ3R5cGVvZiBwYXJhbXMgbXVzdCA9PSBvYmplY3QnKTtcbiAgICAgICAgdmFyIGNvbm5VUkw7XG4gICAgICAgIGlmICh0eXBlID09PSBDb25zdGFudHNfMS5XRUJTT0NLRVQpIHtcbiAgICAgICAgICAgIGNvbm5VUkwgPVxuICAgICAgICAgICAgICAgICh0aGlzLnNlY3VyZSA/ICd3c3M6Ly8nIDogJ3dzOi8vJykgKyB0aGlzLmludGVybmFsSG9zdCArICcvLndzPyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gQ29uc3RhbnRzXzEuTE9OR19QT0xMSU5HKSB7XG4gICAgICAgICAgICBjb25uVVJMID1cbiAgICAgICAgICAgICAgICAodGhpcy5zZWN1cmUgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nKSArIHRoaXMuaW50ZXJuYWxIb3N0ICsgJy8ubHA/JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjb25uZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZWVkc1F1ZXJ5UGFyYW0oKSkge1xuICAgICAgICAgICAgcGFyYW1zWyducyddID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhaXJzID0gW107XG4gICAgICAgIHV0aWxfMi5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz0nICsgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbm5VUkwgKyBwYWlycy5qb2luKCcmJyk7XG4gICAgfTtcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMudG9VUkxTdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdGVuY2VLZXkpIHtcbiAgICAgICAgICAgIHN0ciArPSAnPCcgKyB0aGlzLnBlcnNpc3RlbmNlS2V5ICsgJz4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIFJlcG9JbmZvLnByb3RvdHlwZS50b1VSTFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICsgdGhpcy5ob3N0O1xuICAgIH07XG4gICAgcmV0dXJuIFJlcG9JbmZvO1xufSgpKTtcbmV4cG9ydHMuUmVwb0luZm8gPSBSZXBvSW5mbztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwb0luZm8uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvUmVwb0luZm8uanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB2YWxpZGF0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3ZhbGlkYXRpb25cIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBPbkRpc2Nvbm5lY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUmVwb30gcmVwb19cbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIE9uRGlzY29ubmVjdChyZXBvXywgcGF0aF8pIHtcbiAgICAgICAgdGhpcy5yZXBvXyA9IHJlcG9fO1xuICAgICAgICB0aGlzLnBhdGhfID0gcGF0aF87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChvbkNvbXBsZXRlKSB7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUFyZ0NvdW50KCdPbkRpc2Nvbm5lY3QuY2FuY2VsJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3QuY2FuY2VsJywgMSwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RDYW5jZWwodGhpcy5wYXRoXywgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgT25EaXNjb25uZWN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnT25EaXNjb25uZWN0LnJlbW92ZScsIDAsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVXcml0YWJsZVBhdGgoJ09uRGlzY29ubmVjdC5yZW1vdmUnLCB0aGlzLnBhdGhfKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5yZW1vdmUnLCAxLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdFNldCh0aGlzLnBhdGhfLCBudWxsLCBkZWZlcnJlZC53cmFwQ2FsbGJhY2sob25Db21wbGV0ZSkpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD9FcnJvcik9fSBvbkNvbXBsZXRlXG4gICAgICogQHJldHVybiB7IWZpcmViYXNlLlByb21pc2V9XG4gICAgICovXG4gICAgT25EaXNjb25uZWN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodmFsdWUsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5zZXQnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0JywgdGhpcy5wYXRoXyk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldCcsIDEsIHZhbHVlLCB0aGlzLnBhdGhfLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3Quc2V0JywgMiwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RTZXQodGhpcy5wYXRoXywgdmFsdWUsIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xudWxsfSBwcmlvcml0eVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oP0Vycm9yKT19IG9uQ29tcGxldGVcbiAgICAgKiBAcmV0dXJuIHshZmlyZWJhc2UuUHJvbWlzZX1cbiAgICAgKi9cbiAgICBPbkRpc2Nvbm5lY3QucHJvdG90eXBlLnNldFdpdGhQcmlvcml0eSA9IGZ1bmN0aW9uICh2YWx1ZSwgcHJpb3JpdHksIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAyLCAzLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgdGhpcy5wYXRoXyk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnT25EaXNjb25uZWN0LnNldFdpdGhQcmlvcml0eScsIDEsIHZhbHVlLCB0aGlzLnBhdGhfLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVByaW9yaXR5KCdPbkRpc2Nvbm5lY3Quc2V0V2l0aFByaW9yaXR5JywgMiwgcHJpb3JpdHksIGZhbHNlKTtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQ2FsbGJhY2soJ09uRGlzY29ubmVjdC5zZXRXaXRoUHJpb3JpdHknLCAzLCBvbkNvbXBsZXRlLCB0cnVlKTtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gbmV3IHV0aWxfMy5EZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnJlcG9fLm9uRGlzY29ubmVjdFNldFdpdGhQcmlvcml0eSh0aGlzLnBhdGhfLCB2YWx1ZSwgcHJpb3JpdHksIGRlZmVycmVkLndyYXBDYWxsYmFjayhvbkNvbXBsZXRlKSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBvYmplY3RUb01lcmdlXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbig/RXJyb3IpPX0gb25Db21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgICAqL1xuICAgIE9uRGlzY29ubmVjdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iamVjdFRvTWVyZ2UsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdXRpbF8xLnZhbGlkYXRlQXJnQ291bnQoJ09uRGlzY29ubmVjdC51cGRhdGUnLCAxLCAyLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlV3JpdGFibGVQYXRoKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgdGhpcy5wYXRoXyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdFRvTWVyZ2UpKSB7XG4gICAgICAgICAgICB2YXIgbmV3T2JqZWN0VG9NZXJnZSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RUb01lcmdlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0VG9NZXJnZVsnJyArIGldID0gb2JqZWN0VG9NZXJnZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdFRvTWVyZ2UgPSBuZXdPYmplY3RUb01lcmdlO1xuICAgICAgICAgICAgdXRpbF8yLndhcm4oJ1Bhc3NpbmcgYW4gQXJyYXkgdG8gZmlyZWJhc2UuZGF0YWJhc2Uub25EaXNjb25uZWN0KCkudXBkYXRlKCkgaXMgZGVwcmVjYXRlZC4gVXNlIHNldCgpIGlmIHlvdSB3YW50IHRvIG92ZXJ3cml0ZSB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ2V4aXN0aW5nIGRhdGEsIG9yIGFuIE9iamVjdCB3aXRoIGludGVnZXIga2V5cyBpZiB5b3UgcmVhbGx5IGRvIHdhbnQgdG8gb25seSB1cGRhdGUgc29tZSBvZiB0aGUgY2hpbGRyZW4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VNZXJnZURhdGFBcmcoJ09uRGlzY29ubmVjdC51cGRhdGUnLCAxLCBvYmplY3RUb01lcmdlLCB0aGlzLnBhdGhfLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMS52YWxpZGF0ZUNhbGxiYWNrKCdPbkRpc2Nvbm5lY3QudXBkYXRlJywgMiwgb25Db21wbGV0ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzMuRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5yZXBvXy5vbkRpc2Nvbm5lY3RVcGRhdGUodGhpcy5wYXRoXywgb2JqZWN0VG9NZXJnZSwgZGVmZXJyZWQud3JhcENhbGxiYWNrKG9uQ29tcGxldGUpKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICByZXR1cm4gT25EaXNjb25uZWN0O1xufSgpKTtcbmV4cG9ydHMuT25EaXNjb25uZWN0ID0gT25EaXNjb25uZWN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vbkRpc2Nvbm5lY3QuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2FwaS9vbkRpc2Nvbm5lY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBLZXlJbmRleF8xID0gcmVxdWlyZShcIi4uL2NvcmUvc25hcC9pbmRleGVzL0tleUluZGV4XCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIFZhbHVlSW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3NuYXAvaW5kZXhlcy9WYWx1ZUluZGV4XCIpO1xudmFyIFBhdGhJbmRleF8xID0gcmVxdWlyZShcIi4uL2NvcmUvc25hcC9pbmRleGVzL1BhdGhJbmRleFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3V0aWxcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC9QYXRoXCIpO1xudmFyIHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdmFsaWRhdGlvblwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgRXZlbnRSZWdpc3RyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZpZXcvRXZlbnRSZWdpc3RyYXRpb25cIik7XG52YXIgdXRpbF80ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIF9fcmVmZXJlbmNlQ29uc3RydWN0b3I7XG4vKipcbiAqIEEgUXVlcnkgcmVwcmVzZW50cyBhIGZpbHRlciB0byBiZSBhcHBsaWVkIHRvIGEgZmlyZWJhc2UgbG9jYXRpb24uICBUaGlzIG9iamVjdCBwdXJlbHkgcmVwcmVzZW50cyB0aGVcbiAqIHF1ZXJ5IGV4cHJlc3Npb24gKGFuZCBleHBvc2VzIG91ciBwdWJsaWMgQVBJIHRvIGJ1aWxkIHRoZSBxdWVyeSkuICBUaGUgYWN0dWFsIHF1ZXJ5IGxvZ2ljIGlzIGluIFZpZXdCYXNlLmpzLlxuICpcbiAqIFNpbmNlIGV2ZXJ5IEZpcmViYXNlIHJlZmVyZW5jZSBpcyBhIHF1ZXJ5LCBGaXJlYmFzZSBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxuICovXG52YXIgUXVlcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUXVlcnkocmVwbywgcGF0aCwgcXVlcnlQYXJhbXNfLCBvcmRlckJ5Q2FsbGVkXykge1xuICAgICAgICB0aGlzLnJlcG8gPSByZXBvO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnF1ZXJ5UGFyYW1zXyA9IHF1ZXJ5UGFyYW1zXztcbiAgICAgICAgdGhpcy5vcmRlckJ5Q2FsbGVkXyA9IG9yZGVyQnlDYWxsZWRfO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUXVlcnksIFwiX19yZWZlcmVuY2VDb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIF9fcmVmZXJlbmNlQ29uc3RydWN0b3IgPSB2YWw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBzdGFydC9lbmQgdmFsdWVzIGZvciBxdWVyaWVzLlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5UGFyYW1zfSBwYXJhbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LnZhbGlkYXRlUXVlcnlFbmRwb2ludHNfID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICB2YXIgc3RhcnROb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGVuZE5vZGUgPSBudWxsO1xuICAgICAgICBpZiAocGFyYW1zLmhhc1N0YXJ0KCkpIHtcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICBlbmROb2RlID0gcGFyYW1zLmdldEluZGV4RW5kVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmdldEluZGV4KCkgPT09IEtleUluZGV4XzEuS0VZX0lOREVYKSB7XG4gICAgICAgICAgICB2YXIgdG9vTWFueUFyZ3NFcnJvciA9ICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHlvdSBtYXkgb25seSBwYXNzIG9uZSBhcmd1bWVudCB0byAnICtcbiAgICAgICAgICAgICAgICAnc3RhcnRBdCgpLCBlbmRBdCgpLCBvciBlcXVhbFRvKCkuJztcbiAgICAgICAgICAgIHZhciB3cm9uZ0FyZ1R5cGVFcnJvciA9ICdRdWVyeTogV2hlbiBvcmRlcmluZyBieSBrZXksIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCBlbmRBdCgpLCcgK1xuICAgICAgICAgICAgICAgICdvciBlcXVhbFRvKCkgbXVzdCBiZSBhIHN0cmluZy4nO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TmFtZSA9IHBhcmFtcy5nZXRJbmRleFN0YXJ0TmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydE5hbWUgIT0gdXRpbF8yLk1JTl9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0Tm9kZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdyb25nQXJnVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc0VuZCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZE5hbWUgPSBwYXJhbXMuZ2V0SW5kZXhFbmROYW1lKCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZE5hbWUgIT0gdXRpbF8yLk1BWF9OQU1FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0b29NYW55QXJnc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGVuZE5vZGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih3cm9uZ0FyZ1R5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5nZXRJbmRleCgpID09PSBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpIHtcbiAgICAgICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgIXZhbGlkYXRpb25fMS5pc1ZhbGlkUHJpb3JpdHkoc3RhcnROb2RlKSkgfHxcbiAgICAgICAgICAgICAgICAoZW5kTm9kZSAhPSBudWxsICYmICF2YWxpZGF0aW9uXzEuaXNWYWxpZFByaW9yaXR5KGVuZE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnk6IFdoZW4gb3JkZXJpbmcgYnkgcHJpb3JpdHksIHRoZSBmaXJzdCBhcmd1bWVudCBwYXNzZWQgdG8gc3RhcnRBdCgpLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2VuZEF0KCksIG9yIGVxdWFsVG8oKSBtdXN0IGJlIGEgdmFsaWQgcHJpb3JpdHkgdmFsdWUgKG51bGwsIGEgbnVtYmVyLCBvciBhIHN0cmluZykuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHBhcmFtcy5nZXRJbmRleCgpIGluc3RhbmNlb2YgUGF0aEluZGV4XzEuUGF0aEluZGV4IHx8XG4gICAgICAgICAgICAgICAgcGFyYW1zLmdldEluZGV4KCkgPT09IFZhbHVlSW5kZXhfMS5WQUxVRV9JTkRFWCwgJ3Vua25vd24gaW5kZXggdHlwZS4nKTtcbiAgICAgICAgICAgIGlmICgoc3RhcnROb2RlICE9IG51bGwgJiYgdHlwZW9mIHN0YXJ0Tm9kZSA9PT0gJ29iamVjdCcpIHx8XG4gICAgICAgICAgICAgICAgKGVuZE5vZGUgIT0gbnVsbCAmJiB0eXBlb2YgZW5kTm9kZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeTogRmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIHN0YXJ0QXQoKSwgZW5kQXQoKSwgb3IgZXF1YWxUbygpIGNhbm5vdCBiZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoYXQgbGltaXQqIGhhcyBiZWVuIGNhbGxlZCB3aXRoIHRoZSBjb3JyZWN0IGNvbWJpbmF0aW9uIG9mIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeS52YWxpZGF0ZUxpbWl0XyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpICYmXG4gICAgICAgICAgICBwYXJhbXMuaGFzRW5kKCkgJiZcbiAgICAgICAgICAgIHBhcmFtcy5oYXNMaW1pdCgpICYmXG4gICAgICAgICAgICAhcGFyYW1zLmhhc0FuY2hvcmVkTGltaXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUXVlcnk6IENhbid0IGNvbWJpbmUgc3RhcnRBdCgpLCBlbmRBdCgpLCBhbmQgbGltaXQoKS4gVXNlIGxpbWl0VG9GaXJzdCgpIG9yIGxpbWl0VG9MYXN0KCkgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IG5vIG90aGVyIG9yZGVyIGJ5IGNhbGwgaGFzIGJlZW4gbWFkZVxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfID0gZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5vcmRlckJ5Q2FsbGVkXyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGZuTmFtZSArIFwiOiBZb3UgY2FuJ3QgY29tYmluZSBtdWx0aXBsZSBvcmRlckJ5IGNhbGxzLlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeVBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlQYXJhbXNfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IVJlZmVyZW5jZX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0UmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkucmVmJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzbGlnaHQgaGFjay4gV2UgY2Fubm90IGdvb2cucmVxdWlyZSgnZmIuYXBpLkZpcmViYXNlJyksIHNpbmNlIEZpcmViYXNlIHJlcXVpcmVzIGZiLmFwaS5RdWVyeS5cbiAgICAgICAgLy8gSG93ZXZlciwgd2Ugd2lsbCBhbHdheXMgZXhwb3J0ICdGaXJlYmFzZScgdG8gdGhlIGdsb2JhbCBuYW1lc3BhY2UsIHNvIGl0J3MgZ3VhcmFudGVlZCB0byBleGlzdCBieSB0aGUgdGltZSB0aGlzXG4gICAgICAgIC8vIG1ldGhvZCBnZXRzIGNhbGxlZC5cbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeS5fX3JlZmVyZW5jZUNvbnN0cnVjdG9yKHRoaXMucmVwbywgdGhpcy5wYXRoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oRGF0YVNuYXBzaG90LCBzdHJpbmc9KX0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbihFcnJvcil8T2JqZWN0KT19IGNhbmNlbENhbGxiYWNrT3JDb250ZXh0XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7IWZ1bmN0aW9uKERhdGFTbmFwc2hvdCwgc3RyaW5nPSl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrT3JDb250ZXh0LCBjb250ZXh0KSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vbicsIDIsIDQsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9uJywgMSwgZXZlbnRUeXBlLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vbicsIDIsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIHZhciByZXQgPSBRdWVyeS5nZXRDYW5jZWxBbmRDb250ZXh0QXJnc18oJ1F1ZXJ5Lm9uJywgY2FuY2VsQ2FsbGJhY2tPckNvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICB0aGlzLm9uVmFsdWVFdmVudChjYWxsYmFjaywgcmV0LmNhbmNlbCwgcmV0LmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2tzW2V2ZW50VHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIHRoaXMub25DaGlsZEV2ZW50KGNhbGxiYWNrcywgcmV0LmNhbmNlbCwgcmV0LmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFEYXRhU25hcHNob3QpfSBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbnRleHRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9uVmFsdWVFdmVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FuY2VsQ2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBFdmVudFJlZ2lzdHJhdGlvbl8xLlZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2ssIGNhbmNlbENhbGxiYWNrIHx8IG51bGwsIGNvbnRleHQgfHwgbnVsbCk7XG4gICAgICAgIHRoaXMucmVwby5hZGRFdmVudENhbGxiYWNrRm9yUXVlcnkodGhpcywgY29udGFpbmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhZnVuY3Rpb24oIURhdGFTbmFwc2hvdCwgP3N0cmluZyk+fSBjYWxsYmFja3NcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbihFcnJvcil9IGNhbmNlbENhbGxiYWNrXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vbkNoaWxkRXZlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2tzLCBjYW5jZWxDYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbmV3IEV2ZW50UmVnaXN0cmF0aW9uXzEuQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbihjYWxsYmFja3MsIGNhbmNlbENhbGxiYWNrLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5yZXBvLmFkZEV2ZW50Q2FsbGJhY2tGb3JRdWVyeSh0aGlzLCBjb250YWluZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBldmVudFR5cGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbighRGF0YVNuYXBzaG90LCA/c3RyaW5nPSkpPX0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9mZicsIDAsIDMsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVFdmVudFR5cGUoJ1F1ZXJ5Lm9mZicsIDEsIGV2ZW50VHlwZSwgdHJ1ZSk7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vZmYnLCAyLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUNvbnRleHRPYmplY3QoJ1F1ZXJ5Lm9mZicsIDMsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IG51bGw7XG4gICAgICAgIGlmIChldmVudFR5cGUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IG5ldyBFdmVudFJlZ2lzdHJhdGlvbl8xLlZhbHVlRXZlbnRSZWdpc3RyYXRpb24odmFsdWVDYWxsYmFjaywgbnVsbCwgY29udGV4dCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IHt9O1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tldmVudFR5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIgPSBuZXcgRXZlbnRSZWdpc3RyYXRpb25fMS5DaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrcywgbnVsbCwgY29udGV4dCB8fCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcG8ucmVtb3ZlRXZlbnRDYWxsYmFja0ZvclF1ZXJ5KHRoaXMsIGNvbnRhaW5lcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhIGxpc3RlbmVyLCB3YWl0cyBmb3IgdGhlIGZpcnN0IGV2ZW50LCBhbmQgdGhlbiByZW1vdmVzIHRoZSBsaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIURhdGFTbmFwc2hvdCwgc3RyaW5nPSl9IHVzZXJDYWxsYmFja1xuICAgICAqIEBwYXJhbSBjYW5jZWxPckNvbnRleHRcbiAgICAgKiBAcGFyYW0gY29udGV4dFxuICAgICAqIEByZXR1cm4geyFmaXJlYmFzZS5Qcm9taXNlfVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgdXNlckNhbGxiYWNrLCBjYW5jZWxPckNvbnRleHQsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5Lm9uY2UnLCAxLCA0LCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRXZlbnRUeXBlKCdRdWVyeS5vbmNlJywgMSwgZXZlbnRUeXBlLCBmYWxzZSk7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUNhbGxiYWNrKCdRdWVyeS5vbmNlJywgMiwgdXNlckNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgdmFyIHJldCA9IFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXygnUXVlcnkub25jZScsIGNhbmNlbE9yQ29udGV4dCwgY29udGV4dCk7XG4gICAgICAgIC8vIFRPRE86IEltcGxlbWVudCB0aGlzIG1vcmUgZWZmaWNpZW50bHkgKGluIHBhcnRpY3VsYXIsIHVzZSAnZ2V0JyB3aXJlIHByb3RvY29sIGZvciAndmFsdWUnIGV2ZW50KVxuICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBhY3R1YWxseSB3aXJpbmcgdGhlIGNhbGxiYWNrcyBpbnRvIHRoZSBwcm9taXNlLiBXZSBjYW5ub3QgZG8gdGhpcyB3aXRob3V0IGEgYnJlYWtpbmcgY2hhbmdlXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIEFQSSBjdXJyZW50bHkgZXhwZWN0cyBjYWxsYmFja3Mgd2lsbCBiZSBjYWxsZWQgc3luY2hyb25vdXNseSBpZiB0aGUgZGF0YSBpcyBjYWNoZWQsIGJ1dCB0aGlzIGlzXG4gICAgICAgIC8vIGFnYWluc3QgdGhlIFByb21pc2Ugc3BlY2lmaWNhdGlvbi5cbiAgICAgICAgdmFyIGZpcnN0Q2FsbCA9IHRydWU7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyB1dGlsXzQuRGVmZXJyZWQoKTtcbiAgICAgICAgLy8gQSBkdW1teSBlcnJvciBoYW5kbGVyIGluIGNhc2UgYSB1c2VyIHdhc24ndCBleHBlY3RpbmcgcHJvbWlzZXNcbiAgICAgICAgZGVmZXJyZWQucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICB2YXIgb25jZUNhbGxiYWNrID0gZnVuY3Rpb24gKHNuYXBzaG90KSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB3ZSB1bnN1YnNjcmliZSwgd2UgbWF5IGdldCBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgYSBzaW5nbGUgYWN0aW9uIChlLmcuIHNldCgpIHdpdGggSlNPTilcbiAgICAgICAgICAgIC8vIHRyaWdnZXJzIG11bHRpcGxlIGV2ZW50cyAoZS5nLiBjaGlsZF9hZGRlZCBvciBjaGlsZF9jaGFuZ2VkKS5cbiAgICAgICAgICAgIGlmIChmaXJzdENhbGwpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZXZlbnRUeXBlLCBvbmNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlckNhbGxiYWNrLmJpbmQocmV0LmNvbnRleHQpKHNuYXBzaG90KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShzbmFwc2hvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24oZXZlbnRUeXBlLCBvbmNlQ2FsbGJhY2ssIFxuICAgICAgICAvKmNhbmNlbD0qLyBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfdGhpcy5vZmYoZXZlbnRUeXBlLCBvbmNlQ2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKHJldC5jYW5jZWwpXG4gICAgICAgICAgICAgICAgcmV0LmNhbmNlbC5iaW5kKHJldC5jb250ZXh0KShlcnIpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGxpbWl0IGFuZCBhbmNob3IgaXQgdG8gdGhlIHN0YXJ0IG9mIHRoZSB3aW5kb3cuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBsaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUubGltaXRUb0ZpcnN0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5saW1pdFRvRmlyc3QnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW1pdCAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE1hdGguZmxvb3IobGltaXQpICE9PSBsaW1pdCB8fFxuICAgICAgICAgICAgbGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5saW1pdFRvRmlyc3Q6IEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5UGFyYW1zXy5oYXNMaW1pdCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9GaXJzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsICcgK1xuICAgICAgICAgICAgICAgICdsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCB0aGlzLnF1ZXJ5UGFyYW1zXy5saW1pdFRvRmlyc3QobGltaXQpLCB0aGlzLm9yZGVyQnlDYWxsZWRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGxpbWl0IGFuZCBhbmNob3IgaXQgdG8gdGhlIGVuZCBvZiB0aGUgd2luZG93LlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gbGltaXRcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLmxpbWl0VG9MYXN0ID0gZnVuY3Rpb24gKGxpbWl0KSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5saW1pdFRvTGFzdCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGxpbWl0ICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgTWF0aC5mbG9vcihsaW1pdCkgIT09IGxpbWl0IHx8XG4gICAgICAgICAgICBsaW1pdCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5LmxpbWl0VG9MYXN0OiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzTGltaXQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5saW1pdFRvTGFzdDogTGltaXQgd2FzIGFscmVhZHkgc2V0IChieSBhbm90aGVyIGNhbGwgdG8gbGltaXQsICcgK1xuICAgICAgICAgICAgICAgICdsaW1pdFRvRmlyc3QsIG9yIGxpbWl0VG9MYXN0KS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCB0aGlzLnF1ZXJ5UGFyYW1zXy5saW1pdFRvTGFzdChsaW1pdCksIHRoaXMub3JkZXJCeUNhbGxlZF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjaGlsZCBwYXRoLCByZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgc3BlY2lmaWVkIGdyYW5kY2hpbGQgcGF0aC5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9yZGVyQnlDaGlsZCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5Q2hpbGQnLCAxLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHBhdGggPT09ICcka2V5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJGtleVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeUtleSgpIGluc3RlYWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aCA9PT0gJyRwcmlvcml0eScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkub3JkZXJCeUNoaWxkOiBcIiRwcmlvcml0eVwiIGlzIGludmFsaWQuICBVc2UgUXVlcnkub3JkZXJCeVByaW9yaXR5KCkgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoID09PSAnJHZhbHVlJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5vcmRlckJ5Q2hpbGQ6IFwiJHZhbHVlXCIgaXMgaW52YWxpZC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZVBhdGhTdHJpbmcoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcsIDEsIHBhdGgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5vUHJldmlvdXNPcmRlckJ5Q2FsbF8oJ1F1ZXJ5Lm9yZGVyQnlDaGlsZCcpO1xuICAgICAgICB2YXIgcGFyc2VkUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwYXRoKTtcbiAgICAgICAgaWYgKHBhcnNlZFBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1F1ZXJ5Lm9yZGVyQnlDaGlsZDogY2Fubm90IHBhc3MgaW4gZW1wdHkgcGF0aC4gIFVzZSBRdWVyeS5vcmRlckJ5VmFsdWUoKSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IG5ldyBQYXRoSW5kZXhfMS5QYXRoSW5kZXgocGFyc2VkUGF0aCk7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5vcmRlckJ5KGluZGV4KTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgS2V5SW5kZXhcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLm9yZGVyQnlLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5vcmRlckJ5S2V5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfKCdRdWVyeS5vcmRlckJ5S2V5Jyk7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLnF1ZXJ5UGFyYW1zXy5vcmRlckJ5KEtleUluZGV4XzEuS0VZX0lOREVYKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgUHJpb3JpdHlJbmRleFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeVByaW9yaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeVByaW9yaXR5JywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfKCdRdWVyeS5vcmRlckJ5UHJpb3JpdHknKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgcXVlcnkgb3JkZXJlZCBieSB0aGUgVmFsdWVJbmRleFxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUub3JkZXJCeVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkub3JkZXJCeVZhbHVlJywgMCwgMCwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVOb1ByZXZpb3VzT3JkZXJCeUNhbGxfKCdRdWVyeS5vcmRlckJ5VmFsdWUnKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLm9yZGVyQnkoVmFsdWVJbmRleF8xLlZBTFVFX0lOREVYKTtcbiAgICAgICAgUXVlcnkudmFsaWRhdGVRdWVyeUVuZHBvaW50c18obmV3UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCAvKm9yZGVyQnlDYWxsZWQ9Ki8gdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLnN0YXJ0QXQgPSBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSBudWxsOyB9XG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS5zdGFydEF0JywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuc3RhcnRBdCcsIDEsIHZhbHVlLCB0aGlzLnBhdGgsIHRydWUpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVLZXkoJ1F1ZXJ5LnN0YXJ0QXQnLCAyLCBuYW1lLCB0cnVlKTtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMucXVlcnlQYXJhbXNfLnN0YXJ0QXQodmFsdWUsIG5hbWUpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZUxpbWl0XyhuZXdQYXJhbXMpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5zdGFydEF0OiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0ICcgK1xuICAgICAgICAgICAgICAgICdvciBlcXVhbFRvKS4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsaW5nIHdpdGggbm8gcGFyYW1zIHRlbGxzIHVzIHRvIHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBuYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMucmVwbywgdGhpcy5wYXRoLCBuZXdQYXJhbXMsIHRoaXMub3JkZXJCeUNhbGxlZF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmc9fSBuYW1lXG4gICAgICogQHJldHVybiB7IVF1ZXJ5fVxuICAgICAqL1xuICAgIFF1ZXJ5LnByb3RvdHlwZS5lbmRBdCA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IG51bGw7IH1cbiAgICAgICAgdXRpbF8zLnZhbGlkYXRlQXJnQ291bnQoJ1F1ZXJ5LmVuZEF0JywgMCwgMiwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUZpcmViYXNlRGF0YUFyZygnUXVlcnkuZW5kQXQnLCAxLCB2YWx1ZSwgdGhpcy5wYXRoLCB0cnVlKTtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlS2V5KCdRdWVyeS5lbmRBdCcsIDIsIG5hbWUsIHRydWUpO1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5xdWVyeVBhcmFtc18uZW5kQXQodmFsdWUsIG5hbWUpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZUxpbWl0XyhuZXdQYXJhbXMpO1xuICAgICAgICBRdWVyeS52YWxpZGF0ZVF1ZXJ5RW5kcG9pbnRzXyhuZXdQYXJhbXMpO1xuICAgICAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzRW5kKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkuZW5kQXQ6IEVuZGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBlbmRBdCBvciAnICtcbiAgICAgICAgICAgICAgICAnZXF1YWxUbykuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLnJlcG8sIHRoaXMucGF0aCwgbmV3UGFyYW1zLCB0aGlzLm9yZGVyQnlDYWxsZWRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIHNlbGVjdGlvbiBvZiBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgdGhlIHNwZWNpZmllZCB2YWx1ZSwgYW5kLCBvcHRpb25hbGx5LFxuICAgICAqIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gbmFtZVxuICAgICAqIEByZXR1cm4geyFRdWVyeX1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuZXF1YWxUbyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuZXF1YWxUbycsIDEsIDIsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uXzEudmFsaWRhdGVGaXJlYmFzZURhdGFBcmcoJ1F1ZXJ5LmVxdWFsVG8nLCAxLCB2YWx1ZSwgdGhpcy5wYXRoLCBmYWxzZSk7XG4gICAgICAgIHZhbGlkYXRpb25fMS52YWxpZGF0ZUtleSgnUXVlcnkuZXF1YWxUbycsIDIsIG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzU3RhcnQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeS5lcXVhbFRvOiBTdGFydGluZyBwb2ludCB3YXMgYWxyZWFkeSBzZXQgKGJ5IGFub3RoZXIgY2FsbCB0byBzdGFydEF0IG9yICcgK1xuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeVBhcmFtc18uaGFzRW5kKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUXVlcnkuZXF1YWxUbzogRW5kaW5nIHBvaW50IHdhcyBhbHJlYWR5IHNldCAoYnkgYW5vdGhlciBjYWxsIHRvIGVuZEF0IG9yICcgK1xuICAgICAgICAgICAgICAgICdlcXVhbFRvKS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydEF0KHZhbHVlLCBuYW1lKS5lbmRBdCh2YWx1ZSwgbmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBVUkwgZm9yIHRoaXMgbG9jYXRpb24uXG4gICAgICovXG4gICAgUXVlcnkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkudG9TdHJpbmcnLCAwLCAwLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwby50b1N0cmluZygpICsgdGhpcy5wYXRoLnRvVXJsRW5jb2RlZFN0cmluZygpO1xuICAgIH07XG4gICAgLy8gRG8gbm90IGNyZWF0ZSBwdWJsaWMgZG9jdW1lbnRhdGlvbi4gVGhpcyBpcyBpbnRlbmRlZCB0byBtYWtlIEpTT04gc2VyaWFsaXphdGlvbiB3b3JrIGJ1dCBpcyBvdGhlcndpc2UgdW5uZWNlc3NhcnlcbiAgICAvLyBmb3IgZW5kLXVzZXJzLlxuICAgIFF1ZXJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEFuIG9wdGlvbmFsIHNwYWNlciBhcmd1bWVudCBpcyB1bm5lY2Vzc2FyeSBmb3IgYSBzdHJpbmcuXG4gICAgICAgIHV0aWxfMy52YWxpZGF0ZUFyZ0NvdW50KCdRdWVyeS50b0pTT04nLCAwLCAxLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcXVlcnkgcGFyYW1ldGVycyB1c2VkIGJ5IHRoaXMgUXVlcnkuXG4gICAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUucXVlcnlPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5UGFyYW1zXy5nZXRRdWVyeU9iamVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUucXVlcnlJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5xdWVyeU9iamVjdCgpO1xuICAgICAgICB2YXIgaWQgPSB1dGlsXzIuT2JqZWN0VG9VbmlxdWVLZXkob2JqKTtcbiAgICAgICAgcmV0dXJuIGlkID09PSAne30nID8gJ2RlZmF1bHQnIDogaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHF1ZXJ5IGFuZCB0aGUgcHJvdmlkZWQgcXVlcnkgYXJlIGVxdWl2YWxlbnQ7IG90aGVyd2lzZSwgcmV0dXJuIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7UXVlcnl9IG90aGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNFcXVhbCA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICB1dGlsXzMudmFsaWRhdGVBcmdDb3VudCgnUXVlcnkuaXNFcXVhbCcsIDEsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFF1ZXJ5KSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gJ1F1ZXJ5LmlzRXF1YWwgZmFpbGVkOiBGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGZpcmViYXNlLmRhdGFiYXNlLlF1ZXJ5Lic7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzYW1lUmVwbyA9IHRoaXMucmVwbyA9PT0gb3RoZXIucmVwbztcbiAgICAgICAgdmFyIHNhbWVQYXRoID0gdGhpcy5wYXRoLmVxdWFscyhvdGhlci5wYXRoKTtcbiAgICAgICAgdmFyIHNhbWVRdWVyeUlkZW50aWZpZXIgPSB0aGlzLnF1ZXJ5SWRlbnRpZmllcigpID09PSBvdGhlci5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgcmV0dXJuIHNhbWVSZXBvICYmIHNhbWVQYXRoICYmIHNhbWVRdWVyeUlkZW50aWZpZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCBieSAub24gYW5kIC5vbmNlIHRvIGV4dHJhY3QgdGhlIGNvbnRleHQgYW5kIG9yIGNhbmNlbCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWUgVGhlIGZ1bmN0aW9uIG5hbWUgKG9uIG9yIG9uY2UpXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24oRXJyb3IpfE9iamVjdCk9fSBjYW5jZWxPckNvbnRleHRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHt7Y2FuY2VsOiA/ZnVuY3Rpb24oRXJyb3IpLCBjb250ZXh0OiA/T2JqZWN0fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5LmdldENhbmNlbEFuZENvbnRleHRBcmdzXyA9IGZ1bmN0aW9uIChmbk5hbWUsIGNhbmNlbE9yQ29udGV4dCwgY29udGV4dCkge1xuICAgICAgICB2YXIgcmV0ID0geyBjYW5jZWw6IG51bGwsIGNvbnRleHQ6IG51bGwgfTtcbiAgICAgICAgaWYgKGNhbmNlbE9yQ29udGV4dCAmJiBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXQuY2FuY2VsID0gY2FuY2VsT3JDb250ZXh0O1xuICAgICAgICAgICAgdXRpbF8zLnZhbGlkYXRlQ2FsbGJhY2soZm5OYW1lLCAzLCByZXQuY2FuY2VsLCB0cnVlKTtcbiAgICAgICAgICAgIHJldC5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgICAgIHV0aWxfMy52YWxpZGF0ZUNvbnRleHRPYmplY3QoZm5OYW1lLCA0LCByZXQuY29udGV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FuY2VsT3JDb250ZXh0KSB7XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGVpdGhlciBhIGNhbmNlbCBjYWxsYmFjayBvciBhIGNvbnRleHQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbmNlbE9yQ29udGV4dCA9PT0gJ29iamVjdCcgJiYgY2FuY2VsT3JDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaXQncyBhIGNvbnRleHQhXG4gICAgICAgICAgICAgICAgcmV0LmNvbnRleHQgPSBjYW5jZWxPckNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2FuY2VsT3JDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0LmNhbmNlbCA9IGNhbmNlbE9yQ29udGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsXzMuZXJyb3JQcmVmaXgoZm5OYW1lLCAzLCB0cnVlKSArXG4gICAgICAgICAgICAgICAgICAgICcgbXVzdCBlaXRoZXIgYmUgYSBjYW5jZWwgY2FsbGJhY2sgb3IgYSBjb250ZXh0IG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFF1ZXJ5LnByb3RvdHlwZSwgXCJyZWZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlZigpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gUXVlcnk7XG59KCkpO1xuZXhwb3J0cy5RdWVyeSA9IFF1ZXJ5O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1RdWVyeS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1F1ZXJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcbnZhciB1dGlsXzMgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgTUFYX05PREU7XG5mdW5jdGlvbiBzZXRNYXhOb2RlKHZhbCkge1xuICAgIE1BWF9OT0RFID0gdmFsO1xufVxuZXhwb3J0cy5zZXRNYXhOb2RlID0gc2V0TWF4Tm9kZTtcbi8qKlxuICogQHBhcmFtIHsoIXN0cmluZ3whbnVtYmVyKX0gcHJpb3JpdHlcbiAqIEByZXR1cm4geyFzdHJpbmd9XG4gKi9cbmV4cG9ydHMucHJpb3JpdHlIYXNoVGV4dCA9IGZ1bmN0aW9uIChwcmlvcml0eSkge1xuICAgIGlmICh0eXBlb2YgcHJpb3JpdHkgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gJ251bWJlcjonICsgdXRpbF8yLmRvdWJsZVRvSUVFRTc1NFN0cmluZyhwcmlvcml0eSk7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gJ3N0cmluZzonICsgcHJpb3JpdHk7XG59O1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhIHByaW9yaXR5IHNuYXBzaG90IE5vZGUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gcHJpb3JpdHlOb2RlXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVQcmlvcml0eU5vZGUgPSBmdW5jdGlvbiAocHJpb3JpdHlOb2RlKSB7XG4gICAgaWYgKHByaW9yaXR5Tm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgdmFyIHZhbCA9IHByaW9yaXR5Tm9kZS52YWwoKTtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB1dGlsXzMuY29udGFpbnModmFsLCAnLnN2JykpLCAnUHJpb3JpdHkgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXIuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHByaW9yaXR5Tm9kZSA9PT0gTUFYX05PREUgfHwgcHJpb3JpdHlOb2RlLmlzRW1wdHkoKSwgJ3ByaW9yaXR5IG9mIHVuZXhwZWN0ZWQgdHlwZS4nKTtcbiAgICB9XG4gICAgLy8gRG9uJ3QgY2FsbCBnZXRQcmlvcml0eSgpIG9uIE1BWF9OT0RFIHRvIGF2b2lkIGhpdHRpbmcgYXNzZXJ0aW9uLlxuICAgIHV0aWxfMS5hc3NlcnQocHJpb3JpdHlOb2RlID09PSBNQVhfTk9ERSB8fCBwcmlvcml0eU5vZGUuZ2V0UHJpb3JpdHkoKS5pc0VtcHR5KCksIFwiUHJpb3JpdHkgbm9kZXMgY2FuJ3QgaGF2ZSBhIHByaW9yaXR5IG9mIHRoZWlyIG93bi5cIik7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbmFwLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvc25hcC5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleF8xID0gcmVxdWlyZShcIi4vSW5kZXhcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4uL05vZGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvdXRpbFwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuLi9ub2RlRnJvbUpTT05cIik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0luZGV4fVxuICogQHByaXZhdGVcbiAqL1xudmFyIFZhbHVlSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZhbHVlSW5kZXgsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFsdWVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgaW5kZXhDbXAgPSBhLm5vZGUuY29tcGFyZVRvKGIubm9kZSk7XG4gICAgICAgIGlmIChpbmRleENtcCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5uYW1lQ29tcGFyZShhLm5hbWUsIGIubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhDbXA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUuaXNEZWZpbmVkT24gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUuaW5kZXhlZFZhbHVlQ2hhbmdlZCA9IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIHJldHVybiAhb2xkTm9kZS5lcXVhbHMobmV3Tm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1pblBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBOb2RlXzEuTmFtZWROb2RlLk1JTjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVJbmRleC5wcm90b3R5cGUubWF4UG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVfMS5OYW1lZE5vZGUuTUFYO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqL1xuICAgIFZhbHVlSW5kZXgucHJvdG90eXBlLm1ha2VQb3N0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlXzEuTmFtZWROb2RlKG5hbWUsIHZhbHVlTm9kZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshc3RyaW5nfSBTdHJpbmcgcmVwcmVzZW50YXRpb24gZm9yIGluY2x1c2lvbiBpbiBhIHF1ZXJ5IHNwZWNcbiAgICAgKi9cbiAgICBWYWx1ZUluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcudmFsdWUnO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbHVlSW5kZXg7XG59KEluZGV4XzEuSW5kZXgpKTtcbmV4cG9ydHMuVmFsdWVJbmRleCA9IFZhbHVlSW5kZXg7XG5leHBvcnRzLlZBTFVFX0lOREVYID0gbmV3IFZhbHVlSW5kZXgoKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWVJbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zbmFwL2luZGV4ZXMvVmFsdWVJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIGNoaWxkU2V0XzEgPSByZXF1aXJlKFwiLi9jaGlsZFNldFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgTm9kZV8xID0gcmVxdWlyZShcIi4vTm9kZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgS2V5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL2luZGV4ZXMvS2V5SW5kZXhcIik7XG52YXIgX2RlZmF1bHRJbmRleE1hcDtcbnZhciBmYWxsYmFja09iamVjdCA9IHt9O1xuLyoqXG4gKlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgRmFsbGJhY2tUeXBlfFNvcnRlZE1hcC48TmFtZWROb2RlLCBOb2RlPj59IGluZGV4ZXNcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIEluZGV4Pn0gaW5kZXhTZXRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW5kZXhNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5kZXhNYXAoaW5kZXhlc18sIGluZGV4U2V0Xykge1xuICAgICAgICB0aGlzLmluZGV4ZXNfID0gaW5kZXhlc187XG4gICAgICAgIHRoaXMuaW5kZXhTZXRfID0gaW5kZXhTZXRfO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5kZXhNYXAsIFwiRGVmYXVsdFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBJbmRleE1hcCBmb3Igbm9kZXMgd2l0aG91dCBhIHByaW9yaXR5XG4gICAgICAgICAqIEB0eXBlIHshSW5kZXhNYXB9XG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KGZhbGxiYWNrT2JqZWN0ICYmIFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgJ0NoaWxkcmVuTm9kZS50cyBoYXMgbm90IGJlZW4gbG9hZGVkJyk7XG4gICAgICAgICAgICBfZGVmYXVsdEluZGV4TWFwID1cbiAgICAgICAgICAgICAgICBfZGVmYXVsdEluZGV4TWFwIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbmRleE1hcCh7ICcucHJpb3JpdHknOiBmYWxsYmFja09iamVjdCB9LCB7ICcucHJpb3JpdHknOiBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVggfSk7XG4gICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRJbmRleE1hcDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGluZGV4S2V5XG4gICAgICogQHJldHVybiB7P1NvcnRlZE1hcC48TmFtZWROb2RlLCBOb2RlPn1cbiAgICAgKi9cbiAgICBJbmRleE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGluZGV4S2V5KSB7XG4gICAgICAgIHZhciBzb3J0ZWRNYXAgPSB1dGlsXzIuc2FmZUdldCh0aGlzLmluZGV4ZXNfLCBpbmRleEtleSk7XG4gICAgICAgIGlmICghc29ydGVkTWFwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbmRleCBkZWZpbmVkIGZvciAnICsgaW5kZXhLZXkpO1xuICAgICAgICBpZiAoc29ydGVkTWFwID09PSBmYWxsYmFja09iamVjdCkge1xuICAgICAgICAgICAgLy8gVGhlIGluZGV4IGV4aXN0cywgYnV0IGl0IGZhbGxzIGJhY2sgdG8ganVzdCBuYW1lIGNvbXBhcmlzb24uIFJldHVybiBudWxsIHNvIHRoYXQgdGhlIGNhbGxpbmcgY29kZSB1c2VzIHRoZVxuICAgICAgICAgICAgLy8gcmVndWxhciBjaGlsZCBtYXBcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNvcnRlZE1hcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4RGVmaW5pdGlvblxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgSW5kZXhNYXAucHJvdG90eXBlLmhhc0luZGV4ID0gZnVuY3Rpb24gKGluZGV4RGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdXRpbF8yLmNvbnRhaW5zKHRoaXMuaW5kZXhTZXRfLCBpbmRleERlZmluaXRpb24udG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhEZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHshU29ydGVkTWFwLjxzdHJpbmcsICFOb2RlPn0gZXhpc3RpbmdDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICAgKi9cbiAgICBJbmRleE1hcC5wcm90b3R5cGUuYWRkSW5kZXggPSBmdW5jdGlvbiAoaW5kZXhEZWZpbml0aW9uLCBleGlzdGluZ0NoaWxkcmVuKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoaW5kZXhEZWZpbml0aW9uICE9PSBLZXlJbmRleF8xLktFWV9JTkRFWCwgXCJLZXlJbmRleCBhbHdheXMgZXhpc3RzIGFuZCBpc24ndCBtZWFudCB0byBiZSBhZGRlZCB0byB0aGUgSW5kZXhNYXAuXCIpO1xuICAgICAgICB2YXIgY2hpbGRMaXN0ID0gW107XG4gICAgICAgIHZhciBzYXdJbmRleGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGl0ZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldEl0ZXJhdG9yKE5vZGVfMS5OYW1lZE5vZGUuV3JhcCk7XG4gICAgICAgIHZhciBuZXh0ID0gaXRlci5nZXROZXh0KCk7XG4gICAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgICAgICBzYXdJbmRleGVkVmFsdWUgPVxuICAgICAgICAgICAgICAgIHNhd0luZGV4ZWRWYWx1ZSB8fCBpbmRleERlZmluaXRpb24uaXNEZWZpbmVkT24obmV4dC5ub2RlKTtcbiAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdJbmRleDtcbiAgICAgICAgaWYgKHNhd0luZGV4ZWRWYWx1ZSkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBjaGlsZFNldF8xLmJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleERlZmluaXRpb24uZ2V0Q29tcGFyZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld0luZGV4ID0gZmFsbGJhY2tPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4TmFtZSA9IGluZGV4RGVmaW5pdGlvbi50b1N0cmluZygpO1xuICAgICAgICB2YXIgbmV3SW5kZXhTZXQgPSB1dGlsXzIuY2xvbmUodGhpcy5pbmRleFNldF8pO1xuICAgICAgICBuZXdJbmRleFNldFtpbmRleE5hbWVdID0gaW5kZXhEZWZpbml0aW9uO1xuICAgICAgICB2YXIgbmV3SW5kZXhlcyA9IHV0aWxfMi5jbG9uZSh0aGlzLmluZGV4ZXNfKTtcbiAgICAgICAgbmV3SW5kZXhlc1tpbmRleE5hbWVdID0gbmV3SW5kZXg7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhNYXAobmV3SW5kZXhlcywgbmV3SW5kZXhTZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhpcyBub2RlIGlzIHByb3Blcmx5IHRyYWNrZWQgaW4gYW55IGluZGV4ZXMgdGhhdCB3ZSdyZSBtYWludGFpbmluZ1xuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gbmFtZWROb2RlXG4gICAgICogQHBhcmFtIHshU29ydGVkTWFwLjxzdHJpbmcsICFOb2RlPn0gZXhpc3RpbmdDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFJbmRleE1hcH1cbiAgICAgKi9cbiAgICBJbmRleE1hcC5wcm90b3R5cGUuYWRkVG9JbmRleGVzID0gZnVuY3Rpb24gKG5hbWVkTm9kZSwgZXhpc3RpbmdDaGlsZHJlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbmV3SW5kZXhlcyA9IHV0aWxfMi5tYXAodGhpcy5pbmRleGVzXywgZnVuY3Rpb24gKGluZGV4ZWRDaGlsZHJlbiwgaW5kZXhOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsXzIuc2FmZUdldChfdGhpcy5pbmRleFNldF8sIGluZGV4TmFtZSk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KGluZGV4LCAnTWlzc2luZyBpbmRleCBpbXBsZW1lbnRhdGlvbiBmb3IgJyArIGluZGV4TmFtZSk7XG4gICAgICAgICAgICBpZiAoaW5kZXhlZENoaWxkcmVuID09PSBmYWxsYmFja09iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIGluZGV4IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXguaXNEZWZpbmVkT24obmFtZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gYnVpbGQgdGhpcyBpbmRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXRJdGVyYXRvcihOb2RlXzEuTmFtZWROb2RlLldyYXApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQubmFtZSAhPSBuYW1lZE5vZGUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGl0ZXIuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTGlzdC5wdXNoKG5hbWVkTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFNldF8xLmJ1aWxkQ2hpbGRTZXQoY2hpbGRMaXN0LCBpbmRleC5nZXRDb21wYXJlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gY2hhbmdlLCB0aGlzIHJlbWFpbnMgYSBmYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nU25hcCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5hbWVkTm9kZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpbmRleGVkQ2hpbGRyZW47XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU25hcCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZHJlbiA9IG5ld0NoaWxkcmVuLnJlbW92ZShuZXcgTm9kZV8xLk5hbWVkTm9kZShuYW1lZE5vZGUubmFtZSwgZXhpc3RpbmdTbmFwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDaGlsZHJlbi5pbnNlcnQobmFtZWROb2RlLCBuYW1lZE5vZGUubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBJbmRleE1hcCBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBuYW1lZE5vZGVcbiAgICAgKiBAcGFyYW0geyFTb3J0ZWRNYXAuPHN0cmluZywgIU5vZGU+fSBleGlzdGluZ0NoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUluZGV4TWFwfVxuICAgICAqL1xuICAgIEluZGV4TWFwLnByb3RvdHlwZS5yZW1vdmVGcm9tSW5kZXhlcyA9IGZ1bmN0aW9uIChuYW1lZE5vZGUsIGV4aXN0aW5nQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIG5ld0luZGV4ZXMgPSB1dGlsXzIubWFwKHRoaXMuaW5kZXhlc18sIGZ1bmN0aW9uIChpbmRleGVkQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChpbmRleGVkQ2hpbGRyZW4gPT09IGZhbGxiYWNrT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmFsbGJhY2suIEp1c3QgcmV0dXJuIGl0LCBub3RoaW5nIHRvIGRvIGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleGVkQ2hpbGRyZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTbmFwID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmFtZWROb2RlLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1NuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbi5yZW1vdmUobmV3IE5vZGVfMS5OYW1lZE5vZGUobmFtZWROb2RlLm5hbWUsIGV4aXN0aW5nU25hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkIG9mIHRoaXMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ZWRDaGlsZHJlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4TWFwKG5ld0luZGV4ZXMsIHRoaXMuaW5kZXhTZXRfKTtcbiAgICB9O1xuICAgIHJldHVybiBJbmRleE1hcDtcbn0oKSk7XG5leHBvcnRzLkluZGV4TWFwID0gSW5kZXhNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluZGV4TWFwLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvSW5kZXhNYXAuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFNvcnRlZE1hcF8xID0gcmVxdWlyZShcIi4uL3V0aWwvU29ydGVkTWFwXCIpO1xudmFyIFNvcnRlZE1hcF8yID0gcmVxdWlyZShcIi4uL3V0aWwvU29ydGVkTWFwXCIpO1xudmFyIExPR18yID0gTWF0aC5sb2coMik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQmFzZTEyTnVtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCYXNlMTJOdW0obGVuZ3RoKSB7XG4gICAgICAgIHZhciBsb2dCYXNlMiA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCgoTWF0aC5sb2cobnVtKSAvIExPR18yKSwgMTApO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYml0TWFzayA9IGZ1bmN0aW9uIChiaXRzKSB7IHJldHVybiBwYXJzZUludChBcnJheShiaXRzICsgMSkuam9pbignMScpLCAyKTsgfTtcbiAgICAgICAgdGhpcy5jb3VudCA9IGxvZ0Jhc2UyKGxlbmd0aCArIDEpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfID0gdGhpcy5jb3VudCAtIDE7XG4gICAgICAgIHZhciBtYXNrID0gYml0TWFzayh0aGlzLmNvdW50KTtcbiAgICAgICAgdGhpcy5iaXRzXyA9IChsZW5ndGggKyAxKSAmIG1hc2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQmFzZTEyTnVtLnByb3RvdHlwZS5uZXh0Qml0SXNPbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vbm9pbnNwZWN0aW9uIEpTQml0d2lzZU9wZXJhdG9yVXNhZ2VcbiAgICAgICAgdmFyIHJlc3VsdCA9ICEodGhpcy5iaXRzXyAmICgweDEgPDwgdGhpcy5jdXJyZW50XykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRfLS07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZTEyTnVtO1xufSgpKTtcbi8qKlxuICogVGFrZXMgYSBsaXN0IG9mIGNoaWxkIG5vZGVzIGFuZCBjb25zdHJ1Y3RzIGEgU29ydGVkU2V0IHVzaW5nIHRoZSBnaXZlbiBjb21wYXJpc29uXG4gKiBmdW5jdGlvblxuICpcbiAqIFVzZXMgdGhlIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gdGhlIHBhcGVyIGxpbmtlZCBoZXJlOlxuICogaHR0cDovL2NpdGVzZWVyeC5pc3QucHN1LmVkdS92aWV3ZG9jL3N1bW1hcnk/ZG9pPTEwLjEuMS40Ni4xNDU4XG4gKlxuICogQHRlbXBsYXRlIEssIFZcbiAqIEBwYXJhbSB7QXJyYXkuPCFOYW1lZE5vZGU+fSBjaGlsZExpc3QgVW5zb3J0ZWQgbGlzdCBvZiBjaGlsZHJlblxuICogQHBhcmFtIHtmdW5jdGlvbighTmFtZWROb2RlLCAhTmFtZWROb2RlKTpudW1iZXJ9IGNtcCBUaGUgY29tcGFyaXNvbiBtZXRob2QgdG8gYmUgdXNlZFxuICogQHBhcmFtIHsoZnVuY3Rpb24oTmFtZWROb2RlKTpLKT19IGtleUZuIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4dHJhY3QgSyBmcm9tIGEgbm9kZSB3cmFwcGVyLCBpZiBLJ3NcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlIGlzIG5vdCBOYW1lZE5vZGVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9uKEssIEspOm51bWJlcik9fSBtYXBTb3J0Rm4gQW4gb3B0aW9uYWwgb3ZlcnJpZGUgZm9yIGNvbXBhcmF0b3IgdXNlZCBieSB0aGUgZ2VuZXJhdGVkIHNvcnRlZCBtYXBcbiAqIEByZXR1cm4ge1NvcnRlZE1hcC48SywgVj59XG4gKi9cbmV4cG9ydHMuYnVpbGRDaGlsZFNldCA9IGZ1bmN0aW9uIChjaGlsZExpc3QsIGNtcCwga2V5Rm4sIG1hcFNvcnRGbikge1xuICAgIGNoaWxkTGlzdC5zb3J0KGNtcCk7XG4gICAgdmFyIGJ1aWxkQmFsYW5jZWRUcmVlID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gaGlnaCAtIGxvdztcbiAgICAgICAgdmFyIG5hbWVkTm9kZTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XG4gICAgICAgICAgICBrZXkgPSBrZXlGbiA/IGtleUZuKG5hbWVkTm9kZSkgOiBuYW1lZE5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNvcnRlZE1hcF8xLkxMUkJOb2RlKGtleSwgbmFtZWROb2RlLm5vZGUsIFNvcnRlZE1hcF8xLkxMUkJOb2RlLkJMQUNLLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSBwYXJzZUludCgobGVuZ3RoIC8gMiksIDEwKSArIGxvdztcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gYnVpbGRCYWxhbmNlZFRyZWUobG93LCBtaWRkbGUpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gYnVpbGRCYWxhbmNlZFRyZWUobWlkZGxlICsgMSwgaGlnaCk7XG4gICAgICAgICAgICBuYW1lZE5vZGUgPSBjaGlsZExpc3RbbWlkZGxlXTtcbiAgICAgICAgICAgIGtleSA9IGtleUZuID8ga2V5Rm4obmFtZWROb2RlKSA6IG5hbWVkTm9kZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU29ydGVkTWFwXzEuTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgU29ydGVkTWFwXzEuTExSQk5vZGUuQkxBQ0ssIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGJ1aWxkRnJvbTEyQXJyYXkgPSBmdW5jdGlvbiAoYmFzZTEyKSB7XG4gICAgICAgIHZhciBub2RlID0gbnVsbDtcbiAgICAgICAgdmFyIHJvb3QgPSBudWxsO1xuICAgICAgICB2YXIgaW5kZXggPSBjaGlsZExpc3QubGVuZ3RoO1xuICAgICAgICB2YXIgYnVpbGRQZW5uYW50ID0gZnVuY3Rpb24gKGNodW5rU2l6ZSwgY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBsb3cgPSBpbmRleCAtIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIHZhciBoaWdoID0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCAtPSBjaHVua1NpemU7XG4gICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gYnVpbGRCYWxhbmNlZFRyZWUobG93ICsgMSwgaGlnaCk7XG4gICAgICAgICAgICB2YXIgbmFtZWROb2RlID0gY2hpbGRMaXN0W2xvd107XG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5Rm4gPyBrZXlGbihuYW1lZE5vZGUpIDogbmFtZWROb2RlO1xuICAgICAgICAgICAgYXR0YWNoUGVubmFudChuZXcgU29ydGVkTWFwXzEuTExSQk5vZGUoa2V5LCBuYW1lZE5vZGUubm9kZSwgY29sb3IsIG51bGwsIGNoaWxkVHJlZSkpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0YWNoUGVubmFudCA9IGZ1bmN0aW9uIChwZW5uYW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IHBlbm5hbnQ7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHBlbm5hbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByb290ID0gcGVubmFudDtcbiAgICAgICAgICAgICAgICBub2RlID0gcGVubmFudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlMTIuY291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGlzT25lID0gYmFzZTEyLm5leHRCaXRJc09uZSgpO1xuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBub2RlcyB0YWtlbiBpbiBlYWNoIHNsaWNlIGlzIDJeKGFyci5sZW5ndGggLSAoaSArIDEpKVxuICAgICAgICAgICAgdmFyIGNodW5rU2l6ZSA9IE1hdGgucG93KDIsIGJhc2UxMi5jb3VudCAtIChpICsgMSkpO1xuICAgICAgICAgICAgaWYgKGlzT25lKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgU29ydGVkTWFwXzEuTExSQk5vZGUuQkxBQ0spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCA9PSAyXG4gICAgICAgICAgICAgICAgYnVpbGRQZW5uYW50KGNodW5rU2l6ZSwgU29ydGVkTWFwXzEuTExSQk5vZGUuQkxBQ0spO1xuICAgICAgICAgICAgICAgIGJ1aWxkUGVubmFudChjaHVua1NpemUsIFNvcnRlZE1hcF8xLkxMUkJOb2RlLlJFRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfTtcbiAgICB2YXIgYmFzZTEyID0gbmV3IEJhc2UxMk51bShjaGlsZExpc3QubGVuZ3RoKTtcbiAgICB2YXIgcm9vdCA9IGJ1aWxkRnJvbTEyQXJyYXkoYmFzZTEyKTtcbiAgICByZXR1cm4gbmV3IFNvcnRlZE1hcF8yLlNvcnRlZE1hcChtYXBTb3J0Rm4gfHwgY21wLCByb290KTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoaWxkU2V0LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvY2hpbGRTZXQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsL3V0aWxcIik7XG5mdW5jdGlvbiBOQU1FX09OTFlfQ09NUEFSQVRPUihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB1dGlsXzEubmFtZUNvbXBhcmUobGVmdC5uYW1lLCByaWdodC5uYW1lKTtcbn1cbmV4cG9ydHMuTkFNRV9PTkxZX0NPTVBBUkFUT1IgPSBOQU1FX09OTFlfQ09NUEFSQVRPUjtcbmZ1bmN0aW9uIE5BTUVfQ09NUEFSQVRPUihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiB1dGlsXzEubmFtZUNvbXBhcmUobGVmdCwgcmlnaHQpO1xufVxuZXhwb3J0cy5OQU1FX0NPTVBBUkFUT1IgPSBOQU1FX0NPTVBBUkFUT1I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBhcmF0b3JzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3NuYXAvY29tcGFyYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMiA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL3V0aWxcIik7XG52YXIgSW5kZXhfMSA9IHJlcXVpcmUoXCIuL0luZGV4XCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uL0NoaWxkcmVuTm9kZVwiKTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi4vTm9kZVwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuLi9ub2RlRnJvbUpTT05cIik7XG4vKipcbiAqIEBwYXJhbSB7IVBhdGh9IGluZGV4UGF0aFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SW5kZXh9XG4gKi9cbnZhciBQYXRoSW5kZXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBhdGhJbmRleCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXRoSW5kZXgoaW5kZXhQYXRoXykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbmRleFBhdGhfID0gaW5kZXhQYXRoXztcbiAgICAgICAgdXRpbF8xLmFzc2VydCghaW5kZXhQYXRoXy5pc0VtcHR5KCkgJiYgaW5kZXhQYXRoXy5nZXRGcm9udCgpICE9PSAnLnByaW9yaXR5JywgXCJDYW4ndCBjcmVhdGUgUGF0aEluZGV4IHdpdGggZW1wdHkgcGF0aCBvciAucHJpb3JpdHkga2V5XCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNuYXBcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgUGF0aEluZGV4LnByb3RvdHlwZS5leHRyYWN0Q2hpbGQgPSBmdW5jdGlvbiAoc25hcCkge1xuICAgICAgICByZXR1cm4gc25hcC5nZXRDaGlsZCh0aGlzLmluZGV4UGF0aF8pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLmlzRGVmaW5lZE9uID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLmdldENoaWxkKHRoaXMuaW5kZXhQYXRoXykuaXNFbXB0eSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgYUNoaWxkID0gdGhpcy5leHRyYWN0Q2hpbGQoYS5ub2RlKTtcbiAgICAgICAgdmFyIGJDaGlsZCA9IHRoaXMuZXh0cmFjdENoaWxkKGIubm9kZSk7XG4gICAgICAgIHZhciBpbmRleENtcCA9IGFDaGlsZC5jb21wYXJlVG8oYkNoaWxkKTtcbiAgICAgICAgaWYgKGluZGV4Q21wID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXRpbF8yLm5hbWVDb21wYXJlKGEubmFtZSwgYi5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleENtcDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQYXRoSW5kZXgucHJvdG90eXBlLm1ha2VQb3N0ID0gZnVuY3Rpb24gKGluZGV4VmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlTm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihpbmRleFZhbHVlKTtcbiAgICAgICAgdmFyIG5vZGUgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERS51cGRhdGVDaGlsZCh0aGlzLmluZGV4UGF0aF8sIHZhbHVlTm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZV8xLk5hbWVkTm9kZShuYW1lLCBub2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGF0aEluZGV4LnByb3RvdHlwZS5tYXhQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLnVwZGF0ZUNoaWxkKHRoaXMuaW5kZXhQYXRoXywgQ2hpbGRyZW5Ob2RlXzEuTUFYX05PREUpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVfMS5OYW1lZE5vZGUodXRpbF8yLk1BWF9OQU1FLCBub2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGF0aEluZGV4LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhQYXRoXy5zbGljZSgpLmpvaW4oJy8nKTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRoSW5kZXg7XG59KEluZGV4XzEuSW5kZXgpKTtcbmV4cG9ydHMuUGF0aEluZGV4ID0gUGF0aEluZGV4O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoSW5kZXguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc25hcC9pbmRleGVzL1BhdGhJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG52YXIgU3BhcnNlU25hcHNob3RUcmVlXzEgPSByZXF1aXJlKFwiLi4vU3BhcnNlU25hcHNob3RUcmVlXCIpO1xudmFyIExlYWZOb2RlXzEgPSByZXF1aXJlKFwiLi4vc25hcC9MZWFmTm9kZVwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuLi9zbmFwL25vZGVGcm9tSlNPTlwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIEdlbmVyYXRlIHBsYWNlaG9sZGVycyBmb3IgZGVmZXJyZWQgdmFsdWVzLlxuICogQHBhcmFtIHs/T2JqZWN0fSB2YWx1ZXNcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVXaXRoVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgIHZhbHVlcyA9IHZhbHVlcyB8fCB7fTtcbiAgICB2YWx1ZXNbJ3RpbWVzdGFtcCddID0gdmFsdWVzWyd0aW1lc3RhbXAnXSB8fCBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICByZXR1cm4gdmFsdWVzO1xufTtcbi8qKlxuICogVmFsdWUgdG8gdXNlIHdoZW4gZmlyaW5nIGxvY2FsIGV2ZW50cy4gV2hlbiB3cml0aW5nIHNlcnZlciB2YWx1ZXMsIGZpcmVcbiAqIGxvY2FsIGV2ZW50cyB3aXRoIGFuIGFwcHJveGltYXRlIHZhbHVlLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIGFzLWlzLlxuICogQHBhcmFtIHsoT2JqZWN0fHN0cmluZ3xudW1iZXJ8Ym9vbGVhbil9IHZhbHVlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IShzdHJpbmd8bnVtYmVyfGJvb2xlYW4pfVxuICovXG5leHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBzZXJ2ZXJWYWx1ZXMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCgnLnN2JyBpbiB2YWx1ZSwgJ1VuZXhwZWN0ZWQgbGVhZiBub2RlIG9yIHByaW9yaXR5IGNvbnRlbnRzJyk7XG4gICAgICAgIHJldHVybiBzZXJ2ZXJWYWx1ZXNbdmFsdWVbJy5zdiddXTtcbiAgICB9XG59O1xuLyoqXG4gKiBSZWN1cnNpdmVseSByZXBsYWNlIGFsbCBkZWZlcnJlZCB2YWx1ZXMgYW5kIHByaW9yaXRpZXMgaW4gdGhlIHRyZWUgd2l0aCB0aGVcbiAqIHNwZWNpZmllZCBnZW5lcmF0ZWQgcmVwbGFjZW1lbnQgdmFsdWVzLlxuICogQHBhcmFtIHshU3BhcnNlU25hcHNob3RUcmVlfSB0cmVlXG4gKiBAcGFyYW0geyFPYmplY3R9IHNlcnZlclZhbHVlc1xuICogQHJldHVybiB7IVNwYXJzZVNuYXBzaG90VHJlZX1cbiAqL1xuZXhwb3J0cy5yZXNvbHZlRGVmZXJyZWRWYWx1ZVRyZWUgPSBmdW5jdGlvbiAodHJlZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJlc29sdmVkVHJlZSA9IG5ldyBTcGFyc2VTbmFwc2hvdFRyZWVfMS5TcGFyc2VTbmFwc2hvdFRyZWUoKTtcbiAgICB0cmVlLmZvckVhY2hUcmVlKG5ldyBQYXRoXzEuUGF0aCgnJyksIGZ1bmN0aW9uIChwYXRoLCBub2RlKSB7XG4gICAgICAgIHJlc29sdmVkVHJlZS5yZW1lbWJlcihwYXRoLCBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3Qobm9kZSwgc2VydmVyVmFsdWVzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc29sdmVkVHJlZTtcbn07XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHJlcGxhY2UgYWxsIGRlZmVycmVkIHZhbHVlcyBhbmQgcHJpb3JpdGllcyBpbiB0aGUgbm9kZSB3aXRoIHRoZVxuICogc3BlY2lmaWVkIGdlbmVyYXRlZCByZXBsYWNlbWVudCB2YWx1ZXMuICBJZiB0aGVyZSBhcmUgbm8gc2VydmVyIHZhbHVlcyBpbiB0aGUgbm9kZSxcbiAqIGl0J2xsIGJlIHJldHVybmVkIGFzLWlzLlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHshT2JqZWN0fSBzZXJ2ZXJWYWx1ZXNcbiAqIEByZXR1cm4geyFOb2RlfVxuICovXG5leHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QgPSBmdW5jdGlvbiAobm9kZSwgc2VydmVyVmFsdWVzKSB7XG4gICAgdmFyIHJhd1ByaSA9IG5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICB2YXIgcHJpb3JpdHkgPSBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlKHJhd1ByaSwgc2VydmVyVmFsdWVzKTtcbiAgICB2YXIgbmV3Tm9kZTtcbiAgICBpZiAobm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgdmFyIGxlYWZOb2RlID0gbm9kZTtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwb3J0cy5yZXNvbHZlRGVmZXJyZWRWYWx1ZShsZWFmTm9kZS5nZXRWYWx1ZSgpLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IGxlYWZOb2RlLmdldFZhbHVlKCkgfHxcbiAgICAgICAgICAgIHByaW9yaXR5ICE9PSBsZWFmTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExlYWZOb2RlXzEuTGVhZk5vZGUodmFsdWUsIG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk5vZGUgPSBub2RlO1xuICAgICAgICBuZXdOb2RlID0gY2hpbGRyZW5Ob2RlO1xuICAgICAgICBpZiAocHJpb3JpdHkgIT09IGNoaWxkcmVuTm9kZS5nZXRQcmlvcml0eSgpLnZhbCgpKSB7XG4gICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZS51cGRhdGVQcmlvcml0eShuZXcgTGVhZk5vZGVfMS5MZWFmTm9kZShwcmlvcml0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuTm9kZS5mb3JFYWNoQ2hpbGQoUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYLCBmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBuZXdDaGlsZE5vZGUgPSBleHBvcnRzLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QoY2hpbGROb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkTm9kZSAhPT0gY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgbmV3Tm9kZSA9IG5ld05vZGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBuZXdDaGlsZE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld05vZGU7XG4gICAgfVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VydmVyVmFsdWVzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvU2VydmVyVmFsdWVzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi91dGlsL1BhdGhcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgQ291bnRlZFNldF8xID0gcmVxdWlyZShcIi4vdXRpbC9Db3VudGVkU2V0XCIpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gc3RvcmUgYSBzcGFyc2Ugc2V0IG9mIHNuYXBzaG90cy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNwYXJzZVNuYXBzaG90VHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTcGFyc2VTbmFwc2hvdFRyZWUoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7Tm9kZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtDb3VudGVkU2V0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBub2RlIHN0b3JlZCBhdCB0aGUgZ2l2ZW4gcGF0aCBpZiBvbmUgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxuICAgICAqIEByZXR1cm4gez9Ob2RlfSBUaGUgcmV0cmlldmVkIG5vZGUsIG9yIG51bGwuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlXy5nZXRDaGlsZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcGF0aC5pc0VtcHR5KCkgJiYgdGhpcy5jaGlsZHJlbl8gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5jb250YWlucyhjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gdGhpcy5jaGlsZHJlbl8uZ2V0KGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGRUcmVlLmZpbmQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGdpdmVuIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoLiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbm9kZVxuICAgICAqIGF0IGEgc2hhbGxvd2VyIHBhdGgsIGl0IG1lcmdlcyB0aGUgbmV3IGRhdGEgaW50byB0aGF0IHNuYXBzaG90IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggdG8gbG9vayB1cCBzbmFwc2hvdCBmb3IuXG4gICAgICogQHBhcmFtIHshTm9kZX0gZGF0YSBUaGUgbmV3IGRhdGEsIG9yIG51bGwuXG4gICAgICovXG4gICAgU3BhcnNlU25hcHNob3RUcmVlLnByb3RvdHlwZS5yZW1lbWJlciA9IGZ1bmN0aW9uIChwYXRoLCBkYXRhKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlXyA9IHRoaXMudmFsdWVfLnVwZGF0ZUNoaWxkKHBhdGgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5fID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuXyA9IG5ldyBDb3VudGVkU2V0XzEuQ291bnRlZFNldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gcGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuXy5jb250YWlucyhjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuXy5hZGQoY2hpbGRLZXksIG5ldyBTcGFyc2VTbmFwc2hvdFRyZWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuXy5nZXQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgIGNoaWxkLnJlbWVtYmVyKHBhdGgsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdXJnZSB0aGUgZGF0YSBhdCBwYXRoIGZyb20gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBQYXRoIHRvIGxvb2sgdXAgc25hcHNob3QgZm9yLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBub2RlIHNob3VsZCBub3cgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBTcGFyc2VTbmFwc2hvdFRyZWUucHJvdG90eXBlLmZvcmdldCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZV8uaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHRyeWluZyB0byBmb3JnZXQgYSBub2RlIHRoYXQgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlXztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZV8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgdHJlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZl8xLnJlbWVtYmVyKG5ldyBQYXRoXzEuUGF0aChrZXkpLCB0cmVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcmdldChwYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5jb250YWlucyhjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhZmVUb1JlbW92ZSA9IHRoaXMuY2hpbGRyZW5fLmdldChjaGlsZEtleSkuZm9yZ2V0KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2FmZVRvUmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuXy5yZW1vdmUoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgb2YgdGhlIHN0b3JlZCB0cmVlIGFuZCBjYWxscyB0aGVcbiAgICAgKiBjYWxsYmFjayBvbiBlYWNoIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHByZWZpeFBhdGggUGF0aCB0byBsb29rIHVwIG5vZGUgZm9yLlxuICAgICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggdHJlZS5cbiAgICAgKi9cbiAgICBTcGFyc2VTbmFwc2hvdFRyZWUucHJvdG90eXBlLmZvckVhY2hUcmVlID0gZnVuY3Rpb24gKHByZWZpeFBhdGgsIGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmdW5jKHByZWZpeFBhdGgsIHRoaXMudmFsdWVfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaENoaWxkKGZ1bmN0aW9uIChrZXksIHRyZWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwcmVmaXhQYXRoLnRvU3RyaW5nKCkgKyAnLycgKyBrZXkpO1xuICAgICAgICAgICAgICAgIHRyZWUuZm9yRWFjaFRyZWUocGF0aCwgZnVuYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgdGhyb3VnaCBlYWNoIGltbWVkaWF0ZSBjaGlsZCBhbmQgdHJpZ2dlcnMgdGhlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshRnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCBjaGlsZC5cbiAgICAgKi9cbiAgICBTcGFyc2VTbmFwc2hvdFRyZWUucHJvdG90eXBlLmZvckVhY2hDaGlsZCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbl8uZWFjaChmdW5jdGlvbiAoa2V5LCB0cmVlKSB7XG4gICAgICAgICAgICAgICAgZnVuYyhrZXksIHRyZWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTcGFyc2VTbmFwc2hvdFRyZWU7XG59KCkpO1xuZXhwb3J0cy5TcGFyc2VTbmFwc2hvdFRyZWUgPSBTcGFyc2VTbmFwc2hvdFRyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNwYXJzZVNuYXBzaG90VHJlZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TcGFyc2VTbmFwc2hvdFRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogSW1wbGVtZW50cyBhIHNldCB3aXRoIGEgY291bnQgb2YgZWxlbWVudHMuXG4gKlxuICogQHRlbXBsYXRlIEssIFZcbiAqL1xudmFyIENvdW50ZWRTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ291bnRlZFNldCgpIHtcbiAgICAgICAgdGhpcy5zZXQgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS30gaXRlbVxuICAgICAqIEBwYXJhbSB7Vn0gdmFsXG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGl0ZW0sIHZhbCkge1xuICAgICAgICB0aGlzLnNldFtpdGVtXSA9IHZhbCAhPT0gbnVsbCA/IHZhbCA6IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFLfSBrZXlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKHRoaXMuc2V0LCBrZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshS30gaXRlbVxuICAgICAqIEByZXR1cm4ge1Z9XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoaXRlbSkgPyB0aGlzLnNldFtpdGVtXSA6IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUt9IGl0ZW1cbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZXRbaXRlbV07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGV2ZXJ5dGhpbmcgaW4gdGhlIHNldFxuICAgICAqL1xuICAgIENvdW50ZWRTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNldCA9IHt9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxfMS5pc0VtcHR5KHRoaXMuc2V0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgc2V0XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzEuZ2V0Q291bnQodGhpcy5zZXQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUnVuIGEgZnVuY3Rpb24gb24gZWFjaCBrLHYgcGFpciBpbiB0aGUgc2V0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihLLCBWKX0gZm5cbiAgICAgKi9cbiAgICBDb3VudGVkU2V0LnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKHRoaXMuc2V0LCBmdW5jdGlvbiAoaywgdikgeyByZXR1cm4gZm4oaywgdik7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGZvciBkZWJ1Z2dpbmdcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48Sz59IFRoZSBrZXlzIHByZXNlbnQgaW4gdGhpcyBDb3VudGVkU2V0XG4gICAgICovXG4gICAgQ291bnRlZFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgdXRpbF8xLmZvckVhY2godGhpcy5zZXQsIGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuICAgIHJldHVybiBDb3VudGVkU2V0O1xufSgpKTtcbmV4cG9ydHMuQ291bnRlZFNldCA9IENvdW50ZWRTZXQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvdW50ZWRTZXQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9Db3VudGVkU2V0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL09wZXJhdGlvblwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQHBhcmFtIHshTm9kZX0gc25hcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG52YXIgT3ZlcndyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE92ZXJ3cml0ZShzb3VyY2UsIHBhdGgsIHNuYXApIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuc25hcCA9IHNuYXA7XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk9WRVJXUklURTtcbiAgICB9XG4gICAgT3ZlcndyaXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT3ZlcndyaXRlKHRoaXMuc291cmNlLCBQYXRoXzEuUGF0aC5FbXB0eSwgdGhpcy5zbmFwLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpLCB0aGlzLnNuYXApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT3ZlcndyaXRlO1xufSgpKTtcbmV4cG9ydHMuT3ZlcndyaXRlID0gT3ZlcndyaXRlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdmVyd3JpdGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvb3BlcmF0aW9uL092ZXJ3cml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ2FjaGVOb2RlXzEgPSByZXF1aXJlKFwiLi92aWV3L0NhY2hlTm9kZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgVmlld0NhY2hlXzEgPSByZXF1aXJlKFwiLi92aWV3L1ZpZXdDYWNoZVwiKTtcbnZhciBWaWV3XzEgPSByZXF1aXJlKFwiLi92aWV3L1ZpZXdcIik7XG52YXIgX19yZWZlcmVuY2VDb25zdHJ1Y3Rvcjtcbi8qKlxuICogU3luY1BvaW50IHJlcHJlc2VudHMgYSBzaW5nbGUgbG9jYXRpb24gaW4gYSBTeW5jVHJlZSB3aXRoIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLCBtZWFuaW5nIHdlIG5lZWQgdG9cbiAqIG1haW50YWluIDEgb3IgbW9yZSBWaWV3cyBhdCB0aGlzIGxvY2F0aW9uIHRvIGNhY2hlIHNlcnZlciBkYXRhIGFuZCByYWlzZSBhcHByb3ByaWF0ZSBldmVudHMgZm9yIHNlcnZlciBjaGFuZ2VzXG4gKiBhbmQgdXNlciB3cml0ZXMgKHNldCwgdHJhbnNhY3Rpb24sIHVwZGF0ZSkuXG4gKlxuICogSXQncyByZXNwb25zaWJsZSBmb3I6XG4gKiAgLSBNYWludGFpbmluZyB0aGUgc2V0IG9mIDEgb3IgbW9yZSB2aWV3cyBuZWNlc3NhcnkgYXQgdGhpcyBsb2NhdGlvbiAoYSBTeW5jUG9pbnQgd2l0aCAwIHZpZXdzIHNob3VsZCBiZSByZW1vdmVkKS5cbiAqICAtIFByb3h5aW5nIHVzZXIgLyBzZXJ2ZXIgb3BlcmF0aW9ucyB0byB0aGUgdmlld3MgYXMgYXBwcm9wcmlhdGUgKGkuZS4gYXBwbHlTZXJ2ZXJPdmVyd3JpdGUsXG4gKiAgICBhcHBseVVzZXJPdmVyd3JpdGUsIGV0Yy4pXG4gKi9cbnZhciBTeW5jUG9pbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3luY1BvaW50KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFZpZXdzIGJlaW5nIHRyYWNrZWQgYXQgdGhpcyBsb2NhdGlvbiBpbiB0aGUgdHJlZSwgc3RvcmVkIGFzIGEgbWFwIHdoZXJlIHRoZSBrZXkgaXMgYVxuICAgICAgICAgKiBxdWVyeUlkIGFuZCB0aGUgdmFsdWUgaXMgdGhlIFZpZXcgZm9yIHRoYXQgcXVlcnkuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFRoaXMgbGlzdCB3aWxsIGJlIHF1aXRlIHNtYWxsICh1c3VhbGx5IDEsIGJ1dCBwZXJoYXBzIDIgb3IgMzsgYW55IG1vcmUgaXMgYW4gb2RkIHVzZSBjYXNlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyFPYmplY3QuPCFzdHJpbmcsICFWaWV3Pn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3NfID0ge307XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTeW5jUG9pbnQsIFwiX19yZWZlcmVuY2VDb25zdHJ1Y3RvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydChfX3JlZmVyZW5jZUNvbnN0cnVjdG9yLCAnUmVmZXJlbmNlLnRzIGhhcyBub3QgYmVlbiBsb2FkZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfX3JlZmVyZW5jZUNvbnN0cnVjdG9yO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoIV9fcmVmZXJlbmNlQ29uc3RydWN0b3IsICdfX3JlZmVyZW5jZUNvbnN0cnVjdG9yIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCcpO1xuICAgICAgICAgICAgX19yZWZlcmVuY2VDb25zdHJ1Y3RvciA9IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB1dGlsXzIuaXNFbXB0eSh0aGlzLnZpZXdzXyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9wZXJhdGlvbn0gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbiA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKSB7XG4gICAgICAgIHZhciBxdWVyeUlkID0gb3BlcmF0aW9uLnNvdXJjZS5xdWVyeUlkO1xuICAgICAgICBpZiAocXVlcnlJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHZpZXcgPSB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHZpZXcgIT0gbnVsbCwgJ1N5bmNUcmVlIGdhdmUgdXMgYW4gb3AgZm9yIGFuIGludmFsaWQgcXVlcnkuJyk7XG4gICAgICAgICAgICByZXR1cm4gdmlldy5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBldmVudHNfMSA9IFtdO1xuICAgICAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uIChrZXksIHZpZXcpIHtcbiAgICAgICAgICAgICAgICBldmVudHNfMSA9IGV2ZW50c18xLmNvbmNhdCh2aWV3LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIG9wdENvbXBsZXRlU2VydmVyQ2FjaGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50c18xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgY2FsbGJhY2sgZm9yIHRoZSBzcGVjaWZpZWQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGUgQ29tcGxldGUgc2VydmVyIGNhY2hlLCBpZiB3ZSBoYXZlIGl0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VydmVyQ2FjaGVDb21wbGV0ZVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuYWRkRXZlbnRSZWdpc3RyYXRpb24gPSBmdW5jdGlvbiAocXVlcnksIGV2ZW50UmVnaXN0cmF0aW9uLCB3cml0ZXNDYWNoZSwgc2VydmVyQ2FjaGUsIHNlcnZlckNhY2hlQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHZpZXcgPSB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSB3cml0ZXNDYWNoZSB0YWtlIGZsYWcgZm9yIGNvbXBsZXRlIHNlcnZlciBub2RlXG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUoc2VydmVyQ2FjaGVDb21wbGV0ZSA/IHNlcnZlckNhY2hlIDogbnVsbCk7XG4gICAgICAgICAgICB2YXIgZXZlbnRDYWNoZUNvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGVDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZSkge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHNlcnZlckNhY2hlKTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50Q2FjaGUgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICBldmVudENhY2hlQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2aWV3Q2FjaGUgPSBuZXcgVmlld0NhY2hlXzEuVmlld0NhY2hlKG5ldyBDYWNoZU5vZGVfMS5DYWNoZU5vZGUoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZXZlbnRDYWNoZSksIGV2ZW50Q2FjaGVDb21wbGV0ZSwgZmFsc2UpLCBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi8gKHNlcnZlckNhY2hlKSwgc2VydmVyQ2FjaGVDb21wbGV0ZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIHZpZXcgPSBuZXcgVmlld18xLlZpZXcocXVlcnksIHZpZXdDYWNoZSk7XG4gICAgICAgICAgICB0aGlzLnZpZXdzX1txdWVyeUlkXSA9IHZpZXc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIGV4aXN0IG5vdywgd2UganVzdCBjcmVhdGVkIGFueXRoaW5nIHRoYXQgd2FzIG1pc3NpbmdcbiAgICAgICAgdmlldy5hZGRFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgICAgIHJldHVybiB2aWV3LmdldEluaXRpYWxFdmVudHMoZXZlbnRSZWdpc3RyYXRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLiAgUmV0dXJuIGNhbmNlbEV2ZW50cyBpZiBhIGNhbmNlbEVycm9yIGlzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIElmIHF1ZXJ5IGlzIHRoZSBkZWZhdWx0IHF1ZXJ5LCB3ZSdsbCBjaGVjayBhbGwgdmlld3MgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRSZWdpc3RyYXRpb24uXG4gICAgICogSWYgZXZlbnRSZWdpc3RyYXRpb24gaXMgbnVsbCwgd2UnbGwgcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBzcGVjaWZpZWQgdmlldyhzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7P0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvbiBJZiBudWxsLCByZW1vdmUgYWxsIGNhbGxiYWNrcy5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4ge3tyZW1vdmVkOiFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiFBcnJheS48IUV2ZW50Pn19IHJlbW92ZWQgcXVlcmllcyBhbmQgYW55IGNhbmNlbCBldmVudHNcbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgdmFyIGNhbmNlbEV2ZW50cyA9IFtdO1xuICAgICAgICB2YXIgaGFkQ29tcGxldGVWaWV3ID0gdGhpcy5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgaWYgKHF1ZXJ5SWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgLy8gV2hlbiB5b3UgZG8gcmVmLm9mZiguLi4pLCB3ZSBzZWFyY2ggYWxsIHZpZXdzIGZvciB0aGUgcmVnaXN0cmF0aW9uIHRvIHJlbW92ZS5cbiAgICAgICAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uICh2aWV3UXVlcnlJZCwgdmlldykge1xuICAgICAgICAgICAgICAgIGNhbmNlbEV2ZW50cyA9IGNhbmNlbEV2ZW50cy5jb25jYXQodmlldy5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbihldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpKTtcbiAgICAgICAgICAgICAgICBpZiAodmlldy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNlbGZfMS52aWV3c19bdmlld1F1ZXJ5SWRdO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSdsbCBkZWFsIHdpdGggY29tcGxldGUgdmlld3MgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaCh2aWV3LmdldFF1ZXJ5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gdGhlIHNwZWNpZmljIHZpZXcuXG4gICAgICAgICAgICB2YXIgdmlldyA9IHV0aWxfMi5zYWZlR2V0KHRoaXMudmlld3NfLCBxdWVyeUlkKTtcbiAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gY2FuY2VsRXZlbnRzLmNvbmNhdCh2aWV3LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKGV2ZW50UmVnaXN0cmF0aW9uLCBjYW5jZWxFcnJvcikpO1xuICAgICAgICAgICAgICAgIGlmICh2aWV3LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52aWV3c19bcXVlcnlJZF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGRlYWwgd2l0aCBjb21wbGV0ZSB2aWV3cyBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UXVlcnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldFF1ZXJ5UGFyYW1zKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKHZpZXcuZ2V0UXVlcnkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhZENvbXBsZXRlVmlldyAmJiAhdGhpcy5oYXNDb21wbGV0ZVZpZXcoKSkge1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlZCBvdXIgbGFzdCBjb21wbGV0ZSB2aWV3LlxuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG5ldyBTeW5jUG9pbnQuX19yZWZlcmVuY2VDb25zdHJ1Y3RvcihxdWVyeS5yZXBvLCBxdWVyeS5wYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVtb3ZlZDogcmVtb3ZlZCwgZXZlbnRzOiBjYW5jZWxFdmVudHMgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuZ2V0UXVlcnlWaWV3cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHZhbHVlcyA9IE9iamVjdC5rZXlzKHRoaXMudmlld3NfKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gX3RoaXMudmlld3NfW2tleV07IH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzLmZpbHRlcihmdW5jdGlvbiAodmlldykge1xuICAgICAgICAgICAgcmV0dXJuICF2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgY29tcGxldGUgc25hcHNob3RcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX0gQSBjb21wbGV0ZSBjYWNoZSwgaWYgaXQgZXhpc3RzXG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS5nZXRDb21wbGV0ZVNlcnZlckNhY2hlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHNlcnZlckNhY2hlID0gbnVsbDtcbiAgICAgICAgdXRpbF8yLmZvckVhY2godGhpcy52aWV3c18sIGZ1bmN0aW9uIChrZXksIHZpZXcpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUgfHwgdmlldy5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHBhdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcnZlckNhY2hlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7P1ZpZXd9XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS52aWV3Rm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCk7XG4gICAgICAgIGlmIChwYXJhbXMubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXBsZXRlVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzIuc2FmZUdldCh0aGlzLnZpZXdzXywgcXVlcnlJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgU3luY1BvaW50LnByb3RvdHlwZS52aWV3RXhpc3RzRm9yUXVlcnkgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0ZvclF1ZXJ5KHF1ZXJ5KSAhPSBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBTeW5jUG9pbnQucHJvdG90eXBlLmhhc0NvbXBsZXRlVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcGxldGVWaWV3KCkgIT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9WaWV3fVxuICAgICAqL1xuICAgIFN5bmNQb2ludC5wcm90b3R5cGUuZ2V0Q29tcGxldGVWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxldGVWaWV3ID0gdXRpbF8yLmZpbmRWYWx1ZSh0aGlzLnZpZXdzXywgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3XG4gICAgICAgICAgICAgICAgLmdldFF1ZXJ5KClcbiAgICAgICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgICAgIC5sb2Fkc0FsbERhdGEoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZVZpZXcgfHwgbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTeW5jUG9pbnQ7XG59KCkpO1xuZXhwb3J0cy5TeW5jUG9pbnQgPSBTeW5jUG9pbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bmNQb2ludC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TeW5jUG9pbnQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIENhY2hlTm9kZV8xID0gcmVxdWlyZShcIi4vQ2FjaGVOb2RlXCIpO1xuLyoqXG4gKiBTdG9yZXMgdGhlIGRhdGEgd2UgaGF2ZSBjYWNoZWQgZm9yIGEgdmlldy5cbiAqXG4gKiBzZXJ2ZXJTbmFwIGlzIHRoZSBjYWNoZWQgc2VydmVyIGRhdGEsIGV2ZW50U25hcCBpcyB0aGUgY2FjaGVkIGV2ZW50IGRhdGEgKHNlcnZlciBkYXRhIHBsdXMgYW55IGxvY2FsIHdyaXRlcykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBWaWV3Q2FjaGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFDYWNoZU5vZGV9IGV2ZW50Q2FjaGVfXG4gICAgICogQHBhcmFtIHshQ2FjaGVOb2RlfSBzZXJ2ZXJDYWNoZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3Q2FjaGUoZXZlbnRDYWNoZV8sIHNlcnZlckNhY2hlXykge1xuICAgICAgICB0aGlzLmV2ZW50Q2FjaGVfID0gZXZlbnRDYWNoZV87XG4gICAgICAgIHRoaXMuc2VydmVyQ2FjaGVfID0gc2VydmVyQ2FjaGVfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBldmVudFNuYXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZFxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS51cGRhdGVFdmVudFNuYXAgPSBmdW5jdGlvbiAoZXZlbnRTbmFwLCBjb21wbGV0ZSwgZmlsdGVyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWaWV3Q2FjaGUobmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShldmVudFNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCksIHRoaXMuc2VydmVyQ2FjaGVfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHNlcnZlclNuYXBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJlZFxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS51cGRhdGVTZXJ2ZXJTbmFwID0gZnVuY3Rpb24gKHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFZpZXdDYWNoZSh0aGlzLmV2ZW50Q2FjaGVfLCBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKHNlcnZlclNuYXAsIGNvbXBsZXRlLCBmaWx0ZXJlZCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUNhY2hlTm9kZX1cbiAgICAgKi9cbiAgICBWaWV3Q2FjaGUucHJvdG90eXBlLmdldEV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50Q2FjaGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRDb21wbGV0ZUV2ZW50U25hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRDYWNoZV8uaXNGdWxseUluaXRpYWxpemVkKClcbiAgICAgICAgICAgID8gdGhpcy5ldmVudENhY2hlXy5nZXROb2RlKClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFDYWNoZU5vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRTZXJ2ZXJDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyQ2FjaGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLnByb3RvdHlwZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlckNhY2hlXy5pc0Z1bGx5SW5pdGlhbGl6ZWQoKVxuICAgICAgICAgICAgPyB0aGlzLnNlcnZlckNhY2hlXy5nZXROb2RlKClcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBjb25zdFxuICAgICAqIEB0eXBlIHtWaWV3Q2FjaGV9XG4gICAgICovXG4gICAgVmlld0NhY2hlLkVtcHR5ID0gbmV3IFZpZXdDYWNoZShuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBcbiAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsIFxuICAgIC8qZmlsdGVyZWQ9Ki8gZmFsc2UpLCBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBcbiAgICAvKmZ1bGx5SW5pdGlhbGl6ZWQ9Ki8gZmFsc2UsIFxuICAgIC8qZmlsdGVyZWQ9Ki8gZmFsc2UpKTtcbiAgICByZXR1cm4gVmlld0NhY2hlO1xufSgpKTtcbmV4cG9ydHMuVmlld0NhY2hlID0gVmlld0NhY2hlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3Q2FjaGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9WaWV3Q2FjaGUuanNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogUmV0dXJucyB0aGUgZGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgY2FsbCB0byBnZXQgc3RhdHMuXG4gKlxuICogQHBhcmFtIGNvbGxlY3Rpb25fIFRoZSBjb2xsZWN0aW9uIHRvIFwibGlzdGVuXCIgdG8uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN0YXRzTGlzdGVuZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdHNMaXN0ZW5lcihjb2xsZWN0aW9uXykge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25fID0gY29sbGVjdGlvbl87XG4gICAgICAgIHRoaXMubGFzdF8gPSBudWxsO1xuICAgIH1cbiAgICBTdGF0c0xpc3RlbmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTdGF0cyA9IHRoaXMuY29sbGVjdGlvbl8uZ2V0KCk7XG4gICAgICAgIHZhciBkZWx0YSA9IHV0aWxfMS5jbG9uZShuZXdTdGF0cyk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RfKSB7XG4gICAgICAgICAgICB1dGlsXzEuZm9yRWFjaCh0aGlzLmxhc3RfLCBmdW5jdGlvbiAoc3RhdCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBkZWx0YVtzdGF0XSA9IGRlbHRhW3N0YXRdIC0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RfID0gbmV3U3RhdHM7XG4gICAgICAgIHJldHVybiBkZWx0YTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0c0xpc3RlbmVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdHNMaXN0ZW5lciA9IFN0YXRzTGlzdGVuZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRzTGlzdGVuZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc3RhdHMvU3RhdHNMaXN0ZW5lci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcHBfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvYXBwXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNCA9IHJlcXVpcmUoXCIuL3V0aWwvdXRpbFwiKTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi91dGlsL1BhdGhcIik7XG52YXIgVmlzaWJpbGl0eU1vbml0b3JfMSA9IHJlcXVpcmUoXCIuL3V0aWwvVmlzaWJpbGl0eU1vbml0b3JcIik7XG52YXIgT25saW5lTW9uaXRvcl8xID0gcmVxdWlyZShcIi4vdXRpbC9PbmxpbmVNb25pdG9yXCIpO1xudmFyIHV0aWxfNSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvQ29ubmVjdGlvblwiKTtcbnZhciB1dGlsXzYgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF83ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFNlcnZlckFjdGlvbnNfMSA9IHJlcXVpcmUoXCIuL1NlcnZlckFjdGlvbnNcIik7XG52YXIgUkVDT05ORUNUX01JTl9ERUxBWSA9IDEwMDA7XG52YXIgUkVDT05ORUNUX01BWF9ERUxBWV9ERUZBVUxUID0gNjAgKiA1ICogMTAwMDsgLy8gNSBtaW51dGVzIGluIG1pbGxpc2Vjb25kcyAoQ2FzZTogMTg1OClcbnZhciBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlMgPSAzMCAqIDEwMDA7IC8vIDMwIHNlY29uZHMgZm9yIGFkbWluIGNsaWVudHMgKGxpa2VseSB0byBiZSBhIGJhY2tlbmQgc2VydmVyKVxudmFyIFJFQ09OTkVDVF9ERUxBWV9NVUxUSVBMSUVSID0gMS4zO1xudmFyIFJFQ09OTkVDVF9ERUxBWV9SRVNFVF9USU1FT1VUID0gMzAwMDA7IC8vIFJlc2V0IGRlbGF5IGJhY2sgdG8gTUlOX0RFTEFZIGFmdGVyIGJlaW5nIGNvbm5lY3RlZCBmb3IgMzBzZWMuXG52YXIgU0VSVkVSX0tJTExfSU5URVJSVVBUX1JFQVNPTiA9ICdzZXJ2ZXJfa2lsbCc7XG4vLyBJZiBhdXRoIGZhaWxzIHJlcGVhdGVkbHksIHdlJ2xsIGFzc3VtZSBzb21ldGhpbmcgaXMgd3JvbmcgYW5kIGxvZyBhIHdhcm5pbmcgLyBiYWNrIG9mZi5cbnZhciBJTlZBTElEX0FVVEhfVE9LRU5fVEhSRVNIT0xEID0gMztcbi8qKlxuICogRmlyZWJhc2UgY29ubmVjdGlvbi4gIEFic3RyYWN0cyB3aXJlIHByb3RvY29sIGFuZCBoYW5kbGVzIHJlY29ubmVjdGluZy5cbiAqXG4gKiBOT1RFOiBBbGwgSlNPTiBvYmplY3RzIHNlbnQgdG8gdGhlIHJlYWx0aW1lIGNvbm5lY3Rpb24gbXVzdCBoYXZlIHByb3BlcnR5IG5hbWVzIGVuY2xvc2VkXG4gKiBpbiBxdW90ZXMgdG8gbWFrZSBzdXJlIHRoZSBjbG9zdXJlIGNvbXBpbGVyIGRvZXMgbm90IG1pbmlmeSB0aGVtLlxuICovXG52YXIgUGVyc2lzdGVudENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlcnNpc3RlbnRDb25uZWN0aW9uLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBpbXBsZW1lbnRzIHtTZXJ2ZXJBY3Rpb25zfVxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb18gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICosIGJvb2xlYW4sID9udW1iZXIpfSBvbkRhdGFVcGRhdGVfIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSBvbkNvbm5lY3RTdGF0dXNfXG4gICAgICogQHBhcmFtIG9uU2VydmVySW5mb1VwZGF0ZV9cbiAgICAgKiBAcGFyYW0gYXV0aFRva2VuUHJvdmlkZXJfXG4gICAgICogQHBhcmFtIGF1dGhPdmVycmlkZV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQZXJzaXN0ZW50Q29ubmVjdGlvbihyZXBvSW5mb18sIG9uRGF0YVVwZGF0ZV8sIG9uQ29ubmVjdFN0YXR1c18sIG9uU2VydmVySW5mb1VwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXywgYXV0aE92ZXJyaWRlXykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XG4gICAgICAgIF90aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xuICAgICAgICBfdGhpcy5vbkNvbm5lY3RTdGF0dXNfID0gb25Db25uZWN0U3RhdHVzXztcbiAgICAgICAgX3RoaXMub25TZXJ2ZXJJbmZvVXBkYXRlXyA9IG9uU2VydmVySW5mb1VwZGF0ZV87XG4gICAgICAgIF90aGlzLmF1dGhUb2tlblByb3ZpZGVyXyA9IGF1dGhUb2tlblByb3ZpZGVyXztcbiAgICAgICAgX3RoaXMuYXV0aE92ZXJyaWRlXyA9IGF1dGhPdmVycmlkZV87XG4gICAgICAgIC8vIFVzZWQgZm9yIGRpYWdub3N0aWMgbG9nZ2luZy5cbiAgICAgICAgX3RoaXMuaWQgPSBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8rKztcbiAgICAgICAgX3RoaXMubG9nXyA9IHV0aWxfNC5sb2dXcmFwcGVyKCdwOicgKyBfdGhpcy5pZCArICc6Jyk7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7T2JqZWN0fSAqL1xuICAgICAgICBfdGhpcy5pbnRlcnJ1cHRSZWFzb25zXyA9IHt9O1xuICAgICAgICBfdGhpcy5saXN0ZW5zXyA9IHt9O1xuICAgICAgICBfdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XG4gICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfID0gMDtcbiAgICAgICAgX3RoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXyA9IFtdO1xuICAgICAgICBfdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgIF90aGlzLm1heFJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NQVhfREVMQVlfREVGQVVMVDtcbiAgICAgICAgX3RoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXyA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RTZXNzaW9uSWQgPSBudWxsO1xuICAgICAgICAvKiogQHByaXZhdGUge251bWJlcnxudWxsfSAqL1xuICAgICAgICBfdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcbiAgICAgICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgICAgICBfdGhpcy52aXNpYmxlXyA9IGZhbHNlO1xuICAgICAgICAvLyBCZWZvcmUgd2UgZ2V0IGNvbm5lY3RlZCwgd2Uga2VlcCBhIHF1ZXVlIG9mIHBlbmRpbmcgbWVzc2FnZXMgdG8gc2VuZC5cbiAgICAgICAgX3RoaXMucmVxdWVzdENCSGFzaF8gPSB7fTtcbiAgICAgICAgX3RoaXMucmVxdWVzdE51bWJlcl8gPSAwO1xuICAgICAgICAvKiogQHByaXZhdGUgez97XG4gICAgICAgICAqICAgc2VuZFJlcXVlc3QoT2JqZWN0KSxcbiAgICAgICAgICogICBjbG9zZSgpXG4gICAgICAgICAqIH19ICovXG4gICAgICAgIF90aGlzLnJlYWx0aW1lXyA9IG51bGw7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfG51bGx9ICovXG4gICAgICAgIF90aGlzLmF1dGhUb2tlbl8gPSBudWxsO1xuICAgICAgICBfdGhpcy5mb3JjZVRva2VuUmVmcmVzaF8gPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaW52YWxpZEF1dGhUb2tlbkNvdW50XyA9IDA7XG4gICAgICAgIF90aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSB0cnVlO1xuICAgICAgICBfdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG51bGw7XG4gICAgICAgIF90aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XG4gICAgICAgIGlmIChhdXRoT3ZlcnJpZGVfICYmICF1dGlsXzcuaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aCBvdmVycmlkZSBzcGVjaWZpZWQgaW4gb3B0aW9ucywgYnV0IG5vdCBzdXBwb3J0ZWQgb24gbm9uIE5vZGUuanMgcGxhdGZvcm1zJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcbiAgICAgICAgVmlzaWJpbGl0eU1vbml0b3JfMS5WaXNpYmlsaXR5TW9uaXRvci5nZXRJbnN0YW5jZSgpLm9uKCd2aXNpYmxlJywgX3RoaXMub25WaXNpYmxlXywgX3RoaXMpO1xuICAgICAgICBpZiAocmVwb0luZm9fLmhvc3QuaW5kZXhPZignZmJsb2NhbCcpID09PSAtMSkge1xuICAgICAgICAgICAgT25saW5lTW9uaXRvcl8xLk9ubGluZU1vbml0b3IuZ2V0SW5zdGFuY2UoKS5vbignb25saW5lJywgX3RoaXMub25PbmxpbmVfLCBfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGFjdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gYm9keVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKik9fSBvblJlc3BvbnNlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChhY3Rpb24sIGJvZHksIG9uUmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIGN1clJlcU51bSA9ICsrdGhpcy5yZXF1ZXN0TnVtYmVyXztcbiAgICAgICAgdmFyIG1zZyA9IHsgcjogY3VyUmVxTnVtLCBhOiBhY3Rpb24sIGI6IGJvZHkgfTtcbiAgICAgICAgdGhpcy5sb2dfKHV0aWxfMi5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIHV0aWxfMy5hc3NlcnQodGhpcy5jb25uZWN0ZWRfLCBcInNlbmRSZXF1ZXN0IGNhbGwgd2hlbiB3ZSdyZSBub3QgY29ubmVjdGVkIG5vdCBhbGxvd2VkLlwiKTtcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uc2VuZFJlcXVlc3QobXNnKTtcbiAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENCSGFzaF9bY3VyUmVxTnVtXSA9IG9uUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChxdWVyeSwgY3VycmVudEhhc2hGbiwgdGFnLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgICAgIHZhciBwYXRoU3RyaW5nID0gcXVlcnkucGF0aC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLmxvZ18oJ0xpc3RlbiBjYWxsZWQgZm9yICcgKyBwYXRoU3RyaW5nICsgJyAnICsgcXVlcnlJZCk7XG4gICAgICAgIHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ10gPSB0aGlzLmxpc3RlbnNfW3BhdGhTdHJpbmddIHx8IHt9O1xuICAgICAgICB1dGlsXzMuYXNzZXJ0KHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCkgfHxcbiAgICAgICAgICAgICFxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpLCAnbGlzdGVuKCkgY2FsbGVkIGZvciBub24tZGVmYXVsdCBidXQgY29tcGxldGUgcXVlcnknKTtcbiAgICAgICAgdXRpbF8zLmFzc2VydCghdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXSwgJ2xpc3RlbigpIGNhbGxlZCB0d2ljZSBmb3Igc2FtZSBwYXRoL3F1ZXJ5SWQuJyk7XG4gICAgICAgIHZhciBsaXN0ZW5TcGVjID0ge1xuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZSxcbiAgICAgICAgICAgIGhhc2hGbjogY3VycmVudEhhc2hGbixcbiAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgICAgICAgIHRhZzogdGFnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubGlzdGVuc19bcGF0aFN0cmluZ11bcXVlcnlJZF0gPSBsaXN0ZW5TcGVjO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyF7b25Db21wbGV0ZSgpLFxuICAgICAqICAgICAgICAgICBoYXNoRm4oKTohc3RyaW5nLFxuICAgICAqICAgICAgICAgICBxdWVyeTogIVF1ZXJ5LFxuICAgICAqICAgICAgICAgICB0YWc6ID9udW1iZXJ9fSBsaXN0ZW5TcGVjXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZExpc3Rlbl8gPSBmdW5jdGlvbiAobGlzdGVuU3BlYykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcXVlcnkgPSBsaXN0ZW5TcGVjLnF1ZXJ5O1xuICAgICAgICB2YXIgcGF0aFN0cmluZyA9IHF1ZXJ5LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIHF1ZXJ5SWQgPSBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKTtcbiAgICAgICAgdGhpcy5sb2dfKCdMaXN0ZW4gb24gJyArIHBhdGhTdHJpbmcgKyAnIGZvciAnICsgcXVlcnlJZCk7XG4gICAgICAgIHZhciByZXEgPSB7IC8qcGF0aCovIHA6IHBhdGhTdHJpbmcgfTtcbiAgICAgICAgdmFyIGFjdGlvbiA9ICdxJztcbiAgICAgICAgLy8gT25seSBib3RoZXIgdG8gc2VuZCBxdWVyeSBpZiBpdCdzIG5vbi1kZWZhdWx0LlxuICAgICAgICBpZiAobGlzdGVuU3BlYy50YWcpIHtcbiAgICAgICAgICAgIHJlcVsncSddID0gcXVlcnkucXVlcnlPYmplY3QoKTtcbiAgICAgICAgICAgIHJlcVsndCddID0gbGlzdGVuU3BlYy50YWc7XG4gICAgICAgIH1cbiAgICAgICAgcmVxWydoJ10gPSBsaXN0ZW5TcGVjLmhhc2hGbigpO1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGFjdGlvbiwgcmVxLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBtZXNzYWdlWydkJ107XG4gICAgICAgICAgICB2YXIgc3RhdHVzID0gbWVzc2FnZVsncyddO1xuICAgICAgICAgICAgLy8gcHJpbnQgd2FybmluZ3MgaW4gYW55IGNhc2UuLi5cbiAgICAgICAgICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyhwYXlsb2FkLCBxdWVyeSk7XG4gICAgICAgICAgICB2YXIgY3VycmVudExpc3RlblNwZWMgPSBfdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXSAmJiBfdGhpcy5saXN0ZW5zX1twYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJpZ2dlciBhY3Rpb25zIGlmIHRoZSBsaXN0ZW4gaGFzbid0IGJlZW4gcmVtb3ZlZCBhbmQgcmVhZGRlZFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaXN0ZW5TcGVjID09PSBsaXN0ZW5TcGVjKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnbGlzdGVuIHJlc3BvbnNlJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuU3BlYy5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlblNwZWMub25Db21wbGV0ZShzdGF0dXMsIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyp9IHBheWxvYWRcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLndhcm5Pbkxpc3Rlbldhcm5pbmdzXyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBxdWVyeSkge1xuICAgICAgICBpZiAocGF5bG9hZCAmJiB0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgdXRpbF8xLmNvbnRhaW5zKHBheWxvYWQsICd3JykpIHtcbiAgICAgICAgICAgIHZhciB3YXJuaW5ncyA9IHV0aWxfMS5zYWZlR2V0KHBheWxvYWQsICd3Jyk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3YXJuaW5ncykgJiYgfndhcm5pbmdzLmluZGV4T2YoJ25vX2luZGV4JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhTcGVjID0gJ1wiLmluZGV4T25cIjogXCInICtcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRRdWVyeVBhcmFtcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW5kZXgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAnXCInO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleFBhdGggPSBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdXRpbF80Lndhcm4oXCJVc2luZyBhbiB1bnNwZWNpZmllZCBpbmRleC4gWW91ciBkYXRhIHdpbGwgYmUgZG93bmxvYWRlZCBhbmQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJmaWx0ZXJlZCBvbiB0aGUgY2xpZW50LiBDb25zaWRlciBhZGRpbmcgXCIgKyBpbmRleFNwZWMgKyBcIiBhdCBcIikgK1xuICAgICAgICAgICAgICAgICAgICAoaW5kZXhQYXRoICsgXCIgdG8geW91ciBzZWN1cml0eSBydWxlcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlZnJlc2hBdXRoVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5fID0gdG9rZW47XG4gICAgICAgIHRoaXMubG9nXygnQXV0aCB0b2tlbiByZWZyZXNoZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0aFRva2VuXykge1xuICAgICAgICAgICAgdGhpcy50cnlBdXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL0lmIHdlJ3JlIGNvbm5lY3RlZCB3ZSB3YW50IHRvIGxldCB0aGUgc2VydmVyIGtub3cgdG8gdW5hdXRoZW50aWNhdGUgdXMuIElmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIHNpbXBseSBkZWxldGVcbiAgICAgICAgICAgIC8vdGhlIGNyZWRlbnRpYWwgc28gd2UgZG9udCBiZWNvbWUgYXV0aGVudGljYXRlZCBuZXh0IHRpbWUgd2UgY29ubmVjdC5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KCd1bmF1dGgnLCB7fSwgZnVuY3Rpb24gKCkgeyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVJlY29ubmVjdERlbGF5SWZBZG1pbkNyZWRlbnRpYWxfKHRva2VuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gY3JlZGVudGlhbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlZHVjZVJlY29ubmVjdERlbGF5SWZBZG1pbkNyZWRlbnRpYWxfID0gZnVuY3Rpb24gKGNyZWRlbnRpYWwpIHtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpc24ndCBpbnRlbmRlZCB0byBiZSBidWxsZXRwcm9vZiAoYSBtYWxpY2lvdXMgZGV2ZWxvcGVyIGNhbiBhbHdheXMganVzdCBtb2RpZnkgdGhlIGNsaWVudCkuXG4gICAgICAgIC8vIEFkZGl0aW9uYWxseSwgd2UgZG9uJ3QgYm90aGVyIHJlc2V0dGluZyB0aGUgbWF4IGRlbGF5IGJhY2sgdG8gdGhlIGRlZmF1bHQgaWYgYXV0aCBmYWlscyAvIGV4cGlyZXMuXG4gICAgICAgIHZhciBpc0ZpcmViYXNlU2VjcmV0ID0gY3JlZGVudGlhbCAmJiBjcmVkZW50aWFsLmxlbmd0aCA9PT0gNDA7XG4gICAgICAgIGlmIChpc0ZpcmViYXNlU2VjcmV0IHx8IHV0aWxfNS5pc0FkbWluKGNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0FkbWluIGF1dGggY3JlZGVudGlhbCBkZXRlY3RlZC4gIFJlZHVjaW5nIG1heCByZWNvbm5lY3QgdGltZS4nKTtcbiAgICAgICAgICAgIHRoaXMubWF4UmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01BWF9ERUxBWV9GT1JfQURNSU5TO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBhdXRoZW50aWNhdGUgd2l0aCB0aGUgZ2l2ZW4gY3JlZGVudGlhbHMuIElmIHRoZSBhdXRoZW50aWNhdGlvbiBhdHRlbXB0IGZhaWxzLCBpdCdzIHRyaWdnZXJlZCBsaWtlXG4gICAgICogYSBhdXRoIHJldm9rZWQgKHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCkuXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnRyeUF1dGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8gJiYgdGhpcy5hdXRoVG9rZW5fKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW5fMSA9IHRoaXMuYXV0aFRva2VuXztcbiAgICAgICAgICAgIHZhciBhdXRoTWV0aG9kID0gdXRpbF81LmlzVmFsaWRGb3JtYXQodG9rZW5fMSkgPyAnYXV0aCcgOiAnZ2F1dGgnO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3REYXRhID0geyBjcmVkOiB0b2tlbl8xIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRoT3ZlcnJpZGVfID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ25vYXV0aCddID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmF1dGhPdmVycmlkZV8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGFbJ2F1dGh2YXInXSA9IHRoaXMuYXV0aE92ZXJyaWRlXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYXV0aE1ldGhvZCwgcmVxdWVzdERhdGEsIGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gcmVzWydzJ107XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSByZXNbJ2QnXSB8fCAnZXJyb3InO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5hdXRoVG9rZW5fID09PSB0b2tlbl8xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmludmFsaWRBdXRoVG9rZW5Db3VudF8gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlcnMgcmVjb25uZWN0IGFuZCBmb3JjZSByZWZyZXNoIGZvciBhdXRoIHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkF1dGhSZXZva2VkXyhzdGF0dXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnVubGlzdGVuID0gZnVuY3Rpb24gKHF1ZXJ5LCB0YWcpIHtcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBxdWVyeUlkID0gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG4gICAgICAgIHRoaXMubG9nXygnVW5saXN0ZW4gY2FsbGVkIGZvciAnICsgcGF0aFN0cmluZyArICcgJyArIHF1ZXJ5SWQpO1xuICAgICAgICB1dGlsXzMuYXNzZXJ0KHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCkgfHxcbiAgICAgICAgICAgICFxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpLCAndW5saXN0ZW4oKSBjYWxsZWQgZm9yIG5vbi1kZWZhdWx0IGJ1dCBjb21wbGV0ZSBxdWVyeScpO1xuICAgICAgICB2YXIgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICBpZiAobGlzdGVuICYmIHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kVW5saXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5LnF1ZXJ5T2JqZWN0KCksIHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kVW5saXN0ZW5fID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIHF1ZXJ5SWQsIHF1ZXJ5T2JqLCB0YWcpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdVbmxpc3RlbiBvbiAnICsgcGF0aFN0cmluZyArICcgZm9yICcgKyBxdWVyeUlkKTtcbiAgICAgICAgdmFyIHJlcSA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZyB9O1xuICAgICAgICB2YXIgYWN0aW9uID0gJ24nO1xuICAgICAgICAvLyBPbmx5IGJvdGhlciBzZW5kaW5nIHF1ZXJ5SWQgaWYgaXQncyBub24tZGVmYXVsdC5cbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgcmVxWydxJ10gPSBxdWVyeU9iajtcbiAgICAgICAgICAgIHJlcVsndCddID0gdGFnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFJlcXVlc3QoYWN0aW9uLCByZXEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EaXNjb25uZWN0UHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0XygnbycsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnbycsXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EaXNjb25uZWN0TWVyZ2UgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRPbkRpc2Nvbm5lY3RfKCdvbScsIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RSZXF1ZXN0UXVldWVfLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGhTdHJpbmc6IHBhdGhTdHJpbmcsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiAnb20nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uRGlzY29ubmVjdENhbmNlbCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBvbkNvbXBsZXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE9uRGlzY29ubmVjdF8oJ29jJywgcGF0aFN0cmluZywgbnVsbCwgb25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZzogcGF0aFN0cmluZyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICdvYycsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRPbkRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKGFjdGlvbiwgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHsgLypwYXRoKi8gcDogcGF0aFN0cmluZywgLypkYXRhKi8gZDogZGF0YSB9O1xuICAgICAgICB0aGlzLmxvZ18oJ29uRGlzY29ubmVjdCAnICsgYWN0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShyZXNwb25zZVsncyddLCByZXNwb25zZVsnZCddKTtcbiAgICAgICAgICAgICAgICB9LCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCkge1xuICAgICAgICB0aGlzLnB1dEludGVybmFsKCdwJywgcGF0aFN0cmluZywgZGF0YSwgb25Db21wbGV0ZSwgaGFzaCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKSB7XG4gICAgICAgIHRoaXMucHV0SW50ZXJuYWwoJ20nLCBwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlLCBoYXNoKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXRJbnRlcm5hbCA9IGZ1bmN0aW9uIChhY3Rpb24sIHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICAvKnBhdGgqLyBwOiBwYXRoU3RyaW5nLFxuICAgICAgICAgICAgLypkYXRhKi8gZDogZGF0YVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmVxdWVzdFsnaCddID0gaGFzaDtcbiAgICAgICAgLy8gVE9ETzogT25seSBrZWVwIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCBwdXQgZm9yIGEgZ2l2ZW4gcGF0aD9cbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dHNfLnB1c2goe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgb25Db21wbGV0ZTogb25Db21wbGV0ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XysrO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm91dHN0YW5kaW5nUHV0c18ubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kUHV0XyhpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0J1ZmZlcmluZyBwdXQ6ICcgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRQdXRfID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLmFjdGlvbjtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnJlcXVlc3Q7XG4gICAgICAgIHZhciBvbkNvbXBsZXRlID0gdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XS5vbkNvbXBsZXRlO1xuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0c19baW5kZXhdLnF1ZXVlZCA9IHRoaXMuY29ubmVjdGVkXztcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChhY3Rpb24sIHJlcXVlc3QsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKGFjdGlvbiArICcgcmVzcG9uc2UnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5vdXRzdGFuZGluZ1B1dHNfW2luZGV4XTtcbiAgICAgICAgICAgIF90aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBhcnJheSBvY2Nhc2lvbmFsbHkuXG4gICAgICAgICAgICBpZiAoX3RoaXMub3V0c3RhbmRpbmdQdXRDb3VudF8gPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vdXRzdGFuZGluZ1B1dHNfID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSlcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKG1lc3NhZ2VbJ3MnXSwgbWVzc2FnZVsnZCddKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXBvcnRTdGF0cyA9IGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY29ubmVjdGVkLCB3ZSBqdXN0IGRyb3AgdGhlIHN0YXRzLlxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRfKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHsgLypjb3VudGVycyovIGM6IHN0YXRzIH07XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3JlcG9ydFN0YXRzJywgcmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KC8qc3RhdHMqLyAncycsIHJlcXVlc3QsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gcmVzdWx0WydzJ107XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gJ29rJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3JSZWFzb24gPSByZXN1bHRbJ2QnXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygncmVwb3J0U3RhdHMnLCAnRXJyb3Igc2VuZGluZyBzdGF0czogJyArIGVycm9yUmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25EYXRhTWVzc2FnZV8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoJ3InIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5sb2dfKCdmcm9tIHNlcnZlcjogJyArIHV0aWxfMi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIHJlcU51bSA9IG1lc3NhZ2VbJ3InXTtcbiAgICAgICAgICAgIHZhciBvblJlc3BvbnNlID0gdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xuICAgICAgICAgICAgaWYgKG9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0Q0JIYXNoX1tyZXFOdW1dO1xuICAgICAgICAgICAgICAgIG9uUmVzcG9uc2UobWVzc2FnZVsnYiddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnZXJyb3InIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93ICdBIHNlcnZlci1zaWRlIGVycm9yIGhhcyBvY2N1cnJlZDogJyArIG1lc3NhZ2VbJ2Vycm9yJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2EnIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIGEgYW5kIGIgYXJlIGFjdGlvbiBhbmQgYm9keSwgcmVzcGVjdGl2ZWx5XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVB1c2hfKG1lc3NhZ2VbJ2EnXSwgbWVzc2FnZVsnYiddKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uRGF0YVB1c2hfID0gZnVuY3Rpb24gKGFjdGlvbiwgYm9keSkge1xuICAgICAgICB0aGlzLmxvZ18oJ2hhbmRsZVNlcnZlck1lc3NhZ2UnLCBhY3Rpb24sIGJvZHkpO1xuICAgICAgICBpZiAoYWN0aW9uID09PSAnZCcpXG4gICAgICAgICAgICB0aGlzLm9uRGF0YVVwZGF0ZV8oYm9keVsncCddLCBib2R5WydkJ10sIFxuICAgICAgICAgICAgLyppc01lcmdlKi8gZmFsc2UsIGJvZHlbJ3QnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ20nKVxuICAgICAgICAgICAgdGhpcy5vbkRhdGFVcGRhdGVfKGJvZHlbJ3AnXSwgYm9keVsnZCddLCBcbiAgICAgICAgICAgIC8qaXNNZXJnZT0qLyB0cnVlLCBib2R5Wyd0J10pO1xuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdjJylcbiAgICAgICAgICAgIHRoaXMub25MaXN0ZW5SZXZva2VkXyhib2R5WydwJ10sIGJvZHlbJ3EnXSk7XG4gICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gJ2FjJylcbiAgICAgICAgICAgIHRoaXMub25BdXRoUmV2b2tlZF8oYm9keVsncyddLCBib2R5WydkJ10pO1xuICAgICAgICBlbHNlIGlmIChhY3Rpb24gPT09ICdzZCcpXG4gICAgICAgICAgICB0aGlzLm9uU2VjdXJpdHlEZWJ1Z1BhY2tldF8oYm9keSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHV0aWxfNC5lcnJvcignVW5yZWNvZ25pemVkIGFjdGlvbiByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArXG4gICAgICAgICAgICAgICAgdXRpbF8yLnN0cmluZ2lmeShhY3Rpb24pICtcbiAgICAgICAgICAgICAgICAnXFxuQXJlIHlvdSB1c2luZyB0aGUgbGF0ZXN0IGNsaWVudD8nKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblJlYWR5XyA9IGZ1bmN0aW9uICh0aW1lc3RhbXAsIHNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmxvZ18oJ2Nvbm5lY3Rpb24gcmVhZHknKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVUaW1lc3RhbXBfKHRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDb25uZWN0aW9uXykge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ29ubmVjdFN0YXRzXygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdG9yZVN0YXRlXygpO1xuICAgICAgICB0aGlzLmZpcnN0Q29ubmVjdGlvbl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKHRydWUpO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlQ29ubmVjdF8gPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB1dGlsXzMuYXNzZXJ0KCF0aGlzLnJlYWx0aW1lXywgXCJTY2hlZHVsaW5nIGEgY29ubmVjdCB3aGVuIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkL2luZz9cIik7XG4gICAgICAgIGlmICh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVzdGFibGlzaENvbm5lY3Rpb25UaW1lcl8pO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVEU6IEV2ZW4gd2hlbiB0aW1lb3V0IGlzIDAsIGl0J3MgaW1wb3J0YW50IHRvIGRvIGEgc2V0VGltZW91dCB0byB3b3JrIGFyb3VuZCBhbiBpbmZ1cmlhdGluZyBcIlNlY3VyaXR5IEVycm9yXCIgaW5cbiAgICAgICAgLy8gRmlyZWZveCB3aGVuIHRyeWluZyB0byB3cml0ZSB0byBvdXIgbG9uZy1wb2xsaW5nIGlmcmFtZSBpbiBzb21lIHNjZW5hcmlvcyAoZS5nLiBGb3JnZSBvciBvdXIgdW5pdCB0ZXN0cykuXG4gICAgICAgIHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uXygpO1xuICAgICAgICB9LCBNYXRoLmZsb29yKHRpbWVvdXQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uVmlzaWJsZV8gPSBmdW5jdGlvbiAodmlzaWJsZSkge1xuICAgICAgICAvLyBOT1RFOiBUYWJiaW5nIGF3YXkgYW5kIGJhY2sgdG8gYSB3aW5kb3cgd2lsbCBkZWZlYXQgb3VyIHJlY29ubmVjdCBiYWNrb2ZmLCBidXQgSSB0aGluayB0aGF0J3MgZmluZS5cbiAgICAgICAgaWYgKHZpc2libGUgJiZcbiAgICAgICAgICAgICF0aGlzLnZpc2libGVfICYmXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9PT0gdGhpcy5tYXhSZWNvbm5lY3REZWxheV8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2luZG93IGJlY2FtZSB2aXNpYmxlLiAgUmVkdWNpbmcgZGVsYXkuJyk7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZV8gPSB2aXNpYmxlO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uT25saW5lXyA9IGZ1bmN0aW9uIChvbmxpbmUpIHtcbiAgICAgICAgaWYgKG9ubGluZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdCcm93c2VyIHdlbnQgb25saW5lLicpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUlOX0RFTEFZO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWx0aW1lXykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVDb25uZWN0XygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnQnJvd3NlciB3ZW50IG9mZmxpbmUuICBLaWxsaW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lXy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUub25SZWFsdGltZURpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmxvZ18oJ2RhdGEgY2xpZW50IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFsdGltZV8gPSBudWxsO1xuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrbm93IGlmIG91ciBzZW50IHRyYW5zYWN0aW9ucyBzdWNjZWVkZWQgb3Igbm90LCB3ZSBuZWVkIHRvIGNhbmNlbCB0aGVtLlxuICAgICAgICB0aGlzLmNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfKCk7XG4gICAgICAgIC8vIENsZWFyIG91dCB0aGUgcGVuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgdGhpcy5yZXF1ZXN0Q0JIYXNoXyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5zaG91bGRSZWNvbm5lY3RfKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy52aXNpYmxlXykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nXyhcIldpbmRvdyBpc24ndCB2aXNpYmxlLiAgRGVsYXlpbmcgcmVjb25uZWN0LlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IHRoaXMubWF4UmVjb25uZWN0RGVsYXlfO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdENvbm5lY3Rpb25BdHRlbXB0VGltZV8gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGFzdENvbm5lY3Rpb25Fc3RhYmxpc2hlZFRpbWVfKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBjb25uZWN0ZWQgbG9uZyBlbm91Z2gsIHJlc2V0IHJlY29ubmVjdCBkZWxheSB0byBtaW5pbXVtLlxuICAgICAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q29ubmVjdFN1Y2NlZWRlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV87XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDb25uZWN0U3VjY2VlZGVkID4gUkVDT05ORUNUX0RFTEFZX1JFU0VUX1RJTUVPVVQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0RGVsYXlfID0gUkVDT05ORUNUX01JTl9ERUxBWTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb25uZWN0aW9uRXN0YWJsaXNoZWRUaW1lXyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENvbm5lY3RBdHRlbXB0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLmxhc3RDb25uZWN0aW9uQXR0ZW1wdFRpbWVfO1xuICAgICAgICAgICAgdmFyIHJlY29ubmVjdERlbGF5ID0gTWF0aC5tYXgoMCwgdGhpcy5yZWNvbm5lY3REZWxheV8gLSB0aW1lU2luY2VMYXN0Q29ubmVjdEF0dGVtcHQpO1xuICAgICAgICAgICAgcmVjb25uZWN0RGVsYXkgPSBNYXRoLnJhbmRvbSgpICogcmVjb25uZWN0RGVsYXk7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1RyeWluZyB0byByZWNvbm5lY3QgaW4gJyArIHJlY29ubmVjdERlbGF5ICsgJ21zJyk7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlQ29ubmVjdF8ocmVjb25uZWN0RGVsYXkpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IHJlY29ubmVjdCBkZWxheSBmb3IgbmV4dCB0aW1lLlxuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBNYXRoLm1pbih0aGlzLm1heFJlY29ubmVjdERlbGF5XywgdGhpcy5yZWNvbm5lY3REZWxheV8gKiBSRUNPTk5FQ1RfREVMQVlfTVVMVElQTElFUik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNvbm5lY3RTdGF0dXNfKGZhbHNlKTtcbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5lc3RhYmxpc2hDb25uZWN0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkUmVjb25uZWN0XygpKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ01ha2luZyBhIGNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkF0dGVtcHRUaW1lXyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29ubmVjdGlvbkVzdGFibGlzaGVkVGltZV8gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG9uRGF0YU1lc3NhZ2VfMSA9IHRoaXMub25EYXRhTWVzc2FnZV8uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBvblJlYWR5XzEgPSB0aGlzLm9uUmVhZHlfLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB2YXIgb25EaXNjb25uZWN0XzEgPSB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0Xy5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdmFyIGNvbm5JZF8xID0gdGhpcy5pZCArICc6JyArIFBlcnNpc3RlbnRDb25uZWN0aW9uLm5leHRDb25uZWN0aW9uSWRfKys7XG4gICAgICAgICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsYXN0U2Vzc2lvbklkXzEgPSB0aGlzLmxhc3RTZXNzaW9uSWQ7XG4gICAgICAgICAgICB2YXIgY2FuY2VsZWRfMSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25fMSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY2xvc2VGbl8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl8xLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxlZF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25EaXNjb25uZWN0XzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNlbmRSZXF1ZXN0Rm4gPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8zLmFzc2VydChjb25uZWN0aW9uXzEsIFwic2VuZFJlcXVlc3QgY2FsbCB3aGVuIHdlJ3JlIG5vdCBjb25uZWN0ZWQgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25fMS5zZW5kUmVxdWVzdChtc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfID0ge1xuICAgICAgICAgICAgICAgIGNsb3NlOiBjbG9zZUZuXzEsXG4gICAgICAgICAgICAgICAgc2VuZFJlcXVlc3Q6IHNlbmRSZXF1ZXN0Rm5cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZm9yY2VSZWZyZXNoID0gdGhpcy5mb3JjZVRva2VuUmVmcmVzaF87XG4gICAgICAgICAgICB0aGlzLmZvcmNlVG9rZW5SZWZyZXNoXyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRmlyc3QgZmV0Y2ggYXV0aCB0b2tlbiwgYW5kIGVzdGFibGlzaCBjb25uZWN0aW9uIGFmdGVyIGZldGNoaW5nIHRoZSB0b2tlbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl9cbiAgICAgICAgICAgICAgICAuZ2V0VG9rZW4oZm9yY2VSZWZyZXNoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbF80LmxvZygnZ2V0VG9rZW4oKSBjb21wbGV0ZWQuIENyZWF0aW5nIGNvbm5lY3Rpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfMS5hdXRoVG9rZW5fID0gcmVzdWx0ICYmIHJlc3VsdC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbl8xID0gbmV3IENvbm5lY3Rpb25fMS5Db25uZWN0aW9uKGNvbm5JZF8xLCBzZWxmXzEucmVwb0luZm9fLCBvbkRhdGFNZXNzYWdlXzEsIG9uUmVhZHlfMSwgb25EaXNjb25uZWN0XzEsIFxuICAgICAgICAgICAgICAgICAgICAvKiBvbktpbGw9ICovIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfNC53YXJuKHJlYXNvbiArICcgKCcgKyBzZWxmXzEucmVwb0luZm9fLnRvU3RyaW5nKCkgKyAnKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZl8xLmludGVycnVwdChTRVJWRVJfS0lMTF9JTlRFUlJVUFRfUkVBU09OKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgbGFzdFNlc3Npb25JZF8xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfNC5sb2coJ2dldFRva2VuKCkgY29tcGxldGVkIGJ1dCB3YXMgY2FuY2VsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNlbGZfMS5sb2dfKCdGYWlsZWQgdG8gZ2V0IHRva2VuOiAnICsgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWRfMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXRpbF82LkNPTlNUQU5UUy5OT0RFX0FETUlOKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSBhIGNyaXRpY2FsIGVycm9yIGZvciB0aGUgQWRtaW4gTm9kZS5qcyBTREssIHNvIGxvZyBhIHdhcm5pbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZ2V0VG9rZW4oKSBtYXkgYWxzbyBqdXN0IGhhdmUgdGVtcG9yYXJpbHkgZmFpbGVkLCBzbyB3ZSBzdGlsbCB3YW50IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZSByZXRyeWluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfNC53YXJuKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbG9zZUZuXzEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgICAqL1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHV0aWxfNC5sb2coJ0ludGVycnVwdGluZyBjb25uZWN0aW9uIGZvciByZWFzb246ICcgKyByZWFzb24pO1xuICAgICAgICB0aGlzLmludGVycnVwdFJlYXNvbnNfW3JlYXNvbl0gPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5yZWFsdGltZV8pIHtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWVfLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZXN0YWJsaXNoQ29ubmVjdGlvblRpbWVyXyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lc3RhYmxpc2hDb25uZWN0aW9uVGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVhbHRpbWVEaXNjb25uZWN0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdXRpbF80LmxvZygnUmVzdW1pbmcgY29ubmVjdGlvbiBmb3IgcmVhc29uOiAnICsgcmVhc29uKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaW50ZXJydXB0UmVhc29uc19bcmVhc29uXTtcbiAgICAgICAgaWYgKHV0aWxfMS5pc0VtcHR5KHRoaXMuaW50ZXJydXB0UmVhc29uc18pKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdERlbGF5XyA9IFJFQ09OTkVDVF9NSU5fREVMQVk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVhbHRpbWVfKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUNvbm5lY3RfKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlVGltZXN0YW1wXyA9IGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgdmFyIGRlbHRhID0gdGltZXN0YW1wIC0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMub25TZXJ2ZXJJbmZvVXBkYXRlXyh7IHNlcnZlclRpbWVPZmZzZXQ6IGRlbHRhIH0pO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLmNhbmNlbFNlbnRUcmFuc2FjdGlvbnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHB1dCA9IHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcbiAgICAgICAgICAgIGlmIChwdXQgJiYgLypoYXNoKi8gJ2gnIGluIHB1dC5yZXF1ZXN0ICYmIHB1dC5xdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAocHV0Lm9uQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgICAgIHB1dC5vbkNvbXBsZXRlKCdkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUHV0Q291bnRfLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW4gdXAgYXJyYXkgb2NjYXNpb25hbGx5LlxuICAgICAgICBpZiAodGhpcy5vdXRzdGFuZGluZ1B1dENvdW50XyA9PT0gMClcbiAgICAgICAgICAgIHRoaXMub3V0c3RhbmRpbmdQdXRzXyA9IFtdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHtBcnJheS48Kj49fSBxdWVyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uTGlzdGVuUmV2b2tlZF8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcnkpIHtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBsaXN0ZW4gYW5kIG1hbnVmYWN0dXJlIGEgXCJwZXJtaXNzaW9uX2RlbmllZFwiIGVycm9yIGZvciB0aGUgZmFpbGVkIGxpc3Rlbi5cbiAgICAgICAgdmFyIHF1ZXJ5SWQ7XG4gICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5SWQgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBxdWVyeUlkID0gcXVlcnkubWFwKGZ1bmN0aW9uIChxKSB7IHJldHVybiB1dGlsXzQuT2JqZWN0VG9VbmlxdWVLZXkocSk7IH0pLmpvaW4oJyQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuID0gdGhpcy5yZW1vdmVMaXN0ZW5fKHBhdGhTdHJpbmcsIHF1ZXJ5SWQpO1xuICAgICAgICBpZiAobGlzdGVuICYmIGxpc3Rlbi5vbkNvbXBsZXRlKVxuICAgICAgICAgICAgbGlzdGVuLm9uQ29tcGxldGUoJ3Blcm1pc3Npb25fZGVuaWVkJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHF1ZXJ5SWRcbiAgICAgKiBAcmV0dXJuIHt7cXVlcmllczpBcnJheS48UXVlcnk+LCBvbkNvbXBsZXRlOmZ1bmN0aW9uKHN0cmluZyl9fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZUxpc3Rlbl8gPSBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcnlJZCkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFBhdGhTdHJpbmcgPSBuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZykudG9TdHJpbmcoKTsgLy8gbm9ybWFsaXplIHBhdGguXG4gICAgICAgIHZhciBsaXN0ZW47XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW4gPSB0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW25vcm1hbGl6ZWRQYXRoU3RyaW5nXVtxdWVyeUlkXTtcbiAgICAgICAgICAgIGlmICh1dGlsXzEuZ2V0Q291bnQodGhpcy5saXN0ZW5zX1tub3JtYWxpemVkUGF0aFN0cmluZ10pID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuc19bbm9ybWFsaXplZFBhdGhTdHJpbmddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWxsIGxpc3RlbnMgZm9yIHRoaXMgcGF0aCBoYXMgYWxyZWFkeSBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGxpc3RlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdGVuO1xuICAgIH07XG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQXV0aFJldm9rZWRfID0gZnVuY3Rpb24gKHN0YXR1c0NvZGUsIGV4cGxhbmF0aW9uKSB7XG4gICAgICAgIHV0aWxfNC5sb2coJ0F1dGggdG9rZW4gcmV2b2tlZDogJyArIHN0YXR1c0NvZGUgKyAnLycgKyBleHBsYW5hdGlvbik7XG4gICAgICAgIHRoaXMuYXV0aFRva2VuXyA9IG51bGw7XG4gICAgICAgIHRoaXMuZm9yY2VUb2tlblJlZnJlc2hfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFsdGltZV8uY2xvc2UoKTtcbiAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09ICdpbnZhbGlkX3Rva2VuJyB8fCBzdGF0dXNDb2RlID09PSAncGVybWlzc2lvbl9kZW5pZWQnKSB7XG4gICAgICAgICAgICAvLyBXZSdsbCB3YWl0IGEgY291cGxlIHRpbWVzIGJlZm9yZSBsb2dnaW5nIHRoZSB3YXJuaW5nIC8gaW5jcmVhc2luZyB0aGVcbiAgICAgICAgICAgIC8vIHJldHJ5IHBlcmlvZCBzaW5jZSBvYXV0aCB0b2tlbnMgd2lsbCByZXBvcnQgYXMgXCJpbnZhbGlkXCIgaWYgdGhleSdyZVxuICAgICAgICAgICAgLy8ganVzdCBleHBpcmVkLiBQbHVzIHRoZXJlIG1heSBiZSB0cmFuc2llbnQgaXNzdWVzIHRoYXQgcmVzb2x2ZSB0aGVtc2VsdmVzLlxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfKys7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnZhbGlkQXV0aFRva2VuQ291bnRfID49IElOVkFMSURfQVVUSF9UT0tFTl9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgYSBsb25nIHJlY29ubmVjdCBkZWxheSBiZWNhdXNlIHJlY292ZXJ5IGlzIHVubGlrZWx5XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3REZWxheV8gPSBSRUNPTk5FQ1RfTUFYX0RFTEFZX0ZPUl9BRE1JTlM7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IHRoZSBhdXRoIHRva2VuIHByb3ZpZGVyIHRoYXQgdGhlIHRva2VuIGlzIGludmFsaWQsIHdoaWNoIHdpbGwgbG9nXG4gICAgICAgICAgICAgICAgLy8gYSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8ubm90aWZ5Rm9ySW52YWxpZFRva2VuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5vblNlY3VyaXR5RGVidWdQYWNrZXRfID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VjdXJpdHlEZWJ1Z0NhbGxiYWNrXykge1xuICAgICAgICAgICAgdGhpcy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfKGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCdtc2cnIGluIGJvZHkgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZJUkVCQVNFOiAnICsgYm9keVsnbXNnJ10ucmVwbGFjZSgnXFxuJywgJ1xcbkZJUkVCQVNFOiAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5yZXN0b3JlU3RhdGVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL1JlLWF1dGhlbnRpY2F0ZSBvdXJzZWx2ZXMgaWYgd2UgaGF2ZSBhIGNyZWRlbnRpYWwgc3RvcmVkLlxuICAgICAgICB0aGlzLnRyeUF1dGgoKTtcbiAgICAgICAgLy8gUHV0cyBkZXBlbmQgb24gaGF2aW5nIHJlY2VpdmVkIHRoZSBjb3JyZXNwb25kaW5nIGRhdGEgdXBkYXRlIGZyb20gdGhlIHNlcnZlciBiZWZvcmUgdGhleSBjb21wbGV0ZSwgc28gd2UgbXVzdFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gc2VuZCBsaXN0ZW5zIGJlZm9yZSBwdXRzLlxuICAgICAgICB1dGlsXzEuZm9yRWFjaCh0aGlzLmxpc3RlbnNfLCBmdW5jdGlvbiAocGF0aFN0cmluZywgcXVlcmllcykge1xuICAgICAgICAgICAgdXRpbF8xLmZvckVhY2gocXVlcmllcywgZnVuY3Rpb24gKGtleSwgbGlzdGVuU3BlYykge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRMaXN0ZW5fKGxpc3RlblNwZWMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0c3RhbmRpbmdQdXRzXy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0c3RhbmRpbmdQdXRzX1tpXSlcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRQdXRfKGkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLm9uRGlzY29ubmVjdFJlcXVlc3RRdWV1ZV8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMub25EaXNjb25uZWN0UmVxdWVzdFF1ZXVlXy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5zZW5kT25EaXNjb25uZWN0XyhyZXF1ZXN0LmFjdGlvbiwgcmVxdWVzdC5wYXRoU3RyaW5nLCByZXF1ZXN0LmRhdGEsIHJlcXVlc3Qub25Db21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmRzIGNsaWVudCBzdGF0cyBmb3IgZmlyc3QgY29ubmVjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRDb25uZWN0U3RhdHNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdHMgPSB7fTtcbiAgICAgICAgdmFyIGNsaWVudE5hbWUgPSAnanMnO1xuICAgICAgICBpZiAodXRpbF82LkNPTlNUQU5UUy5OT0RFX0FETUlOKSB7XG4gICAgICAgICAgICBjbGllbnROYW1lID0gJ2FkbWluX25vZGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxfNi5DT05TVEFOVFMuTk9ERV9DTElFTlQpIHtcbiAgICAgICAgICAgIGNsaWVudE5hbWUgPSAnbm9kZSc7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdHNbJ3Nkay4nICsgY2xpZW50TmFtZSArICcuJyArIGFwcF8xLmRlZmF1bHQuU0RLX1ZFUlNJT04ucmVwbGFjZSgvXFwuL2csICctJyldID0gMTtcbiAgICAgICAgaWYgKHV0aWxfNy5pc01vYmlsZUNvcmRvdmEoKSkge1xuICAgICAgICAgICAgc3RhdHNbJ2ZyYW1ld29yay5jb3Jkb3ZhJ10gPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHV0aWxfNy5pc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIHN0YXRzWydmcmFtZXdvcmsucmVhY3RuYXRpdmUnXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBvcnRTdGF0cyhzdGF0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnNob3VsZFJlY29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvbmxpbmUgPSBPbmxpbmVNb25pdG9yXzEuT25saW5lTW9uaXRvci5nZXRJbnN0YW5jZSgpLmN1cnJlbnRseU9ubGluZSgpO1xuICAgICAgICByZXR1cm4gdXRpbF8xLmlzRW1wdHkodGhpcy5pbnRlcnJ1cHRSZWFzb25zXykgJiYgb25saW5lO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0UGVyc2lzdGVudENvbm5lY3Rpb25JZF8gPSAwO1xuICAgIC8qKlxuICAgICAqIENvdW50ZXIgZm9yIG51bWJlciBvZiBjb25uZWN0aW9ucyBjcmVhdGVkLiBNYWlubHkgdXNlZCBmb3IgdGFnZ2luZyBpbiB0aGUgbG9nc1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbi5uZXh0Q29ubmVjdGlvbklkXyA9IDA7XG4gICAgcmV0dXJuIFBlcnNpc3RlbnRDb25uZWN0aW9uO1xufShTZXJ2ZXJBY3Rpb25zXzEuU2VydmVyQWN0aW9ucykpO1xuZXhwb3J0cy5QZXJzaXN0ZW50Q29ubmVjdGlvbiA9IFBlcnNpc3RlbnRDb25uZWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJzaXN0ZW50Q29ubmVjdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9QZXJzaXN0ZW50Q29ubmVjdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGJlIHVzZWQgaWYgeW91IHdhbnQgdG8gZW1pdCBldmVudHMuIENhbGwgdGhlIGNvbnN0cnVjdG9yIHdpdGhcbiAqIHRoZSBzZXQgb2YgYWxsb3dlZCBldmVudCBuYW1lcy5cbiAqL1xudmFyIEV2ZW50RW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFBcnJheS48c3RyaW5nPn0gYWxsb3dlZEV2ZW50c19cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoYWxsb3dlZEV2ZW50c18pIHtcbiAgICAgICAgdGhpcy5hbGxvd2VkRXZlbnRzXyA9IGFsbG93ZWRFdmVudHNfO1xuICAgICAgICB0aGlzLmxpc3RlbmVyc18gPSB7fTtcbiAgICAgICAgdXRpbF8xLmFzc2VydChBcnJheS5pc0FycmF5KGFsbG93ZWRFdmVudHNfKSAmJiBhbGxvd2VkRXZlbnRzXy5sZW5ndGggPiAwLCAnUmVxdWlyZXMgYSBub24tZW1wdHkgYXJyYXknKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgY2FsbGVkIGJ5IGRlcml2ZWQgY2xhc3NlcyB0byB0cmlnZ2VyIGV2ZW50cy5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3NcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0pKSB7XG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgbGlzdCwgc2luY2UgY2FsbGJhY2tzIGNvdWxkIGFkZC9yZW1vdmUgbGlzdGVuZXJzLlxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsYmFjay5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgdmFyX2FyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0gPSB0aGlzLmxpc3RlbmVyc19bZXZlbnRUeXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNfW2V2ZW50VHlwZV0ucHVzaCh7IGNhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCB9KTtcbiAgICAgICAgdmFyIGV2ZW50RGF0YSA9IHRoaXMuZ2V0SW5pdGlhbEV2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmIChldmVudERhdGEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGV2ZW50RGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUV2ZW50VHlwZV8oZXZlbnRUeXBlKTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzX1tldmVudFR5cGVdIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiZcbiAgICAgICAgICAgICAgICAoIWNvbnRleHQgfHwgY29udGV4dCA9PT0gbGlzdGVuZXJzW2ldLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUudmFsaWRhdGVFdmVudFR5cGVfID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuYWxsb3dlZEV2ZW50c18uZmluZChmdW5jdGlvbiAoZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBldCA9PT0gZXZlbnRUeXBlO1xuICAgICAgICB9KSwgJ1Vua25vd24gZXZlbnQ6ICcgKyBldmVudFR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRFbWl0dGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvRXZlbnRFbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3V0aWxcIik7XG52YXIgc3RvcmFnZV8xID0gcmVxdWlyZShcIi4uL2NvcmUvc3RvcmFnZS9zdG9yYWdlXCIpO1xudmFyIENvbnN0YW50c18xID0gcmVxdWlyZShcIi4vQ29uc3RhbnRzXCIpO1xudmFyIFRyYW5zcG9ydE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL1RyYW5zcG9ydE1hbmFnZXJcIik7XG4vLyBBYm9ydCB1cGdyYWRlIGF0dGVtcHQgaWYgaXQgdGFrZXMgbG9uZ2VyIHRoYW4gNjBzLlxudmFyIFVQR1JBREVfVElNRU9VVCA9IDYwMDAwO1xuLy8gRm9yIHNvbWUgdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gXCJ2YWxpZGF0ZVwiIHRoZSB0cmFuc3BvcnQgYnkgZXhjaGFuZ2luZyBhIGZldyByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLlxuLy8gSWYgd2UgaGF2ZW4ndCBzZW50IGVub3VnaCByZXF1ZXN0cyB3aXRoaW4gNXMsIHdlJ2xsIHN0YXJ0IHNlbmRpbmcgbm9vcCBwaW5nIHJlcXVlc3RzLlxudmFyIERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTID0gNTAwMDtcbi8vIElmIHRoZSBpbml0aWFsIGRhdGEgc2VudCB0cmlnZ2VycyBhIGxvdCBvZiBiYW5kd2lkdGggKGkuZS4gaXQncyBhIGxhcmdlIHB1dCBvciBhIGxpc3RlbiBmb3IgYSBsYXJnZSBhbW91bnQgb2YgZGF0YSlcbi8vIHRoZW4gd2UgbWF5IG5vdCBiZSBhYmxlIHRvIGV4Y2hhbmdlIG91ciBwaW5nL3BvbmcgcmVxdWVzdHMgd2l0aGluIHRoZSBoZWFsdGh5IHRpbWVvdXQuICBTbyBpZiB3ZSByZWFjaCB0aGUgdGltZW91dFxuLy8gYnV0IHdlJ3ZlIHNlbnQvcmVjZWl2ZWQgZW5vdWdoIGJ5dGVzLCB3ZSBkb24ndCBjYW5jZWwgdGhlIGNvbm5lY3Rpb24uXG52YXIgQllURVNfU0VOVF9IRUFMVEhZX09WRVJSSURFID0gMTAgKiAxMDI0O1xudmFyIEJZVEVTX1JFQ0VJVkVEX0hFQUxUSFlfT1ZFUlJJREUgPSAxMDAgKiAxMDI0O1xudmFyIE1FU1NBR0VfVFlQRSA9ICd0JztcbnZhciBNRVNTQUdFX0RBVEEgPSAnZCc7XG52YXIgQ09OVFJPTF9TSFVURE9XTiA9ICdzJztcbnZhciBDT05UUk9MX1JFU0VUID0gJ3InO1xudmFyIENPTlRST0xfRVJST1IgPSAnZSc7XG52YXIgQ09OVFJPTF9QT05HID0gJ28nO1xudmFyIFNXSVRDSF9BQ0sgPSAnYSc7XG52YXIgRU5EX1RSQU5TTUlTU0lPTiA9ICduJztcbnZhciBQSU5HID0gJ3AnO1xudmFyIFNFUlZFUl9IRUxMTyA9ICdoJztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFsLXRpbWUgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIHVzaW5nIHdoaWNoZXZlciBtZXRob2Qgd29ya3NcbiAqIGJlc3QgaW4gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBpZCAtIGFuIGlkIGZvciB0aGlzIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0geyFSZXBvSW5mb30gcmVwb0luZm9fIC0gdGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBvbk1lc3NhZ2VfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgc2VydmVyLXB1c2ggbWVzc2FnZSBhcnJpdmVzXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIHN0cmluZyl9IG9uUmVhZHlfIC0gdGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoaXMgY29ubmVjdGlvbiBpcyByZWFkeSB0byBzZW5kIG1lc3NhZ2VzLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gb25EaXNjb25uZWN0XyAtIHRoZSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gd2FzIGxvc3RcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZyl9IG9uS2lsbF8gLSB0aGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBjb25uZWN0aW9uIGhhcyBwZXJtYW5lbnRseSBzaHV0IGRvd24uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIC0gbGFzdCBzZXNzaW9uIGlkIGluIHBlcnNpc3RlbnQgY29ubmVjdGlvbi4gaXMgdXNlZCB0byBjbGVhbiB1cCBvbGQgc2Vzc2lvbiBpbiByZWFsLXRpbWUgc2VydmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbihpZCwgcmVwb0luZm9fLCBvbk1lc3NhZ2VfLCBvblJlYWR5Xywgb25EaXNjb25uZWN0Xywgb25LaWxsXywgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucmVwb0luZm9fID0gcmVwb0luZm9fO1xuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xuICAgICAgICB0aGlzLm9uUmVhZHlfID0gb25SZWFkeV87XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG9uRGlzY29ubmVjdF87XG4gICAgICAgIHRoaXMub25LaWxsXyA9IG9uS2lsbF87XG4gICAgICAgIHRoaXMubGFzdFNlc3Npb25JZCA9IGxhc3RTZXNzaW9uSWQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMuc3RhdGVfID0gMCAvKiBDT05ORUNUSU5HICovO1xuICAgICAgICB0aGlzLmxvZ18gPSB1dGlsXzEubG9nV3JhcHBlcignYzonICsgdGhpcy5pZCArICc6Jyk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0TWFuYWdlcl8gPSBuZXcgVHJhbnNwb3J0TWFuYWdlcl8xLlRyYW5zcG9ydE1hbmFnZXIocmVwb0luZm9fKTtcbiAgICAgICAgdGhpcy5sb2dfKCdDb25uZWN0aW9uIGNyZWF0ZWQnKTtcbiAgICAgICAgdGhpcy5zdGFydF8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgY29ubmVjdGlvbiBhdHRlbXB0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb25uID0gdGhpcy50cmFuc3BvcnRNYW5hZ2VyXy5pbml0aWFsVHJhbnNwb3J0KCk7XG4gICAgICAgIHRoaXMuY29ubl8gPSBuZXcgY29ubih0aGlzLm5leHRUcmFuc3BvcnRJZF8oKSwgdGhpcy5yZXBvSW5mb18sIHVuZGVmaW5lZCwgdGhpcy5sYXN0U2Vzc2lvbklkKTtcbiAgICAgICAgLy8gRm9yIGNlcnRhaW4gdHJhbnNwb3J0cyAoV2ViU29ja2V0cyksIHdlIG5lZWQgdG8gc2VuZCBhbmQgcmVjZWl2ZSBzZXZlcmFsIG1lc3NhZ2VzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSB3ZVxuICAgICAgICAvLyBjYW4gY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBoZWFsdGh5LlxuICAgICAgICB0aGlzLnByaW1hcnlSZXNwb25zZXNSZXF1aXJlZF8gPSBjb25uWydyZXNwb25zZXNSZXF1aXJlZFRvQmVIZWFsdGh5J10gfHwgMDtcbiAgICAgICAgdmFyIG9uTWVzc2FnZVJlY2VpdmVkID0gdGhpcy5jb25uUmVjZWl2ZXJfKHRoaXMuY29ubl8pO1xuICAgICAgICB2YXIgb25Db25uZWN0aW9uTG9zdCA9IHRoaXMuZGlzY29ublJlY2VpdmVyXyh0aGlzLmNvbm5fKTtcbiAgICAgICAgdGhpcy50eF8gPSB0aGlzLmNvbm5fO1xuICAgICAgICB0aGlzLnJ4XyA9IHRoaXMuY29ubl87XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5Q29ubl8gPSBudWxsO1xuICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSBmYWxzZTtcbiAgICAgICAgLypcbiAgICAgICAgICogRmlyZWZveCBkb2Vzbid0IGxpa2Ugd2hlbiBjb2RlIGZyb20gb25lIGlmcmFtZSB0cmllcyB0byBjcmVhdGUgYW5vdGhlciBpZnJhbWUgYnkgd2F5IG9mIHRoZSBwYXJlbnQgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgY2FuIG9jY3VyIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3QsIGkuZS4gd2UgZ3Vlc3NlZCB3cm9uZyBvbiB3aGF0IHNlcnZlciB0byBjb25uZWN0IHRvIGFuZCByZWNlaXZlZCBhIHJlc2V0LlxuICAgICAgICAgKiBTb21laG93LCBzZXRUaW1lb3V0IHNlZW1zIHRvIG1ha2UgdGhpcyBvay4gVGhhdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZnJvbSBhIHNlY3VyaXR5IHBlcnNwZWN0aXZlLCBzaW5jZSB5b3Ugc2hvdWxkXG4gICAgICAgICAqIHN0aWxsIGhhdmUgdGhlIGNvbnRleHQgb2YgeW91ciBvcmlnaW5hdGluZyBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gdGhpcy5jb25uXyBnZXRzIHNldCB0byBudWxsIGluIHNvbWUgb2YgdGhlIHRlc3RzLiBDaGVjayB0byBtYWtlIHN1cmUgaXQgc3RpbGwgZXhpc3RzIGJlZm9yZSB1c2luZyBpdFxuICAgICAgICAgICAgX3RoaXMuY29ubl8gJiYgX3RoaXMuY29ubl8ub3Blbihvbk1lc3NhZ2VSZWNlaXZlZCwgb25Db25uZWN0aW9uTG9zdCk7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoMCkpO1xuICAgICAgICB2YXIgaGVhbHRoeVRpbWVvdXRfbXMgPSBjb25uWydoZWFsdGh5VGltZW91dCddIHx8IDA7XG4gICAgICAgIGlmIChoZWFsdGh5VGltZW91dF9tcyA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhbHRoeVRpbWVvdXRfID0gdXRpbF8xLnNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGVhbHRoeVRpbWVvdXRfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzSGVhbHRoeV8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5fICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkID4gQllURVNfUkVDRUlWRURfSEVBTFRIWV9PVkVSUklERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnQ29ubmVjdGlvbiBleGNlZWRlZCBoZWFsdGh5IHRpbWVvdXQgYnV0IGhhcyByZWNlaXZlZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1JlY2VpdmVkICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzLiAgTWFya2luZyBjb25uZWN0aW9uIGhlYWx0aHkuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5fLm1hcmtDb25uZWN0aW9uSGVhbHRoeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmNvbm5fICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1NlbnQgPiBCWVRFU19TRU5UX0hFQUxUSFlfT1ZFUlJJREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gZXhjZWVkZWQgaGVhbHRoeSB0aW1lb3V0IGJ1dCBoYXMgc2VudCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25uXy5ieXRlc1NlbnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgYnl0ZXMuICBMZWF2aW5nIGNvbm5lY3Rpb24gYWxpdmUuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOT1RFOiBXZSBkb24ndCB3YW50IHRvIG1hcmsgaXQgaGVhbHRoeSwgc2luY2Ugd2UgaGF2ZSBubyBndWFyYW50ZWUgdGhhdCB0aGUgYnl0ZXMgaGF2ZSBtYWRlIGl0IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VydmVyLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnQ2xvc2luZyB1bmhlYWx0aHkgY29ubmVjdGlvbiBhZnRlciB0aW1lb3V0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIE1hdGguZmxvb3IoaGVhbHRoeVRpbWVvdXRfbXMpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm5leHRUcmFuc3BvcnRJZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnYzonICsgdGhpcy5pZCArICc6JyArIHRoaXMuY29ubmVjdGlvbkNvdW50Kys7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5kaXNjb25uUmVjZWl2ZXJfID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVyQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBpZiAoY29ubiA9PT0gX3RoaXMuY29ubl8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNvbm5lY3Rpb25Mb3N0XyhldmVyQ29ubmVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbm4gPT09IF90aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnU2Vjb25kYXJ5IGNvbm5lY3Rpb24gbG9zdC4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubG9nXygnY2xvc2luZyBhbiBvbGQgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY29ublJlY2VpdmVyXyA9IGZ1bmN0aW9uIChjb25uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlXyAhPSAyIC8qIERJU0NPTk5FQ1RFRCAqLykge1xuICAgICAgICAgICAgICAgIGlmIChjb25uID09PSBfdGhpcy5yeF8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25QcmltYXJ5TWVzc2FnZVJlY2VpdmVkXyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29ubiA9PT0gX3RoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25TZWNvbmRhcnlNZXNzYWdlUmVjZWl2ZWRfKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubG9nXygnbWVzc2FnZSBvbiBvbGQgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFNc2cgQW4gYXJiaXRyYXJ5IGRhdGEgbWVzc2FnZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChkYXRhTXNnKSB7XG4gICAgICAgIC8vIHdyYXAgaW4gYSBkYXRhIG1lc3NhZ2UgZW52ZWxvcGUgYW5kIHNlbmQgaXQgb25cbiAgICAgICAgdmFyIG1zZyA9IHsgdDogJ2QnLCBkOiBkYXRhTXNnIH07XG4gICAgICAgIHRoaXMuc2VuZERhdGFfKG1zZyk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS50cnlDbGVhbnVwQ29ubmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fICYmIHRoaXMucnhfID09PSB0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ2NsZWFuaW5nIHVwIGFuZCBwcm9tb3RpbmcgYSBjb25uZWN0aW9uOiAnICsgdGhpcy5zZWNvbmRhcnlDb25uXy5jb25uSWQpO1xuICAgICAgICAgICAgdGhpcy5jb25uXyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgICAgICAgIC8vIHRoZSBzZXJ2ZXIgd2lsbCBzaHV0ZG93biB0aGUgb2xkIGNvbm5lY3Rpb25cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25TZWNvbmRhcnlDb250cm9sXyA9IGZ1bmN0aW9uIChjb250cm9sRGF0YSkge1xuICAgICAgICBpZiAoTUVTU0FHRV9UWVBFIGluIGNvbnRyb2xEYXRhKSB7XG4gICAgICAgICAgICB2YXIgY21kID0gY29udHJvbERhdGFbTUVTU0FHRV9UWVBFXTtcbiAgICAgICAgICAgIGlmIChjbWQgPT09IFNXSVRDSF9BQ0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbWQgPT09IENPTlRST0xfUkVTRVQpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3N0IGxpa2VseSB0aGUgc2Vzc2lvbiB3YXNuJ3QgdmFsaWQuIEFiYW5kb24gdGhlIHN3aXRjaCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdHb3QgYSByZXNldCBvbiBzZWNvbmRhcnksIGNsb3NpbmcgaXQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBhbHJlYWR5IHVzaW5nIHRoaXMgY29ubmVjdGlvbiBmb3Igc29tZXRoaW5nLCB0aGFuIHdlIG5lZWQgdG8gZnVsbHkgY2xvc2VcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8gfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yeF8gPT09IHRoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9QT05HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBzZWNvbmRhcnkuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlSZXNwb25zZXNSZXF1aXJlZF8tLTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVJZlNlY29uZGFyeUhlYWx0aHlfKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uU2Vjb25kYXJ5TWVzc2FnZVJlY2VpdmVkXyA9IGZ1bmN0aW9uIChwYXJzZWREYXRhKSB7XG4gICAgICAgIHZhciBsYXllciA9IHV0aWxfMS5yZXF1aXJlS2V5KCd0JywgcGFyc2VkRGF0YSk7XG4gICAgICAgIHZhciBkYXRhID0gdXRpbF8xLnJlcXVpcmVLZXkoJ2QnLCBwYXJzZWREYXRhKTtcbiAgICAgICAgaWYgKGxheWVyID09ICdjJykge1xuICAgICAgICAgICAgdGhpcy5vblNlY29uZGFyeUNvbnRyb2xfKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxheWVyID09ICdkJykge1xuICAgICAgICAgICAgLy8gZ290IGEgZGF0YSBtZXNzYWdlLCBidXQgd2UncmUgc3RpbGwgc2Vjb25kIGNvbm5lY3Rpb24uIE5lZWQgdG8gYnVmZmVyIGl0IHVwXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEYXRhTWVzc2FnZXMucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcm90b2NvbCBsYXllcjogJyArIGxheWVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUudXBncmFkZUlmU2Vjb25kYXJ5SGVhbHRoeV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1NlY29uZGFyeSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuJyk7XG4gICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5tYXJrQ29ubmVjdGlvbkhlYWx0aHkoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2VlZFdpdGhVcGdyYWRlXygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VuZCBhIHBpbmcgdG8gbWFrZSBzdXJlIHRoZSBjb25uZWN0aW9uIGlzIGhlYWx0aHkuXG4gICAgICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgcGluZyBvbiBzZWNvbmRhcnkuJyk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLnNlbmQoeyB0OiAnYycsIGQ6IHsgdDogUElORywgZDoge30gfSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUucHJvY2VlZFdpdGhVcGdyYWRlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGVsbCB0aGlzIGNvbm5lY3Rpb24gdG8gY29uc2lkZXIgaXRzZWxmIG9wZW5cbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zdGFydCgpO1xuICAgICAgICAvLyBzZW5kIGFja1xuICAgICAgICB0aGlzLmxvZ18oJ3NlbmRpbmcgY2xpZW50IGFjayBvbiBzZWNvbmRhcnknKTtcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXy5zZW5kKHsgdDogJ2MnLCBkOiB7IHQ6IFNXSVRDSF9BQ0ssIGQ6IHt9IH0gfSk7XG4gICAgICAgIC8vIHNlbmQgZW5kIHBhY2tldCBvbiBwcmltYXJ5IHRyYW5zcG9ydCwgc3dpdGNoIHRvIHNlbmRpbmcgb24gdGhpcyBvbmVcbiAgICAgICAgLy8gY2FuIHJlY2VpdmUgb24gdGhpcyBvbmUsIGJ1ZmZlciByZXNwb25zZXMgdW50aWwgZW5kIHJlY2VpdmVkIG9uIHByaW1hcnkgdHJhbnNwb3J0XG4gICAgICAgIHRoaXMubG9nXygnRW5kaW5nIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XG4gICAgICAgIHRoaXMuY29ubl8uc2VuZCh7IHQ6ICdjJywgZDogeyB0OiBFTkRfVFJBTlNNSVNTSU9OLCBkOiB7fSB9IH0pO1xuICAgICAgICB0aGlzLnR4XyA9IHRoaXMuc2Vjb25kYXJ5Q29ubl87XG4gICAgICAgIHRoaXMudHJ5Q2xlYW51cENvbm5lY3Rpb24oKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUHJpbWFyeU1lc3NhZ2VSZWNlaXZlZF8gPSBmdW5jdGlvbiAocGFyc2VkRGF0YSkge1xuICAgICAgICAvLyBNdXN0IHJlZmVyIHRvIHBhcnNlZERhdGEgcHJvcGVydGllcyBpbiBxdW90ZXMsIHNvIGNsb3N1cmUgZG9lc24ndCB0b3VjaCB0aGVtLlxuICAgICAgICB2YXIgbGF5ZXIgPSB1dGlsXzEucmVxdWlyZUtleSgndCcsIHBhcnNlZERhdGEpO1xuICAgICAgICB2YXIgZGF0YSA9IHV0aWxfMS5yZXF1aXJlS2V5KCdkJywgcGFyc2VkRGF0YSk7XG4gICAgICAgIGlmIChsYXllciA9PSAnYycpIHtcbiAgICAgICAgICAgIHRoaXMub25Db250cm9sXyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXllciA9PSAnZCcpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhTWVzc2FnZV8oZGF0YSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uRGF0YU1lc3NhZ2VfID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5vblByaW1hcnlSZXNwb25zZV8oKTtcbiAgICAgICAgLy8gV2UgZG9uJ3QgZG8gYW55dGhpbmcgd2l0aCBkYXRhIG1lc3NhZ2VzLCBqdXN0IGtpY2sgdGhlbSB1cCBhIGxldmVsXG4gICAgICAgIHRoaXMub25NZXNzYWdlXyhtZXNzYWdlKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUHJpbWFyeVJlc3BvbnNlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhbHRoeV8pIHtcbiAgICAgICAgICAgIHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXy0tO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeVJlc3BvbnNlc1JlcXVpcmVkXyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdQcmltYXJ5IGNvbm5lY3Rpb24gaXMgaGVhbHRoeS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSGVhbHRoeV8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubl8ubWFya0Nvbm5lY3Rpb25IZWFsdGh5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29udHJvbF8gPSBmdW5jdGlvbiAoY29udHJvbERhdGEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHV0aWxfMS5yZXF1aXJlS2V5KE1FU1NBR0VfVFlQRSwgY29udHJvbERhdGEpO1xuICAgICAgICBpZiAoTUVTU0FHRV9EQVRBIGluIGNvbnRyb2xEYXRhKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNvbnRyb2xEYXRhW01FU1NBR0VfREFUQV07XG4gICAgICAgICAgICBpZiAoY21kID09PSBTRVJWRVJfSEVMTE8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZHNoYWtlXyhwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gRU5EX1RSQU5TTUlTU0lPTikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nXygncmVjdmQgZW5kIHRyYW5zbWlzc2lvbiBvbiBwcmltYXJ5Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yeF8gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25EYXRhTWVzc2FnZV8odGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRGF0YU1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy50cnlDbGVhbnVwQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1NIVVRET1dOKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXMgcHJldmlvdXNseSB0aGUgJ29uS2lsbCcgY2FsbGJhY2sgcGFzc2VkIHRvIHRoZSBsb3dlci1sZXZlbCBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIHJlYXNvbiBmb3IgdGhlIHNodXRkb3duLiBHZW5lcmFsbHkgYSBodW1hbi1yZWFkYWJsZSBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMub25Db25uZWN0aW9uU2h1dGRvd25fKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX1JFU0VUKSB7XG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZCBpbiB0aGlzIGNhc2UgaXMgdGhlIGhvc3Qgd2Ugc2hvdWxkIGNvbnRhY3RcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVzZXRfKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY21kID09PSBDT05UUk9MX0VSUk9SKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmVycm9yKCdTZXJ2ZXIgRXJyb3I6ICcgKyBwYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNtZCA9PT0gQ09OVFJPTF9QT05HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKCdnb3QgcG9uZyBvbiBwcmltYXJ5LicpO1xuICAgICAgICAgICAgICAgIHRoaXMub25QcmltYXJ5UmVzcG9uc2VfKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGluZ09uUHJpbWFyeUlmTmVjZXNzYXJ5XygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmVycm9yKCdVbmtub3duIGNvbnRyb2wgcGFja2V0IGNvbW1hbmQ6ICcgKyBjbWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2UgVGhlIGhhbmRzaGFrZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25IYW5kc2hha2VfID0gZnVuY3Rpb24gKGhhbmRzaGFrZSkge1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gaGFuZHNoYWtlLnRzO1xuICAgICAgICB2YXIgdmVyc2lvbiA9IGhhbmRzaGFrZS52O1xuICAgICAgICB2YXIgaG9zdCA9IGhhbmRzaGFrZS5oO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IGhhbmRzaGFrZS5zO1xuICAgICAgICB0aGlzLnJlcG9JbmZvXy51cGRhdGVIb3N0KGhvc3QpO1xuICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IGNsb3NlZCB0aGUgY29ubmVjdGlvbiwgdGhlbiBkb24ndCBib3RoZXIgdHJ5aW5nIHRvIHByb2dyZXNzIGZ1cnRoZXJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfID09IDAgLyogQ09OTkVDVElORyAqLykge1xuICAgICAgICAgICAgdGhpcy5jb25uXy5zdGFydCgpO1xuICAgICAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8odGhpcy5jb25uXywgdGltZXN0YW1wKTtcbiAgICAgICAgICAgIGlmIChDb25zdGFudHNfMS5QUk9UT0NPTF9WRVJTSU9OICE9PSB2ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oJ1Byb3RvY29sIHZlcnNpb24gbWlzbWF0Y2ggZGV0ZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIHdhbnQgdG8gdXBncmFkZT8gd2hlbj8gbWF5YmUgYSBkZWxheT9cbiAgICAgICAgICAgIHRoaXMudHJ5U3RhcnRVcGdyYWRlXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS50cnlTdGFydFVwZ3JhZGVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubiA9IHRoaXMudHJhbnNwb3J0TWFuYWdlcl8udXBncmFkZVRyYW5zcG9ydCgpO1xuICAgICAgICBpZiAoY29ubikge1xuICAgICAgICAgICAgdGhpcy5zdGFydFVwZ3JhZGVfKGNvbm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5zdGFydFVwZ3JhZGVfID0gZnVuY3Rpb24gKGNvbm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZWNvbmRhcnlDb25uXyA9IG5ldyBjb25uKHRoaXMubmV4dFRyYW5zcG9ydElkXygpLCB0aGlzLnJlcG9JbmZvXywgdGhpcy5zZXNzaW9uSWQpO1xuICAgICAgICAvLyBGb3IgY2VydGFpbiB0cmFuc3BvcnRzIChXZWJTb2NrZXRzKSwgd2UgbmVlZCB0byBzZW5kIGFuZCByZWNlaXZlIHNldmVyYWwgbWVzc2FnZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIHdlXG4gICAgICAgIC8vIGNhbiBjb25zaWRlciB0aGUgdHJhbnNwb3J0IGhlYWx0aHkuXG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID1cbiAgICAgICAgICAgIGNvbm5bJ3Jlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHknXSB8fCAwO1xuICAgICAgICB2YXIgb25NZXNzYWdlID0gdGhpcy5jb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xuICAgICAgICB2YXIgb25EaXNjb25uZWN0ID0gdGhpcy5kaXNjb25uUmVjZWl2ZXJfKHRoaXMuc2Vjb25kYXJ5Q29ubl8pO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLm9wZW4ob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IHN1Y2Nlc3NmdWxseSB1cGdyYWRlZCBhZnRlciBVUEdSQURFX1RJTUVPVVQsIGdpdmUgdXAgYW5kIGtpbGwgdGhlIHNlY29uZGFyeS5cbiAgICAgICAgdXRpbF8xLnNldFRpbWVvdXROb25CbG9ja2luZyhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc2Vjb25kYXJ5Q29ubl8pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKCdUaW1lZCBvdXQgdHJ5aW5nIHRvIHVwZ3JhZGUuJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kYXJ5Q29ubl8uY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgTWF0aC5mbG9vcihVUEdSQURFX1RJTUVPVVQpKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uUmVzZXRfID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgdGhpcy5sb2dfKCdSZXNldCBwYWNrZXQgcmVjZWl2ZWQuICBOZXcgaG9zdDogJyArIGhvc3QpO1xuICAgICAgICB0aGlzLnJlcG9JbmZvXy51cGRhdGVIb3N0KGhvc3QpO1xuICAgICAgICAvLyBUT0RPOiBpZiB3ZSdyZSBhbHJlYWR5IFwiY29ubmVjdGVkXCIsIHdlIG5lZWQgdG8gdHJpZ2dlciBhIGRpc2Nvbm5lY3QgYXQgdGhlIG5leHQgbGF5ZXIgdXAuXG4gICAgICAgIC8vIFdlIGRvbid0IGN1cnJlbnRseSBzdXBwb3J0IHJlc2V0cyBhZnRlciB0aGUgY29ubmVjdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGVzdGFibGlzaGVkXG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyA9PT0gMSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsb3NlIHdoYXRldmVyIGNvbm5lY3Rpb25zIHdlIGhhdmUgb3BlbiBhbmQgc3RhcnQgYWdhaW4uXG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29ubmVjdGlvbnNfKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNvbm5lY3Rpb25Fc3RhYmxpc2hlZF8gPSBmdW5jdGlvbiAoY29ubiwgdGltZXN0YW1wKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4nKTtcbiAgICAgICAgdGhpcy5jb25uXyA9IGNvbm47XG4gICAgICAgIHRoaXMuc3RhdGVfID0gMSAvKiBDT05ORUNURUQgKi87XG4gICAgICAgIGlmICh0aGlzLm9uUmVhZHlfKSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVhZHlfKHRpbWVzdGFtcCwgdGhpcy5zZXNzaW9uSWQpO1xuICAgICAgICAgICAgdGhpcy5vblJlYWR5XyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYWZ0ZXIgNSBzZWNvbmRzIHdlIGhhdmVuJ3Qgc2VudCBlbm91Z2ggcmVxdWVzdHMgdG8gdGhlIHNlcnZlciB0byBnZXQgdGhlIGNvbm5lY3Rpb24gaGVhbHRoeSxcbiAgICAgICAgLy8gc2VuZCBzb21lIHBpbmdzLlxuICAgICAgICBpZiAodGhpcy5wcmltYXJ5UmVzcG9uc2VzUmVxdWlyZWRfID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ1ByaW1hcnkgY29ubmVjdGlvbiBpcyBoZWFsdGh5LicpO1xuICAgICAgICAgICAgdGhpcy5pc0hlYWx0aHlfID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxfMS5zZXRUaW1lb3V0Tm9uQmxvY2tpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfKCk7XG4gICAgICAgICAgICB9LCBNYXRoLmZsb29yKERFTEFZX0JFRk9SRV9TRU5ESU5HX0VYVFJBX1JFUVVFU1RTKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmRQaW5nT25QcmltYXJ5SWZOZWNlc3NhcnlfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBJZiB0aGUgY29ubmVjdGlvbiBpc24ndCBjb25zaWRlcmVkIGhlYWx0aHkgeWV0LCB3ZSdsbCBzZW5kIGEgbm9vcCBwaW5nIHBhY2tldCByZXF1ZXN0LlxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFsdGh5XyAmJiB0aGlzLnN0YXRlXyA9PT0gMSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnc2VuZGluZyBwaW5nIG9uIHByaW1hcnkuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbmREYXRhXyh7IHQ6ICdjJywgZDogeyB0OiBQSU5HLCBkOiB7fSB9IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5vblNlY29uZGFyeUNvbm5lY3Rpb25Mb3N0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm4gPSB0aGlzLnNlY29uZGFyeUNvbm5fO1xuICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHhfID09PSBjb25uIHx8IHRoaXMucnhfID09PSBjb25uKSB7XG4gICAgICAgICAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiB0aGlzIGNvbm5lY3Rpb24gYWxyZWFkeSBpbiBzb21lIGNhcGFjaXR5LiBUaGVyZWZvcmUsIGEgZmFpbHVyZSBpcyByZWFsXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBldmVyQ29ubmVjdGVkIFdoZXRoZXIgb3Igbm90IHRoZSBjb25uZWN0aW9uIGV2ZXIgcmVhY2hlZCBhIHNlcnZlci4gVXNlZCB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiB3ZSBzaG91bGQgZmx1c2ggdGhlIGhvc3QgY2FjaGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm9uQ29ubmVjdGlvbkxvc3RfID0gZnVuY3Rpb24gKGV2ZXJDb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5jb25uXyA9IG51bGw7XG4gICAgICAgIC8vIE5PVEU6IElGIHlvdSdyZSBzZWVpbmcgYSBGaXJlZm94IGVycm9yIGZvciB0aGlzIGxpbmUsIEkgdGhpbmsgaXQgbWlnaHQgYmUgYmVjYXVzZSBpdCdzIGdldHRpbmdcbiAgICAgICAgLy8gY2FsbGVkIG9uIHdpbmRvdyBjbG9zZSBhbmQgUmVhbHRpbWVTdGF0ZS5DT05ORUNUSU5HIGlzIG5vIGxvbmdlciBkZWZpbmVkLiAgSnVzdCBhIGd1ZXNzLlxuICAgICAgICBpZiAoIWV2ZXJDb25uZWN0ZWQgJiYgdGhpcy5zdGF0ZV8gPT09IDAgLyogQ09OTkVDVElORyAqLykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdSZWFsdGltZSBjb25uZWN0aW9uIGZhaWxlZC4nKTtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGZhaWxlZCB0byBjb25uZWN0IGF0IGFsbCwgY2xlYXIgYW55IGNhY2hlZCBlbnRyeSBmb3IgdGhpcyBuYW1lc3BhY2UgaW4gY2FzZSB0aGUgbWFjaGluZSB3ZW50IGF3YXlcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcG9JbmZvXy5pc0NhY2hlYWJsZUhvc3QoKSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VfMS5QZXJzaXN0ZW50U3RvcmFnZS5yZW1vdmUoJ2hvc3Q6JyArIHRoaXMucmVwb0luZm9fLmhvc3QpO1xuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBpbnRlcm5hbCBob3N0IHRvIHdoYXQgd2Ugd291bGQgc2hvdyB0aGUgdXNlciwgaS5lLiA8bnM+LmZpcmViYXNlaW8uY29tXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvSW5mb18uaW50ZXJuYWxIb3N0ID0gdGhpcy5yZXBvSW5mb18uaG9zdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlXyA9PT0gMSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnUmVhbHRpbWUgY29ubmVjdGlvbiBsb3N0LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUub25Db25uZWN0aW9uU2h1dGRvd25fID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICB0aGlzLmxvZ18oJ0Nvbm5lY3Rpb24gc2h1dGRvd24gY29tbWFuZCByZWNlaXZlZC4gU2h1dHRpbmcgZG93bi4uLicpO1xuICAgICAgICBpZiAodGhpcy5vbktpbGxfKSB7XG4gICAgICAgICAgICB0aGlzLm9uS2lsbF8ocmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMub25LaWxsXyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB3YW50IHRvIGZpcmUgb25EaXNjb25uZWN0IChraWxsIGlzIGEgZGlmZmVyZW50IGNhc2UpLFxuICAgICAgICAvLyBzbyBjbGVhciB0aGUgY2FsbGJhY2suXG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0XyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmREYXRhXyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMSAvKiBDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRocm93ICdDb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50eF8uc2VuZChkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHRoaXMgY29ubmVjdGlvbiwgY2FsbGluZyB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tzXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlXyAhPT0gMiAvKiBESVNDT05ORUNURUQgKi8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnQ2xvc2luZyByZWFsdGltZSBjb25uZWN0aW9uLicpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSAyIC8qIERJU0NPTk5FQ1RFRCAqLztcbiAgICAgICAgICAgIHRoaXMuY2xvc2VDb25uZWN0aW9uc18oKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdF8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2VDb25uZWN0aW9uc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nXygnU2h1dHRpbmcgZG93biBhbGwgY29ubmVjdGlvbnMnKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubl8pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubl8uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29ubl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlY29uZGFyeUNvbm5fKSB7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNlY29uZGFyeUNvbm5fID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFsdGh5VGltZW91dF8pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlYWx0aHlUaW1lb3V0Xyk7XG4gICAgICAgICAgICB0aGlzLmhlYWx0aHlUaW1lb3V0XyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3Rpb24uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL0Nvbm5lY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWwvdXRpbFwiKTtcbnZhciBDb3VudGVkU2V0XzEgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL0NvdW50ZWRTZXRcIik7XG52YXIgU3RhdHNNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9zdGF0cy9TdGF0c01hbmFnZXJcIik7XG52YXIgUGFja2V0UmVjZWl2ZXJfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmcvUGFja2V0UmVjZWl2ZXJcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8vIFVSTCBxdWVyeSBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCBsb25ncG9sbGluZ1xuZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTSA9ICdzdGFydCc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0NMT1NFX0NPTU1BTkQgPSAnY2xvc2UnO1xuZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9DT01NQU5EX0NCX05BTUUgPSAncExQQ29tbWFuZCc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSA9ICdwUlRMUENCJztcbmV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU0gPSAnaWQnO1xuZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9QV19QQVJBTSA9ICdwdyc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFUklBTF9QQVJBTSA9ICdzZXInO1xuZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9DQUxMQkFDS19JRF9QQVJBTSA9ICdjYic7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNID0gJ3NlZyc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRTX0lOX1BBQ0tFVCA9ICd0cyc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfUEFSQU0gPSAnZCc7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUEFSQU0gPSAnZGlzY29ubic7XG5leHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUkVRVUVTVF9QQVJBTSA9ICdkZnJhbWUnO1xuLy9EYXRhIHNpemUgY29uc3RhbnRzLlxuLy9UT0RPOiBQZXJmOiB0aGUgbWF4aW11bSBsZW5ndGggYWN0dWFsbHkgZGlmZmVycyBmcm9tIGJyb3dzZXIgdG8gYnJvd3Nlci5cbi8vIFdlIHNob3VsZCBjaGVjayB3aGF0IGJyb3dzZXIgd2UncmUgb24gYW5kIHNldCBhY2NvcmRpbmdseS5cbnZhciBNQVhfVVJMX0RBVEFfU0laRSA9IDE4NzA7XG52YXIgU0VHX0hFQURFUl9TSVpFID0gMzA7IC8vaWU6ICZzZWc9ODI5OTIzNCZ0cz05ODIzODkxMjMmZD1cbnZhciBNQVhfUEFZTE9BRF9TSVpFID0gTUFYX1VSTF9EQVRBX1NJWkUgLSBTRUdfSEVBREVSX1NJWkU7XG4vKipcbiAqIEtlZXBhbGl2ZSBwZXJpb2RcbiAqIHNlbmQgYSBmcmVzaCByZXF1ZXN0IGF0IG1pbmltdW0gZXZlcnkgMjUgc2Vjb25kcy4gT3BlcmEgaGFzIGEgbWF4aW11bSByZXF1ZXN0XG4gKiBsZW5ndGggb2YgMzAgc2Vjb25kcyB0aGF0IHdlIGNhbid0IGV4Y2VlZC5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIEtFRVBBTElWRV9SRVFVRVNUX0lOVEVSVkFMID0gMjUwMDA7XG4vKipcbiAqIEhvdyBsb25nIHRvIHdhaXQgYmVmb3JlIGFib3J0aW5nIGEgbG9uZy1wb2xsaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAqIEBjb25zdFxuICogQHR5cGUge251bWJlcn1cbiAqL1xudmFyIExQX0NPTk5FQ1RfVElNRU9VVCA9IDMwMDAwO1xuLyoqXG4gKiBUaGlzIGNsYXNzIG1hbmFnZXMgYSBzaW5nbGUgbG9uZy1wb2xsaW5nIGNvbm5lY3Rpb24uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7VHJhbnNwb3J0fVxuICovXG52YXIgQnJvd3NlclBvbGxDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25uSWQgQW4gaWRlbnRpZmllciBmb3IgdGhpcyBjb25uZWN0aW9uLCB1c2VkIGZvciBsb2dnaW5nXG4gICAgICogQHBhcmFtIHtSZXBvSW5mb30gcmVwb0luZm8gVGhlIGluZm8gZm9yIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0cmFuc3BvcnRTZXNzaW9uSWQgT3B0aW9uYWwgdHJhbnNwb3J0U2Vzc2lvbmlkIGlmIHdlIGFyZSByZWNvbm5lY3RpbmcgZm9yIGFuIGV4aXN0aW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSAgbGFzdFNlc3Npb25JZCBPcHRpb25hbCBsYXN0U2Vzc2lvbklkIGlmIHRoZSBQZXJzaXN0ZW50Q29ubmVjdGlvbiBoYXMgYWxyZWFkeSBjcmVhdGVkIGFcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uIHByZXZpb3VzbHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCcm93c2VyUG9sbENvbm5lY3Rpb24oY29ubklkLCByZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xuICAgICAgICB0aGlzLnJlcG9JbmZvID0gcmVwb0luZm87XG4gICAgICAgIHRoaXMudHJhbnNwb3J0U2Vzc2lvbklkID0gdHJhbnNwb3J0U2Vzc2lvbklkO1xuICAgICAgICB0aGlzLmxhc3RTZXNzaW9uSWQgPSBsYXN0U2Vzc2lvbklkO1xuICAgICAgICB0aGlzLmJ5dGVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMuZXZlckNvbm5lY3RlZF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2dfID0gdXRpbF8xLmxvZ1dyYXBwZXIoY29ubklkKTtcbiAgICAgICAgdGhpcy5zdGF0c18gPSBTdGF0c01hbmFnZXJfMS5TdGF0c01hbmFnZXIuZ2V0Q29sbGVjdGlvbihyZXBvSW5mbyk7XG4gICAgICAgIHRoaXMudXJsRm4gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVwb0luZm8uY29ubmVjdGlvblVSTChDb25zdGFudHNfMS5MT05HX1BPTExJTkcsIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBvbk1lc3NhZ2UgQ2FsbGJhY2sgd2hlbiBtZXNzYWdlcyBhcnJpdmVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IG9uRGlzY29ubmVjdCBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAob25NZXNzYWdlLCBvbkRpc2Nvbm5lY3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jdXJTZWdtZW50TnVtID0gMDtcbiAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3RfID0gb25EaXNjb25uZWN0O1xuICAgICAgICB0aGlzLm15UGFja2V0T3JkZXJlciA9IG5ldyBQYWNrZXRSZWNlaXZlcl8xLlBhY2tldFJlY2VpdmVyKG9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1RpbWVkIG91dCB0cnlpbmcgdG8gY29ubmVjdC4nKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbGVhciB0aGUgaG9zdCBjYWNoZVxuICAgICAgICAgICAgX3RoaXMub25DbG9zZWRfKCk7XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyA9IG51bGw7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoTFBfQ09OTkVDVF9USU1FT1VUKSk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBkZWxheSB0aGUgY3JlYXRpb24gb2YgdGhlIGlmcmFtZSB1bnRpbCB0aGUgRE9NIGlzIGxvYWRlZC5cbiAgICAgICAgdXRpbF8xLmV4ZWN1dGVXaGVuRE9NUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzQ2xvc2VkXylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvL1NldCB1cCBhIGNhbGxiYWNrIHRoYXQgZ2V0cyB0cmlnZ2VyZWQgb25jZSBhIGNvbm5lY3Rpb24gaXMgc2V0IHVwLlxuICAgICAgICAgICAgX3RoaXMuc2NyaXB0VGFnSG9sZGVyID0gbmV3IEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBhcmdzWzBdLCBhcmcxID0gYXJnc1sxXSwgYXJnMiA9IGFyZ3NbMl0sIGFyZzMgPSBhcmdzWzNdLCBhcmc0ID0gYXJnc1s0XTtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyhhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNjcmlwdFRhZ0hvbGRlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5jb25uZWN0VGltZW91dFRpbWVyXyk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlckNvbm5lY3RlZF8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kID09IGV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU1RBUlRfUEFSQU0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWQgPSBhcmcxO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXNzd29yZCA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IGV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfQ0xPU0VfQ09NTUFORCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjbGVhciB0aGUgaG9zdCBjYWNoZS4gV2UgZ290IGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBrbm93IGl0J3MgcmVhY2hhYmxlXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhcmVuJ3QgZXhwZWN0aW5nIGFueSBtb3JlIGRhdGEgKG90aGVyIHRoYW4gd2hhdCB0aGUgc2VydmVyJ3MgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiBzZW5kaW5nIHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdWdoIG91ciBhbHJlYWR5IG9wZW4gcG9sbHMpLCBzbyBkb24ndCBzZW5kIGFueSBtb3JlLlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2NyaXB0VGFnSG9sZGVyLnNlbmROZXdQb2xscyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJnMSBpbiB0aGlzIGNhc2UgaXMgdGhlIGxhc3QgcmVzcG9uc2UgbnVtYmVyIHNlbnQgYnkgdGhlIHNlcnZlci4gV2Ugc2hvdWxkIHRyeSB0byByZWNlaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGwgb2YgdGhlIHJlc3BvbnNlcyB1cCB0byB0aGlzIG9uZSBiZWZvcmUgY2xvc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubXlQYWNrZXRPcmRlcmVyLmNsb3NlQWZ0ZXIoYXJnMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnJlY29nbml6ZWQgY29tbWFuZCByZWNlaXZlZDogJyArIGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBOID0gYXJnc1swXSwgZGF0YSA9IGFyZ3NbMV07XG4gICAgICAgICAgICAgICAgX3RoaXMuaW5jcmVtZW50SW5jb21pbmdCeXRlc18oYXJncyk7XG4gICAgICAgICAgICAgICAgX3RoaXMubXlQYWNrZXRPcmRlcmVyLmhhbmRsZVJlc3BvbnNlKHBOLCBkYXRhKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNsb3NlZF8oKTtcbiAgICAgICAgICAgIH0sIF90aGlzLnVybEZuKTtcbiAgICAgICAgICAgIC8vU2VuZCB0aGUgaW5pdGlhbCByZXF1ZXN0IHRvIGNvbm5lY3QuIFRoZSBzZXJpYWwgbnVtYmVyIGlzIHNpbXBseSB0byBrZWVwIHRoZSBicm93c2VyIGZyb20gcHVsbGluZyBwcmV2aW91cyByZXN1bHRzXG4gICAgICAgICAgICAvL2Zyb20gY2FjaGUuXG4gICAgICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TVEFSVF9QQVJBTV0gPSAndCc7XG4gICAgICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TRVJJQUxfUEFSQU1dID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zY3JpcHRUYWdIb2xkZXIudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyKVxuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0NBTExCQUNLX0lEX1BBUkFNXSA9IF90aGlzLnNjcmlwdFRhZ0hvbGRlci51bmlxdWVDYWxsYmFja0lkZW50aWZpZXI7XG4gICAgICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuVkVSU0lPTl9QQVJBTV0gPSBDb25zdGFudHNfMS5QUk9UT0NPTF9WRVJTSU9OO1xuICAgICAgICAgICAgaWYgKF90aGlzLnRyYW5zcG9ydFNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5UUkFOU1BPUlRfU0VTU0lPTl9QQVJBTV0gPSBfdGhpcy50cmFuc3BvcnRTZXNzaW9uSWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubGFzdFNlc3Npb25JZCkge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5MQVNUX1NFU1NJT05fUEFSQU1dID0gX3RoaXMubGFzdFNlc3Npb25JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbF8zLmlzTm9kZVNkaygpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uLmhyZWYgJiZcbiAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmLmluZGV4T2YoQ29uc3RhbnRzXzEuRk9SR0VfRE9NQUlOKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuUkVGRVJFUl9QQVJBTV0gPSBDb25zdGFudHNfMS5GT1JHRV9SRUY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29ubmVjdFVSTCA9IF90aGlzLnVybEZuKHVybFBhcmFtcyk7XG4gICAgICAgICAgICBfdGhpcy5sb2dfKCdDb25uZWN0aW5nIHZpYSBsb25nLXBvbGwgdG8gJyArIGNvbm5lY3RVUkwpO1xuICAgICAgICAgICAgX3RoaXMuc2NyaXB0VGFnSG9sZGVyLmFkZFRhZyhjb25uZWN0VVJMLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLyogZG8gbm90aGluZyAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGlzIHdoZW4gYSBoYW5kc2hha2UgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgYW5kIHdlIHdhbnQgdG8gY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWRcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5zdGFydExvbmdQb2xsKHRoaXMuaWQsIHRoaXMucGFzc3dvcmQpO1xuICAgICAgICB0aGlzLmFkZERpc2Nvbm5lY3RQaW5nRnJhbWUodGhpcy5pZCwgdGhpcy5wYXNzd29yZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgbG9uZyBwb2xsaW5nIHRvIGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlQWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZUFsbG93XyA9IHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3JjZXMgbG9uZ3BvbGxpbmcgdG8gbm90IGJlIGNvbnNpZGVyZWQgYXMgYSBwb3RlbnRpYWwgdHJhbnNwb3J0XG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XG4gICAgfTtcbiAgICAvLyBTdGF0aWMgbWV0aG9kLCB1c2Ugc3RyaW5nIGxpdGVyYWwgc28gaXQgY2FuIGJlIGFjY2Vzc2VkIGluIGEgZ2VuZXJpYyB3YXlcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24uaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5PVEU6IEluIFJlYWN0LU5hdGl2ZSB0aGVyZSdzIG5vcm1hbGx5IG5vICdkb2N1bWVudCcsIGJ1dCBpZiB5b3UgZGVidWcgYSBSZWFjdC1OYXRpdmUgYXBwIGluXG4gICAgICAgIC8vIHRoZSBDaHJvbWUgZGVidWdnZXIsICdkb2N1bWVudCcgaXMgZGVmaW5lZCwgYnV0IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgbnVsbCAoMjAxNS8wNi8wOCkuXG4gICAgICAgIHJldHVybiAoQnJvd3NlclBvbGxDb25uZWN0aW9uLmZvcmNlQWxsb3dfIHx8XG4gICAgICAgICAgICAoIUJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhdXRpbF8xLmlzQ2hyb21lRXh0ZW5zaW9uQ29udGVudFNjcmlwdCgpICYmXG4gICAgICAgICAgICAgICAgIXV0aWxfMS5pc1dpbmRvd3NTdG9yZUFwcCgpICYmXG4gICAgICAgICAgICAgICAgIXV0aWxfMy5pc05vZGVTZGsoKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTm8tb3AgZm9yIHBvbGxpbmdcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLm1hcmtDb25uZWN0aW9uSGVhbHRoeSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wcyBwb2xsaW5nIGFuZCBjbGVhbnMgdXAgdGhlIGlmcmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5zaHV0ZG93bl8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWRfID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc2NyaXB0VGFnSG9sZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdFRhZ0hvbGRlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zY3JpcHRUYWdIb2xkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vcmVtb3ZlIHRoZSBkaXNjb25uZWN0IGZyYW1lLCB3aGljaCB3aWxsIHRyaWdnZXIgYW4gWEhSIGNhbGwgdG8gdGhlIHNlcnZlciB0byB0ZWxsIGl0IHdlJ3JlIGxlYXZpbmcuXG4gICAgICAgIGlmICh0aGlzLm15RGlzY29ubkZyYW1lKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubXlEaXNjb25uRnJhbWUpO1xuICAgICAgICAgICAgdGhpcy5teURpc2Nvbm5GcmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8pIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0VGltZXJfKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRUaW1lcl8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHRyYW5zcG9ydCBpcyBjbG9zZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbi5wcm90b3R5cGUub25DbG9zZWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGNsb3NpbmcgaXRzZWxmJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25EaXNjb25uZWN0Xykge1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0Xyh0aGlzLmV2ZXJDb25uZWN0ZWRfKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdF8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFeHRlcm5hbC1mYWNpbmcgY2xvc2UgaGFuZGxlci4gUmVhbFRpbWUgaGFzIHJlcXVlc3RlZCB3ZSBzaHV0IGRvd24uIEtpbGwgb3VyIGNvbm5lY3Rpb24gYW5kIHRlbGwgdGhlIHNlcnZlclxuICAgICAqIHRoYXQgd2UndmUgbGVmdC5cbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWRfKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ18oJ0xvbmdwb2xsIGlzIGJlaW5nIGNsb3NlZC4nKTtcbiAgICAgICAgICAgIHRoaXMuc2h1dGRvd25fKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgdGhlIEpTT04gb2JqZWN0IGRvd24gdG8gdGhlIHNlcnZlci4gSXQgd2lsbCBuZWVkIHRvIGJlIHN0cmluZ2lmaWVkLCBiYXNlNjQgZW5jb2RlZCwgYW5kIHRoZW5cbiAgICAgKiBicm9rZW4gaW50byBjaHVua3MgKHNpbmNlIFVSTHMgaGF2ZSBhIHNtYWxsIG1heGltdW0gbGVuZ3RoKS5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgVGhlIEpTT04gZGF0YSB0byB0cmFuc21pdC5cbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVN0ciA9IHV0aWxfMi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19zZW50JywgZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAvL2ZpcnN0LCBsZXRzIGdldCB0aGUgYmFzZTY0LWVuY29kZWQgZGF0YVxuICAgICAgICB2YXIgYmFzZTY0ZGF0YSA9IHV0aWxfMi5iYXNlNjRFbmNvZGUoZGF0YVN0cik7XG4gICAgICAgIC8vV2UgY2FuIG9ubHkgZml0IGEgY2VydGFpbiBhbW91bnQgaW4gZWFjaCBVUkwsIHNvIHdlIG5lZWQgdG8gc3BsaXQgdGhpcyByZXF1ZXN0XG4gICAgICAgIC8vdXAgaW50byBtdWx0aXBsZSBwaWVjZXMgaWYgaXQgZG9lc24ndCBmaXQgaW4gb25lIHJlcXVlc3QuXG4gICAgICAgIHZhciBkYXRhU2VncyA9IHV0aWxfMS5zcGxpdFN0cmluZ0J5U2l6ZShiYXNlNjRkYXRhLCBNQVhfUEFZTE9BRF9TSVpFKTtcbiAgICAgICAgLy9FbnF1ZXVlIGVhY2ggc2VnbWVudCBmb3IgdHJhbnNtaXNzaW9uLiBXZSBhc3NpZ24gZWFjaCBjaHVuayBhIHNlcXVlbnRpYWwgSUQgYW5kIGEgdG90YWwgbnVtYmVyXG4gICAgICAgIC8vb2Ygc2VnbWVudHMgc28gdGhhdCB3ZSBjYW4gcmVhc3NlbWJsZSB0aGUgcGFja2V0IG9uIHRoZSBzZXJ2ZXIuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0VGFnSG9sZGVyLmVucXVldWVTZWdtZW50KHRoaXMuY3VyU2VnbWVudE51bSwgZGF0YVNlZ3MubGVuZ3RoLCBkYXRhU2Vnc1tpXSk7XG4gICAgICAgICAgICB0aGlzLmN1clNlZ21lbnROdW0rKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBob3cgd2Ugbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSBsZWF2aW5nLlxuICAgICAqIFdlIGFyZW4ndCBhYmxlIHRvIHNlbmQgcmVxdWVzdHMgd2l0aCBESFRNTCBvbiBhIHdpbmRvdyBjbG9zZSBldmVudCwgYnV0IHdlIGNhblxuICAgICAqIHRyaWdnZXIgWEhSIHJlcXVlc3RzIGluIHNvbWUgYnJvd3NlcnMgKGV2ZXJ5dGhpbmcgYnV0IE9wZXJhIGJhc2ljYWxseSkuXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcHdcbiAgICAgKi9cbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb24ucHJvdG90eXBlLmFkZERpc2Nvbm5lY3RQaW5nRnJhbWUgPSBmdW5jdGlvbiAoaWQsIHB3KSB7XG4gICAgICAgIGlmICh1dGlsXzMuaXNOb2RlU2RrKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9ESVNDT05OX0ZSQU1FX1JFUVVFU1RfUEFSQU1dID0gJ3QnO1xuICAgICAgICB1cmxQYXJhbXNbZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9JRF9QQVJBTV0gPSBpZDtcbiAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU1dID0gcHc7XG4gICAgICAgIHRoaXMubXlEaXNjb25uRnJhbWUuc3JjID0gdGhpcy51cmxGbih1cmxQYXJhbXMpO1xuICAgICAgICB0aGlzLm15RGlzY29ubkZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5teURpc2Nvbm5GcmFtZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHRyYWNrIHRoZSBieXRlcyByZWNlaXZlZCBieSB0aGlzIGNsaWVudFxuICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQnJvd3NlclBvbGxDb25uZWN0aW9uLnByb3RvdHlwZS5pbmNyZW1lbnRJbmNvbWluZ0J5dGVzXyA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYW4gYW5ub3lpbmcgcGVyZiBoaXQganVzdCB0byB0cmFjayB0aGUgbnVtYmVyIG9mIGluY29taW5nIGJ5dGVzLiAgTWF5YmUgaXQgc2hvdWxkIGJlIG9wdC1pbi5cbiAgICAgICAgdmFyIGJ5dGVzUmVjZWl2ZWQgPSB1dGlsXzIuc3RyaW5naWZ5KGFyZ3MpLmxlbmd0aDtcbiAgICAgICAgdGhpcy5ieXRlc1JlY2VpdmVkICs9IGJ5dGVzUmVjZWl2ZWQ7XG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgYnl0ZXNSZWNlaXZlZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQnJvd3NlclBvbGxDb25uZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuQnJvd3NlclBvbGxDb25uZWN0aW9uID0gQnJvd3NlclBvbGxDb25uZWN0aW9uO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQSB3cmFwcGVyIGFyb3VuZCBhbiBpZnJhbWUgdGhhdCBpcyB1c2VkIGFzIGEgbG9uZy1wb2xsaW5nIHNjcmlwdCBob2xkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbW1hbmRDQiAtIFRoZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBjb250cm9sIGNvbW1hbmRzIGFyZSByZWNldmllZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIG9uTWVzc2FnZUNCIC0gVGhlIGNhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHJlc3BvbnNlcyBhcnJpdmUgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSBvbkRpc2Nvbm5lY3QgLSBUaGUgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyB0YWcgaG9sZGVyIGlzIGNsb3NlZFxuICAgICAqIEBwYXJhbSB1cmxGbiAtIEEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyB0aGUgVVJMIG9mIHRoZSBlbmRwb2ludCB0byBzZW5kIGRhdGEgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIoY29tbWFuZENCLCBvbk1lc3NhZ2VDQiwgb25EaXNjb25uZWN0LCB1cmxGbikge1xuICAgICAgICB0aGlzLm9uRGlzY29ubmVjdCA9IG9uRGlzY29ubmVjdDtcbiAgICAgICAgdGhpcy51cmxGbiA9IHVybEZuO1xuICAgICAgICAvL1dlIG1haW50YWluIGEgY291bnQgb2YgYWxsIG9mIHRoZSBvdXRzdGFuZGluZyByZXF1ZXN0cywgYmVjYXVzZSBpZiB3ZSBoYXZlIHRvbyBtYW55IGFjdGl2ZSBhdCBvbmNlIGl0IGNhbiBjYXVzZVxuICAgICAgICAvL3Byb2JsZW1zIGluIHNvbWUgYnJvd3NlcnMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Q291bnRlZFNldC48bnVtYmVyLCBudW1iZXI+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzID0gbmV3IENvdW50ZWRTZXRfMS5Db3VudGVkU2V0KCk7XG4gICAgICAgIC8vQSBxdWV1ZSBvZiB0aGUgcGVuZGluZyBzZWdtZW50cyB3YWl0aW5nIGZvciB0cmFuc21pc3Npb24gdG8gdGhlIHNlcnZlci5cbiAgICAgICAgdGhpcy5wZW5kaW5nU2VncyA9IFtdO1xuICAgICAgICAvL0Egc2VyaWFsIG51bWJlci4gV2UgdXNlIHRoaXMgZm9yIHR3byB0aGluZ3M6XG4gICAgICAgIC8vIDEpIEEgd2F5IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBkb2Vzbid0IGNhY2hlIHJlc3BvbnNlcyB0byBwb2xsc1xuICAgICAgICAvLyAyKSBBIHdheSB0byBtYWtlIHRoZSBzZXJ2ZXIgYXdhcmUgd2hlbiBsb25nLXBvbGxzIGFycml2ZSBpbiBhIGRpZmZlcmVudCBvcmRlciB0aGFuIHdlIHN0YXJ0ZWQgdGhlbS4gVGhlXG4gICAgICAgIC8vICAgIHNlcnZlciBuZWVkcyB0byByZWxlYXNlIGJvdGggcG9sbHMgaW4gdGhpcyBjYXNlIG9yIGl0IHdpbGwgY2F1c2UgcHJvYmxlbXMgaW4gT3BlcmEgc2luY2UgT3BlcmEgY2FuIG9ubHkgZXhlY3V0ZVxuICAgICAgICAvLyAgICBKU09OUCBjb2RlIGluIHRoZSBvcmRlciBpdCB3YXMgYWRkZWQgdG8gdGhlIGlmcmFtZS5cbiAgICAgICAgdGhpcy5jdXJyZW50U2VyaWFsID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMDAwKTtcbiAgICAgICAgLy8gVGhpcyBnZXRzIHNldCB0byBmYWxzZSB3aGVuIHdlJ3JlIFwiY2xvc2luZyBkb3duXCIgdGhlIGNvbm5lY3Rpb24gKGUuZy4gd2UncmUgc3dpdGNoaW5nIHRyYW5zcG9ydHMgYnV0IHRoZXJlJ3Mgc3RpbGxcbiAgICAgICAgLy8gaW5jb21pbmcgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCB3ZSdyZSB3YWl0aW5nIGZvcikuXG4gICAgICAgIHRoaXMuc2VuZE5ld1BvbGxzID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF1dGlsXzMuaXNOb2RlU2RrKCkpIHtcbiAgICAgICAgICAgIC8vRWFjaCBzY3JpcHQgaG9sZGVyIHJlZ2lzdGVycyBhIGNvdXBsZSBvZiB1bmlxdWVseSBuYW1lZCBjYWxsYmFja3Mgd2l0aCB0aGUgd2luZG93LiBUaGVzZSBhcmUgY2FsbGVkIGZyb20gdGhlXG4gICAgICAgICAgICAvL2lmcmFtZXMgd2hlcmUgd2UgcHV0IHRoZSBsb25nLXBvbGxpbmcgc2NyaXB0IHRhZ3MuIFdlIGhhdmUgdHdvIGNhbGxiYWNrczpcbiAgICAgICAgICAgIC8vICAgMSkgQ29tbWFuZCBDYWxsYmFjayAtIFRyaWdnZXJlZCBmb3IgY29udHJvbCBpc3N1ZXMsIGxpa2Ugc3RhcnRpbmcgYSBjb25uZWN0aW9uLlxuICAgICAgICAgICAgLy8gICAyKSBNZXNzYWdlIENhbGxiYWNrIC0gVHJpZ2dlcmVkIHdoZW4gbmV3IGRhdGEgYXJyaXZlcy5cbiAgICAgICAgICAgIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyID0gdXRpbF8xLkxVSURHZW5lcmF0b3IoKTtcbiAgICAgICAgICAgIHdpbmRvd1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0NPTU1BTkRfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IGNvbW1hbmRDQjtcbiAgICAgICAgICAgIHdpbmRvd1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RBVEFfQ0JfTkFNRSArIHRoaXMudW5pcXVlQ2FsbGJhY2tJZGVudGlmaWVyXSA9IG9uTWVzc2FnZUNCO1xuICAgICAgICAgICAgLy9DcmVhdGUgYW4gaWZyYW1lIGZvciB1cyB0byBhZGQgc2NyaXB0IHRhZ3MgdG8uXG4gICAgICAgICAgICB0aGlzLm15SUZyYW1lID0gRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIuY3JlYXRlSUZyYW1lXygpO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBpZnJhbWUncyBjb250ZW50cy5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSAnJztcbiAgICAgICAgICAgIC8vIGlmIHdlIHNldCBhIGphdmFzY3JpcHQgdXJsLCBpdCdzIElFIGFuZCB3ZSBuZWVkIHRvIHNldCB0aGUgZG9jdW1lbnQgZG9tYWluLiBUaGUgamF2YXNjcmlwdCB1cmwgaXMgc3VmZmljaWVudFxuICAgICAgICAgICAgLy8gZm9yIGllOSwgYnV0IGllOCBuZWVkcyB0byBkbyBpdCBhZ2FpbiBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuICAgICAgICAgICAgaWYgKHRoaXMubXlJRnJhbWUuc3JjICYmXG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5zcmMuc3Vic3RyKDAsICdqYXZhc2NyaXB0OicubGVuZ3RoKSA9PT0gJ2phdmFzY3JpcHQ6Jykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50RG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9ICc8c2NyaXB0PmRvY3VtZW50LmRvbWFpbj1cIicgKyBjdXJyZW50RG9tYWluICsgJ1wiOzwvc2NyaXB0Pic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWZyYW1lQ29udGVudHMgPSAnPGh0bWw+PGJvZHk+JyArIHNjcmlwdCArICc8L2JvZHk+PC9odG1sPic7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubXlJRnJhbWUuZG9jLm9wZW4oKTtcbiAgICAgICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy53cml0ZShpZnJhbWVDb250ZW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5teUlGcmFtZS5kb2MuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmxvZygnZnJhbWUgd3JpdGluZyBleGNlcHRpb24nKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEubG9nKGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsXzEubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21tYW5kQ0IgPSBjb21tYW5kQ0I7XG4gICAgICAgICAgICB0aGlzLm9uTWVzc2FnZUNCID0gb25NZXNzYWdlQ0I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRWFjaCBicm93c2VyIGhhcyBpdHMgb3duIGZ1bm55IHdheSB0byBoYW5kbGUgaWZyYW1lcy4gSGVyZSB3ZSBtdXNoIHRoZW0gYWxsIHRvZ2V0aGVyIGludG8gb25lIG9iamVjdCB0aGF0IEkgY2FuXG4gICAgICogYWN0dWFsbHkgdXNlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5jcmVhdGVJRnJhbWVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBpbml0aWFsaXplIHRoZSBkb2N1bWVudCBpbnNpZGUgdGhlIGlmcmFtZVxuICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBJZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gbW9kaWZpZWQgaW4gSUUsIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciwgYW5kIHdlIG5lZWQgdG8gc2V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGRvbWFpbiBvZiB0aGUgaWZyYW1lJ3MgZG9jdW1lbnQgbWFudWFsbHkuIFdlIGNhbiBkbyB0aGlzIHZpYSBhIGphdmFzY3JpcHQ6IHVybCBhcyB0aGUgc3JjIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHdlIG11c3QgZG8gdGhpcyAqYWZ0ZXIqIHRoZSBpZnJhbWUgaGFzIGJlZW4gYXBwZW5kZWQgdG8gdGhlIHBhZ2UuIE90aGVyd2lzZSBpdCBkb2Vzbid0IHdvcmsuXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBvbG9naWVzIGZvciB0aGUgbG9nLXNwYW0sIEkgbmVlZCB0byBkbyBzb21ldGhpbmcgdG8ga2VlcCBjbG9zdXJlIGZyb20gb3B0aW1pemluZyBvdXQgdGhlIGFzc2lnbm1lbnQgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coJ05vIElFIGRvbWFpbiBzZXR0aW5nIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gZG9jdW1lbnQuZG9tYWluO1xuICAgICAgICAgICAgICAgIGlmcmFtZS5zcmMgPVxuICAgICAgICAgICAgICAgICAgICBcImphdmFzY3JpcHQ6dm9pZCgoZnVuY3Rpb24oKXtkb2N1bWVudC5vcGVuKCk7ZG9jdW1lbnQuZG9tYWluPSdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBkb21haW4gK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInO2RvY3VtZW50LmNsb3NlKCk7fSkoKSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIExvbmdQb2xsQ29ubmVjdGlvbiBhdHRlbXB0cyB0byBkZWxheSBpbml0aWFsaXphdGlvbiB1bnRpbCB0aGUgZG9jdW1lbnQgaXMgcmVhZHksIHNvIGhvcGVmdWxseSB0aGlzXG4gICAgICAgICAgICAvLyBuZXZlciBnZXRzIGhpdC5cbiAgICAgICAgICAgIHRocm93ICdEb2N1bWVudCBib2R5IGhhcyBub3QgaW5pdGlhbGl6ZWQuIFdhaXQgdG8gaW5pdGlhbGl6ZSBGaXJlYmFzZSB1bnRpbCBhZnRlciB0aGUgZG9jdW1lbnQgaXMgcmVhZHkuJztcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGRvY3VtZW50IG9mIHRoZSBpZnJhbWUgaW4gYSBicm93c2VyLXNwZWNpZmljIHdheS5cbiAgICAgICAgaWYgKGlmcmFtZS5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50OyAvLyBGaXJlZm94LCBPcGVyYSwgU2FmYXJpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZnJhbWUuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmcmFtZS5kb2MgPSBpZnJhbWUuZG9jdW1lbnQ7IC8vb3RoZXJzP1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZnJhbWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYWxsIG91dHN0YW5kaW5nIHF1ZXJpZXMgYW5kIHJlbW92ZSB0aGUgZnJhbWUuXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvL01hcmsgdGhpcyBpZnJhbWUgYXMgZGVhZCwgc28gbm8gbmV3IHJlcXVlc3RzIGFyZSBzZW50LlxuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLm15SUZyYW1lKSB7XG4gICAgICAgICAgICAvL1dlIGhhdmUgdG8gYWN0dWFsbHkgcmVtb3ZlIGFsbCBvZiB0aGUgaHRtbCBpbnNpZGUgdGhpcyBpZnJhbWUgYmVmb3JlIHJlbW92aW5nIGl0IGZyb20gdGhlXG4gICAgICAgICAgICAvL3dpbmRvdywgb3IgSUUgd2lsbCBjb250aW51ZSBsb2FkaW5nIGFuZCBleGVjdXRpbmcgdGhlIHNjcmlwdCB0YWdzIHdlJ3ZlIGFscmVhZHkgYWRkZWQsIHdoaWNoXG4gICAgICAgICAgICAvL2NhbiBsZWFkIHRvIHNvbWUgZXJyb3JzIGJlaW5nIHRocm93bi4gU2V0dGluZyBpbm5lckhUTUwgc2VlbXMgdG8gYmUgdGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMuXG4gICAgICAgICAgICB0aGlzLm15SUZyYW1lLmRvYy5ib2R5LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm15SUZyYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoX3RoaXMubXlJRnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5teUlGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWxfMy5pc05vZGVTZGsoKSAmJiB0aGlzLm15SUQpIHtcbiAgICAgICAgICAgIHZhciB1cmxQYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIHVybFBhcmFtc1tleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX0RJU0NPTk5fRlJBTUVfUEFSQU1dID0gJ3QnO1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gdGhpcy5teUlEO1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU1dID0gdGhpcy5teVBXO1xuICAgICAgICAgICAgdmFyIHRoZVVSTCA9IHRoaXMudXJsRm4odXJsUGFyYW1zKTtcbiAgICAgICAgICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLm5vZGVSZXN0UmVxdWVzdCh0aGVVUkwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3RlY3QgZnJvbSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkuXG4gICAgICAgIHZhciBvbkRpc2Nvbm5lY3QgPSB0aGlzLm9uRGlzY29ubmVjdDtcbiAgICAgICAgaWYgKG9uRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBudWxsO1xuICAgICAgICAgICAgb25EaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFjdHVhbGx5IHN0YXJ0IHRoZSBsb25nLXBvbGxpbmcgc2Vzc2lvbiBieSBhZGRpbmcgdGhlIGZpcnN0IHNjcmlwdCB0YWcocykgdG8gdGhlIGlmcmFtZS5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoaXMgY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gcHcgLSBUaGUgcGFzc3dvcmQgZm9yIHRoaXMgY29ubmVjdGlvblxuICAgICAqL1xuICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLnByb3RvdHlwZS5zdGFydExvbmdQb2xsID0gZnVuY3Rpb24gKGlkLCBwdykge1xuICAgICAgICB0aGlzLm15SUQgPSBpZDtcbiAgICAgICAgdGhpcy5teVBXID0gcHc7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICAvL3NlbmQgdGhlIGluaXRpYWwgcmVxdWVzdC4gSWYgdGhlcmUgYXJlIHJlcXVlc3RzIHF1ZXVlZCwgbWFrZSBzdXJlIHRoYXQgd2UgdHJhbnNtaXQgYXMgbWFueSBhcyB3ZSBhcmUgY3VycmVudGx5IGFibGUgdG8uXG4gICAgICAgIHdoaWxlICh0aGlzLm5ld1JlcXVlc3RfKCkpIHsgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYW55IHRpbWUgc29tZW9uZSBtaWdodCB3YW50IGEgc2NyaXB0IHRhZyB0byBiZSBhZGRlZC4gSXQgYWRkcyBhIHNjcmlwdCB0YWcgd2hlbiB0aGVyZSBhcmVuJ3RcbiAgICAgKiB0b28gbWFueSBvdXRzdGFuZGluZyByZXF1ZXN0cyBhbmQgd2UgYXJlIHN0aWxsIGFsaXZlLlxuICAgICAqXG4gICAgICogSWYgdGhlcmUgYXJlIG91dHN0YW5kaW5nIHBhY2tldCBzZWdtZW50cyB0byBzZW5kLCBpdCBzZW5kcyBvbmUuIElmIHRoZXJlIGFyZW4ndCwgaXQgc2VuZHMgYSBsb25nLXBvbGwgYW55d2F5cyBpZlxuICAgICAqIG5lZWRlZC5cbiAgICAgKi9cbiAgICBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlci5wcm90b3R5cGUubmV3UmVxdWVzdF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGtlZXAgb25lIG91dHN0YW5kaW5nIHJlcXVlc3Qgb3BlbiBhbGwgdGhlIHRpbWUgdG8gcmVjZWl2ZSBkYXRhLCBidXQgaWYgd2UgbmVlZCB0byBzZW5kIGRhdGFcbiAgICAgICAgLy8gKHBlbmRpbmdTZWdzLmxlbmd0aCA+IDApIHRoZW4gd2UgY3JlYXRlIGEgbmV3IHJlcXVlc3QgdG8gc2VuZCB0aGUgZGF0YS4gIFRoZSBzZXJ2ZXIgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGNsb3NlIHRoZSBvbGQgcmVxdWVzdC5cbiAgICAgICAgaWYgKHRoaXMuYWxpdmUgJiZcbiAgICAgICAgICAgIHRoaXMuc2VuZE5ld1BvbGxzICYmXG4gICAgICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuY291bnQoKSA8ICh0aGlzLnBlbmRpbmdTZWdzLmxlbmd0aCA+IDAgPyAyIDogMSkpIHtcbiAgICAgICAgICAgIC8vY29uc3RydWN0IG91ciB1cmxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlcmlhbCsrO1xuICAgICAgICAgICAgdmFyIHVybFBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfSURfUEFSQU1dID0gdGhpcy5teUlEO1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfUFdfUEFSQU1dID0gdGhpcy5teVBXO1xuICAgICAgICAgICAgdXJsUGFyYW1zW2V4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfU0VSSUFMX1BBUkFNXSA9IHRoaXMuY3VycmVudFNlcmlhbDtcbiAgICAgICAgICAgIHZhciB0aGVVUkwgPSB0aGlzLnVybEZuKHVybFBhcmFtcyk7XG4gICAgICAgICAgICAvL05vdyBhZGQgYXMgbXVjaCBkYXRhIGFzIHdlIGNhbi5cbiAgICAgICAgICAgIHZhciBjdXJEYXRhU3RyaW5nID0gJyc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wZW5kaW5nU2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy9maXJzdCwgbGV0cyBzZWUgaWYgdGhlIG5leHQgc2VnbWVudCB3aWxsIGZpdC5cbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNlZyA9IHRoaXMucGVuZGluZ1NlZ3NbMF07XG4gICAgICAgICAgICAgICAgaWYgKG5leHRTZWcuZC5sZW5ndGggKyBTRUdfSEVBREVSX1NJWkUgKyBjdXJEYXRhU3RyaW5nLmxlbmd0aCA8PVxuICAgICAgICAgICAgICAgICAgICBNQVhfVVJMX0RBVEFfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAvL2dyZWF0LCB0aGUgc2VnbWVudCB3aWxsIGZpdC4gTGV0cyBhcHBlbmQgaXQuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVTZWcgPSB0aGlzLnBlbmRpbmdTZWdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRhdGFTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyRGF0YVN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBvcnRzLkZJUkVCQVNFX0xPTkdQT0xMX1NFR01FTlRfTlVNX1BBUkFNICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZVNlZy5zZWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5GSVJFQkFTRV9MT05HUE9MTF9TRUdNRU5UU19JTl9QQUNLRVQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc9JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlU2VnLnRzICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMuRklSRUJBU0VfTE9OR1BPTExfREFUQV9QQVJBTSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJz0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVTZWcuZDtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlVVJMID0gdGhlVVJMICsgY3VyRGF0YVN0cmluZztcbiAgICAgICAgICAgIHRoaXMuYWRkTG9uZ1BvbGxUYWdfKHRoZVVSTCwgdGhpcy5jdXJyZW50U2VyaWFsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBRdWV1ZSBhIHBhY2tldCBmb3IgdHJhbnNtaXNzaW9uIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHNlZ251bSAtIEEgc2VxdWVudGlhbCBpZCBmb3IgdGhpcyBwYWNrZXQgc2VnbWVudCB1c2VkIGZvciByZWFzc2VtYmx5XG4gICAgICogQHBhcmFtIHRvdGFsc2VncyAtIFRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYWNrZXRcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGlzIHNlZ21lbnQuXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmVucXVldWVTZWdtZW50ID0gZnVuY3Rpb24gKHNlZ251bSwgdG90YWxzZWdzLCBkYXRhKSB7XG4gICAgICAgIC8vYWRkIHRoaXMgdG8gdGhlIHF1ZXVlIG9mIHNlZ21lbnRzIHRvIHNlbmQuXG4gICAgICAgIHRoaXMucGVuZGluZ1NlZ3MucHVzaCh7IHNlZzogc2VnbnVtLCB0czogdG90YWxzZWdzLCBkOiBkYXRhIH0pO1xuICAgICAgICAvL3NlbmQgdGhlIGRhdGEgaW1tZWRpYXRlbHkgaWYgdGhlcmUgaXNuJ3QgYWxyZWFkeSBkYXRhIGJlaW5nIHRyYW5zbWl0dGVkLCB1bmxlc3NcbiAgICAgICAgLy9zdGFydExvbmdQb2xsIGhhc24ndCBiZWVuIGNhbGxlZCB5ZXQuXG4gICAgICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICAgICAgICB0aGlzLm5ld1JlcXVlc3RfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHNjcmlwdCB0YWcgZm9yIGEgcmVndWxhciBsb25nLXBvbGwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIHNjcmlwdCB0YWcuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBzZXJpYWwgLSBUaGUgc2VyaWFsIG51bWJlciBvZiB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyLnByb3RvdHlwZS5hZGRMb25nUG9sbFRhZ18gPSBmdW5jdGlvbiAodXJsLCBzZXJpYWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy9yZW1lbWJlciB0aGF0IHdlIHNlbnQgdGhpcyByZXF1ZXN0LlxuICAgICAgICB0aGlzLm91dHN0YW5kaW5nUmVxdWVzdHMuYWRkKHNlcmlhbCwgMSk7XG4gICAgICAgIHZhciBkb05ld1JlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vdXRzdGFuZGluZ1JlcXVlc3RzLnJlbW92ZShzZXJpYWwpO1xuICAgICAgICAgICAgX3RoaXMubmV3UmVxdWVzdF8oKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhpcyByZXF1ZXN0IGRvZXNuJ3QgcmV0dXJuIG9uIGl0cyBvd24gYWNjb3JkIChieSB0aGUgc2VydmVyIHNlbmRpbmcgdXMgc29tZSBkYXRhKSwgd2UnbGxcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9uZSBhZnRlciB0aGUgS0VFUEFMSVZFIGludGVydmFsIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMga2VlcCBhIGZyZXNoIHJlcXVlc3Qgb3Blbi5cbiAgICAgICAgdmFyIGtlZXBhbGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvTmV3UmVxdWVzdCwgTWF0aC5mbG9vcihLRUVQQUxJVkVfUkVRVUVTVF9JTlRFUlZBTCkpO1xuICAgICAgICB2YXIgcmVhZHlTdGF0ZUNCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCBjb21wbGV0ZWQuICBDYW5jZWwgdGhlIGtlZXBhbGl2ZS5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dChrZWVwYWxpdmVUaW1lb3V0KTtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgYSBuZXcgcmVxdWVzdCBzbyB3ZSBjYW4gY29udGludWUgcmVjZWl2aW5nIGRhdGEuXG4gICAgICAgICAgICBkb05ld1JlcXVlc3QoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRUYWcodXJsLCByZWFkeVN0YXRlQ0IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGFyYml0cmFyeSBzY3JpcHQgdGFnIHRvIHRoZSBpZnJhbWUuXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSB1cmwgLSBUaGUgVVJMIGZvciB0aGUgc2NyaXB0IHRhZyBzb3VyY2UuXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbG9hZENCIC0gQSBjYWxsYmFjayB0byBiZSB0cmlnZ2VyZWQgb25jZSB0aGUgc2NyaXB0IGhhcyBsb2FkZWQuXG4gICAgICovXG4gICAgRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXIucHJvdG90eXBlLmFkZFRhZyA9IGZ1bmN0aW9uICh1cmwsIGxvYWRDQikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodXRpbF8zLmlzTm9kZVNkaygpKSB7XG4gICAgICAgICAgICB0aGlzLmRvTm9kZUxvbmdQb2xsKHVybCwgbG9hZENCKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGFscmVhZHkgY2xvc2VkLCBkb24ndCBhZGQgdGhpcyBwb2xsXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuc2VuZE5ld1BvbGxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2NyaXB0XzEgPSBfdGhpcy5teUlGcmFtZS5kb2MuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5zcmMgPSB1cmw7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLm9ubG9hZCA9IG5ld1NjcmlwdF8xLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByc3RhdGUgPSBuZXdTY3JpcHRfMS5yZWFkeVN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyc3RhdGUgfHwgcnN0YXRlID09PSAnbG9hZGVkJyB8fCByc3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTY3JpcHRfMS5vbmxvYWQgPSBuZXdTY3JpcHRfMS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdTY3JpcHRfMS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjcmlwdF8xLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobmV3U2NyaXB0XzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkQ0IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbmV3U2NyaXB0XzEub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coJ0xvbmctcG9sbCBzY3JpcHQgZmFpbGVkIHRvIGxvYWQ6ICcgKyB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2VuZE5ld1BvbGxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5teUlGcmFtZS5kb2MuYm9keS5hcHBlbmRDaGlsZChuZXdTY3JpcHRfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBtYWtlIHRoaXMgZXJyb3IgdmlzaWJsZSBzb21laG93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgTWF0aC5mbG9vcigxKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaXJlYmFzZUlGcmFtZVNjcmlwdEhvbGRlcjtcbn0oKSk7XG5leHBvcnRzLkZpcmViYXNlSUZyYW1lU2NyaXB0SG9sZGVyID0gRmlyZWJhc2VJRnJhbWVTY3JpcHRIb2xkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJQb2xsQ29ubmVjdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvcmVhbHRpbWUvQnJvd3NlclBvbGxDb25uZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcHBfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvYXBwXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsL3V0aWxcIik7XG52YXIgU3RhdHNNYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9zdGF0cy9TdGF0c01hbmFnZXJcIik7XG52YXIgQ29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9Db25zdGFudHNcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHN0b3JhZ2VfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL3N0b3JhZ2Uvc3RvcmFnZVwiKTtcbnZhciB1dGlsXzQgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF81ID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFdFQlNPQ0tFVF9NQVhfRlJBTUVfU0laRSA9IDE2Mzg0O1xudmFyIFdFQlNPQ0tFVF9LRUVQQUxJVkVfSU5URVJWQUwgPSA0NTAwMDtcbnZhciBXZWJTb2NrZXRJbXBsID0gbnVsbDtcbmlmICh0eXBlb2YgTW96V2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIFdlYlNvY2tldEltcGwgPSBNb3pXZWJTb2NrZXQ7XG59XG5lbHNlIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIFdlYlNvY2tldEltcGwgPSBXZWJTb2NrZXQ7XG59XG5mdW5jdGlvbiBzZXRXZWJTb2NrZXRJbXBsKGltcGwpIHtcbiAgICBXZWJTb2NrZXRJbXBsID0gaW1wbDtcbn1cbmV4cG9ydHMuc2V0V2ViU29ja2V0SW1wbCA9IHNldFdlYlNvY2tldEltcGw7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtUcmFuc3BvcnR9XG4gKi9cbnZhciBXZWJTb2NrZXRDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb25uSWQgaWRlbnRpZmllciBmb3IgdGhpcyB0cmFuc3BvcnRcbiAgICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdlYlNvY2tldENvbm5lY3Rpb24oY29ubklkLCByZXBvSW5mbywgdHJhbnNwb3J0U2Vzc2lvbklkLCBsYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgIHRoaXMuY29ubklkID0gY29ubklkO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gMDtcbiAgICAgICAgdGhpcy5ieXRlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLmxvZ18gPSB1dGlsXzIubG9nV3JhcHBlcih0aGlzLmNvbm5JZCk7XG4gICAgICAgIHRoaXMuc3RhdHNfID0gU3RhdHNNYW5hZ2VyXzEuU3RhdHNNYW5hZ2VyLmdldENvbGxlY3Rpb24ocmVwb0luZm8pO1xuICAgICAgICB0aGlzLmNvbm5VUkwgPSBXZWJTb2NrZXRDb25uZWN0aW9uLmNvbm5lY3Rpb25VUkxfKHJlcG9JbmZvLCB0cmFuc3BvcnRTZXNzaW9uSWQsIGxhc3RTZXNzaW9uSWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1JlcG9JbmZvfSByZXBvSW5mbyBUaGUgaW5mbyBmb3IgdGhlIHdlYnNvY2tldCBlbmRwb2ludC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHRyYW5zcG9ydFNlc3Npb25JZCBPcHRpb25hbCB0cmFuc3BvcnRTZXNzaW9uSWQgaWYgdGhpcyBpcyBjb25uZWN0aW5nIHRvIGFuIGV4aXN0aW5nIHRyYW5zcG9ydFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBsYXN0U2Vzc2lvbklkIE9wdGlvbmFsIGxhc3RTZXNzaW9uSWQgaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gY29ubmVjdGlvbiB1cmxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uY29ubmVjdGlvblVSTF8gPSBmdW5jdGlvbiAocmVwb0luZm8sIHRyYW5zcG9ydFNlc3Npb25JZCwgbGFzdFNlc3Npb25JZCkge1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0ge307XG4gICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5WRVJTSU9OX1BBUkFNXSA9IENvbnN0YW50c18xLlBST1RPQ09MX1ZFUlNJT047XG4gICAgICAgIGlmICghdXRpbF81LmlzTm9kZVNkaygpICYmXG4gICAgICAgICAgICB0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBsb2NhdGlvbi5ocmVmICYmXG4gICAgICAgICAgICBsb2NhdGlvbi5ocmVmLmluZGV4T2YoQ29uc3RhbnRzXzEuRk9SR0VfRE9NQUlOKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVybFBhcmFtc1tDb25zdGFudHNfMS5SRUZFUkVSX1BBUkFNXSA9IENvbnN0YW50c18xLkZPUkdFX1JFRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNwb3J0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuVFJBTlNQT1JUX1NFU1NJT05fUEFSQU1dID0gdHJhbnNwb3J0U2Vzc2lvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0U2Vzc2lvbklkKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXNbQ29uc3RhbnRzXzEuTEFTVF9TRVNTSU9OX1BBUkFNXSA9IGxhc3RTZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcG9JbmZvLmNvbm5lY3Rpb25VUkwoQ29uc3RhbnRzXzEuV0VCU09DS0VULCB1cmxQYXJhbXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb25NZXNzYWdlIENhbGxiYWNrIHdoZW4gbWVzc2FnZXMgYXJyaXZlXG4gICAgICogQHBhcmFtIG9uRGlzY29ubmVjdCBDYWxsYmFjayB3aXRoIGNvbm5lY3Rpb24gbG9zdC5cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKG9uTWVzc2FnZSwgb25EaXNjb25uZWN0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gb25EaXNjb25uZWN0O1xuICAgICAgICB0aGlzLm9uTWVzc2FnZSA9IG9uTWVzc2FnZTtcbiAgICAgICAgdGhpcy5sb2dfKCdXZWJzb2NrZXQgY29ubmVjdGluZyB0byAnICsgdGhpcy5jb25uVVJMKTtcbiAgICAgICAgdGhpcy5ldmVyQ29ubmVjdGVkXyA9IGZhbHNlO1xuICAgICAgICAvLyBBc3N1bWUgZmFpbHVyZSB1bnRpbCBwcm92ZW4gb3RoZXJ3aXNlLlxuICAgICAgICBzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2Uuc2V0KCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScsIHRydWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHV0aWxfNS5pc05vZGVTZGsoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXZpY2UgPSB1dGlsXzMuQ09OU1RBTlRTLk5PREVfQURNSU4gPyAnQWRtaW5Ob2RlJyA6ICdOb2RlJztcbiAgICAgICAgICAgICAgICAvLyBVQSBGb3JtYXQ6IEZpcmViYXNlLzx3aXJlX3Byb3RvY29sPi88c2RrX3ZlcnNpb24+LzxwbGF0Zm9ybT4vPGRldmljZT5cbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzZXItQWdlbnQnOiBcIkZpcmViYXNlL1wiICsgQ29uc3RhbnRzXzEuUFJPVE9DT0xfVkVSU0lPTiArIFwiL1wiICsgYXBwXzEuZGVmYXVsdC5TREtfVkVSU0lPTiArIFwiL1wiICsgcHJvY2Vzcy5wbGF0Zm9ybSArIFwiL1wiICsgZGV2aWNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIFBsdW1iIGFwcHJvcHJpYXRlIGh0dHBfcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgaW50byBmYXllLXdlYnNvY2tldCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgdmFyIGVudiA9IHByb2Nlc3NbJ2VudiddO1xuICAgICAgICAgICAgICAgIHZhciBwcm94eSA9IHRoaXMuY29ublVSTC5pbmRleE9mKCd3c3M6Ly8nKSA9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gZW52WydIVFRQU19QUk9YWSddIHx8IGVudlsnaHR0cHNfcHJveHknXVxuICAgICAgICAgICAgICAgICAgICA6IGVudlsnSFRUUF9QUk9YWSddIHx8IGVudlsnaHR0cF9wcm94eSddO1xuICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zWydwcm94eSddID0geyBvcmlnaW46IHByb3h5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubXlTb2NrID0gbmV3IFdlYlNvY2tldEltcGwodGhpcy5jb25uVVJMLCBbXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm15U29jayA9IG5ldyBXZWJTb2NrZXRJbXBsKHRoaXMuY29ublVSTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnRXJyb3IgaW5zdGFudGlhdGluZyBXZWJTb2NrZXQuJyk7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBlLm1lc3NhZ2UgfHwgZS5kYXRhO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dfKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25DbG9zZWRfKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5teVNvY2sub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMubG9nXygnV2Vic29ja2V0IGNvbm5lY3RlZC4nKTtcbiAgICAgICAgICAgIF90aGlzLmV2ZXJDb25uZWN0ZWRfID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5teVNvY2sub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1dlYnNvY2tldCBjb25uZWN0aW9uIHdhcyBkaXNjb25uZWN0ZWQuJyk7XG4gICAgICAgICAgICBfdGhpcy5teVNvY2sgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMub25DbG9zZWRfKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubXlTb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVJbmNvbWluZ0ZyYW1lKG0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm15U29jay5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1dlYlNvY2tldCBlcnJvci4gIENsb3NpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IGUubWVzc2FnZSB8fCBlLmRhdGE7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2dfKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLm9uQ2xvc2VkXygpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTm8tb3AgZm9yIHdlYnNvY2tldHMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBjb25maXJtZWQgYXMgb3BlblxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgV2ViU29ja2V0Q29ubmVjdGlvbi5mb3JjZURpc2FsbG93XyA9IHRydWU7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXNPbGRBbmRyb2lkID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgICAgICAgICB2YXIgb2xkQW5kcm9pZFJlZ2V4ID0gL0FuZHJvaWQgKFswLTldezAsfVxcLlswLTldezAsfSkvO1xuICAgICAgICAgICAgdmFyIG9sZEFuZHJvaWRNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2gob2xkQW5kcm9pZFJlZ2V4KTtcbiAgICAgICAgICAgIGlmIChvbGRBbmRyb2lkTWF0Y2ggJiYgb2xkQW5kcm9pZE1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChvbGRBbmRyb2lkTWF0Y2hbMV0pIDwgNC40KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzT2xkQW5kcm9pZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoIWlzT2xkQW5kcm9pZCAmJlxuICAgICAgICAgICAgV2ViU29ja2V0SW1wbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgIVdlYlNvY2tldENvbm5lY3Rpb24uZm9yY2VEaXNhbGxvd18pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHdlIHByZXZpb3VzbHkgZmFpbGVkIHRvIGNvbm5lY3Qgd2l0aCB0aGlzIHRyYW5zcG9ydC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJldmlvdXNseUZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSWYgb3VyIHBlcnNpc3RlbnQgc3RvcmFnZSBpcyBhY3R1YWxseSBvbmx5IGluLW1lbW9yeSBzdG9yYWdlLFxuICAgICAgICAvLyB3ZSBkZWZhdWx0IHRvIGFzc3VtaW5nIHRoYXQgaXQgcHJldmlvdXNseSBmYWlsZWQgdG8gYmUgc2FmZS5cbiAgICAgICAgcmV0dXJuIChzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2UuaXNJbk1lbW9yeVN0b3JhZ2UgfHxcbiAgICAgICAgICAgIHN0b3JhZ2VfMS5QZXJzaXN0ZW50U3RvcmFnZS5nZXQoJ3ByZXZpb3VzX3dlYnNvY2tldF9mYWlsdXJlJykgPT09IHRydWUpO1xuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUubWFya0Nvbm5lY3Rpb25IZWFsdGh5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdG9yYWdlXzEuUGVyc2lzdGVudFN0b3JhZ2UucmVtb3ZlKCdwcmV2aW91c193ZWJzb2NrZXRfZmFpbHVyZScpO1xuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuYXBwZW5kRnJhbWVfID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5mcmFtZXMucHVzaChkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVzLmxlbmd0aCA9PSB0aGlzLnRvdGFsRnJhbWVzKSB7XG4gICAgICAgICAgICB2YXIgZnVsbE1lc3MgPSB0aGlzLmZyYW1lcy5qb2luKCcnKTtcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBqc29uTWVzcyA9IHV0aWxfNC5qc29uRXZhbChmdWxsTWVzcyk7XG4gICAgICAgICAgICAvL2hhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoanNvbk1lc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVDb3VudCBUaGUgbnVtYmVyIG9mIGZyYW1lcyB3ZSBhcmUgZXhwZWN0aW5nIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuaGFuZGxlTmV3RnJhbWVDb3VudF8gPSBmdW5jdGlvbiAoZnJhbWVDb3VudCkge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gZnJhbWVDb3VudDtcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHBhcnNlIGEgZnJhbWUgY291bnQgb3V0IG9mIHNvbWUgdGV4dC4gSWYgaXQgY2FuJ3QsIGFzc3VtZXMgYSB2YWx1ZSBvZiAxXG4gICAgICogQHBhcmFtIHshU3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybiB7P1N0cmluZ30gQW55IHJlbWFpbmluZyBkYXRhIHRvIGJlIHByb2Nlc3MsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuZXh0cmFjdEZyYW1lQ291bnRfID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0aGlzLmZyYW1lcyA9PT0gbnVsbCwgJ1dlIGFscmVhZHkgaGF2ZSBhIGZyYW1lIGJ1ZmZlcicpO1xuICAgICAgICAvLyBUT0RPOiBUaGUgc2VydmVyIGlzIG9ubHkgc3VwcG9zZWQgdG8gc2VuZCB1cCB0byA5OTk5IGZyYW1lcyAoaS5lLiBsZW5ndGggPD0gNCksIGJ1dCB0aGF0IGlzbid0IGJlaW5nIGVuZm9yY2VkXG4gICAgICAgIC8vIGN1cnJlbnRseS4gIFNvIGFsbG93aW5nIGxhcmdlciBmcmFtZSBjb3VudHMgKGxlbmd0aCA8PSA2KS4gIFNlZSBodHRwczovL2FwcC5hc2FuYS5jb20vMC9zZWFyY2gvODY4ODU5ODk5ODM4MC84MjM3NjA4MDQyNTA4XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSA2KSB7XG4gICAgICAgICAgICB2YXIgZnJhbWVDb3VudCA9IE51bWJlcihkYXRhKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oZnJhbWVDb3VudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU5ld0ZyYW1lQ291bnRfKGZyYW1lQ291bnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlTmV3RnJhbWVDb3VudF8oMSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHdlYnNvY2tldCBmcmFtZSB0aGF0IGhhcyBhcnJpdmVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gbWVzcyBUaGUgZnJhbWUgZGF0YVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24ucHJvdG90eXBlLmhhbmRsZUluY29taW5nRnJhbWUgPSBmdW5jdGlvbiAobWVzcykge1xuICAgICAgICBpZiAodGhpcy5teVNvY2sgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47IC8vIENocm9tZSBhcHBhcmVudGx5IGRlbGl2ZXJzIGluY29taW5nIHBhY2tldHMgZXZlbiBhZnRlciB3ZSAuY2xvc2UoKSB0aGUgY29ubmVjdGlvbiBzb21ldGltZXMuXG4gICAgICAgIHZhciBkYXRhID0gbWVzc1snZGF0YSddO1xuICAgICAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIHRoaXMuc3RhdHNfLmluY3JlbWVudENvdW50ZXIoJ2J5dGVzX3JlY2VpdmVkJywgZGF0YS5sZW5ndGgpO1xuICAgICAgICB0aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG4gICAgICAgIGlmICh0aGlzLmZyYW1lcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2UncmUgYnVmZmVyaW5nXG4gICAgICAgICAgICB0aGlzLmFwcGVuZEZyYW1lXyhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRyeSB0byBwYXJzZSBvdXQgYSBmcmFtZSBjb3VudCwgb3RoZXJ3aXNlLCBhc3N1bWUgMSBhbmQgcHJvY2VzcyBpdFxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0RhdGEgPSB0aGlzLmV4dHJhY3RGcmFtZUNvdW50XyhkYXRhKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRGcmFtZV8ocmVtYWluaW5nRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgSlNPTiBvYmplY3QgdG8gdHJhbnNtaXRcbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNldEtlZXBBbGl2ZSgpO1xuICAgICAgICB2YXIgZGF0YVN0ciA9IHV0aWxfNC5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIHRoaXMuYnl0ZXNTZW50ICs9IGRhdGFTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRzXy5pbmNyZW1lbnRDb3VudGVyKCdieXRlc19zZW50JywgZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAvL1dlIGNhbiBvbmx5IGZpdCBhIGNlcnRhaW4gYW1vdW50IGluIGVhY2ggd2Vic29ja2V0IGZyYW1lLCBzbyB3ZSBuZWVkIHRvIHNwbGl0IHRoaXMgcmVxdWVzdFxuICAgICAgICAvL3VwIGludG8gbXVsdGlwbGUgcGllY2VzIGlmIGl0IGRvZXNuJ3QgZml0IGluIG9uZSByZXF1ZXN0LlxuICAgICAgICB2YXIgZGF0YVNlZ3MgPSB1dGlsXzIuc3BsaXRTdHJpbmdCeVNpemUoZGF0YVN0ciwgV0VCU09DS0VUX01BWF9GUkFNRV9TSVpFKTtcbiAgICAgICAgLy9TZW5kIHRoZSBsZW5ndGggaGVhZGVyXG4gICAgICAgIGlmIChkYXRhU2Vncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKFN0cmluZyhkYXRhU2Vncy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICAvL1NlbmQgdGhlIGFjdHVhbCBkYXRhIGluIHNlZ21lbnRzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFTZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdHJpbmdfKGRhdGFTZWdzW2ldKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2h1dGRvd25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkXyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMua2VlcGFsaXZlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubXlTb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm15U29jay5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5teVNvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5vbkNsb3NlZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZF8pIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnV2ViU29ja2V0IGlzIGNsb3NpbmcgaXRzZWxmJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhbiBpbnRlcm5hbCBjbG9zZSwgdHJpZ2dlciB0aGUgY2xvc2UgbGlzdGVuZXJcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0KHRoaXMuZXZlckNvbm5lY3RlZF8pO1xuICAgICAgICAgICAgICAgIHRoaXMub25EaXNjb25uZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWwtZmFjaW5nIGNsb3NlIGhhbmRsZXIuXG4gICAgICogQ2xvc2UgdGhlIHdlYnNvY2tldCBhbmQga2lsbCB0aGUgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2xvc2VkXykge1xuICAgICAgICAgICAgdGhpcy5sb2dfKCdXZWJTb2NrZXQgaXMgYmVpbmcgY2xvc2VkJyk7XG4gICAgICAgICAgICB0aGlzLnNodXRkb3duXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBLaWxsIHRoZSBjdXJyZW50IGtlZXBhbGl2ZSB0aW1lciBhbmQgc3RhcnQgYSBuZXcgb25lLCB0byBlbnN1cmUgdGhhdCBpdCBhbHdheXMgZmlyZXMgTiBzZWNvbmRzIGFmdGVyXG4gICAgICogdGhlIGxhc3QgYWN0aXZpdHkuXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUucmVzZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwYWxpdmVUaW1lcik7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvL0lmIHRoZXJlIGhhcyBiZWVuIG5vIHdlYnNvY2tldCBhY3Rpdml0eSBmb3IgYSB3aGlsZSwgc2VuZCBhIG5vLW9wXG4gICAgICAgICAgICBpZiAoX3RoaXMubXlTb2NrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFN0cmluZ18oJzAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlc2V0S2VlcEFsaXZlKCk7XG4gICAgICAgIH0sIE1hdGguZmxvb3IoV0VCU09DS0VUX0tFRVBBTElWRV9JTlRFUlZBTCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHN0cmluZyBvdmVyIHRoZSB3ZWJzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBzZW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV2ViU29ja2V0Q29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZFN0cmluZ18gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8vIEZpcmVmb3ggc2VlbXMgdG8gc29tZXRpbWVzIHRocm93IGV4Y2VwdGlvbnMgKE5TX0VSUk9SX1VORVhQRUNURUQpIGZyb20gd2Vic29ja2V0IC5zZW5kKClcbiAgICAgICAgLy8gY2FsbHMgZm9yIHNvbWUgdW5rbm93biByZWFzb24uICBXZSB0cmVhdCB0aGVzZSBhcyBhbiBlcnJvciBhbmQgZGlzY29ubmVjdC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vYXBwLmFzYW5hLmNvbS8wLzU4OTI2MTExNDAyMjkyLzY4MDIxMzQwMjUwNDEwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLm15U29jay5zZW5kKHN0cik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nXygnRXhjZXB0aW9uIHRocm93biBmcm9tIFdlYlNvY2tldC5zZW5kKCk6JywgZS5tZXNzYWdlIHx8IGUuZGF0YSwgJ0Nsb3NpbmcgY29ubmVjdGlvbi4nKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5vbkNsb3NlZF8uYmluZCh0aGlzKSwgMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiByZXNwb25zZSBiZWZvcmUgd2UgY29uc2lkZXIgdGhlIGNvbm5lY3Rpb24gXCJoZWFsdGh5LlwiXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICBXZWJTb2NrZXRDb25uZWN0aW9uLnJlc3BvbnNlc1JlcXVpcmVkVG9CZUhlYWx0aHkgPSAyO1xuICAgIC8qKlxuICAgICAqIFRpbWUgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdGUgYmVjb21lIGhlYWx0aHkgYmVmb3JlIGdpdmluZyB1cC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb24uaGVhbHRoeVRpbWVvdXQgPSAzMDAwMDtcbiAgICByZXR1cm4gV2ViU29ja2V0Q29ubmVjdGlvbjtcbn0oKSk7XG5leHBvcnRzLldlYlNvY2tldENvbm5lY3Rpb24gPSBXZWJTb2NrZXRDb25uZWN0aW9uO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XZWJTb2NrZXRDb25uZWN0aW9uLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9XZWJTb2NrZXRDb25uZWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSW50ZXJmYWNlIGRlZmluaW5nIHRoZSBzZXQgb2YgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgYWdhaW5zdCB0aGUgRmlyZWJhc2Ugc2VydmVyXG4gKiAoYmFzaWNhbGx5IGNvcnJlc3BvbmRzIHRvIG91ciB3aXJlIHByb3RvY29sKS5cbiAqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbnZhciBTZXJ2ZXJBY3Rpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcnZlckFjdGlvbnMoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHsqfSBkYXRhXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZyk9fSBvbkNvbXBsZXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBoYXNoXG4gICAgICovXG4gICAgU2VydmVyQWN0aW9ucy5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCA/c3RyaW5nKX0gb25Db21wbGV0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gaGFzaFxuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIGRhdGEsIG9uQ29tcGxldGUsIGhhc2gpIHsgfTtcbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGF1dGggdG9rZW4gZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLnJlZnJlc2hBdXRoVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHsgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Kn0gZGF0YVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcpPX0gb25Db21wbGV0ZVxuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLm9uRGlzY29ubmVjdFB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0geyp9IGRhdGFcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RNZXJnZSA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvbkNvbXBsZXRlKSB7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nKT19IG9uQ29tcGxldGVcbiAgICAgKi9cbiAgICBTZXJ2ZXJBY3Rpb25zLnByb3RvdHlwZS5vbkRpc2Nvbm5lY3RDYW5jZWwgPSBmdW5jdGlvbiAocGF0aFN0cmluZywgb25Db21wbGV0ZSkgeyB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBzdGF0c1xuICAgICAqL1xuICAgIFNlcnZlckFjdGlvbnMucHJvdG90eXBlLnJlcG9ydFN0YXRzID0gZnVuY3Rpb24gKHN0YXRzKSB7IH07XG4gICAgcmV0dXJuIFNlcnZlckFjdGlvbnM7XG59KCkpO1xuZXhwb3J0cy5TZXJ2ZXJBY3Rpb25zID0gU2VydmVyQWN0aW9ucztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VydmVyQWN0aW9ucy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9TZXJ2ZXJBY3Rpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleGVkRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9JbmRleGVkRmlsdGVyXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29yZS9zbmFwL05vZGVcIik7XG52YXIgQ2hpbGRyZW5Ob2RlXzEgPSByZXF1aXJlKFwiLi4vLi4vc25hcC9DaGlsZHJlbk5vZGVcIik7XG4vKipcbiAqIEZpbHRlcnMgbm9kZXMgYnkgcmFuZ2UgYW5kIHVzZXMgYW4gSW5kZXhGaWx0ZXIgdG8gdHJhY2sgYW55IGNoYW5nZXMgYWZ0ZXIgZmlsdGVyaW5nIHRoZSBub2RlXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7Tm9kZUZpbHRlcn1cbiAqL1xudmFyIFJhbmdlZEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gUmFuZ2VkRmlsdGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLmluZGV4ZWRGaWx0ZXJfID0gbmV3IEluZGV4ZWRGaWx0ZXJfMS5JbmRleGVkRmlsdGVyKHBhcmFtcy5nZXRJbmRleCgpKTtcbiAgICAgICAgdGhpcy5pbmRleF8gPSBwYXJhbXMuZ2V0SW5kZXgoKTtcbiAgICAgICAgdGhpcy5zdGFydFBvc3RfID0gUmFuZ2VkRmlsdGVyLmdldFN0YXJ0UG9zdF8ocGFyYW1zKTtcbiAgICAgICAgdGhpcy5lbmRQb3N0XyA9IFJhbmdlZEZpbHRlci5nZXRFbmRQb3N0XyhwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshTmFtZWROb2RlfVxuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUuZ2V0U3RhcnRQb3N0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydFBvc3RfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IU5hbWVkTm9kZX1cbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLmdldEVuZFBvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZFBvc3RfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshTmFtZWROb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5nZXRTdGFydFBvc3QoKSwgbm9kZSkgPD0gMCAmJlxuICAgICAgICAgICAgdGhpcy5pbmRleF8uY29tcGFyZShub2RlLCB0aGlzLmdldEVuZFBvc3QoKSkgPD0gMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlQ2hpbGQgPSBmdW5jdGlvbiAoc25hcCwga2V5LCBuZXdDaGlsZCwgYWZmZWN0ZWRQYXRoLCBzb3VyY2UsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaGVzKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXy51cGRhdGVDaGlsZChzbmFwLCBrZXksIG5ld0NoaWxkLCBhZmZlY3RlZFBhdGgsIHNvdXJjZSwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUZ1bGxOb2RlID0gZnVuY3Rpb24gKG9sZFNuYXAsIG5ld1NuYXAsIG9wdENoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIGlmIChuZXdTbmFwLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjaGlsZHJlbiBub2RlIHdpdGggdGhlIGNvcnJlY3QgaW5kZXgsIG5vdCBhIGxlYWYgbm9kZTtcbiAgICAgICAgICAgIG5ld1NuYXAgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyZWQgPSBuZXdTbmFwLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXG4gICAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQudXBkYXRlUHJpb3JpdHkoQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIG5ld1NuYXAuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYubWF0Y2hlcyhuZXcgTm9kZV8xLk5hbWVkTm9kZShrZXksIGNoaWxkTm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVJbW1lZGlhdGVDaGlsZChrZXksIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWRGaWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKG9sZFNuYXAsIGZpbHRlcmVkLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlUHJpb3JpdHkgPSBmdW5jdGlvbiAob2xkU25hcCwgbmV3UHJpb3JpdHkpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc3VwcG9ydCBwcmlvcml0aWVzIG9uIHF1ZXJpZXNcbiAgICAgICAgcmV0dXJuIG9sZFNuYXA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFJhbmdlZEZpbHRlci5wcm90b3R5cGUuZmlsdGVyc05vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5nZXRJbmRleGVkRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkRmlsdGVyXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgUmFuZ2VkRmlsdGVyLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnlQYXJhbXN9IHBhcmFtc1xuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIuZ2V0U3RhcnRQb3N0XyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5oYXNTdGFydCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnROYW1lID0gcGFyYW1zLmdldEluZGV4U3RhcnROYW1lKCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmdldEluZGV4KCkubWFrZVBvc3QocGFyYW1zLmdldEluZGV4U3RhcnRWYWx1ZSgpLCBzdGFydE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1pblBvc3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUXVlcnlQYXJhbXN9IHBhcmFtc1xuICAgICAqIEByZXR1cm4geyFOYW1lZE5vZGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSYW5nZWRGaWx0ZXIuZ2V0RW5kUG9zdF8gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzRW5kKCkpIHtcbiAgICAgICAgICAgIHZhciBlbmROYW1lID0gcGFyYW1zLmdldEluZGV4RW5kTmFtZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1ha2VQb3N0KHBhcmFtcy5nZXRJbmRleEVuZFZhbHVlKCksIGVuZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5nZXRJbmRleCgpLm1heFBvc3QoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJhbmdlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLlJhbmdlZEZpbHRlciA9IFJhbmdlZEZpbHRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmFuZ2VkRmlsdGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL1JhbmdlZEZpbHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IEVycm9ycyBmcm9tICcuLi9tb2RlbHMvZXJyb3JzJztcbmltcG9ydCBUb2tlbk1hbmFnZXIgZnJvbSAnLi4vbW9kZWxzL3Rva2VuLW1hbmFnZXInO1xuaW1wb3J0IE5PVElGSUNBVElPTl9QRVJNSVNTSU9OIGZyb20gJy4uL21vZGVscy9ub3RpZmljYXRpb24tcGVybWlzc2lvbic7XG52YXIgU0VOREVSX0lEX09QVElPTl9OQU1FID0gJ21lc3NhZ2luZ1NlbmRlcklkJztcbnZhciBDb250cm9sbGVySW50ZXJmYWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyZmFjZSBvZiB0aGUgTWVzc2FnaW5nIFNlcnZpY2UgQVBJXG4gICAgICogQHBhcmFtIHshZmlyZWJhc2UuYXBwLkFwcH0gYXBwXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ29udHJvbGxlckludGVyZmFjZShhcHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5lcnJvckZhY3RvcnlfID0gbmV3IEVycm9yRmFjdG9yeSgnbWVzc2FnaW5nJywgJ01lc3NhZ2luZycsIEVycm9ycy5tYXApO1xuICAgICAgICBpZiAoIWFwcC5vcHRpb25zW1NFTkRFUl9JRF9PUFRJT05fTkFNRV0gfHxcbiAgICAgICAgICAgIHR5cGVvZiBhcHAub3B0aW9uc1tTRU5ERVJfSURfT1BUSU9OX05BTUVdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuQkFEX1NFTkRFUl9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTZW5kZXJJZF8gPSBhcHAub3B0aW9uc1tTRU5ERVJfSURfT1BUSU9OX05BTUVdO1xuICAgICAgICB0aGlzLnRva2VuTWFuYWdlcl8gPSBuZXcgVG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuICAgICAgICB0aGlzLklOVEVSTkFMID0ge307XG4gICAgICAgIHRoaXMuSU5URVJOQUwuZGVsZXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVsZXRlOyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+IHwgUHJvbWlzZTxudWxsPn0gUmV0dXJucyBhIHByb21pc2UgdGhhdFxuICAgICAqIHJlc29sdmVzIHRvIGFuIEZDTSB0b2tlbi5cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2hlY2sgd2l0aCBwZXJtaXNzaW9uc1xuICAgICAgICB2YXIgY3VycmVudFBlcm1pc3Npb24gPSB0aGlzLmdldE5vdGlmaWNhdGlvblBlcm1pc3Npb25fKCk7XG4gICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbiAhPT0gTk9USUZJQ0FUSU9OX1BFUk1JU1NJT04uZ3JhbnRlZCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRQZXJtaXNzaW9uID09PSBOT1RJRklDQVRJT05fUEVSTUlTU0lPTi5kZW5pZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuTk9USUZJQ0FUSU9OU19CTE9DS0VEKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSBtdXN0IHdhaXQgZm9yIHBlcm1pc3Npb24gdG8gYmUgZ3JhbnRlZFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTV1JlZ2lzdHJhdGlvbl8oKS50aGVuKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50b2tlbk1hbmFnZXJfXG4gICAgICAgICAgICAgICAgLmdldFNhdmVkVG9rZW4oX3RoaXMubWVzc2FnaW5nU2VuZGVySWRfLCByZWdpc3RyYXRpb24pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnRva2VuTWFuYWdlcl8uY3JlYXRlVG9rZW4oX3RoaXMubWVzc2FnaW5nU2VuZGVySWRfLCByZWdpc3RyYXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgZGVsZXRlcyB0b2tlbnMgdGhhdCB0aGUgdG9rZW4gbWFuYWdlciBsb29rcyBhZnRlciBhbmQgdGhlblxuICAgICAqIHVucmVnaXN0ZXJzIHRoZSBwdXNoIHN1YnNjcmlwdGlvbiBpZiBpdCBleGlzdHMuXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuZGVsZXRlVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5NYW5hZ2VyXy5kZWxldGVUb2tlbih0b2tlbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2V0U1dSZWdpc3RyYXRpb25fKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyLmdldFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLmdldFNXUmVnaXN0cmF0aW9uXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU0hPVUxEX0JFX0lOSEVSSVRFRCk7XG4gICAgfTtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBzaG91bGQgb25seSBiZSBhdmFpbGFibGUgaW4gdGhlIHdpbmRvdy5cbiAgICAvL1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLnJlcXVlc3RQZXJtaXNzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5BVkFJTEFCTEVfSU5fV0lORE9XKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0geyFTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9ufSByZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS51c2VTZXJ2aWNlV29ya2VyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5BVkFJTEFCTEVfSU5fV0lORE9XKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0geyFmaXJlYmFzZS5PYnNlcnZlcnxmdW5jdGlvbigqKX0gbmV4dE9yT2JzZXJ2ZXJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFcnJvcik9fSBvcHRFcnJvclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdENvbXBsZXRlZFxuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuICAgICAqL1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgb3B0RXJyb3IsIG9wdENvbXBsZXRlZCkge1xuICAgICAgICB0aHJvdyB0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5BVkFJTEFCTEVfSU5fV0lORE9XKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0geyFmaXJlYmFzZS5PYnNlcnZlcnxmdW5jdGlvbigpfSBuZXh0T3JPYnNlcnZlciBBbiBvYnNlcnZlciBvYmplY3RcbiAgICAgKiBvciBhIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiB0b2tlbiByZWZyZXNoLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUVycm9yKT19IG9wdEVycm9yIE9wdGlvbmFsIEEgZnVuY3Rpb25cbiAgICAgKiB0cmlnZ2VyZWQgb24gdG9rZW4gcmVmcmVzaCBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRDb21wbGV0ZWQgT3B0aW9uYWwgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gdGhlXG4gICAgICogb2JzZXJ2ZXIgaXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIGZvciB0aGUgb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUub25Ub2tlblJlZnJlc2ggPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuQVZBSUxBQkxFX0lOX1dJTkRPVyk7XG4gICAgfTtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCBieSB0aGUgc2VydmljZSB3b3JrZXIgb25seS5cbiAgICAvL1xuICAgIC8qKlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCl9IGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuc2V0QmFja2dyb3VuZE1lc3NhZ2VIYW5kbGVyID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLkFWQUlMQUJMRV9JTl9TVyk7XG4gICAgfTtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCBieSB0aGUgc2VydmljZSB0aGVtc2VsdmVzIGFuZCBub3QgZXhwb3NlZFxuICAgIC8vIHB1YmxpY2x5IG9yIG5vdCBleHBlY3RlZCB0byBiZSB1c2VkIGJ5IGRldmVsb3BlcnMuXG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyByZXF1aXJlZCB0byBhZGhlcmUgdG8gdGhlIEZpcmViYXNlIGludGVyZmFjZS5cbiAgICAgKiBJdCBjbG9zZXMgYW55IGN1cnJlbnRseSBvcGVuIGluZGV4ZGIgZGF0YWJhc2UgY29ubmVjdGlvbnMuXG4gICAgICovXG4gICAgQ29udHJvbGxlckludGVyZmFjZS5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hbmFnZXJfLmNsb3NlRGF0YWJhc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgTm90aWZpY2F0aW9uIFBlcm1pc3Npb24gc3RhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjdXJyZW5jdCBwZXJtaXNzaW9uIHN0YXRlLlxuICAgICAqL1xuICAgIENvbnRyb2xsZXJJbnRlcmZhY2UucHJvdG90eXBlLmdldE5vdGlmaWNhdGlvblBlcm1pc3Npb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTm90aWZpY2F0aW9uLnBlcm1pc3Npb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHJldHVybnMge1Rva2VuTWFuYWdlcn1cbiAgICAgKi9cbiAgICBDb250cm9sbGVySW50ZXJmYWNlLnByb3RvdHlwZS5nZXRUb2tlbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTWFuYWdlcl87XG4gICAgfTtcbiAgICByZXR1cm4gQ29udHJvbGxlckludGVyZmFjZTtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBDb250cm9sbGVySW50ZXJmYWNlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sbGVyLWludGVyZmFjZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL2NvbnRyb2xsZXJzL2NvbnRyb2xsZXItaW50ZXJmYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgRkNNX0FQUExJQ0FUSU9OX1NFUlZFUl9LRVkgPSBbXG4gICAgMHgwNCxcbiAgICAweDMzLFxuICAgIDB4OTQsXG4gICAgMHhmNyxcbiAgICAweGRmLFxuICAgIDB4YTEsXG4gICAgMHhlYixcbiAgICAweGIxLFxuICAgIDB4ZGMsXG4gICAgMHgwMyxcbiAgICAweGEyLFxuICAgIDB4NWUsXG4gICAgMHgxNSxcbiAgICAweDcxLFxuICAgIDB4ZGIsXG4gICAgMHg0OCxcbiAgICAweGQzLFxuICAgIDB4MmUsXG4gICAgMHhlZCxcbiAgICAweGVkLFxuICAgIDB4YjIsXG4gICAgMHgzNCxcbiAgICAweGRiLFxuICAgIDB4YjcsXG4gICAgMHg0NyxcbiAgICAweDNhLFxuICAgIDB4MGMsXG4gICAgMHg4ZixcbiAgICAweGM0LFxuICAgIDB4Y2MsXG4gICAgMHhlMSxcbiAgICAweDZmLFxuICAgIDB4M2MsXG4gICAgMHg4YyxcbiAgICAweDg0LFxuICAgIDB4ZGYsXG4gICAgMHhhYixcbiAgICAweGI2LFxuICAgIDB4NjYsXG4gICAgMHgzZSxcbiAgICAweGYyLFxuICAgIDB4MGMsXG4gICAgMHhkNCxcbiAgICAweDhiLFxuICAgIDB4ZmUsXG4gICAgMHhlMyxcbiAgICAweGY5LFxuICAgIDB4NzYsXG4gICAgMHgyZixcbiAgICAweDE0LFxuICAgIDB4MWMsXG4gICAgMHg2MyxcbiAgICAweDA4LFxuICAgIDB4NmEsXG4gICAgMHg2ZixcbiAgICAweDJkLFxuICAgIDB4YjEsXG4gICAgMHgxYSxcbiAgICAweDk1LFxuICAgIDB4YjAsXG4gICAgMHhjZSxcbiAgICAweDM3LFxuICAgIDB4YzAsXG4gICAgMHg5YyxcbiAgICAweDZlXG5dO1xudmFyIFNVQlNDUklQVElPTl9ERVRBSUxTID0ge1xuICAgIHVzZXJWaXNpYmxlT25seTogdHJ1ZSxcbiAgICBhcHBsaWNhdGlvblNlcnZlcktleTogbmV3IFVpbnQ4QXJyYXkoRkNNX0FQUExJQ0FUSU9OX1NFUlZFUl9LRVkpXG59O1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIEVORFBPSU5UOiAnaHR0cHM6Ly9mY20uZ29vZ2xlYXBpcy5jb20nLFxuICAgIEFQUExJQ0FUSU9OX1NFUlZFUl9LRVk6IEZDTV9BUFBMSUNBVElPTl9TRVJWRVJfS0VZLFxuICAgIFNVQlNDUklQVElPTl9PUFRJT05TOiBTVUJTQ1JJUFRJT05fREVUQUlMU1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmNtLWRldGFpbHMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvZmNtLWRldGFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBncmFudGVkOiAnZ3JhbnRlZCcsXG4gICAgZGVmYXVsdDogJ2RlZmF1bHQnLFxuICAgIGRlbmllZDogJ2RlbmllZCdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vdGlmaWNhdGlvbi1wZXJtaXNzaW9uLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvbW9kZWxzL25vdGlmaWNhdGlvbi1wZXJtaXNzaW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG4vLyBUaGVzZSBmaWVsZHMgYXJlIHN0cmluZ3MgdG8gcHJldmVudCBjbG9zdXJlIGZyb20gdGhpbmtpbmcgZ29vZy5nZXRNc2dcbi8vIHNob3VsZCBiZSB1c2VkIHRvIGluaXRpYWxpc2UgdGhlIHZhbHVlc1xudmFyIFBBUkFNUyA9IHtcbiAgICBUWVBFX09GX01TRzogJ2ZpcmViYXNlLW1lc3NhZ2luZy1tc2ctdHlwZScsXG4gICAgREFUQTogJ2ZpcmViYXNlLW1lc3NhZ2luZy1tc2ctZGF0YSdcbn07XG4vLyBUaGlzIHZhbHVlIGlzbid0IHVzaW5nIHRoZSBUWVBFX09GX01TRyBzaG9ydCBoYW5kIGFzIGNsb3N1cmVcbi8vIGV4cGVjdHMgdGhlIHZhcmlhYmxlIHRvIGJlIGRlZmluZWQgdmlhIGdvb2cuZ2V0TXNnXG52YXIgbXNnVHlwZSA9IHtcbiAgICBQVVNIX01TR19SRUNFSVZFRDogJ3B1c2gtbXNnLXJlY2VpdmVkJyxcbiAgICBOT1RJRklDQVRJT05fQ0xJQ0tFRDogJ25vdGlmaWNhdGlvbi1jbGlja2VkJ1xufTtcbnZhciBjcmVhdGVOZXdNc2cgPSBmdW5jdGlvbiAobXNnVHlwZSwgbXNnRGF0YSkge1xuICAgIHZhciBtZXNzYWdlID0gKF9hID0ge30sXG4gICAgICAgIF9hW1BBUkFNUy5UWVBFX09GX01TR10gPSBtc2dUeXBlLFxuICAgICAgICBfYVtQQVJBTVMuREFUQV0gPSBtc2dEYXRhLFxuICAgICAgICBfYSk7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgdmFyIF9hO1xufTtcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBQQVJBTVM6IFBBUkFNUyxcbiAgICBUWVBFU19PRl9NU0c6IG1zZ1R5cGUsXG4gICAgY3JlYXRlTmV3TXNnOiBjcmVhdGVOZXdNc2dcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci1wYWdlLW1lc3NhZ2UuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvd29ya2VyLXBhZ2UtbWVzc2FnZS5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZW51bXtudW1iZXJ9XG4gKi9cbmV4cG9ydCB2YXIgRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChFcnJvckNvZGUpIHtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTk9fRVJST1JcIl0gPSAwXSA9IFwiTk9fRVJST1JcIjtcbiAgICBFcnJvckNvZGVbRXJyb3JDb2RlW1wiTkVUV09SS19FUlJPUlwiXSA9IDFdID0gXCJORVRXT1JLX0VSUk9SXCI7XG4gICAgRXJyb3JDb2RlW0Vycm9yQ29kZVtcIkFCT1JUXCJdID0gMl0gPSBcIkFCT1JUXCI7XG59KShFcnJvckNvZGUgfHwgKEVycm9yQ29kZSA9IHt9KSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhocmlvLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3hocmlvLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyB0aGUgRmlyZWJhc2UgU3RvcmFnZSBSZWZlcmVuY2UgY2xhc3MuXG4gKi9cbmltcG9ydCAqIGFzIGFyZ3MgZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9hcmdzJztcbmltcG9ydCB7IEZic0Jsb2IgfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL2Jsb2InO1xuaW1wb3J0ICogYXMgZXJyb3JzRXhwb3J0cyBmcm9tICcuL2ltcGxlbWVudGF0aW9uL2Vycm9yJztcbmltcG9ydCB7IExvY2F0aW9uIH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9sb2NhdGlvbic7XG5pbXBvcnQgKiBhcyBtZXRhZGF0YSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL21ldGFkYXRhJztcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL2ltcGxlbWVudGF0aW9uL29iamVjdCc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJy4vaW1wbGVtZW50YXRpb24vcGF0aCc7XG5pbXBvcnQgKiBhcyByZXF1ZXN0cyBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3JlcXVlc3RzJztcbmltcG9ydCAqIGFzIGZic1N0cmluZyBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3N0cmluZyc7XG5pbXBvcnQgeyBTdHJpbmdGb3JtYXQgfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3N0cmluZyc7XG5pbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vaW1wbGVtZW50YXRpb24vdHlwZSc7XG5pbXBvcnQgeyBVcGxvYWRUYXNrIH0gZnJvbSAnLi90YXNrJztcbi8qKlxuICogUHJvdmlkZXMgbWV0aG9kcyB0byBpbnRlcmFjdCB3aXRoIGEgYnVja2V0IGluIHRoZSBGaXJlYmFzZSBTdG9yYWdlIHNlcnZpY2UuXG4gKiBAcGFyYW0gbG9jYXRpb24gQW4gZmJzLmxvY2F0aW9uLCBvciB0aGUgVVJMIGF0XG4gKiAgICAgd2hpY2ggdG8gYmFzZSB0aGlzIG9iamVjdCwgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6XG4gKiAgICAgICAgIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxuICogICAgICAgICBodHRwW3NdOi8vZmlyZWJhc2VzdG9yYWdlLmdvb2dsZWFwaXMuY29tL1xuICogICAgICAgICAgICAgICAgICAgICA8YXBpLXZlcnNpb24+L2IvPGJ1Y2tldD4vby88b2JqZWN0LXBhdGg+XG4gKiAgICAgQW55IHF1ZXJ5IG9yIGZyYWdtZW50IHN0cmluZ3Mgd2lsbCBiZSBpZ25vcmVkIGluIHRoZSBodHRwW3NdXG4gKiAgICAgZm9ybWF0LiBJZiBubyB2YWx1ZSBpcyBwYXNzZWQsIHRoZSBzdG9yYWdlIG9iamVjdCB3aWxsIHVzZSBhIFVSTCBiYXNlZCBvblxuICogICAgIHRoZSBwcm9qZWN0IElEIG9mIHRoZSBiYXNlIGZpcmViYXNlLkFwcCBpbnN0YW5jZS5cbiAqL1xudmFyIFJlZmVyZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZlcmVuY2UoYXV0aFdyYXBwZXIsIGxvY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYXV0aFdyYXBwZXIgPSBhdXRoV3JhcHBlcjtcbiAgICAgICAgaWYgKGxvY2F0aW9uIGluc3RhbmNlb2YgTG9jYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpb24gPSBMb2NhdGlvbi5tYWtlRnJvbVVybChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiBUaGUgVVJMIGZvciB0aGUgYnVja2V0IGFuZCBwYXRoIHRoaXMgb2JqZWN0IHJlZmVyZW5jZXMsXG4gICAgICogICAgIGluIHRoZSBmb3JtIGdzOi8vPGJ1Y2tldD4vPG9iamVjdC1wYXRoPlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3RvU3RyaW5nJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiAnZ3M6Ly8nICsgdGhpcy5sb2NhdGlvbi5idWNrZXQgKyAnLycgKyB0aGlzLmxvY2F0aW9uLnBhdGg7XG4gICAgfTtcbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLm5ld1JlZiA9IGZ1bmN0aW9uIChhdXRoV3JhcHBlciwgbG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWZlcmVuY2UoYXV0aFdyYXBwZXIsIGxvY2F0aW9uKTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUubWFwcGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YS5nZXRNYXBwaW5ncygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiBBIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IG9idGFpbmVkIGJ5XG4gICAgICogICAgIGFwcGVuZGluZyBjaGlsZFBhdGgsIHJlbW92aW5nIGFueSBkdXBsaWNhdGUsIGJlZ2lubmluZywgb3IgdHJhaWxpbmdcbiAgICAgKiAgICAgc2xhc2hlcy5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKGNoaWxkUGF0aCkge1xuICAgICAgICBhcmdzLnZhbGlkYXRlKCdjaGlsZCcsIFthcmdzLnN0cmluZ1NwZWMoKV0sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gcGF0aC5jaGlsZCh0aGlzLmxvY2F0aW9uLnBhdGgsIGNoaWxkUGF0aCk7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5ldyBMb2NhdGlvbih0aGlzLmxvY2F0aW9uLmJ1Y2tldCwgbmV3UGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld1JlZih0aGlzLmF1dGhXcmFwcGVyLCBsb2NhdGlvbik7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBBIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IG9mIHRoZVxuICAgICAgICAgKiAgICAgY3VycmVudCBvYmplY3QsIG9yIG51bGwgaWYgdGhlIGN1cnJlbnQgb2JqZWN0IGlzIHRoZSByb290LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aCA9IHBhdGgucGFyZW50KHRoaXMubG9jYXRpb24ucGF0aCk7XG4gICAgICAgICAgICBpZiAobmV3UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbmV3IExvY2F0aW9uKHRoaXMubG9jYXRpb24uYnVja2V0LCBuZXdQYXRoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1JlZih0aGlzLmF1dGhXcmFwcGVyLCBsb2NhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2UucHJvdG90eXBlLCBcInJvb3RcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiBBbiByZWZlcmVuY2UgdG8gdGhlIHJvb3Qgb2YgdGhpc1xuICAgICAgICAgKiAgICAgb2JqZWN0J3MgYnVja2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBuZXcgTG9jYXRpb24odGhpcy5sb2NhdGlvbi5idWNrZXQsICcnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ld1JlZih0aGlzLmF1dGhXcmFwcGVyLCBsb2NhdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWZlcmVuY2UucHJvdG90eXBlLCBcImJ1Y2tldFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYnVja2V0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJmdWxsUGF0aFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24ucGF0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlZmVyZW5jZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGgubGFzdENvbXBvbmVudCh0aGlzLmxvY2F0aW9uLnBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVmZXJlbmNlLnByb3RvdHlwZSwgXCJzdG9yYWdlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlci5zZXJ2aWNlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBibG9iIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGJsb2IgdG8gdXBsb2FkLlxuICAgICAqIEByZXR1cm4gQW4gVXBsb2FkVGFzayB0aGF0IGxldHMgeW91IGNvbnRyb2wgYW5kXG4gICAgICogICAgIG9ic2VydmUgdGhlIHVwbG9hZC5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChkYXRhLCBtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHZvaWQgMCkgeyBtZXRhZGF0YSA9IG51bGw7IH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncHV0JywgW2FyZ3MudXBsb2FkRGF0YVNwZWMoKSwgYXJncy5tZXRhZGF0YVNwZWModHJ1ZSldLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRocm93SWZSb290XygncHV0Jyk7XG4gICAgICAgIHJldHVybiBuZXcgVXBsb2FkVGFzayh0aGlzLCB0aGlzLmF1dGhXcmFwcGVyLCB0aGlzLmxvY2F0aW9uLCB0aGlzLm1hcHBpbmdzKCksIG5ldyBGYnNCbG9iKGRhdGEpLCBtZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIGEgc3RyaW5nIHRvIHRoaXMgb2JqZWN0J3MgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHN0cmluZyBUaGUgc3RyaW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gb3B0X2Zvcm1hdCBUaGUgZm9ybWF0IG9mIHRoZSBzdHJpbmcgdG8gdXBsb2FkLlxuICAgICAqIEByZXR1cm4gQW4gVXBsb2FkVGFzayB0aGF0IGxldHMgeW91IGNvbnRyb2wgYW5kXG4gICAgICogICAgIG9ic2VydmUgdGhlIHVwbG9hZC5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLnB1dFN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmcsIGZvcm1hdCwgb3B0X21ldGFkYXRhKSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09IHZvaWQgMCkgeyBmb3JtYXQgPSBTdHJpbmdGb3JtYXQuUkFXOyB9XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3B1dFN0cmluZycsIFtcbiAgICAgICAgICAgIGFyZ3Muc3RyaW5nU3BlYygpLFxuICAgICAgICAgICAgYXJncy5zdHJpbmdTcGVjKGZic1N0cmluZy5mb3JtYXRWYWxpZGF0b3IsIHRydWUpLFxuICAgICAgICAgICAgYXJncy5tZXRhZGF0YVNwZWModHJ1ZSlcbiAgICAgICAgXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50aHJvd0lmUm9vdF8oJ3B1dFN0cmluZycpO1xuICAgICAgICB2YXIgZGF0YSA9IGZic1N0cmluZy5kYXRhRnJvbVN0cmluZyhmb3JtYXQsIHN0cmluZyk7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IG9iamVjdC5jbG9uZShvcHRfbWV0YWRhdGEpO1xuICAgICAgICBpZiAoIXR5cGUuaXNEZWYobWV0YWRhdGFbJ2NvbnRlbnRUeXBlJ10pICYmIHR5cGUuaXNEZWYoZGF0YS5jb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhWydjb250ZW50VHlwZSddID0gZGF0YS5jb250ZW50VHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVwbG9hZFRhc2sodGhpcywgdGhpcy5hdXRoV3JhcHBlciwgdGhpcy5sb2NhdGlvbiwgdGhpcy5tYXBwaW5ncygpLCBuZXcgRmJzQmxvYihkYXRhLmRhdGEsIHRydWUpLCBtZXRhZGF0YSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBvYmplY3QgYXQgdGhpcyBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSBkZWxldGlvbiBzdWNjZWVkcy5cbiAgICAgKi9cbiAgICBSZWZlcmVuY2UucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJncy52YWxpZGF0ZSgnZGVsZXRlJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGhyb3dJZlJvb3RfKCdkZWxldGUnKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlci5nZXRBdXRoVG9rZW4oKS50aGVuKGZ1bmN0aW9uIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IHJlcXVlc3RzLmRlbGV0ZU9iamVjdChzZWxmLmF1dGhXcmFwcGVyLCBzZWxmLmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmF1dGhXcmFwcGVyLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pLmdldFByb21pc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiAgICAgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LiBJZiB0aGlzXG4gICAgICogICAgIG9iamVjdCBkb2Vzbid0IGV4aXN0IG9yIG1ldGFkYXRhIGNhbm5vdCBiZSByZXRyZWl2ZWQsIHRoZSBwcm9taXNlIGlzXG4gICAgICogICAgIHJlamVjdGVkLlxuICAgICAqL1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUuZ2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ2dldE1ldGFkYXRhJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGhyb3dJZlJvb3RfKCdnZXRNZXRhZGF0YScpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhXcmFwcGVyLmdldEF1dGhUb2tlbigpLnRoZW4oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gcmVxdWVzdHMuZ2V0TWV0YWRhdGEoc2VsZi5hdXRoV3JhcHBlciwgc2VsZi5sb2NhdGlvbiwgc2VsZi5tYXBwaW5ncygpKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmF1dGhXcmFwcGVyLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pLmdldFByb21pc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBmb3IgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhIFRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoZSBvYmplY3QuXG4gICAgICogICAgIE9ubHkgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgc2V0IHdpbGwgYmUgY2hhbmdlZC4gRXhwbGljaXRseVxuICAgICAqICAgICBzZXR0aW5nIGEgdmFsdWUgdG8gbnVsbCB3aWxsIHJlbW92ZSB0aGUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybiBBIHByb21pc2UgdGhhdCByZXNvbHZlc1xuICAgICAqICAgICB3aXRoIHRoZSBuZXcgbWV0YWRhdGEgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqICAgICBAc2VlIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UucHJvdG90eXBlLmdldE1ldGFkYXRhXG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS51cGRhdGVNZXRhZGF0YSA9IGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICBhcmdzLnZhbGlkYXRlKCd1cGRhdGVNZXRhZGF0YScsIFthcmdzLm1ldGFkYXRhU3BlYygpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50aHJvd0lmUm9vdF8oJ3VwZGF0ZU1ldGFkYXRhJyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFdyYXBwZXIuZ2V0QXV0aFRva2VuKCkudGhlbihmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSByZXF1ZXN0cy51cGRhdGVNZXRhZGF0YShzZWxmLmF1dGhXcmFwcGVyLCBzZWxmLmxvY2F0aW9uLCBtZXRhZGF0YSwgc2VsZi5tYXBwaW5ncygpKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmF1dGhXcmFwcGVyLm1ha2VSZXF1ZXN0KHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pLmdldFByb21pc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGRvd25sb2FkXG4gICAgICogICAgIFVSTCBmb3IgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgUmVmZXJlbmNlLnByb3RvdHlwZS5nZXREb3dubG9hZFVSTCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXJncy52YWxpZGF0ZSgnZ2V0RG93bmxvYWRVUkwnLCBbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50aHJvd0lmUm9vdF8oJ2dldERvd25sb2FkVVJMJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKCkudGhlbihmdW5jdGlvbiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHZhciB1cmwgPSBtZXRhZGF0YVsnZG93bmxvYWRVUkxzJ11bMF07XG4gICAgICAgICAgICBpZiAodHlwZS5pc0RlZih1cmwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMubm9Eb3dubG9hZFVSTCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlZmVyZW5jZS5wcm90b3R5cGUudGhyb3dJZlJvb3RfID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMubG9jYXRpb24ucGF0aCA9PT0gJycpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW52YWxpZFJvb3RPcGVyYXRpb24obmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZlcmVuY2U7XG59KCkpO1xuZXhwb3J0IHsgUmVmZXJlbmNlIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmVyZW5jZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9yZWZlcmVuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBDb250YWlucyBoZWxwZXIgbWV0aG9kcyBmb3IgbWFuaXB1bGF0aW5nIHBhdGhzLlxuICovXG4vKipcbiAqIEByZXR1cm4gTnVsbCBpZiB0aGUgcGF0aCBpcyBhbHJlYWR5IGF0IHRoZSByb290LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyZW50KHBhdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgbmV3UGF0aCA9IHBhdGguc2xpY2UoMCwgaW5kZXgpO1xuICAgIHJldHVybiBuZXdQYXRoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoaWxkKHBhdGgsIGNoaWxkUGF0aCkge1xuICAgIHZhciBjYW5vbmljYWxDaGlsZFBhdGggPSBjaGlsZFBhdGhcbiAgICAgICAgLnNwbGl0KCcvJylcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQubGVuZ3RoID4gMDtcbiAgICB9KVxuICAgICAgICAuam9pbignLycpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY2Fub25pY2FsQ2hpbGRQYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyAnLycgKyBjYW5vbmljYWxDaGlsZFBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGNvbXBvbmVudCBvZiBhIHBhdGguXG4gKiAnL2Zvby9iYXInIC0+ICdiYXInXG4gKiAnL2Zvby9iYXIvYmF6LycgLT4gJ2Jhei8nXG4gKiAnL2EnIC0+ICdhJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gbGFzdENvbXBvbmVudChwYXRoKSB7XG4gICAgdmFyIGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycsIHBhdGgubGVuZ3RoIC0gMik7XG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKGluZGV4ICsgMSk7XG4gICAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGUgUHJvdmlkZXMgYSBCbG9iLWxpa2Ugd3JhcHBlciBmb3IgdmFyaW91cyBiaW5hcnkgdHlwZXMgKGluY2x1ZGluZyB0aGVcbiAqIG5hdGl2ZSBCbG9iIHR5cGUpLiBUaGlzIG1ha2VzIGl0IHBvc3NpYmxlIHRvIHVwbG9hZCB0eXBlcyBsaWtlIEFycmF5QnVmZmVycyxcbiAqIG1ha2luZyB1cGxvYWRzIHBvc3NpYmxlIGluIGVudmlyb25tZW50cyB3aXRob3V0IHRoZSBuYXRpdmUgQmxvYiB0eXBlLlxuICovXG5pbXBvcnQgKiBhcyBmcyBmcm9tICcuL2ZzJztcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZyc7XG5pbXBvcnQgeyBTdHJpbmdGb3JtYXQgfSBmcm9tICcuL3N0cmluZyc7XG5pbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vdHlwZSc7XG4vKipcbiAqIEBwYXJhbSBvcHRfZWxpZGVDb3B5IElmIHRydWUsIGRvZXNuJ3QgY29weSBtdXRhYmxlIGlucHV0IGRhdGFcbiAqICAgICAoZS5nLiBVaW50OEFycmF5cykuIFBhc3MgdHJ1ZSBvbmx5IGlmIHlvdSBrbm93IHRoZSBvYmplY3RzIHdpbGwgbm90IGJlXG4gKiAgICAgbW9kaWZpZWQgYWZ0ZXIgdGhpcyBibG9iJ3MgY29uc3RydWN0aW9uLlxuICovXG52YXIgRmJzQmxvYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGYnNCbG9iKGRhdGEsIG9wdF9lbGlkZUNvcHkpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwO1xuICAgICAgICB2YXIgYmxvYlR5cGUgPSAnJztcbiAgICAgICAgaWYgKHR5cGUuaXNOYXRpdmVCbG9iKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFfID0gZGF0YTtcbiAgICAgICAgICAgIHNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBibG9iVHlwZSA9IGRhdGEudHlwZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChvcHRfZWxpZGVDb3B5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXy5zZXQobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuZGF0YV8ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICBpZiAob3B0X2VsaWRlQ29weSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YV8gPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhXyA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFfLnNldChkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNpemVfID0gc2l6ZTtcbiAgICAgICAgdGhpcy50eXBlXyA9IGJsb2JUeXBlO1xuICAgIH1cbiAgICBGYnNCbG9iLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplXztcbiAgICB9O1xuICAgIEZic0Jsb2IucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVfO1xuICAgIH07XG4gICAgRmJzQmxvYi5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnRCeXRlLCBlbmRCeXRlKSB7XG4gICAgICAgIGlmICh0eXBlLmlzTmF0aXZlQmxvYih0aGlzLmRhdGFfKSkge1xuICAgICAgICAgICAgdmFyIHJlYWxCbG9iID0gdGhpcy5kYXRhXztcbiAgICAgICAgICAgIHZhciBzbGljZWQgPSBmcy5zbGljZUJsb2IocmVhbEJsb2IsIHN0YXJ0Qnl0ZSwgZW5kQnl0ZSk7XG4gICAgICAgICAgICBpZiAoc2xpY2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2Ioc2xpY2VkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzbGljZSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YV8uYnVmZmVyLCBzdGFydEJ5dGUsIGVuZEJ5dGUgLSBzdGFydEJ5dGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYnNCbG9iKHNsaWNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmJzQmxvYi5nZXRCbG9iID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFyX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUuaXNOYXRpdmVCbG9iRGVmaW5lZCgpKSB7XG4gICAgICAgICAgICB2YXIgYmxvYmJ5ID0gdmFyX2FyZ3MubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgRmJzQmxvYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLmRhdGFfO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmJzQmxvYihmcy5nZXRCbG9iLmFwcGx5KG51bGwsIGJsb2JieSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHVpbnQ4QXJyYXlzID0gdmFyX2FyZ3MubWFwKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pc1N0cmluZyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcuZGF0YUZyb21TdHJpbmcoU3RyaW5nRm9ybWF0LlJBVywgdmFsKS5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxvYnMgZG9uJ3QgZXhpc3QsIHNvIHRoaXMgaGFzIHRvIGJlIGEgVWludDhBcnJheS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5kYXRhXztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBmaW5hbExlbmd0aF8xID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgZmluYWxMZW5ndGhfMSArPSBhcnJheS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWVyZ2VkXzEgPSBuZXcgVWludDhBcnJheShmaW5hbExlbmd0aF8xKTtcbiAgICAgICAgICAgIHZhciBpbmRleF8xID0gMDtcbiAgICAgICAgICAgIHVpbnQ4QXJyYXlzLmZvckVhY2goZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRfMVtpbmRleF8xKytdID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZic0Jsb2IobWVyZ2VkXzEsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGYnNCbG9iLnByb3RvdHlwZS51cGxvYWREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhXztcbiAgICB9O1xuICAgIHJldHVybiBGYnNCbG9iO1xufSgpKTtcbmV4cG9ydCB7IEZic0Jsb2IgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvYi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9ibG9iLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuL2FycmF5JztcbmltcG9ydCB7IEZic0Jsb2IgfSBmcm9tICcuL2Jsb2InO1xuaW1wb3J0ICogYXMgZXJyb3JzRXhwb3J0cyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCAqIGFzIE1ldGFkYXRhVXRpbHMgZnJvbSAnLi9tZXRhZGF0YSc7XG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnLi9vYmplY3QnO1xuaW1wb3J0IHsgUmVxdWVzdEluZm8gfSBmcm9tICcuL3JlcXVlc3RpbmZvJztcbmltcG9ydCAqIGFzIHR5cGUgZnJvbSAnLi90eXBlJztcbmltcG9ydCAqIGFzIFVybFV0aWxzIGZyb20gJy4vdXJsJztcbi8qKlxuICogVGhyb3dzIHRoZSBVTktOT1dOIEZpcmViYXNlU3RvcmFnZUVycm9yIGlmIGNuZG4gaXMgZmFsc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVyQ2hlY2soY25kbikge1xuICAgIGlmICghY25kbikge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLnVua25vd24oKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncykge1xuICAgIGZ1bmN0aW9uIGhhbmRsZXIoeGhyLCB0ZXh0KSB7XG4gICAgICAgIHZhciBtZXRhZGF0YSA9IE1ldGFkYXRhVXRpbHMuZnJvbVJlc291cmNlU3RyaW5nKGF1dGhXcmFwcGVyLCB0ZXh0LCBtYXBwaW5ncyk7XG4gICAgICAgIGhhbmRsZXJDaGVjayhtZXRhZGF0YSAhPT0gbnVsbCk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKSB7XG4gICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKHhociwgZXJyKSB7XG4gICAgICAgIHZhciBuZXdFcnI7XG4gICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwMSkge1xuICAgICAgICAgICAgbmV3RXJyID0gZXJyb3JzRXhwb3J0cy51bmF1dGhlbnRpY2F0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4aHIuZ2V0U3RhdHVzKCkgPT09IDQwMikge1xuICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycm9yc0V4cG9ydHMucXVvdGFFeGNlZWRlZChsb2NhdGlvbi5idWNrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5nZXRTdGF0dXMoKSA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0VyciA9IGVycm9yc0V4cG9ydHMudW5hdXRob3JpemVkKGxvY2F0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXJyID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdFcnIuc2V0U2VydmVyUmVzcG9uc2VQcm9wKGVyci5zZXJ2ZXJSZXNwb25zZVByb3AoKSk7XG4gICAgICAgIHJldHVybiBuZXdFcnI7XG4gICAgfVxuICAgIHJldHVybiBlcnJvckhhbmRsZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0RXJyb3JIYW5kbGVyKGxvY2F0aW9uKSB7XG4gICAgdmFyIHNoYXJlZCA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgZnVuY3Rpb24gZXJyb3JIYW5kbGVyKHhociwgZXJyKSB7XG4gICAgICAgIHZhciBuZXdFcnIgPSBzaGFyZWQoeGhyLCBlcnIpO1xuICAgICAgICBpZiAoeGhyLmdldFN0YXR1cygpID09PSA0MDQpIHtcbiAgICAgICAgICAgIG5ld0VyciA9IGVycm9yc0V4cG9ydHMub2JqZWN0Tm90Rm91bmQobG9jYXRpb24ucGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3RXJyLnNldFNlcnZlclJlc3BvbnNlUHJvcChlcnIuc2VydmVyUmVzcG9uc2VQcm9wKCkpO1xuICAgICAgICByZXR1cm4gbmV3RXJyO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JIYW5kbGVyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ldGFkYXRhKGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MpIHtcbiAgICB2YXIgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICB2YXIgdXJsID0gVXJsVXRpbHMubWFrZU5vcm1hbFVybCh1cmxQYXJ0KTtcbiAgICB2YXIgbWV0aG9kID0gJ0dFVCc7XG4gICAgdmFyIHRpbWVvdXQgPSBhdXRoV3JhcHBlci5tYXhPcGVyYXRpb25SZXRyeVRpbWUoKTtcbiAgICB2YXIgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIG1ldGFkYXRhSGFuZGxlcihhdXRoV3JhcHBlciwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5lcnJvckhhbmRsZXIgPSBvYmplY3RFcnJvckhhbmRsZXIobG9jYXRpb24pO1xuICAgIHJldHVybiByZXF1ZXN0SW5mbztcbn1cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNZXRhZGF0YShhdXRoV3JhcHBlciwgbG9jYXRpb24sIG1ldGFkYXRhLCBtYXBwaW5ncykge1xuICAgIHZhciB1cmxQYXJ0ID0gbG9jYXRpb24uZnVsbFNlcnZlclVybCgpO1xuICAgIHZhciB1cmwgPSBVcmxVdGlscy5tYWtlTm9ybWFsVXJsKHVybFBhcnQpO1xuICAgIHZhciBtZXRob2QgPSAnUEFUQ0gnO1xuICAgIHZhciBib2R5ID0gTWV0YWRhdGFVdGlscy50b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhLCBtYXBwaW5ncyk7XG4gICAgdmFyIGhlYWRlcnMgPSB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCcgfTtcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heE9wZXJhdGlvblJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncyksIHRpbWVvdXQpO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZU9iamVjdChhdXRoV3JhcHBlciwgbG9jYXRpb24pIHtcbiAgICB2YXIgdXJsUGFydCA9IGxvY2F0aW9uLmZ1bGxTZXJ2ZXJVcmwoKTtcbiAgICB2YXIgdXJsID0gVXJsVXRpbHMubWFrZU5vcm1hbFVybCh1cmxQYXJ0KTtcbiAgICB2YXIgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgdmFyIHRpbWVvdXQgPSBhdXRoV3JhcHBlci5tYXhPcGVyYXRpb25SZXRyeVRpbWUoKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkgeyB9XG4gICAgdmFyIHJlcXVlc3RJbmZvID0gbmV3IFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby5zdWNjZXNzQ29kZXMgPSBbMjAwLCAyMDRdO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IG9iamVjdEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluZUNvbnRlbnRUeXBlXyhtZXRhZGF0YSwgYmxvYikge1xuICAgIHJldHVybiAoKG1ldGFkYXRhICYmIG1ldGFkYXRhWydjb250ZW50VHlwZSddKSB8fFxuICAgICAgICAoYmxvYiAmJiBibG9iLnR5cGUoKSkgfHxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgb3B0X21ldGFkYXRhKSB7XG4gICAgdmFyIG1ldGFkYXRhID0gb2JqZWN0LmNsb25lKG9wdF9tZXRhZGF0YSk7XG4gICAgbWV0YWRhdGFbJ2Z1bGxQYXRoJ10gPSBsb2NhdGlvbi5wYXRoO1xuICAgIG1ldGFkYXRhWydzaXplJ10gPSBibG9iLnNpemUoKTtcbiAgICBpZiAoIW1ldGFkYXRhWydjb250ZW50VHlwZSddKSB7XG4gICAgICAgIG1ldGFkYXRhWydjb250ZW50VHlwZSddID0gZGV0ZXJtaW5lQ29udGVudFR5cGVfKG51bGwsIGJsb2IpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YWRhdGE7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwYXJ0VXBsb2FkKGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG9wdF9tZXRhZGF0YSkge1xuICAgIHZhciB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAnWC1Hb29nLVVwbG9hZC1Qcm90b2NvbCc6ICdtdWx0aXBhcnQnXG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZW5Cb3VuZGFyeSgpIHtcbiAgICAgICAgdmFyIHN0ciA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgICAgc3RyID1cbiAgICAgICAgICAgICAgICBzdHIgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHZhciBib3VuZGFyeSA9IGdlbkJvdW5kYXJ5KCk7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnbXVsdGlwYXJ0L3JlbGF0ZWQ7IGJvdW5kYXJ5PScgKyBib3VuZGFyeTtcbiAgICB2YXIgbWV0YWRhdGEgPSBtZXRhZGF0YUZvclVwbG9hZF8obG9jYXRpb24sIGJsb2IsIG9wdF9tZXRhZGF0YSk7XG4gICAgdmFyIG1ldGFkYXRhU3RyaW5nID0gTWV0YWRhdGFVdGlscy50b1Jlc291cmNlU3RyaW5nKG1ldGFkYXRhLCBtYXBwaW5ncyk7XG4gICAgdmFyIHByZUJsb2JQYXJ0ID0gJy0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1ldGFkYXRhU3RyaW5nICtcbiAgICAgICAgJ1xcclxcbi0tJyArXG4gICAgICAgIGJvdW5kYXJ5ICtcbiAgICAgICAgJ1xcclxcbicgK1xuICAgICAgICAnQ29udGVudC1UeXBlOiAnICtcbiAgICAgICAgbWV0YWRhdGFbJ2NvbnRlbnRUeXBlJ10gK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJztcbiAgICB2YXIgcG9zdEJsb2JQYXJ0ID0gJ1xcclxcbi0tJyArIGJvdW5kYXJ5ICsgJy0tJztcbiAgICB2YXIgYm9keSA9IEZic0Jsb2IuZ2V0QmxvYihwcmVCbG9iUGFydCwgYmxvYiwgcG9zdEJsb2JQYXJ0KTtcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0geyBuYW1lOiBtZXRhZGF0YVsnZnVsbFBhdGgnXSB9O1xuICAgIHZhciB1cmwgPSBVcmxVdGlscy5tYWtlVXBsb2FkVXJsKHVybFBhcnQpO1xuICAgIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gICAgdmFyIHRpbWVvdXQgPSBhdXRoV3JhcHBlci5tYXhVcGxvYWRSZXRyeVRpbWUoKTtcbiAgICB2YXIgcmVxdWVzdEluZm8gPSBuZXcgUmVxdWVzdEluZm8odXJsLCBtZXRob2QsIG1ldGFkYXRhSGFuZGxlcihhdXRoV3JhcHBlciwgbWFwcGluZ3MpLCB0aW1lb3V0KTtcbiAgICByZXF1ZXN0SW5mby51cmxQYXJhbXMgPSB1cmxQYXJhbXM7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHkudXBsb2FkRGF0YSgpO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBAcGFyYW0gY3VycmVudCBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaGF2ZSBiZWVuIHVwbG9hZGVkIHNvIGZhci5cbiAqIEBwYXJhbSB0b3RhbCBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X2ZpbmFsaXplZCBUcnVlIGlmIHRoZSBzZXJ2ZXIgaGFzIGZpbmlzaGVkIHRoZSB1cGxvYWQuXG4gKiBAcGFyYW0gb3B0X21ldGFkYXRhIFRoZSB1cGxvYWQgbWV0YWRhdGEsIHNob3VsZFxuICogICAgIG9ubHkgYmUgcGFzc2VkIGlmIG9wdF9maW5hbGl6ZWQgaXMgdHJ1ZS5cbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFJlc3VtYWJsZVVwbG9hZFN0YXR1cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN1bWFibGVVcGxvYWRTdGF0dXMoY3VycmVudCwgdG90YWwsIGZpbmFsaXplZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmZpbmFsaXplZCA9ICEhZmluYWxpemVkO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3VtYWJsZVVwbG9hZFN0YXR1cztcbn0oKSk7XG5leHBvcnQgeyBSZXN1bWFibGVVcGxvYWRTdGF0dXMgfTtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Jlc3VtZUhlYWRlcl8oeGhyLCBvcHRfYWxsb3dlZCkge1xuICAgIHZhciBzdGF0dXM7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RhdHVzID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUdvb2ctVXBsb2FkLVN0YXR1cycpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVyQ2hlY2soZmFsc2UpO1xuICAgIH1cbiAgICB2YXIgYWxsb3dlZCA9IG9wdF9hbGxvd2VkIHx8IFsnYWN0aXZlJ107XG4gICAgaGFuZGxlckNoZWNrKGFycmF5LmNvbnRhaW5zKGFsbG93ZWQsIHN0YXR1cykpO1xuICAgIHJldHVybiBzdGF0dXM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzdW1hYmxlVXBsb2FkKGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG9wdF9tZXRhZGF0YSkge1xuICAgIHZhciB1cmxQYXJ0ID0gbG9jYXRpb24uYnVja2V0T25seVNlcnZlclVybCgpO1xuICAgIHZhciBtZXRhZGF0YSA9IG1ldGFkYXRhRm9yVXBsb2FkXyhsb2NhdGlvbiwgYmxvYiwgb3B0X21ldGFkYXRhKTtcbiAgICB2YXIgdXJsUGFyYW1zID0geyBuYW1lOiBtZXRhZGF0YVsnZnVsbFBhdGgnXSB9O1xuICAgIHZhciB1cmwgPSBVcmxVdGlscy5tYWtlVXBsb2FkVXJsKHVybFBhcnQpO1xuICAgIHZhciBtZXRob2QgPSAnUE9TVCc7XG4gICAgdmFyIGhlYWRlcnMgPSB7XG4gICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBibG9iLnNpemUoKSxcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtSGVhZGVyLUNvbnRlbnQtVHlwZSc6IG1ldGFkYXRhWydjb250ZW50VHlwZSddLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXG4gICAgfTtcbiAgICB2YXIgYm9keSA9IE1ldGFkYXRhVXRpbHMudG9SZXNvdXJjZVN0cmluZyhtZXRhZGF0YSwgbWFwcGluZ3MpO1xuICAgIHZhciB0aW1lb3V0ID0gYXV0aFdyYXBwZXIubWF4VXBsb2FkUmV0cnlUaW1lKCk7XG4gICAgZnVuY3Rpb24gaGFuZGxlcih4aHIsIHRleHQpIHtcbiAgICAgICAgY2hlY2tSZXN1bWVIZWFkZXJfKHhocik7XG4gICAgICAgIHZhciB1cmw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cmwgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtR29vZy1VcGxvYWQtVVJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlckNoZWNrKHR5cGUuaXNTdHJpbmcodXJsKSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8udXJsUGFyYW1zID0gdXJsUGFyYW1zO1xuICAgIHJlcXVlc3RJbmZvLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHJlcXVlc3RJbmZvLmJvZHkgPSBib2R5O1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuLyoqXG4gKiBAcGFyYW0gdXJsIEZyb20gYSBjYWxsIHRvIGZicy5yZXF1ZXN0cy5jcmVhdGVSZXN1bWFibGVVcGxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXN1bWFibGVVcGxvYWRTdGF0dXMoYXV0aFdyYXBwZXIsIGxvY2F0aW9uLCB1cmwsIGJsb2IpIHtcbiAgICB2YXIgaGVhZGVycyA9IHsgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6ICdxdWVyeScgfTtcbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIHZhciBzaXplU3RyaW5nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2l6ZVN0cmluZyA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignWC1Hb29nLVVwbG9hZC1TaXplLVJlY2VpdmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJDaGVjayhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChzaXplU3RyaW5nLCAxMCk7XG4gICAgICAgIGhhbmRsZXJDaGVjayghaXNOYU4oc2l6ZSkpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhzaXplLCBibG9iLnNpemUoKSwgc3RhdHVzID09PSAnZmluYWwnKTtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heFVwbG9hZFJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyID0gc2hhcmVkRXJyb3JIYW5kbGVyKGxvY2F0aW9uKTtcbiAgICByZXR1cm4gcmVxdWVzdEluZm87XG59XG4vKipcbiAqIEFueSB1cGxvYWRzIHZpYSB0aGUgcmVzdW1hYmxlIHVwbG9hZCBBUEkgbXVzdCB0cmFuc2ZlciBhIG51bWJlciBvZiBieXRlc1xuICogdGhhdCBpcyBhIG11bHRpcGxlIG9mIHRoaXMgbnVtYmVyLlxuICovXG5leHBvcnQgdmFyIHJlc3VtYWJsZVVwbG9hZENodW5rU2l6ZSA9IDI1NiAqIDEwMjQ7XG4vKipcbiAqIEBwYXJhbSB1cmwgRnJvbSBhIGNhbGwgdG8gZmJzLnJlcXVlc3RzLmNyZWF0ZVJlc3VtYWJsZVVwbG9hZC5cbiAqIEBwYXJhbSBjaHVua1NpemUgTnVtYmVyIG9mIGJ5dGVzIHRvIHVwbG9hZC5cbiAqIEBwYXJhbSBvcHRfc3RhdHVzIFRoZSBwcmV2aW91cyBzdGF0dXMuXG4gKiAgICAgSWYgbm90IHBhc3NlZCBvciBudWxsLCB3ZSBzdGFydCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gKiBAdGhyb3dzIGZicy5FcnJvciBJZiB0aGUgdXBsb2FkIGlzIGFscmVhZHkgY29tcGxldGUsIHRoZSBwYXNzZWQgaW4gc3RhdHVzXG4gKiAgICAgaGFzIGEgZmluYWwgc2l6ZSBpbmNvbnNpc3RlbnQgd2l0aCB0aGUgYmxvYiwgb3IgdGhlIGJsb2IgY2Fubm90IGJlIHNsaWNlZFxuICogICAgIGZvciB1cGxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZVJlc3VtYWJsZVVwbG9hZChsb2NhdGlvbiwgYXV0aFdyYXBwZXIsIHVybCwgYmxvYiwgY2h1bmtTaXplLCBtYXBwaW5ncywgb3B0X3N0YXR1cywgb3B0X3Byb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAvLyBUT0RPKGFuZHlzb3RvKTogc3RhbmRhcmRpemUgb24gaW50ZXJuYWwgYXNzZXJ0c1xuICAgIC8vIGFzc2VydCghKG9wdF9zdGF0dXMgJiYgb3B0X3N0YXR1cy5maW5hbGl6ZWQpKTtcbiAgICB2YXIgc3RhdHVzID0gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cygwLCAwKTtcbiAgICBpZiAob3B0X3N0YXR1cykge1xuICAgICAgICBzdGF0dXMuY3VycmVudCA9IG9wdF9zdGF0dXMuY3VycmVudDtcbiAgICAgICAgc3RhdHVzLnRvdGFsID0gb3B0X3N0YXR1cy50b3RhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXR1cy5jdXJyZW50ID0gMDtcbiAgICAgICAgc3RhdHVzLnRvdGFsID0gYmxvYi5zaXplKCk7XG4gICAgfVxuICAgIGlmIChibG9iLnNpemUoKSAhPT0gc3RhdHVzLnRvdGFsKSB7XG4gICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuc2VydmVyRmlsZVdyb25nU2l6ZSgpO1xuICAgIH1cbiAgICB2YXIgYnl0ZXNMZWZ0ID0gc3RhdHVzLnRvdGFsIC0gc3RhdHVzLmN1cnJlbnQ7XG4gICAgdmFyIGJ5dGVzVG9VcGxvYWQgPSBieXRlc0xlZnQ7XG4gICAgaWYgKGNodW5rU2l6ZSA+IDApIHtcbiAgICAgICAgYnl0ZXNUb1VwbG9hZCA9IE1hdGgubWluKGJ5dGVzVG9VcGxvYWQsIGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIHZhciBzdGFydEJ5dGUgPSBzdGF0dXMuY3VycmVudDtcbiAgICB2YXIgZW5kQnl0ZSA9IHN0YXJ0Qnl0ZSArIGJ5dGVzVG9VcGxvYWQ7XG4gICAgdmFyIHVwbG9hZENvbW1hbmQgPSBieXRlc1RvVXBsb2FkID09PSBieXRlc0xlZnQgPyAndXBsb2FkLCBmaW5hbGl6ZScgOiAndXBsb2FkJztcbiAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgJ1gtR29vZy1VcGxvYWQtQ29tbWFuZCc6IHVwbG9hZENvbW1hbmQsXG4gICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IHN0YXR1cy5jdXJyZW50XG4gICAgfTtcbiAgICB2YXIgYm9keSA9IGJsb2Iuc2xpY2Uoc3RhcnRCeXRlLCBlbmRCeXRlKTtcbiAgICBpZiAoYm9keSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmNhbm5vdFNsaWNlQmxvYigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVyKHhociwgdGV4dCkge1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogVmVyaWZ5IHRoZSBNRDUgb2YgZWFjaCB1cGxvYWRlZCByYW5nZTpcbiAgICAgICAgLy8gdGhlICd4LXJhbmdlLW1kNScgaGVhZGVyIGNvbWVzIGJhY2sgd2l0aCBzdGF0dXMgY29kZSAzMDggcmVzcG9uc2VzLlxuICAgICAgICAvLyBXZSdsbCBvbmx5IGJlIGFibGUgdG8gYmFpbCBvdXQgdGhvdWdoLCBiZWNhdXNlIHlvdSBjYW4ndCByZS11cGxvYWQgYVxuICAgICAgICAvLyByYW5nZSB0aGF0IHlvdSBwcmV2aW91c2x5IHVwbG9hZGVkLlxuICAgICAgICB2YXIgdXBsb2FkU3RhdHVzID0gY2hlY2tSZXN1bWVIZWFkZXJfKHhociwgWydhY3RpdmUnLCAnZmluYWwnXSk7XG4gICAgICAgIHZhciBuZXdDdXJyZW50ID0gc3RhdHVzLmN1cnJlbnQgKyBieXRlc1RvVXBsb2FkO1xuICAgICAgICB2YXIgc2l6ZSA9IGJsb2Iuc2l6ZSgpO1xuICAgICAgICB2YXIgbWV0YWRhdGE7XG4gICAgICAgIGlmICh1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFIYW5kbGVyKGF1dGhXcmFwcGVyLCBtYXBwaW5ncykoeGhyLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc3VtYWJsZVVwbG9hZFN0YXR1cyhuZXdDdXJyZW50LCBzaXplLCB1cGxvYWRTdGF0dXMgPT09ICdmaW5hbCcsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgdmFyIG1ldGhvZCA9ICdQT1NUJztcbiAgICB2YXIgdGltZW91dCA9IGF1dGhXcmFwcGVyLm1heFVwbG9hZFJldHJ5VGltZSgpO1xuICAgIHZhciByZXF1ZXN0SW5mbyA9IG5ldyBSZXF1ZXN0SW5mbyh1cmwsIG1ldGhvZCwgaGFuZGxlciwgdGltZW91dCk7XG4gICAgcmVxdWVzdEluZm8uaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgcmVxdWVzdEluZm8uYm9keSA9IGJvZHkudXBsb2FkRGF0YSgpO1xuICAgIHJlcXVlc3RJbmZvLnByb2dyZXNzQ2FsbGJhY2sgPSBvcHRfcHJvZ3Jlc3NDYWxsYmFjayB8fCBudWxsO1xuICAgIHJlcXVlc3RJbmZvLmVycm9ySGFuZGxlciA9IHNoYXJlZEVycm9ySGFuZGxlcihsb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlcXVlc3RJbmZvO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0cy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0cy5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ0BmaXJlYmFzZS9kYXRhYmFzZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZmlyZWJhc2UvZGF0YWJhc2UvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAnLi9zcmMvcG9seWZpbGxzL3Byb21pc2UnO1xuaW1wb3J0ICcuL3NyYy9zaGltcy9maW5kJztcbmltcG9ydCAnLi9zcmMvc2hpbXMvZmluZEluZGV4JztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2dsb2JhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBsb2NhdGUgZ2xvYmFsIG9iamVjdCcpO1xufSkoKTtcbi8vIFBvbHlmaWxsIFByb21pc2VcbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBIQUNLOiBUUyB0aHJvd3MgYW4gZXJyb3IgaWYgSSBhdHRlbXB0IHRvIHVzZSAnZG90LW5vdGF0aW9uJ1xuICAgIF9fZ2xvYmFsWydQcm9taXNlJ10gPSBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZS1wb2x5ZmlsbCcpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9taXNlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3BvbHlmaWxsL2Rpc3QvZXNtL3NyYy9wb2x5ZmlsbHMvcHJvbWlzZS5qc1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIoZnVuY3Rpb24gKHJvb3QpIHtcblxuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBwcm9taXNlLXBvbHlmaWxsIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuICBmdW5jdGlvbiBub29wKCkge31cbiAgXG4gIC8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuICBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gICAgdGhpcy5fc3RhdGUgPSAwO1xuICAgIHRoaXMuX2hhbmRsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZWZlcnJlZHMgPSBbXTtcblxuICAgIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgICB3aGlsZSAoc2VsZi5fc3RhdGUgPT09IDMpIHtcbiAgICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgICB9XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAwKSB7XG4gICAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYiA9IHNlbGYuX3N0YXRlID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJldDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHNlbGYuX3ZhbHVlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJyk7XG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW47XG4gICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgICAgc2VsZi5fdmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICBmaW5hbGUoc2VsZik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKGJpbmQodGhlbiwgbmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVqZWN0KHNlbGYsIGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICAgIHNlbGYuX3N0YXRlID0gMjtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gICAgaWYgKHNlbGYuX3N0YXRlID09PSAyICYmIHNlbGYuX2RlZmVycmVkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbihzZWxmLl92YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICAgIH1cbiAgICBzZWxmLl9kZWZlcnJlZHMgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSkge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gICAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gICAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICAgKlxuICAgKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gICAqL1xuICBmdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHNlbGYsIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgcmVqZWN0KHNlbGYsIGV4KTtcbiAgICB9XG4gIH1cblxuICBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgfTtcblxuICBQcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHByb20gPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKG5vb3ApO1xuXG4gICAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9tKSk7XG4gICAgcmV0dXJuIHByb207XG4gIH07XG5cbiAgUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICghYXJyIHx8IHR5cGVvZiBhcnIubGVuZ3RoID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZS5hbGwgYWNjZXB0cyBhbiBhcnJheScpO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVqZWN0KHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICBQcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgcG9seWZpbGwgZm9yIHNldEltbWVkaWF0ZSBmb3IgcGVyZm9ybWFuY2UgZ2FpbnNcbiAgUHJvbWlzZS5faW1tZWRpYXRlRm4gPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiAoZm4pIHsgc2V0SW1tZWRpYXRlKGZuKTsgfSkgfHxcbiAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXRGdW5jKGZuLCAwKTtcbiAgICB9O1xuXG4gIFByb21pc2UuX3VuaGFuZGxlZFJlamVjdGlvbkZuID0gZnVuY3Rpb24gX3VuaGFuZGxlZFJlamVjdGlvbkZuKGVycikge1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZSkge1xuICAgICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGltbWVkaWF0ZSBmdW5jdGlvbiB0byBleGVjdXRlIGNhbGxiYWNrc1xuICAgKiBAcGFyYW0gZm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0byBleGVjdXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBQcm9taXNlLl9zZXRJbW1lZGlhdGVGbiA9IGZ1bmN0aW9uIF9zZXRJbW1lZGlhdGVGbihmbikge1xuICAgIFByb21pc2UuX2ltbWVkaWF0ZUZuID0gZm47XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiB1bmhhbmRsZWQgcmVqZWN0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gdW5oYW5kbGVkIHJlamVjdGlvblxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgUHJvbWlzZS5fc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4gPSBmdW5jdGlvbiBfc2V0VW5oYW5kbGVkUmVqZWN0aW9uRm4oZm4pIHtcbiAgICBQcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZuO1xuICB9O1xuICBcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuICB9IGVsc2UgaWYgKCFyb290LlByb21pc2UpIHtcbiAgICByb290LlByb21pc2UgPSBQcm9taXNlO1xuICB9XG5cbn0pKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHJvbWlzZS1wb2x5ZmlsbC9wcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQpIHtcbiAgICB0aW1lb3V0LmNsb3NlKCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIFRpbWVvdXQoaWQsIGNsZWFyRm4pIHtcbiAgdGhpcy5faWQgPSBpZDtcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XG59XG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKCkge307XG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9jbGVhckZuLmNhbGwod2luZG93LCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIEFycmF5LnByb3RvdHlwZS5maW5kIHBvbHlmaWxsIGZyb20gTUROXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kXG4gKiBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICovXG5pZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmQnLCB7XG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiAocHJlZGljYXRlKSB7XG4gICAgICAgICAgICAvLyAxLiBMZXQgTyBiZSA/IFRvT2JqZWN0KHRoaXMgdmFsdWUpLlxuICAgICAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widGhpc1wiIGlzIG51bGwgb3Igbm90IGRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvID0gT2JqZWN0KHRoaXMpO1xuICAgICAgICAgICAgLy8gMi4gTGV0IGxlbiBiZSA/IFRvTGVuZ3RoKD8gR2V0KE8sIFwibGVuZ3RoXCIpKS5cbiAgICAgICAgICAgIHZhciBsZW4gPSBvLmxlbmd0aCA+Pj4gMDtcbiAgICAgICAgICAgIC8vIDMuIElmIElzQ2FsbGFibGUocHJlZGljYXRlKSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcmVkaWNhdGUgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyA0LiBJZiB0aGlzQXJnIHdhcyBzdXBwbGllZCwgbGV0IFQgYmUgdGhpc0FyZzsgZWxzZSBsZXQgVCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIC8vIDUuIExldCBrIGJlIDAuXG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAvLyA2LiBSZXBlYXQsIHdoaWxlIGsgPCBsZW5cbiAgICAgICAgICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gYS4gTGV0IFBrIGJlICEgVG9TdHJpbmcoaykuXG4gICAgICAgICAgICAgICAgLy8gYi4gTGV0IGtWYWx1ZSBiZSA/IEdldChPLCBQaykuXG4gICAgICAgICAgICAgICAgLy8gYy4gTGV0IHRlc3RSZXN1bHQgYmUgVG9Cb29sZWFuKD8gQ2FsbChwcmVkaWNhdGUsIFQsIMKrIGtWYWx1ZSwgaywgTyDCuykpLlxuICAgICAgICAgICAgICAgIC8vIGQuIElmIHRlc3RSZXN1bHQgaXMgdHJ1ZSwgcmV0dXJuIGtWYWx1ZS5cbiAgICAgICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlLiBJbmNyZWFzZSBrIGJ5IDEuXG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gNy4gUmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluZC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9wb2x5ZmlsbC9kaXN0L2VzbS9zcmMvc2hpbXMvZmluZC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBUaGlzIGlzIHRoZSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4IHBvbHlmaWxsIGZyb20gTUROXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maW5kSW5kZXhcbiAqIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhcbiAqL1xuaWYgKCFBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbmRJbmRleCcsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIC8vIDEuIExldCBPIGJlID8gVG9PYmplY3QodGhpcyB2YWx1ZSkuXG4gICAgICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ0aGlzXCIgaXMgbnVsbCBvciBub3QgZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG8gPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICAvLyAyLiBMZXQgbGVuIGJlID8gVG9MZW5ndGgoPyBHZXQoTywgXCJsZW5ndGhcIikpLlxuICAgICAgICAgICAgdmFyIGxlbiA9IG8ubGVuZ3RoID4+PiAwO1xuICAgICAgICAgICAgLy8gMy4gSWYgSXNDYWxsYWJsZShwcmVkaWNhdGUpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDQuIElmIHRoaXNBcmcgd2FzIHN1cHBsaWVkLCBsZXQgVCBiZSB0aGlzQXJnOyBlbHNlIGxldCBUIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIHZhciB0aGlzQXJnID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgLy8gNS4gTGV0IGsgYmUgMC5cbiAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgIC8vIDYuIFJlcGVhdCwgd2hpbGUgayA8IGxlblxuICAgICAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBhLiBMZXQgUGsgYmUgISBUb1N0cmluZyhrKS5cbiAgICAgICAgICAgICAgICAvLyBiLiBMZXQga1ZhbHVlIGJlID8gR2V0KE8sIFBrKS5cbiAgICAgICAgICAgICAgICAvLyBjLiBMZXQgdGVzdFJlc3VsdCBiZSBUb0Jvb2xlYW4oPyBDYWxsKHByZWRpY2F0ZSwgVCwgwqsga1ZhbHVlLCBrLCBPIMK7KSkuXG4gICAgICAgICAgICAgICAgLy8gZC4gSWYgdGVzdFJlc3VsdCBpcyB0cnVlLCByZXR1cm4gay5cbiAgICAgICAgICAgICAgICB2YXIga1ZhbHVlID0gb1trXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywga1ZhbHVlLCBrLCBvKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZS4gSW5jcmVhc2UgayBieSAxLlxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIDcuIFJldHVybiAtMS5cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maW5kSW5kZXguanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvcG9seWZpbGwvZGlzdC9lc20vc3JjL3NoaW1zL2ZpbmRJbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgcGF0Y2hQcm9wZXJ0eSwgZGVlcENvcHksIGRlZXBFeHRlbmQsIEVycm9yRmFjdG9yeSB9IGZyb20gJ0BmaXJlYmFzZS91dGlsJztcbnZhciBjb250YWlucyA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufTtcbnZhciBERUZBVUxUX0VOVFJZX05BTUUgPSAnW0RFRkFVTFRdJztcbi8vIEFuIGFycmF5IHRvIGNhcHR1cmUgbGlzdGVuZXJzIGJlZm9yZSB0aGUgdHJ1ZSBhdXRoIGZ1bmN0aW9uc1xuLy8gZXhpc3RcbnZhciB0b2tlbkxpc3RlbmVycyA9IFtdO1xuLyoqXG4gKiBHbG9iYWwgY29udGV4dCBvYmplY3QgZm9yIGEgY29sbGVjdGlvbiBvZiBzZXJ2aWNlcyB1c2luZ1xuICogYSBzaGFyZWQgYXV0aGVudGljYXRpb24gc3RhdGUuXG4gKi9cbnZhciBGaXJlYmFzZUFwcEltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlyZWJhc2VBcHBJbXBsKG9wdGlvbnMsIG5hbWUsIGZpcmViYXNlXykge1xuICAgICAgICB0aGlzLmZpcmViYXNlXyA9IGZpcmViYXNlXztcbiAgICAgICAgdGhpcy5pc0RlbGV0ZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VydmljZXNfID0ge307XG4gICAgICAgIHRoaXMubmFtZV8gPSBuYW1lO1xuICAgICAgICB0aGlzLm9wdGlvbnNfID0gZGVlcENvcHkob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuSU5URVJOQUwgPSB7XG4gICAgICAgICAgICBnZXRVaWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBnZXRUb2tlbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpOyB9LFxuICAgICAgICAgICAgYWRkQXV0aFRva2VuTGlzdGVuZXI6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRva2VuTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjYWxsYmFjayBpcyBjYWxsZWQsIGFzeW5jaHJvbm91c2x5LCBpbiB0aGUgYWJzZW5jZSBvZiB0aGUgYXV0aCBtb2R1bGVcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxiYWNrKG51bGwpOyB9LCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcjogZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5MaXN0ZW5lcnMgPSB0b2tlbkxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBsaXN0ZW5lciAhPT0gY2FsbGJhY2s7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRGVzdHJveWVkXygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZV87XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zXztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuY2hlY2tEZXN0cm95ZWRfKCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5maXJlYmFzZV8uSU5URVJOQUwucmVtb3ZlQXBwKF90aGlzLm5hbWVfKTtcbiAgICAgICAgICAgIHZhciBzZXJ2aWNlcyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuc2VydmljZXNfKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2aWNlS2V5KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoX3RoaXMuc2VydmljZXNfW3NlcnZpY2VLZXldKS5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZUtleSkge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2aWNlcy5wdXNoKF90aGlzLnNlcnZpY2VzX1tzZXJ2aWNlS2V5XVtpbnN0YW5jZUtleV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2VydmljZXMubWFwKGZ1bmN0aW9uIChzZXJ2aWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2UuSU5URVJOQUwuZGVsZXRlKCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5pc0RlbGV0ZWRfID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLnNlcnZpY2VzXyA9IHt9O1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHNlcnZpY2UgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXBwIChjcmVhdGluZyBpdFxuICAgICAqIG9uIGRlbWFuZCksIGlkZW50aWZpZWQgYnkgdGhlIHBhc3NlZCBpbnN0YW5jZUlkZW50aWZpZXIuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDdXJyZW50bHkgc3RvcmFnZSBpcyB0aGUgb25seSBvbmUgdGhhdCBpcyBsZXZlcmFnaW5nIHRoaXNcbiAgICAgKiBmdW5jdGlvbmFsaXR5LiBUaGV5IGludm9rZSBpdCBieSBjYWxsaW5nOlxuICAgICAqXG4gICAgICogYGBgamF2YXNjcmlwdFxuICAgICAqIGZpcmViYXNlLmFwcCgpLnN0b3JhZ2UoJ1NUT1JBR0UgQlVDS0VUIElEJylcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBzZXJ2aWNlIG5hbWUgaXMgcGFzc2VkIHRvIHRoaXMgYWxyZWFkeVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuX2dldFNlcnZpY2UgPSBmdW5jdGlvbiAobmFtZSwgaW5zdGFuY2VJZGVudGlmaWVyKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZUlkZW50aWZpZXIgPT09IHZvaWQgMCkgeyBpbnN0YW5jZUlkZW50aWZpZXIgPSBERUZBVUxUX0VOVFJZX05BTUU7IH1cbiAgICAgICAgdGhpcy5jaGVja0Rlc3Ryb3llZF8oKTtcbiAgICAgICAgaWYgKCF0aGlzLnNlcnZpY2VzX1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlc19bbmFtZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VydmljZXNfW25hbWVdW2luc3RhbmNlSWRlbnRpZmllcl0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgYSBjdXN0b20gaW5zdGFuY2UgaGFzIGJlZW4gZGVmaW5lZCAoaS5lLiBub3QgJ1tERUZBVUxUXScpXG4gICAgICAgICAgICAgKiB0aGVuIHdlIHdpbGwgcGFzcyB0aGF0IGluc3RhbmNlIG9uLCBvdGhlcndpc2Ugd2UgcGFzcyBgbnVsbGBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlU3BlY2lmaWVyID0gaW5zdGFuY2VJZGVudGlmaWVyICE9PSBERUZBVUxUX0VOVFJZX05BTUVcbiAgICAgICAgICAgICAgICA/IGluc3RhbmNlSWRlbnRpZmllclxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHNlcnZpY2UgPSB0aGlzLmZpcmViYXNlXy5JTlRFUk5BTC5mYWN0b3JpZXNbbmFtZV0odGhpcywgdGhpcy5leHRlbmRBcHAuYmluZCh0aGlzKSwgaW5zdGFuY2VTcGVjaWZpZXIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlc19bbmFtZV1baW5zdGFuY2VJZGVudGlmaWVyXSA9IHNlcnZpY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZXNfW25hbWVdW2luc3RhbmNlSWRlbnRpZmllcl07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB1c2VkIHRvIGV4dGVuZCBhbiBBcHAgaW5zdGFuY2UgYXQgdGhlIHRpbWVcbiAgICAgKiBvZiBzZXJ2aWNlIGluc3RhbmNlIGNyZWF0aW9uLlxuICAgICAqL1xuICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUuZXh0ZW5kQXBwID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIENvcHkgdGhlIG9iamVjdCBvbnRvIHRoZSBGaXJlYmFzZUFwcEltcGwgcHJvdG90eXBlXG4gICAgICAgIGRlZXBFeHRlbmQodGhpcywgcHJvcHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGFwcCBoYXMgb3ZlcndyaXR0ZW4gdGhlIGFkZEF1dGhUb2tlbkxpc3RlbmVyIHN0dWIsIGZvcndhcmRcbiAgICAgICAgICogdGhlIGFjdGl2ZSB0b2tlbiBsaXN0ZW5lcnMgb24gdG8gdGhlIHRydWUgZnhuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIGZ1bmN0aW9uIGlzIHJlcXVpcmVkIGR1ZSB0byBvdXIgY3VycmVudCBtb2R1bGVcbiAgICAgICAgICogc3RydWN0dXJlLiBPbmNlIHdlIGFyZSBhYmxlIHRvIHJlbHkgc3RyaWN0bHkgdXBvbiBhIHNpbmdsZSBtb2R1bGVcbiAgICAgICAgICogaW1wbGVtZW50YXRpb24sIHRoaXMgY29kZSBzaG91bGQgYmUgcmVmYWN0b3JlZCBhbmQgQXV0aCBzaG91bGRcbiAgICAgICAgICogcHJvdmlkZSB0aGVzZSBzdHVicyBhbmQgdGhlIHVwZ3JhZGUgbG9naWNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChwcm9wcy5JTlRFUk5BTCAmJiBwcm9wcy5JTlRFUk5BTC5hZGRBdXRoVG9rZW5MaXN0ZW5lcikge1xuICAgICAgICAgICAgdG9rZW5MaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5JTlRFUk5BTC5hZGRBdXRoVG9rZW5MaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRva2VuTGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0aHJvdyBhbiBFcnJvciBpZiB0aGUgQXBwIGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZCAtXG4gICAgICogdXNlIGJlZm9yZSBwZXJmb3JtaW5nIEFQSSBhY3Rpb25zIG9uIHRoZSBBcHAuXG4gICAgICovXG4gICAgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5jaGVja0Rlc3Ryb3llZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsZXRlZF8pIHtcbiAgICAgICAgICAgIGVycm9yKCdhcHAtZGVsZXRlZCcsIHsgbmFtZTogdGhpcy5uYW1lXyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpcmViYXNlQXBwSW1wbDtcbn0oKSk7XG4vLyBQcmV2ZW50IGRlYWQtY29kZSBlbGltaW5hdGlvbiBvZiB0aGVzZSBtZXRob2RzIHcvbyBpbnZhbGlkIHByb3BlcnR5XG4vLyBjb3B5aW5nLlxuKEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGUubmFtZSAmJiBGaXJlYmFzZUFwcEltcGwucHJvdG90eXBlLm9wdGlvbnMpIHx8XG4gICAgRmlyZWJhc2VBcHBJbXBsLnByb3RvdHlwZS5kZWxldGUgfHxcbiAgICBjb25zb2xlLmxvZygnZGMnKTtcbi8qKlxuICogUmV0dXJuIGEgZmlyZWJhc2UgbmFtZXNwYWNlIG9iamVjdC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIHdpbGwgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSBhbmQgdGhlIHJlc3VsdFxuICogYXNzaWduZWQgdG8gdGhlICdmaXJlYmFzZScgZ2xvYmFsLiAgSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1xuICogaW4gdW5pdCB0ZXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlKCkge1xuICAgIHZhciBhcHBzXyA9IHt9O1xuICAgIHZhciBmYWN0b3JpZXMgPSB7fTtcbiAgICB2YXIgYXBwSG9va3MgPSB7fTtcbiAgICAvLyBBIG5hbWVzcGFjZSBpcyBhIHBsYWluIEphdmFTY3JpcHQgT2JqZWN0LlxuICAgIHZhciBuYW1lc3BhY2UgPSB7XG4gICAgICAgIC8vIEhhY2sgdG8gcHJldmVudCBCYWJlbCBmcm9tIG1vZGlmeWluZyB0aGUgb2JqZWN0IHJldHVybmVkXG4gICAgICAgIC8vIGFzIHRoZSBmaXJlYmFzZSBuYW1lc3BhY2UuXG4gICAgICAgIF9fZXNNb2R1bGU6IHRydWUsXG4gICAgICAgIGluaXRpYWxpemVBcHA6IGluaXRpYWxpemVBcHAsXG4gICAgICAgIGFwcDogYXBwLFxuICAgICAgICBhcHBzOiBudWxsLFxuICAgICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgICBTREtfVkVSU0lPTjogJzQuOC4wJyxcbiAgICAgICAgSU5URVJOQUw6IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU2VydmljZTogcmVnaXN0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgY3JlYXRlRmlyZWJhc2VOYW1lc3BhY2U6IGNyZWF0ZUZpcmViYXNlTmFtZXNwYWNlLFxuICAgICAgICAgICAgZXh0ZW5kTmFtZXNwYWNlOiBleHRlbmROYW1lc3BhY2UsXG4gICAgICAgICAgICBjcmVhdGVTdWJzY3JpYmU6IGNyZWF0ZVN1YnNjcmliZSxcbiAgICAgICAgICAgIEVycm9yRmFjdG9yeTogRXJyb3JGYWN0b3J5LFxuICAgICAgICAgICAgcmVtb3ZlQXBwOiByZW1vdmVBcHAsXG4gICAgICAgICAgICBmYWN0b3JpZXM6IGZhY3RvcmllcyxcbiAgICAgICAgICAgIHVzZUFzU2VydmljZTogdXNlQXNTZXJ2aWNlLFxuICAgICAgICAgICAgUHJvbWlzZTogUHJvbWlzZSxcbiAgICAgICAgICAgIGRlZXBFeHRlbmQ6IGRlZXBFeHRlbmRcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSW5qZWN0IGEgY2lyY3VsYXIgZGVmYXVsdCBleHBvcnQgdG8gYWxsb3cgQmFiZWwgdXNlcnMgd2hvIHdlcmUgcHJldmlvdXNseVxuICAgIC8vIHVzaW5nOlxuICAgIC8vXG4gICAgLy8gICBpbXBvcnQgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UnO1xuICAgIC8vICAgd2hpY2ggYmVjb21lczogdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnZmlyZWJhc2UnKS5kZWZhdWx0O1xuICAgIC8vXG4gICAgLy8gaW5zdGVhZCBvZlxuICAgIC8vXG4gICAgLy8gICBpbXBvcnQgKiBhcyBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZSc7XG4gICAgLy8gICB3aGljaCBiZWNvbWVzOiB2YXIgZmlyZWJhc2UgPSByZXF1aXJlKCdmaXJlYmFzZScpO1xuICAgIHBhdGNoUHJvcGVydHkobmFtZXNwYWNlLCAnZGVmYXVsdCcsIG5hbWVzcGFjZSk7XG4gICAgLy8gZmlyZWJhc2UuYXBwcyBpcyBhIHJlYWQtb25seSBnZXR0ZXIuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hbWVzcGFjZSwgJ2FwcHMnLCB7XG4gICAgICAgIGdldDogZ2V0QXBwc1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBieSBBcHAuZGVsZXRlKCkgLSBidXQgYmVmb3JlIGFueSBzZXJ2aWNlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEFwcFxuICAgICAqIGFyZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUFwcChuYW1lKSB7XG4gICAgICAgIHZhciBhcHAgPSBhcHBzX1tuYW1lXTtcbiAgICAgICAgY2FsbEFwcEhvb2tzKGFwcCwgJ2RlbGV0ZScpO1xuICAgICAgICBkZWxldGUgYXBwc19bbmFtZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQXBwIG9iamVjdCBmb3IgYSBnaXZlbiBuYW1lIChvciBERUZBVUxUKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcHAobmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZSB8fCBERUZBVUxUX0VOVFJZX05BTUU7XG4gICAgICAgIGlmICghY29udGFpbnMoYXBwc18sIG5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcignbm8tYXBwJywgeyBuYW1lOiBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcHBzX1tuYW1lXTtcbiAgICB9XG4gICAgcGF0Y2hQcm9wZXJ0eShhcHAsICdBcHAnLCBGaXJlYmFzZUFwcEltcGwpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBBcHAgaW5zdGFuY2UgKG5hbWUgbXVzdCBiZSB1bmlxdWUpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVBcHAob3B0aW9ucywgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYW1lID0gREVGQVVMVF9FTlRSWV9OQU1FO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lID09PSAnJykge1xuICAgICAgICAgICAgICAgIGVycm9yKCdiYWQtYXBwLW5hbWUnLCB7IG5hbWU6IG5hbWUgKyAnJyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGFpbnMoYXBwc18sIG5hbWUpKSB7XG4gICAgICAgICAgICBlcnJvcignZHVwbGljYXRlLWFwcCcsIHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXBwID0gbmV3IEZpcmViYXNlQXBwSW1wbChvcHRpb25zLCBuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgICBhcHBzX1tuYW1lXSA9IGFwcDtcbiAgICAgICAgY2FsbEFwcEhvb2tzKGFwcCwgJ2NyZWF0ZScpO1xuICAgICAgICByZXR1cm4gYXBwO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBhbGwgdGhlIG5vbi1kZWxldGVkIEZpcmViYXNlQXBwcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBcHBzKCkge1xuICAgICAgICAvLyBNYWtlIGEgY29weSBzbyBjYWxsZXIgY2Fubm90IG11dGF0ZSB0aGUgYXBwcyBsaXN0LlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYXBwc18pLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXBwc19bbmFtZV07IH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFJlZ2lzdGVyIGEgRmlyZWJhc2UgU2VydmljZS5cbiAgICAgKlxuICAgICAqIGZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZSgpXG4gICAgICpcbiAgICAgKiBUT0RPOiBJbXBsZW1lbnQgc2VydmljZVByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJTZXJ2aWNlKG5hbWUsIGNyZWF0ZVNlcnZpY2UsIHNlcnZpY2VQcm9wZXJ0aWVzLCBhcHBIb29rLCBhbGxvd011bHRpcGxlSW5zdGFuY2VzKSB7XG4gICAgICAgIC8vIENhbm5vdCByZS1yZWdpc3RlciBhIHNlcnZpY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBpZiAoZmFjdG9yaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBlcnJvcignZHVwbGljYXRlLXNlcnZpY2UnLCB7IG5hbWU6IG5hbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgc2VydmljZSBmYWN0b3J5IGZvciBsYXRlciBzZXJ2aWNlIGluc3RhbnRpYXRpb25cbiAgICAgICAgZmFjdG9yaWVzW25hbWVdID0gY3JlYXRlU2VydmljZTtcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgYXBwSG9vaywgaWYgcGFzc2VkXG4gICAgICAgIGlmIChhcHBIb29rKSB7XG4gICAgICAgICAgICBhcHBIb29rc1tuYW1lXSA9IGFwcEhvb2s7XG4gICAgICAgICAgICAvLyBSdW4gdGhlICoqbmV3KiogYXBwIGhvb2sgb24gYWxsIGV4aXN0aW5nIGFwcHNcbiAgICAgICAgICAgIGdldEFwcHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChhcHApIHtcbiAgICAgICAgICAgICAgICBhcHBIb29rKCdjcmVhdGUnLCBhcHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIFNlcnZpY2UgbmFtZXNwYWNlIGlzIGFuIGFjY2Vzc29yIGZ1bmN0aW9uIC4uLlxuICAgICAgICB2YXIgc2VydmljZU5hbWVzcGFjZSA9IGZ1bmN0aW9uIChhcHBBcmcpIHtcbiAgICAgICAgICAgIGlmIChhcHBBcmcgPT09IHZvaWQgMCkgeyBhcHBBcmcgPSBhcHAoKTsgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcHBBcmdbbmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGFyZ3VtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyBpbiB0aGUgZm9sbG93aW5nIGNhc2U6IGZpcmViYXNlLnN0b3JhZ2UoJ2dzOi8nKVxuICAgICAgICAgICAgICAgIGVycm9yKCdpbnZhbGlkLWFwcC1hcmd1bWVudCcsIHsgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvcndhcmQgc2VydmljZSBpbnN0YW5jZSBsb29rdXAgdG8gdGhlIEZpcmViYXNlQXBwLlxuICAgICAgICAgICAgcmV0dXJuIGFwcEFyZ1tuYW1lXSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyAuLi4gYW5kIGEgY29udGFpbmVyIGZvciBzZXJ2aWNlLWxldmVsIHByb3BlcnRpZXMuXG4gICAgICAgIGlmIChzZXJ2aWNlUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWVwRXh0ZW5kKHNlcnZpY2VOYW1lc3BhY2UsIHNlcnZpY2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNb25rZXktcGF0Y2ggdGhlIHNlcnZpY2VOYW1lc3BhY2Ugb250byB0aGUgZmlyZWJhc2UgbmFtZXNwYWNlXG4gICAgICAgIG5hbWVzcGFjZVtuYW1lXSA9IHNlcnZpY2VOYW1lc3BhY2U7XG4gICAgICAgIC8vIFBhdGNoIHRoZSBGaXJlYmFzZUFwcEltcGwgcHJvdG90eXBlXG4gICAgICAgIEZpcmViYXNlQXBwSW1wbC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VydmljZUZ4biA9IHRoaXMuX2dldFNlcnZpY2UuYmluZCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlRnhuLmFwcGx5KHRoaXMsIGFsbG93TXVsdGlwbGVJbnN0YW5jZXMgPyBhcmdzIDogW10pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc2VydmljZU5hbWVzcGFjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF0Y2ggdGhlIHRvcC1sZXZlbCBmaXJlYmFzZSBuYW1lc3BhY2Ugd2l0aCBhZGRpdGlvbmFsIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBmaXJlYmFzZS5JTlRFUk5BTC5leHRlbmROYW1lc3BhY2UoKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGV4dGVuZE5hbWVzcGFjZShwcm9wcykge1xuICAgICAgICBkZWVwRXh0ZW5kKG5hbWVzcGFjZSwgcHJvcHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsQXBwSG9va3MoYXBwLCBldmVudE5hbWUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoZmFjdG9yaWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzZXJ2aWNlTmFtZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIHZpcnR1YWwgc2VydmljZXNcbiAgICAgICAgICAgIHZhciBmYWN0b3J5TmFtZSA9IHVzZUFzU2VydmljZShhcHAsIHNlcnZpY2VOYW1lKTtcbiAgICAgICAgICAgIGlmIChmYWN0b3J5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcHBIb29rc1tmYWN0b3J5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhcHBIb29rc1tmYWN0b3J5TmFtZV0oZXZlbnROYW1lLCBhcHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTWFwIHRoZSByZXF1ZXN0ZWQgc2VydmljZSB0byBhIHJlZ2lzdGVyZWQgc2VydmljZSBuYW1lXG4gICAgLy8gKHVzZWQgdG8gbWFwIGF1dGggdG8gc2VydmVyQXV0aCBzZXJ2aWNlIHdoZW4gbmVlZGVkKS5cbiAgICBmdW5jdGlvbiB1c2VBc1NlcnZpY2UoYXBwLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSAnc2VydmVyQXV0aCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VTZXJ2aWNlID0gbmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcHAub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHVzZVNlcnZpY2U7XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG59XG5mdW5jdGlvbiBlcnJvcihjb2RlLCBhcmdzKSB7XG4gICAgdGhyb3cgYXBwRXJyb3JzLmNyZWF0ZShjb2RlLCBhcmdzKTtcbn1cbi8vIFR5cGVTY3JpcHQgZG9lcyBub3Qgc3VwcG9ydCBub24tc3RyaW5nIGluZGV4ZXMhXG4vLyBsZXQgZXJyb3JzOiB7W2NvZGU6IEFwcEVycm9yOiBzdHJpbmd9ID0ge1xudmFyIGVycm9ycyA9IHtcbiAgICAnbm8tYXBwJzogXCJObyBGaXJlYmFzZSBBcHAgJ3skbmFtZX0nIGhhcyBiZWVuIGNyZWF0ZWQgLSBcIiArXG4gICAgICAgICdjYWxsIEZpcmViYXNlIEFwcC5pbml0aWFsaXplQXBwKCknLFxuICAgICdiYWQtYXBwLW5hbWUnOiBcIklsbGVnYWwgQXBwIG5hbWU6ICd7JG5hbWV9XCIsXG4gICAgJ2R1cGxpY2F0ZS1hcHAnOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRuYW1lfScgYWxyZWFkeSBleGlzdHNcIixcbiAgICAnYXBwLWRlbGV0ZWQnOiBcIkZpcmViYXNlIEFwcCBuYW1lZCAneyRuYW1lfScgYWxyZWFkeSBkZWxldGVkXCIsXG4gICAgJ2R1cGxpY2F0ZS1zZXJ2aWNlJzogXCJGaXJlYmFzZSBzZXJ2aWNlIG5hbWVkICd7JG5hbWV9JyBhbHJlYWR5IHJlZ2lzdGVyZWRcIixcbiAgICAnc2Etbm90LXN1cHBvcnRlZCc6ICdJbml0aWFsaXppbmcgdGhlIEZpcmViYXNlIFNESyB3aXRoIGEgc2VydmljZSAnICtcbiAgICAgICAgJ2FjY291bnQgaXMgb25seSBhbGxvd2VkIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC4gT24gY2xpZW50ICcgK1xuICAgICAgICAnZGV2aWNlcywgeW91IHNob3VsZCBpbnN0ZWFkIGluaXRpYWxpemUgdGhlIFNESyB3aXRoIGFuIGFwaSBrZXkgYW5kICcgK1xuICAgICAgICAnYXV0aCBkb21haW4nLFxuICAgICdpbnZhbGlkLWFwcC1hcmd1bWVudCc6ICdmaXJlYmFzZS57JG5hbWV9KCkgdGFrZXMgZWl0aGVyIG5vIGFyZ3VtZW50IG9yIGEgJyArXG4gICAgICAgICdGaXJlYmFzZSBBcHAgaW5zdGFuY2UuJ1xufTtcbnZhciBhcHBFcnJvcnMgPSBuZXcgRXJyb3JGYWN0b3J5KCdhcHAnLCAnRmlyZWJhc2UnLCBlcnJvcnMpO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcmViYXNlQXBwLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FwcC9kaXN0L2VzbS9zcmMvZmlyZWJhc2VBcHAuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEbyBhIGRlZXAtY29weSBvZiBiYXNpYyBKYXZhU2NyaXB0IE9iamVjdHMgb3IgQXJyYXlzLlxuICovXG5mdW5jdGlvbiBkZWVwQ29weSh2YWx1ZSkge1xuICAgIHJldHVybiBkZWVwRXh0ZW5kKHVuZGVmaW5lZCwgdmFsdWUpO1xufVxuZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuLyoqXG4gKiBDb3B5IHByb3BlcnRpZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IChyZWN1cnNpdmVseSBhbGxvd3MgZXh0ZW5zaW9uXG4gKiBvZiBPYmplY3RzIGFuZCBBcnJheXMpLiAgU2NhbGFyIHZhbHVlcyBpbiB0aGUgdGFyZ2V0IGFyZSBvdmVyLXdyaXR0ZW4uXG4gKiBJZiB0YXJnZXQgaXMgdW5kZWZpbmVkLCBhbiBvYmplY3Qgb2YgdGhlIGFwcHJvcHJpYXRlIHR5cGUgd2lsbCBiZSBjcmVhdGVkXG4gKiAoYW5kIHJldHVybmVkKS5cbiAqXG4gKiBXZSByZWN1cnNpdmVseSBjb3B5IGFsbCBjaGlsZCBwcm9wZXJ0aWVzIG9mIHBsYWluIE9iamVjdHMgaW4gdGhlIHNvdXJjZS0gc29cbiAqIHRoYXQgbmFtZXNwYWNlLSBsaWtlIGRpY3Rpb25hcmllcyBhcmUgbWVyZ2VkLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgdGFyZ2V0IGNhbiBiZSBhIGZ1bmN0aW9uLCBpbiB3aGljaCBjYXNlIHRoZSBwcm9wZXJ0aWVzIGluXG4gKiB0aGUgc291cmNlIE9iamVjdCBhcmUgY29waWVkIG9udG8gaXQgYXMgc3RhdGljIHByb3BlcnRpZXMgb2YgdGhlIEZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWVwRXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIERhdGU6XG4gICAgICAgICAgICAvLyBUcmVhdCBEYXRlcyBsaWtlIHNjYWxhcnM7IGlmIHRoZSB0YXJnZXQgZGF0ZSBvYmplY3QgaGFkIGFueSBjaGlsZFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyAtIHRoZXkgd2lsbCBiZSBsb3N0IVxuICAgICAgICAgICAgdmFyIGRhdGVWYWx1ZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlVmFsdWUuZ2V0VGltZSgpKTtcbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgLy8gQWx3YXlzIGNvcHkgdGhlIGFycmF5IHNvdXJjZSBhbmQgb3ZlcndyaXRlIHRoZSB0YXJnZXQuXG4gICAgICAgICAgICB0YXJnZXQgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gTm90IGEgcGxhaW4gT2JqZWN0IC0gdHJlYXQgaXQgYXMgYSBzY2FsYXIuXG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIXNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gZGVlcEV4dGVuZCh0YXJnZXRbcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLmRlZXBFeHRlbmQgPSBkZWVwRXh0ZW5kO1xuLy8gVE9ETzogUmVhbGx5IG5lZWRlZCAoZm9yIEpTQ29tcGlsZXIgdHlwZSBjaGVja2luZyk/XG5mdW5jdGlvbiBwYXRjaFByb3BlcnR5KG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbn1cbmV4cG9ydHMucGF0Y2hQcm9wZXJ0eSA9IHBhdGNoUHJvcGVydHk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXBDb3B5LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2RlZXBDb3B5LmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEZWZlcnJlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWZlcnJlZCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXIgQVBJIGludGVybmFscyBhcmUgbm90IHByb21pc2VpZmllZCBhbmQgY2Fubm90IGJlY2F1c2Ugb3VyIGNhbGxiYWNrIEFQSXMgaGF2ZSBzdWJ0bGUgZXhwZWN0YXRpb25zIGFyb3VuZFxuICAgICAqIGludm9raW5nIHByb21pc2VzIGlubGluZSwgd2hpY2ggUHJvbWlzZXMgYXJlIGZvcmJpZGRlbiB0byBkby4gVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBub2RlLXN0eWxlIGNhbGxiYWNrXG4gICAgICogYW5kIHJldHVybnMgYSBub2RlLXN0eWxlIGNhbGxiYWNrIHdoaWNoIHdpbGwgcmVzb2x2ZSBvciByZWplY3QgdGhlIERlZmVycmVkJ3MgcHJvbWlzZS5cbiAgICAgKiBAcGFyYW0geygoP2Z1bmN0aW9uKD8oRXJyb3IpKTogKD98dW5kZWZpbmVkKSl8ICg/ZnVuY3Rpb24oPyhFcnJvciksPz0pOiAoP3x1bmRlZmluZWQpKSk9fSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbig/KEVycm9yKSwgPz0pfVxuICAgICAqL1xuICAgIERlZmVycmVkLnByb3RvdHlwZS53cmFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRhY2hpbmcgbm9vcCBoYW5kbGVyIGp1c3QgaW4gY2FzZSBkZXZlbG9wZXIgd2Fzbid0IGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIC8vIHByb21pc2VzXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7IH0pO1xuICAgICAgICAgICAgICAgIC8vIFNvbWUgb2Ygb3VyIGNhbGxiYWNrcyBkb24ndCBleHBlY3QgYSB2YWx1ZSBhbmQgb3VyIG93biB0ZXN0c1xuICAgICAgICAgICAgICAgIC8vIGFzc2VydCB0aGF0IHRoZSBwYXJhbWV0ZXIgbGVuZ3RoIGlzIDFcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVycmVkO1xufSgpKTtcbmV4cG9ydHMuRGVmZXJyZWQgPSBEZWZlcnJlZDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXJyZWQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZGVmZXJyZWQuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIG5hdmlnYXRvci51c2VyQWdlbnQgc3RyaW5nIG9yICcnIGlmIGl0J3Mgbm90IGRlZmluZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHVzZXIgYWdlbnQgc3RyaW5nXG4gKi9cbmV4cG9ydHMuZ2V0VUEgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHR5cGVvZiBuYXZpZ2F0b3JbJ3VzZXJBZ2VudCddID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yWyd1c2VyQWdlbnQnXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuLyoqXG4gKiBEZXRlY3QgQ29yZG92YSAvIFBob25lR2FwIC8gSW9uaWMgZnJhbWV3b3JrcyBvbiBhIG1vYmlsZSBkZXZpY2UuXG4gKlxuICogRGVsaWJlcmF0ZWx5IGRvZXMgbm90IHJlbHkgb24gY2hlY2tpbmcgYGZpbGU6Ly9gIFVSTHMgKGFzIHRoaXMgZmFpbHMgUGhvbmVHYXAgaW4gdGhlIFJpcHBsZSBlbXVsYXRvcikgbm9yXG4gKiBDb3Jkb3ZhIGBvbkRldmljZVJlYWR5YCwgd2hpY2ggd291bGQgbm9ybWFsbHkgd2FpdCBmb3IgYSBjYWxsYmFjay5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBpc01vYmlsZUNvcmRvdmFcbiAqL1xuZXhwb3J0cy5pc01vYmlsZUNvcmRvdmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAhISh3aW5kb3dbJ2NvcmRvdmEnXSB8fCB3aW5kb3dbJ3Bob25lZ2FwJ10gfHwgd2luZG93WydQaG9uZUdhcCddKSAmJlxuICAgICAgICAvaW9zfGlwaG9uZXxpcG9kfGlwYWR8YW5kcm9pZHxibGFja2JlcnJ5fGllbW9iaWxlL2kudGVzdChleHBvcnRzLmdldFVBKCkpKTtcbn07XG4vKipcbiAqIERldGVjdCBSZWFjdCBOYXRpdmUuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudCBpcyBkZXRlY3RlZC5cbiAqL1xuZXhwb3J0cy5pc1JlYWN0TmF0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgbmF2aWdhdG9yWydwcm9kdWN0J10gPT09ICdSZWFjdE5hdGl2ZScpO1xufTtcbi8qKlxuICogRGV0ZWN0IE5vZGUuanMuXG4gKlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBOb2RlLmpzIGVudmlyb25tZW50IGlzIGRldGVjdGVkLlxuICovXG5leHBvcnRzLmlzTm9kZVNkayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzXzEuQ09OU1RBTlRTLk5PREVfQ0xJRU5UID09PSB0cnVlIHx8IGNvbnN0YW50c18xLkNPTlNUQU5UUy5OT0RFX0FETUlOID09PSB0cnVlO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52aXJvbm1lbnQuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvZW52aXJvbm1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRVJST1JfTkFNRSA9ICdGaXJlYmFzZUVycm9yJztcbnZhciBjYXB0dXJlU3RhY2tUcmFjZSA9IEVycm9yXG4gICAgLmNhcHR1cmVTdGFja1RyYWNlO1xuLy8gRXhwb3J0IGZvciBmYWtpbmcgaW4gdGVzdHNcbmZ1bmN0aW9uIHBhdGNoQ2FwdHVyZShjYXB0dXJlRmFrZSkge1xuICAgIHZhciByZXN1bHQgPSBjYXB0dXJlU3RhY2tUcmFjZTtcbiAgICBjYXB0dXJlU3RhY2tUcmFjZSA9IGNhcHR1cmVGYWtlO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnBhdGNoQ2FwdHVyZSA9IHBhdGNoQ2FwdHVyZTtcbnZhciBGaXJlYmFzZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpcmViYXNlRXJyb3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB2YXIgc3RhY2s7XG4gICAgICAgIC8vIFdlIHdhbnQgdGhlIHN0YWNrIHZhbHVlLCBpZiBpbXBsZW1lbnRlZCBieSBFcnJvclxuICAgICAgICBpZiAoY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIC8vIFBhdGNoZXMgdGhpcy5zdGFjaywgb21pdHRlZCBjYWxscyBhYm92ZSBFcnJvckZhY3RvcnkjY3JlYXRlXG4gICAgICAgICAgICBjYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFcnJvckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXJyXzEgPSBFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gRVJST1JfTkFNRTtcbiAgICAgICAgICAgIC8vIE1ha2Ugbm9uLWVudW1lcmFibGUgZ2V0dGVyIGZvciB0aGUgcHJvcGVydHkuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0YWNrJywge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyXzEuc3RhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEZpcmViYXNlRXJyb3I7XG59KCkpO1xuZXhwb3J0cy5GaXJlYmFzZUVycm9yID0gRmlyZWJhc2VFcnJvcjtcbi8vIEJhY2stZG9vciBpbmhlcml0YW5jZVxuRmlyZWJhc2VFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5GaXJlYmFzZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZpcmViYXNlRXJyb3I7XG5GaXJlYmFzZUVycm9yLnByb3RvdHlwZS5uYW1lID0gRVJST1JfTkFNRTtcbnZhciBFcnJvckZhY3RvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXJyb3JGYWN0b3J5KHNlcnZpY2UsIHNlcnZpY2VOYW1lLCBlcnJvcnMpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgLy8gTWF0Y2hlcyB7JG5hbWV9LCBieSBkZWZhdWx0LlxuICAgICAgICB0aGlzLnBhdHRlcm4gPSAvXFx7XFwkKFtefV0rKX0vZztcbiAgICAgICAgLy8gZW1wdHlcbiAgICB9XG4gICAgRXJyb3JGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoY29kZSwgZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRlbXBsYXRlID0gdGhpcy5lcnJvcnNbY29kZV07XG4gICAgICAgIHZhciBmdWxsQ29kZSA9IHRoaXMuc2VydmljZSArICcvJyArIGNvZGU7XG4gICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdFcnJvcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gdGVtcGxhdGUucmVwbGFjZSh0aGlzLnBhdHRlcm4sIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUudG9TdHJpbmcoKSA6ICc8JyArIGtleSArICc/Pic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJ2aWNlOiBFcnJvciBtZXNzYWdlIChzZXJ2aWNlL2NvZGUpLlxuICAgICAgICBtZXNzYWdlID0gdGhpcy5zZXJ2aWNlTmFtZSArICc6ICcgKyBtZXNzYWdlICsgJyAoJyArIGZ1bGxDb2RlICsgJykuJztcbiAgICAgICAgdmFyIGVyciA9IG5ldyBGaXJlYmFzZUVycm9yKGZ1bGxDb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgdGhlIEVycm9yIG9iamVjdCB3aXRoIG1lc3NhZ2UgcGFydHMgZm9yIHByb2dyYW1tYXRpY1xuICAgICAgICAvLyBhY2Nlc3NlcyAoZS5nLiwgZS5maWxlKS5cbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIWRhdGEuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgcHJvcC5zbGljZSgtMSkgPT09ICdfJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyW3Byb3BdID0gZGF0YVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9yRmFjdG9yeTtcbn0oKSk7XG5leHBvcnRzLkVycm9yRmFjdG9yeSA9IEVycm9yRmFjdG9yeTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL2Vycm9ycy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY3J5cHRfMSA9IHJlcXVpcmUoXCIuL2NyeXB0XCIpO1xudmFyIGpzb25fMSA9IHJlcXVpcmUoXCIuL2pzb25cIik7XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBpbnRvIGNvbnN0aXR1ZW50IHBhcnRzLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIHdpdGggaW52YWxpZCAvIGluY29tcGxldGUgY2xhaW1zIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJuIHt7aGVhZGVyOiAqLCBjbGFpbXM6ICosIGRhdGE6ICosIHNpZ25hdHVyZTogc3RyaW5nfX1cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgaGVhZGVyID0ge30sIGNsYWltcyA9IHt9LCBkYXRhID0ge30sIHNpZ25hdHVyZSA9ICcnO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgIGhlYWRlciA9IGpzb25fMS5qc29uRXZhbChjcnlwdF8xLmJhc2U2NERlY29kZShwYXJ0c1swXSkgfHwgJycpO1xuICAgICAgICBjbGFpbXMgPSBqc29uXzEuanNvbkV2YWwoY3J5cHRfMS5iYXNlNjREZWNvZGUocGFydHNbMV0pIHx8ICcnKTtcbiAgICAgICAgc2lnbmF0dXJlID0gcGFydHNbMl07XG4gICAgICAgIGRhdGEgPSBjbGFpbXNbJ2QnXSB8fCB7fTtcbiAgICAgICAgZGVsZXRlIGNsYWltc1snZCddO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIGNsYWltczogY2xhaW1zLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgIH07XG59O1xuLyoqXG4gKiBEZWNvZGVzIGEgRmlyZWJhc2UgYXV0aC4gdG9rZW4gYW5kIGNoZWNrcyB0aGUgdmFsaWRpdHkgb2YgaXRzIHRpbWUtYmFzZWQgY2xhaW1zLiBXaWxsIHJldHVybiB0cnVlIGlmIHRoZVxuICogdG9rZW4gaXMgd2l0aGluIHRoZSB0aW1lIHdpbmRvdyBhdXRob3JpemVkIGJ5IHRoZSAnbmJmJyAobm90LWJlZm9yZSkgYW5kICdpYXQnIChpc3N1ZWQtYXQpIGNsYWltcy5cbiAqXG4gKiBOb3RlczpcbiAqIC0gTWF5IHJldHVybiBhIGZhbHNlIG5lZ2F0aXZlIGlmIHRoZXJlJ3Mgbm8gbmF0aXZlIGJhc2U2NCBkZWNvZGluZyBzdXBwb3J0LlxuICogLSBEb2Vzbid0IGNoZWNrIGlmIHRoZSB0b2tlbiBpcyBhY3R1YWxseSB2YWxpZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICB2YXIgY2xhaW1zID0gZXhwb3J0cy5kZWNvZGUodG9rZW4pLmNsYWltcywgbm93ID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLCB2YWxpZFNpbmNlLCB2YWxpZFVudGlsO1xuICAgIGlmICh0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCduYmYnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snbmJmJ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2xhaW1zLmhhc093blByb3BlcnR5KCdpYXQnKSkge1xuICAgICAgICAgICAgdmFsaWRTaW5jZSA9IGNsYWltc1snaWF0J107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnZXhwJykpIHtcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSBjbGFpbXNbJ2V4cCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdG9rZW4gd2lsbCBleHBpcmUgYWZ0ZXIgMjRoIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIHZhbGlkVW50aWwgPSB2YWxpZFNpbmNlICsgODY0MDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChub3cgJiYgdmFsaWRTaW5jZSAmJiB2YWxpZFVudGlsICYmIG5vdyA+PSB2YWxpZFNpbmNlICYmIG5vdyA8PSB2YWxpZFVudGlsKTtcbn07XG4vKipcbiAqIERlY29kZXMgYSBGaXJlYmFzZSBhdXRoLiB0b2tlbiBhbmQgcmV0dXJucyBpdHMgaXNzdWVkIGF0IHRpbWUgaWYgdmFsaWQsIG51bGwgb3RoZXJ3aXNlLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIG51bGwgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4gez9udW1iZXJ9XG4gKi9cbmV4cG9ydHMuaXNzdWVkQXRUaW1lID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGNsYWltcyA9IGV4cG9ydHMuZGVjb2RlKHRva2VuKS5jbGFpbXM7XG4gICAgaWYgKHR5cGVvZiBjbGFpbXMgPT09ICdvYmplY3QnICYmIGNsYWltcy5oYXNPd25Qcm9wZXJ0eSgnaWF0JykpIHtcbiAgICAgICAgcmV0dXJuIGNsYWltc1snaWF0J107XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbi8qKlxuICogRGVjb2RlcyBhIEZpcmViYXNlIGF1dGguIHRva2VuIGFuZCBjaGVja3MgdGhlIHZhbGlkaXR5IG9mIGl0cyBmb3JtYXQuIEV4cGVjdHMgYSB2YWxpZCBpc3N1ZWQtYXQgdGltZSBhbmQgbm9uLWVtcHR5XG4gKiBzaWduYXR1cmUuXG4gKlxuICogTm90ZXM6XG4gKiAtIE1heSByZXR1cm4gYSBmYWxzZSBuZWdhdGl2ZSBpZiB0aGVyZSdzIG5vIG5hdGl2ZSBiYXNlNjQgZGVjb2Rpbmcgc3VwcG9ydC5cbiAqIC0gRG9lc24ndCBjaGVjayBpZiB0aGUgdG9rZW4gaXMgYWN0dWFsbHkgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/c3RyaW5nfSB0b2tlblxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkRm9ybWF0ID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgdmFyIGRlY29kZWQgPSBleHBvcnRzLmRlY29kZSh0b2tlbiksIGNsYWltcyA9IGRlY29kZWQuY2xhaW1zO1xuICAgIHJldHVybiAoISFkZWNvZGVkLnNpZ25hdHVyZSAmJlxuICAgICAgICAhIWNsYWltcyAmJlxuICAgICAgICB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBjbGFpbXMuaGFzT3duUHJvcGVydHkoJ2lhdCcpKTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHBlZXIgaW50byBhbiBhdXRoIHRva2VuIGFuZCBkZXRlcm1pbmUgaWYgaXQncyBhbiBhZG1pbiBhdXRoIHRva2VuIGJ5IGxvb2tpbmcgYXQgdGhlIGNsYWltcyBwb3J0aW9uLlxuICpcbiAqIE5vdGVzOlxuICogLSBNYXkgcmV0dXJuIGEgZmFsc2UgbmVnYXRpdmUgaWYgdGhlcmUncyBubyBuYXRpdmUgYmFzZTY0IGRlY29kaW5nIHN1cHBvcnQuXG4gKiAtIERvZXNuJ3QgY2hlY2sgaWYgdGhlIHRva2VuIGlzIGFjdHVhbGx5IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBZG1pbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgIHZhciBjbGFpbXMgPSBleHBvcnRzLmRlY29kZSh0b2tlbikuY2xhaW1zO1xuICAgIHJldHVybiB0eXBlb2YgY2xhaW1zID09PSAnb2JqZWN0JyAmJiBjbGFpbXNbJ2FkbWluJ10gPT09IHRydWU7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1qd3QuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvand0LmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvYmpfMSA9IHJlcXVpcmUoXCIuL29ialwiKTtcbi8qKlxuICogUmV0dXJucyBhIHF1ZXJ5c3RyaW5nLWZvcm1hdHRlZCBzdHJpbmcgKGUuZy4gJmFyZz12YWwmYXJnMj12YWwyKSBmcm9tIGEgcGFyYW1zXG4gKiBvYmplY3QgKGUuZy4ge2FyZzogJ3ZhbCcsIGFyZzI6ICd2YWwyJ30pXG4gKiBOb3RlOiBZb3UgbXVzdCBwcmVwZW5kIGl0IHdpdGggPyB3aGVuIGFkZGluZyBpdCB0byBhIFVSTC5cbiAqXG4gKiBAcGFyYW0geyFPYmplY3R9IHF1ZXJ5c3RyaW5nUGFyYW1zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMucXVlcnlzdHJpbmcgPSBmdW5jdGlvbiAocXVlcnlzdHJpbmdQYXJhbXMpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgb2JqXzEuZm9yRWFjaChxdWVyeXN0cmluZ1BhcmFtcywgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhcnJheVZhbCkge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFycmF5VmFsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zLmxlbmd0aCA/ICcmJyArIHBhcmFtcy5qb2luKCcmJykgOiAnJztcbn07XG4vKipcbiAqIERlY29kZXMgYSBxdWVyeXN0cmluZyAoZS5nLiA/YXJnPXZhbCZhcmcyPXZhbDIpIGludG8gYSBwYXJhbXMgb2JqZWN0IChlLmcuIHthcmc6ICd2YWwnLCBhcmcyOiAndmFsMid9KVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeXN0cmluZ1xuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZXhwb3J0cy5xdWVyeXN0cmluZ0RlY29kZSA9IGZ1bmN0aW9uIChxdWVyeXN0cmluZykge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICB2YXIgdG9rZW5zID0gcXVlcnlzdHJpbmcucmVwbGFjZSgvXlxcPy8sICcnKS5zcGxpdCgnJicpO1xuICAgIHRva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b2tlbi5zcGxpdCgnPScpO1xuICAgICAgICAgICAgb2JqW2tleVswXV0gPSBrZXlbMV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnkuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvcXVlcnkuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbi8qKlxuICogQGZpbGVvdmVydmlldyBTSEEtMSBjcnlwdG9ncmFwaGljIGhhc2guXG4gKiBWYXJpYWJsZSBuYW1lcyBmb2xsb3cgdGhlIG5vdGF0aW9uIGluIEZJUFMgUFVCIDE4MC0zOlxuICogaHR0cDovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2ZpcHMvZmlwczE4MC0zL2ZpcHMxODAtM19maW5hbC5wZGYuXG4gKlxuICogVXNhZ2U6XG4gKiAgIHZhciBzaGExID0gbmV3IHNoYTEoKTtcbiAqICAgc2hhMS51cGRhdGUoYnl0ZXMpO1xuICogICB2YXIgaGFzaCA9IHNoYTEuZGlnZXN0KCk7XG4gKlxuICogUGVyZm9ybWFuY2U6XG4gKiAgIENocm9tZSAyMzogICB+NDAwIE1iaXQvc1xuICogICBGaXJlZm94IDE2OiAgfjI1MCBNYml0L3NcbiAqXG4gKi9cbi8qKlxuICogU0hBLTEgY3J5cHRvZ3JhcGhpYyBoYXNoIGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSBwcm9wZXJ0aWVzIGRlY2xhcmVkIGhlcmUgYXJlIGRpc2N1c3NlZCBpbiB0aGUgYWJvdmUgYWxnb3JpdGhtIGRvY3VtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SGFzaH1cbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICovXG52YXIgU2hhMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2hhMSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaGExKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIHByZXZpb3VzIHZhbHVlcyBvZiBhY2N1bXVsYXRlZCB2YXJpYWJsZXMgYS1lIGluIHRoZSBjb21wcmVzc19cbiAgICAgICAgICogZnVuY3Rpb24uXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmNoYWluXyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBidWZmZXIgaG9sZGluZyB0aGUgcGFydGlhbGx5IGNvbXB1dGVkIGhhc2ggcmVzdWx0LlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5idWZfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiA4MCBieXRlcywgZWFjaCBhIHBhcnQgb2YgdGhlIG1lc3NhZ2UgdG8gYmUgaGFzaGVkLiAgUmVmZXJyZWQgdG9cbiAgICAgICAgICogYXMgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgaW4gdGhlIGRvY3MuXG4gICAgICAgICAqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLldfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250YWlucyBkYXRhIG5lZWRlZCB0byBwYWQgbWVzc2FnZXMgbGVzcyB0aGFuIDY0IGJ5dGVzLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PG51bWJlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5wYWRfID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5idWZfID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy50b3RhbF8gPSAwO1xuICAgICAgICBfdGhpcy5ibG9ja1NpemUgPSA1MTIgLyA4O1xuICAgICAgICBfdGhpcy5wYWRfWzBdID0gMTI4O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IF90aGlzLmJsb2NrU2l6ZTsgKytpKSB7XG4gICAgICAgICAgICBfdGhpcy5wYWRfW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNoYTEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYWluX1swXSA9IDB4Njc0NTIzMDE7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gMHhlZmNkYWI4OTtcbiAgICAgICAgdGhpcy5jaGFpbl9bMl0gPSAweDk4YmFkY2ZlO1xuICAgICAgICB0aGlzLmNoYWluX1szXSA9IDB4MTAzMjU0NzY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gMHhjM2QyZTFmMDtcbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSAwO1xuICAgICAgICB0aGlzLnRvdGFsXyA9IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBjb21wcmVzcyBoZWxwZXIgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHshQXJyYXk8bnVtYmVyPnwhVWludDhBcnJheXxzdHJpbmd9IGJ1ZiBCbG9jayB0byBjb21wcmVzcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9vZmZzZXQgT2Zmc2V0IG9mIHRoZSBibG9jayBpbiB0aGUgYnVmZmVyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU2hhMS5wcm90b3R5cGUuY29tcHJlc3NfID0gZnVuY3Rpb24gKGJ1Ziwgb3B0X29mZnNldCkge1xuICAgICAgICBpZiAoIW9wdF9vZmZzZXQpIHtcbiAgICAgICAgICAgIG9wdF9vZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBXID0gdGhpcy5XXztcbiAgICAgICAgLy8gZ2V0IDE2IGJpZyBlbmRpYW4gd29yZHNcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKHVzZXIpOiBbYnVnIDgxNDAxMjJdIFJlY2VudCB2ZXJzaW9ucyBvZiBTYWZhcmkgZm9yIE1hYyBPUyBhbmQgaU9TXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGJ1ZyB0aGF0IHR1cm5zIHRoZSBwb3N0LWluY3JlbWVudCArKyBvcGVyYXRvciBpbnRvIHByZS1pbmNyZW1lbnRcbiAgICAgICAgICAgICAgICAvLyBkdXJpbmcgSklUIGNvbXBpbGF0aW9uLiAgV2UgaGF2ZSBjb2RlIHRoYXQgZGVwZW5kcyBoZWF2aWx5IG9uIFNIQS0xIGZvclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3RuZXNzIGFuZCB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIGJ1Zywgc28gSSd2ZSByZW1vdmVkIGFsbCB1c2VzXG4gICAgICAgICAgICAgICAgLy8gb2YgcG9zdC1pbmNyZW1lbnQgKysgaW4gd2hpY2ggdGhlIHJlc3VsdCB2YWx1ZSBpcyB1c2VkLiAgV2UgY2FuIHJldmVydFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgY2hhbmdlIG9uY2UgdGhlIFNhZmFyaSBidWdcbiAgICAgICAgICAgICAgICAvLyAoaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEwOTAzNikgaGFzIGJlZW4gZml4ZWQgYW5kXG4gICAgICAgICAgICAgICAgLy8gbW9zdCBjbGllbnRzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCkgPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvcHRfb2Zmc2V0ICsgMSkgPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChidWYuY2hhckNvZGVBdChvcHRfb2Zmc2V0ICsgMikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmLmNoYXJDb2RlQXQob3B0X29mZnNldCArIDMpO1xuICAgICAgICAgICAgICAgIG9wdF9vZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIFdbaV0gPVxuICAgICAgICAgICAgICAgICAgICAoYnVmW29wdF9vZmZzZXRdIDw8IDI0KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYnVmW29wdF9vZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZltvcHRfb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmW29wdF9vZmZzZXQgKyAzXTtcbiAgICAgICAgICAgICAgICBvcHRfb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwYW5kIHRvIDgwIHdvcmRzXG4gICAgICAgIGZvciAodmFyIGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ID0gV1tpIC0gM10gXiBXW2kgLSA4XSBeIFdbaSAtIDE0XSBeIFdbaSAtIDE2XTtcbiAgICAgICAgICAgIFdbaV0gPSAoKHQgPDwgMSkgfCAodCA+Pj4gMzEpKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGEgPSB0aGlzLmNoYWluX1swXTtcbiAgICAgICAgdmFyIGIgPSB0aGlzLmNoYWluX1sxXTtcbiAgICAgICAgdmFyIGMgPSB0aGlzLmNoYWluX1syXTtcbiAgICAgICAgdmFyIGQgPSB0aGlzLmNoYWluX1szXTtcbiAgICAgICAgdmFyIGUgPSB0aGlzLmNoYWluX1s0XTtcbiAgICAgICAgdmFyIGYsIGs7XG4gICAgICAgIC8vIFRPRE8odXNlcik6IFRyeSB0byB1bnJvbGwgdGhpcyBsb29wIHRvIHNwZWVkIHVwIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAyMCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gZCBeIChiICYgKGMgXiBkKSk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDVhODI3OTk5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4NmVkOWViYTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCA2MCkge1xuICAgICAgICAgICAgICAgICAgICBmID0gKGIgJiBjKSB8IChkICYgKGIgfCBjKSk7XG4gICAgICAgICAgICAgICAgICAgIGsgPSAweDhmMWJiY2RjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICAgICAgICAgICAgayA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHQgPSAoKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBmICsgZSArIGsgKyBXW2ldKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICBlID0gZDtcbiAgICAgICAgICAgIGQgPSBjO1xuICAgICAgICAgICAgYyA9ICgoYiA8PCAzMCkgfCAoYiA+Pj4gMikpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbl9bMF0gPSAodGhpcy5jaGFpbl9bMF0gKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzFdID0gKHRoaXMuY2hhaW5fWzFdICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLmNoYWluX1syXSA9ICh0aGlzLmNoYWluX1syXSArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5jaGFpbl9bM10gPSAodGhpcy5jaGFpbl9bM10gKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuY2hhaW5fWzRdID0gKHRoaXMuY2hhaW5fWzRdICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH07XG4gICAgU2hhMS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGJ5dGVzLCBvcHRfbGVuZ3RoKSB7XG4gICAgICAgIC8vIFRPRE8oam9obmxlbnopOiB0aWdodGVuIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgYW5kIHJlbW92ZSB0aGlzIGNoZWNrXG4gICAgICAgIGlmIChieXRlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdF9sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0X2xlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoTWludXNCbG9jayA9IG9wdF9sZW5ndGggLSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgdmFyIG4gPSAwO1xuICAgICAgICAvLyBVc2luZyBsb2NhbCBpbnN0ZWFkIG9mIG1lbWJlciB2YXJpYWJsZXMgZ2l2ZXMgfjUlIHNwZWVkdXAgb24gRmlyZWZveCAxNi5cbiAgICAgICAgdmFyIGJ1ZiA9IHRoaXMuYnVmXztcbiAgICAgICAgdmFyIGluYnVmID0gdGhpcy5pbmJ1Zl87XG4gICAgICAgIC8vIFRoZSBvdXRlciB3aGlsZSBsb29wIHNob3VsZCBleGVjdXRlIGF0IG1vc3QgdHdpY2UuXG4gICAgICAgIHdoaWxlIChuIDwgb3B0X2xlbmd0aCkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBoYXZlIG5vIGRhdGEgaW4gdGhlIGJsb2NrIHRvIHRvcCB1cCwgd2UgY2FuIGRpcmVjdGx5IHByb2Nlc3MgdGhlXG4gICAgICAgICAgICAvLyBpbnB1dCBidWZmZXIgKGFzc3VtaW5nIGl0IGNvbnRhaW5zIHN1ZmZpY2llbnQgZGF0YSkuIFRoaXMgZ2l2ZXMgfjI1JVxuICAgICAgICAgICAgLy8gc3BlZWR1cCBvbiBDaHJvbWUgMjMgYW5kIH4xNSUgc3BlZWR1cCBvbiBGaXJlZm94IDE2LCBidXQgcmVxdWlyZXMgdGhhdFxuICAgICAgICAgICAgLy8gdGhlIGRhdGEgaXMgcHJvdmlkZWQgaW4gbGFyZ2UgY2h1bmtzIChvciBpbiBtdWx0aXBsZXMgb2YgNjQgYnl0ZXMpLlxuICAgICAgICAgICAgaWYgKGluYnVmID09IDApIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobiA8PSBsZW5ndGhNaW51c0Jsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ5dGVzLCBuKTtcbiAgICAgICAgICAgICAgICAgICAgbiArPSB0aGlzLmJsb2NrU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgb3B0X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXMuY2hhckNvZGVBdChuKTtcbiAgICAgICAgICAgICAgICAgICAgKytpbmJ1ZjtcbiAgICAgICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5idWYgPT0gdGhpcy5ibG9ja1NpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHJlc3NfKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmJ1ZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdW1wIHRvIHRoZSBvdXRlciBsb29wIHNvIHdlIHVzZSB0aGUgZnVsbC1ibG9jayBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChuIDwgb3B0X2xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZbaW5idWZdID0gYnl0ZXNbbl07XG4gICAgICAgICAgICAgICAgICAgICsraW5idWY7XG4gICAgICAgICAgICAgICAgICAgICsrbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluYnVmID09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzXyhidWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5idWYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVtcCB0byB0aGUgb3V0ZXIgbG9vcCBzbyB3ZSB1c2UgdGhlIGZ1bGwtYmxvY2sgb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmJ1Zl8gPSBpbmJ1ZjtcbiAgICAgICAgdGhpcy50b3RhbF8gKz0gb3B0X2xlbmd0aDtcbiAgICB9O1xuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBTaGExLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaWdlc3QgPSBbXTtcbiAgICAgICAgdmFyIHRvdGFsQml0cyA9IHRoaXMudG90YWxfICogODtcbiAgICAgICAgLy8gQWRkIHBhZCAweDgwIDB4MDAqLlxuICAgICAgICBpZiAodGhpcy5pbmJ1Zl8gPCA1Nikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wYWRfLCA1NiAtIHRoaXMuaW5idWZfKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRoaXMucGFkXywgdGhpcy5ibG9ja1NpemUgLSAodGhpcy5pbmJ1Zl8gLSA1NikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCAjIGJpdHMuXG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmJsb2NrU2l6ZSAtIDE7IGkgPj0gNTY7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5idWZfW2ldID0gdG90YWxCaXRzICYgMjU1O1xuICAgICAgICAgICAgdG90YWxCaXRzIC89IDI1NjsgLy8gRG9uJ3QgdXNlIGJpdC1zaGlmdGluZyBoZXJlIVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3NfKHRoaXMuYnVmXyk7XG4gICAgICAgIHZhciBuID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAyNDsgaiA+PSAwOyBqIC09IDgpIHtcbiAgICAgICAgICAgICAgICBkaWdlc3Rbbl0gPSAodGhpcy5jaGFpbl9baV0gPj4gaikgJiAyNTU7XG4gICAgICAgICAgICAgICAgKytuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWdlc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gU2hhMTtcbn0oaGFzaF8xLkhhc2gpKTtcbmV4cG9ydHMuU2hhMSA9IFNoYTE7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTEuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvdXRpbC9kaXN0L2Nqcy9zcmMvc2hhMS5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBDb3B5cmlnaHQgMjAxMSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQGZpbGVvdmVydmlldyBBYnN0cmFjdCBjcnlwdG9ncmFwaGljIGhhc2ggaW50ZXJmYWNlLlxuICpcbiAqIFNlZSBTaGExIGFuZCBNZDUgZm9yIHNhbXBsZSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICovXG4vKipcbiAqIENyZWF0ZSBhIGNyeXB0b2dyYXBoaWMgaGFzaCBpbnN0YW5jZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIEhhc2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGFzaCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBibG9jayBzaXplIGZvciB0aGUgaGFzaGVyLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NpemUgPSAtMTtcbiAgICB9XG4gICAgcmV0dXJuIEhhc2g7XG59KCkpO1xuZXhwb3J0cy5IYXNoID0gSGFzaDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy9oYXNoLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBIZWxwZXIgdG8gbWFrZSBhIFN1YnNjcmliZSBmdW5jdGlvbiAoanVzdCBsaWtlIFByb21pc2UgaGVscHMgbWFrZSBhXG4gKiBUaGVuYWJsZSkuXG4gKlxuICogQHBhcmFtIGV4ZWN1dG9yIEZ1bmN0aW9uIHdoaWNoIGNhbiBtYWtlIGNhbGxzIHRvIGEgc2luZ2xlIE9ic2VydmVyXG4gKiAgICAgYXMgYSBwcm94eS5cbiAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3Vic2NyaWJlKGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XG4gICAgdmFyIHByb3h5ID0gbmV3IE9ic2VydmVyUHJveHkoZXhlY3V0b3IsIG9uTm9PYnNlcnZlcnMpO1xuICAgIHJldHVybiBwcm94eS5zdWJzY3JpYmUuYmluZChwcm94eSk7XG59XG5leHBvcnRzLmNyZWF0ZVN1YnNjcmliZSA9IGNyZWF0ZVN1YnNjcmliZTtcbi8qKlxuICogSW1wbGVtZW50IGZhbi1vdXQgZm9yIGFueSBudW1iZXIgb2YgT2JzZXJ2ZXJzIGF0dGFjaGVkIHZpYSBhIHN1YnNjcmliZVxuICogZnVuY3Rpb24uXG4gKi9cbnZhciBPYnNlcnZlclByb3h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBleGVjdXRvciBGdW5jdGlvbiB3aGljaCBjYW4gbWFrZSBjYWxscyB0byBhIHNpbmdsZSBPYnNlcnZlclxuICAgICAqICAgICBhcyBhIHByb3h5LlxuICAgICAqIEBwYXJhbSBvbk5vT2JzZXJ2ZXJzIENhbGxiYWNrIHdoZW4gY291bnQgb2YgT2JzZXJ2ZXJzIGdvZXMgdG8gemVyby5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZlclByb3h5KGV4ZWN1dG9yLCBvbk5vT2JzZXJ2ZXJzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVzID0gW107XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJDb3VudCA9IDA7XG4gICAgICAgIC8vIE1pY3JvLXRhc2sgc2NoZWR1bGluZyBieSBjYWxsaW5nIHRhc2sudGhlbigpLlxuICAgICAgICB0aGlzLnRhc2sgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzID0gb25Ob09ic2VydmVycztcbiAgICAgICAgLy8gQ2FsbCB0aGUgZXhlY3V0b3IgYXN5bmNocm9ub3VzbHkgc28gc3Vic2NyaWJlcnMgdGhhdCBhcmUgY2FsbGVkXG4gICAgICAgIC8vIHN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhlIGNyZWF0aW9uIG9mIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb25cbiAgICAgICAgLy8gY2FuIHN0aWxsIHJlY2VpdmUgdGhlIHZlcnkgZmlyc3QgdmFsdWUgZ2VuZXJhdGVkIGluIHRoZSBleGVjdXRvci5cbiAgICAgICAgdGhpcy50YXNrXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleGVjdXRvcihfdGhpcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvckVhY2hPYnNlcnZlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZm9yRWFjaE9ic2VydmVyKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZShlcnJvcik7XG4gICAgfTtcbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mb3JFYWNoT2JzZXJ2ZXIoZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gYWRkIGFuIE9ic2VydmVyIHRvIHRoZSBmYW4tb3V0IGxpc3QuXG4gICAgICpcbiAgICAgKiAtIFdlIHJlcXVpcmUgdGhhdCBubyBldmVudCBpcyBzZW50IHRvIGEgc3Vic2NyaWJlciBzeWNocm9ub3VzbHkgdG8gdGhlaXJcbiAgICAgKiAgIGNhbGwgdG8gc3Vic2NyaWJlKCkuXG4gICAgICovXG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9ic2VydmVyO1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgZXJyb3IgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgY29tcGxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIE9ic2VydmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzc2VtYmxlIGFuIE9ic2VydmVyIG9iamVjdCB3aGVuIHBhc3NlZCBhcyBjYWxsYmFjayBmdW5jdGlvbnMuXG4gICAgICAgIGlmIChpbXBsZW1lbnRzQW55TWV0aG9kcyhuZXh0T3JPYnNlcnZlciwgWyduZXh0JywgJ2Vycm9yJywgJ2NvbXBsZXRlJ10pKSB7XG4gICAgICAgICAgICBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgbmV4dDogbmV4dE9yT2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0ID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYnNlcnZlci5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuc3ViID0gdGhpcy51bnN1YnNjcmliZU9uZS5iaW5kKHRoaXMsIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCk7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gc3Vic2NyaWJlIHRvIGEgdGVybWluYXRlZCBPYnNlcnZhYmxlIC0gd2VcbiAgICAgICAgLy8ganVzdCByZXNwb25kIHRvIHRoZSBPYnNlcnZlciB3aXRoIHRoZSBmaW5hbCBlcnJvciBvciBjb21wbGV0ZVxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLnRhc2sudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmZpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKF90aGlzLmZpbmFsRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gdW5zdWI7XG4gICAgfTtcbiAgICAvLyBVbnN1YnNjcmliZSBpcyBzeW5jaHJvbm91cyAtIHdlIGd1YXJhbnRlZSB0aGF0IG5vIGV2ZW50cyBhcmUgc2VudCB0b1xuICAgIC8vIGFueSB1bnN1YnNjcmliZWQgT2JzZXJ2ZXIuXG4gICAgT2JzZXJ2ZXJQcm94eS5wcm90b3R5cGUudW5zdWJzY3JpYmVPbmUgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICBpZiAodGhpcy5vYnNlcnZlcnMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9ic2VydmVyc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMub2JzZXJ2ZXJzW2ldO1xuICAgICAgICB0aGlzLm9ic2VydmVyQ291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXJDb3VudCA9PT0gMCAmJiB0aGlzLm9uTm9PYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbk5vT2JzZXJ2ZXJzKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5mb3JFYWNoT2JzZXJ2ZXIgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGNsb3NlZCBieSBwcmV2aW91cyBldmVudC4uLi5qdXN0IGVhdCB0aGUgYWRkaXRpb25hbCB2YWx1ZXMuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2Ugc2VuZE9uZSBjYWxscyBhc3luY2hyb25vdXNseSAtIHRoZXJlIGlzIG5vIGNoYW5jZSB0aGF0XG4gICAgICAgIC8vIHRoaXMub2JzZXJ2ZXJzIHdpbGwgYmVjb21lIHVuZGVmaW5lZC5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zZW5kT25lKGksIGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQ2FsbCB0aGUgT2JzZXJ2ZXIgdmlhIG9uZSBvZiBpdCdzIGNhbGxiYWNrIGZ1bmN0aW9uLiBXZSBhcmUgY2FyZWZ1bCB0b1xuICAgIC8vIGNvbmZpcm0gdGhhdCB0aGUgb2JzZXJ2ZSBoYXMgbm90IGJlZW4gdW5zdWJzY3JpYmVkIHNpbmNlIHRoaXMgYXN5bmNocm9ub3VzXG4gICAgLy8gZnVuY3Rpb24gaGFkIGJlZW4gcXVldWVkLlxuICAgIE9ic2VydmVyUHJveHkucHJvdG90eXBlLnNlbmRPbmUgPSBmdW5jdGlvbiAoaSwgZm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2sgYXN5bmNocm9ub3VzbHlcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm9ic2VydmVycyAhPT0gdW5kZWZpbmVkICYmIF90aGlzLm9ic2VydmVyc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm4oX3RoaXMub2JzZXJ2ZXJzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGV4Y2VwdGlvbnMgcmFpc2VkIGluIE9ic2VydmVycyBvciBtaXNzaW5nIG1ldGhvZHMgb2YgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gT2JzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBlcnJvciB0byBjb25zb2xlLiBiLzMxNDA0ODA2XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZlclByb3h5LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxFcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcm94eSBpcyBubyBsb25nZXIgbmVlZGVkIC0gZ2FyYmFnZSBjb2xsZWN0IHJlZmVyZW5jZXNcbiAgICAgICAgdGhpcy50YXNrLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgX3RoaXMub25Ob09ic2VydmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZXJQcm94eTtcbn0oKSk7XG4vKiogVHVybiBzeW5jaHJvbm91cyBmdW5jdGlvbiBpbnRvIG9uZSBjYWxsZWQgYXN5bmNocm9ub3VzbHkuICovXG5mdW5jdGlvbiBhc3luYyhmbiwgb25FcnJvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHRydWUpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXN5bmMgPSBhc3luYztcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIG9iamVjdCBwYXNzZWQgaW4gaW1wbGVtZW50cyBhbnkgb2YgdGhlIG5hbWVkIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGltcGxlbWVudHNBbnlNZXRob2RzKG9iaiwgbWV0aG9kcykge1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIG1ldGhvZHNfMSA9IG1ldGhvZHM7IF9pIDwgbWV0aG9kc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kc18xW19pXTtcbiAgICAgICAgaWYgKG1ldGhvZCBpbiBvYmogJiYgdHlwZW9mIG9ialttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBub29wKCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3N1YnNjcmliZS5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgZm9yIGEgcHVibGljIGZ1bmN0aW9uLlxuICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzLlxuICpcbiAqIEBwYXJhbSB7IXN0cmluZ30gZm5OYW1lIFRoZSBmdW5jdGlvbiBuYW1lXG4gKiBAcGFyYW0geyFudW1iZXJ9IG1pbkNvdW50IFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgdG8gYWxsb3cgZm9yIHRoZSBmdW5jdGlvbiBjYWxsXG4gKiBAcGFyYW0geyFudW1iZXJ9IG1heENvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCB0byBhbGxvdyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxcbiAqIEBwYXJhbSB7IW51bWJlcn0gYXJnQ291bnQgVGhlIGFjdHVhbCBudW1iZXIgb2YgYXJndW1lbnRzIHByb3ZpZGVkLlxuICovXG5leHBvcnRzLnZhbGlkYXRlQXJnQ291bnQgPSBmdW5jdGlvbiAoZm5OYW1lLCBtaW5Db3VudCwgbWF4Q291bnQsIGFyZ0NvdW50KSB7XG4gICAgdmFyIGFyZ0Vycm9yO1xuICAgIGlmIChhcmdDb3VudCA8IG1pbkNvdW50KSB7XG4gICAgICAgIGFyZ0Vycm9yID0gJ2F0IGxlYXN0ICcgKyBtaW5Db3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnQ291bnQgPiBtYXhDb3VudCkge1xuICAgICAgICBhcmdFcnJvciA9IG1heENvdW50ID09PSAwID8gJ25vbmUnIDogJ25vIG1vcmUgdGhhbiAnICsgbWF4Q291bnQ7XG4gICAgfVxuICAgIGlmIChhcmdFcnJvcikge1xuICAgICAgICB2YXIgZXJyb3IgPSBmbk5hbWUgK1xuICAgICAgICAgICAgJyBmYWlsZWQ6IFdhcyBjYWxsZWQgd2l0aCAnICtcbiAgICAgICAgICAgIGFyZ0NvdW50ICtcbiAgICAgICAgICAgIChhcmdDb3VudCA9PT0gMSA/ICcgYXJndW1lbnQuJyA6ICcgYXJndW1lbnRzLicpICtcbiAgICAgICAgICAgICcgRXhwZWN0cyAnICtcbiAgICAgICAgICAgIGFyZ0Vycm9yICtcbiAgICAgICAgICAgICcuJztcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG59O1xuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzdHJpbmcgdG8gcHJlZml4IGFuIGVycm9yIG1lc3NhZ2UgYWJvdXQgZmFpbGVkIGFyZ3VtZW50IHZhbGlkYXRpb25cbiAqXG4gKiBAcGFyYW0geyFzdHJpbmd9IGZuTmFtZSBUaGUgZnVuY3Rpb24gbmFtZVxuICogQHBhcmFtIHshbnVtYmVyfSBhcmd1bWVudE51bWJlciBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsIFdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudCBpcyBvcHRpb25hbFxuICogQHJldHVybiB7IXN0cmluZ30gVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIHRocm93biBmb3IgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpIHtcbiAgICB2YXIgYXJnTmFtZSA9ICcnO1xuICAgIHN3aXRjaCAoYXJndW1lbnROdW1iZXIpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgYXJnTmFtZSA9IG9wdGlvbmFsID8gJ2ZpcnN0JyA6ICdGaXJzdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgYXJnTmFtZSA9IG9wdGlvbmFsID8gJ3NlY29uZCcgOiAnU2Vjb25kJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAndGhpcmQnIDogJ1RoaXJkJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBhcmdOYW1lID0gb3B0aW9uYWwgPyAnZm91cnRoJyA6ICdGb3VydGgnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Vycm9yUHJlZml4IGNhbGxlZCB3aXRoIGFyZ3VtZW50TnVtYmVyID4gNC4gIE5lZWQgdG8gdXBkYXRlIGl0PycpO1xuICAgIH1cbiAgICB2YXIgZXJyb3IgPSBmbk5hbWUgKyAnIGZhaWxlZDogJztcbiAgICBlcnJvciArPSBhcmdOYW1lICsgJyBhcmd1bWVudCAnO1xuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3JQcmVmaXggPSBlcnJvclByZWZpeDtcbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7IW51bWJlcn0gYXJndW1lbnROdW1iZXJcbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZXNwYWNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbmFsXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZXNwYWNlKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG5hbWVzcGFjZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgIW5hbWVzcGFjZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvL1RPRE86IEkgc2hvdWxkIGRvIG1vcmUgdmFsaWRhdGlvbiBoZXJlLiBXZSBvbmx5IGFsbG93IGNlcnRhaW4gY2hhcnMgaW4gbmFtZXNwYWNlcy5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUHJlZml4KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIG9wdGlvbmFsKSArXG4gICAgICAgICAgICAnbXVzdCBiZSBhIHZhbGlkIGZpcmViYXNlIG5hbWVzcGFjZS4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlTmFtZXNwYWNlID0gdmFsaWRhdGVOYW1lc3BhY2U7XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbGxiYWNrKGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGNhbGxiYWNrLCBvcHRpb25hbCkge1xuICAgIGlmIChvcHRpb25hbCAmJiAhY2FsbGJhY2spXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgZnVuY3Rpb24uJyk7XG59XG5leHBvcnRzLnZhbGlkYXRlQ2FsbGJhY2sgPSB2YWxpZGF0ZUNhbGxiYWNrO1xuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0T2JqZWN0KGZuTmFtZSwgYXJndW1lbnROdW1iZXIsIGNvbnRleHQsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG9wdGlvbmFsICYmICFjb250ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JyB8fCBjb250ZXh0ID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JQcmVmaXgoZm5OYW1lLCBhcmd1bWVudE51bWJlciwgb3B0aW9uYWwpICtcbiAgICAgICAgICAgICdtdXN0IGJlIGEgdmFsaWQgY29udGV4dCBvYmplY3QuJyk7XG59XG5leHBvcnRzLnZhbGlkYXRlQ29udGV4dE9iamVjdCA9IHZhbGlkYXRlQ29udGV4dE9iamVjdDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS91dGlsL2Rpc3QvY2pzL3NyYy92YWxpZGF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8vIENvZGUgb3JpZ2luYWxseSBjYW1lIGZyb20gZ29vZy5jcnlwdC5zdHJpbmdUb1V0ZjhCeXRlQXJyYXksIGJ1dCBmb3Igc29tZSByZWFzb24gdGhleVxuLy8gYXV0b21hdGljYWxseSByZXBsYWNlZCAnXFxyXFxuJyB3aXRoICdcXG4nLCBhbmQgdGhleSBkaWRuJ3QgaGFuZGxlIHN1cnJvZ2F0ZSBwYWlycyxcbi8vIHNvIGl0J3MgYmVlbiBtb2RpZmllZC5cbi8vIE5vdGUgdGhhdCBub3QgYWxsIFVuaWNvZGUgY2hhcmFjdGVycyBhcHBlYXIgYXMgc2luZ2xlIGNoYXJhY3RlcnMgaW4gSmF2YVNjcmlwdCBzdHJpbmdzLlxuLy8gZnJvbUNoYXJDb2RlIHJldHVybnMgdGhlIFVURi0xNiBlbmNvZGluZyBvZiBhIGNoYXJhY3RlciAtIHNvIHNvbWUgVW5pY29kZSBjaGFyYWN0ZXJzXG4vLyB1c2UgMiBjaGFyYWN0ZXJzIGluIEphdmFzY3JpcHQuICBBbGwgNC1ieXRlIFVURi04IGNoYXJhY3RlcnMgYmVnaW4gd2l0aCBhIGZpcnN0XG4vLyBjaGFyYWN0ZXIgaW4gdGhlIHJhbmdlIDB4RDgwMCAtIDB4REJGRiAodGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHNvLWNhbGxlZCBzdXJyb2dhdGVcbi8vIHBhaXIpLlxuLy8gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy0xNS4xLjNcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydHMuc3RyaW5nVG9CeXRlQXJyYXkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIG91dCA9IFtdLCBwID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBJcyB0aGlzIHRoZSBsZWFkIHN1cnJvZ2F0ZSBpbiBhIHN1cnJvZ2F0ZSBwYWlyP1xuICAgICAgICBpZiAoYyA+PSAweGQ4MDAgJiYgYyA8PSAweGRiZmYpIHtcbiAgICAgICAgICAgIHZhciBoaWdoID0gYyAtIDB4ZDgwMDsgLy8gdGhlIGhpZ2ggMTAgYml0cy5cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGFzc2VydF8xLmFzc2VydChpIDwgc3RyLmxlbmd0aCwgJ1N1cnJvZ2F0ZSBwYWlyIG1pc3NpbmcgdHJhaWwgc3Vycm9nYXRlLicpO1xuICAgICAgICAgICAgdmFyIGxvdyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gMHhkYzAwOyAvLyB0aGUgbG93IDEwIGJpdHMuXG4gICAgICAgICAgICBjID0gMHgxMDAwMCArIChoaWdoIDw8IDEwKSArIGxvdztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgICAgb3V0W3ArK10gPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KSB7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjID4+IDYpIHwgMTkyO1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgNjU1MzYpIHtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgPj4gMTIpIHwgMjI0O1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9IChjICYgNjMpIHwgMTI4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0W3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiAxMikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgICBvdXRbcCsrXSA9ICgoYyA+PiA2KSAmIDYzKSB8IDEyODtcbiAgICAgICAgICAgIG91dFtwKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBsZW5ndGggd2l0aG91dCBhY3R1YWxseSBjb252ZXJ0aW5nOyB1c2VmdWwgZm9yIGRvaW5nIGNoZWFwZXIgdmFsaWRhdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0cy5zdHJpbmdMZW5ndGggPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIHAgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICBwKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpIHtcbiAgICAgICAgICAgIHAgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID49IDB4ZDgwMCAmJiBjIDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gTGVhZCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpci4gIFRoZSBwYWlyIHRvZ2V0aGVyIHdpbGwgdGFrZSA0IGJ5dGVzIHRvIHJlcHJlc2VudC5cbiAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgIGkrKzsgLy8gc2tpcCB0cmFpbCBzdXJyb2dhdGUuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3V0aWwvZGlzdC9janMvc3JjL3V0ZjguanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIihmdW5jdGlvbigpIHtcbiAgdmFyIGZpcmViYXNlID0gcmVxdWlyZSgnQGZpcmViYXNlL2FwcCcpLmRlZmF1bHQ7XG4gIHZhciBoLGFhPWFhfHx7fSxrPXRoaXM7ZnVuY3Rpb24gbShhKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYX1mdW5jdGlvbiBiYShhKXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIGF9ZnVuY3Rpb24gY2EoKXt9XG5mdW5jdGlvbiBkYShhKXt2YXIgYj10eXBlb2YgYTtpZihcIm9iamVjdFwiPT1iKWlmKGEpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm5cImFycmF5XCI7aWYoYSBpbnN0YW5jZW9mIE9iamVjdClyZXR1cm4gYjt2YXIgYz1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7aWYoXCJbb2JqZWN0IFdpbmRvd11cIj09YylyZXR1cm5cIm9iamVjdFwiO2lmKFwiW29iamVjdCBBcnJheV1cIj09Y3x8XCJudW1iZXJcIj09dHlwZW9mIGEubGVuZ3RoJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5zcGxpY2UmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhLnByb3BlcnR5SXNFbnVtZXJhYmxlJiYhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcInNwbGljZVwiKSlyZXR1cm5cImFycmF5XCI7aWYoXCJbb2JqZWN0IEZ1bmN0aW9uXVwiPT1jfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5jYWxsJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSYmIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJjYWxsXCIpKXJldHVyblwiZnVuY3Rpb25cIn1lbHNlIHJldHVyblwibnVsbFwiO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PWImJlwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmNhbGwpcmV0dXJuXCJvYmplY3RcIjtyZXR1cm4gYn1mdW5jdGlvbiBlYShhKXtyZXR1cm4gbnVsbD09PWF9ZnVuY3Rpb24gZmEoYSl7cmV0dXJuXCJhcnJheVwiPT1kYShhKX1mdW5jdGlvbiBoYShhKXt2YXIgYj1kYShhKTtyZXR1cm5cImFycmF5XCI9PWJ8fFwib2JqZWN0XCI9PWImJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aH1mdW5jdGlvbiBwKGEpe3JldHVyblwiZnVuY3Rpb25cIj09ZGEoYSl9ZnVuY3Rpb24gcShhKXt2YXIgYj10eXBlb2YgYTtyZXR1cm5cIm9iamVjdFwiPT1iJiZudWxsIT1hfHxcImZ1bmN0aW9uXCI9PWJ9dmFyIGlhPVwiY2xvc3VyZV91aWRfXCIrKDFFOSpNYXRoLnJhbmRvbSgpPj4+MCksamE9MDtmdW5jdGlvbiBrYShhLGIsYyl7cmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIGxhKGEsYixjKXtpZighYSl0aHJvdyBFcnJvcigpO2lmKDI8YXJndW1lbnRzLmxlbmd0aCl7dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7QXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoYyxkKTtyZXR1cm4gYS5hcHBseShiLGMpfX1yZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5hcHBseShiLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIHIoYSxiLGMpe0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kJiYtMSE9RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIik/cj1rYTpyPWxhO3JldHVybiByLmFwcGx5KG51bGwsYXJndW1lbnRzKX1cbmZ1bmN0aW9uIG1hKGEsYil7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBmdW5jdGlvbigpe3ZhciBiPWMuc2xpY2UoKTtiLnB1c2guYXBwbHkoYixhcmd1bWVudHMpO3JldHVybiBhLmFwcGx5KHRoaXMsYil9fXZhciBuYT1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4rbmV3IERhdGV9O2Z1bmN0aW9uIHQoYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPWIucHJvdG90eXBlO2EuaWI9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGM7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLlJjPWZ1bmN0aW9uKGEsYyxmKXtmb3IodmFyIGQ9QXJyYXkoYXJndW1lbnRzLmxlbmd0aC0yKSxlPTI7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKylkW2UtMl09YXJndW1lbnRzW2VdO3JldHVybiBiLnByb3RvdHlwZVtjXS5hcHBseShhLGQpfX07ZnVuY3Rpb24gdShhKXtpZihFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSlFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLHUpO2Vsc2V7dmFyIGI9RXJyb3IoKS5zdGFjaztiJiYodGhpcy5zdGFjaz1iKX1hJiYodGhpcy5tZXNzYWdlPVN0cmluZyhhKSl9dCh1LEVycm9yKTt1LnByb3RvdHlwZS5uYW1lPVwiQ3VzdG9tRXJyb3JcIjtmdW5jdGlvbiBvYShhLGIpe2Zvcih2YXIgYz1hLnNwbGl0KFwiJXNcIiksZD1cIlwiLGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2UubGVuZ3RoJiYxPGMubGVuZ3RoOylkKz1jLnNoaWZ0KCkrZS5zaGlmdCgpO3JldHVybiBkK2Muam9pbihcIiVzXCIpfXZhciBwYT1TdHJpbmcucHJvdG90eXBlLnRyaW0/ZnVuY3Rpb24oYSl7cmV0dXJuIGEudHJpbSgpfTpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZXBsYWNlKC9eW1xcc1xceGEwXSt8W1xcc1xceGEwXSskL2csXCJcIil9O1xuZnVuY3Rpb24gcWEoYSl7aWYoIXJhLnRlc3QoYSkpcmV0dXJuIGE7LTEhPWEuaW5kZXhPZihcIiZcIikmJihhPWEucmVwbGFjZShzYSxcIiZhbXA7XCIpKTstMSE9YS5pbmRleE9mKFwiPFwiKSYmKGE9YS5yZXBsYWNlKHRhLFwiJmx0O1wiKSk7LTEhPWEuaW5kZXhPZihcIj5cIikmJihhPWEucmVwbGFjZSh1YSxcIiZndDtcIikpOy0xIT1hLmluZGV4T2YoJ1wiJykmJihhPWEucmVwbGFjZSh2YSxcIiZxdW90O1wiKSk7LTEhPWEuaW5kZXhPZihcIidcIikmJihhPWEucmVwbGFjZSh3YSxcIiYjMzk7XCIpKTstMSE9YS5pbmRleE9mKFwiXFx4MDBcIikmJihhPWEucmVwbGFjZSh4YSxcIiYjMDtcIikpO3JldHVybiBhfXZhciBzYT0vJi9nLHRhPS88L2csdWE9Lz4vZyx2YT0vXCIvZyx3YT0vJy9nLHhhPS9cXHgwMC9nLHJhPS9bXFx4MDAmPD5cIiddLztmdW5jdGlvbiB2KGEsYil7cmV0dXJuLTEhPWEuaW5kZXhPZihiKX1mdW5jdGlvbiB5YShhLGIpe3JldHVybiBhPGI/LTE6YT5iPzE6MH07ZnVuY3Rpb24gemEoYSxiKXtiLnVuc2hpZnQoYSk7dS5jYWxsKHRoaXMsb2EuYXBwbHkobnVsbCxiKSk7Yi5zaGlmdCgpfXQoemEsdSk7emEucHJvdG90eXBlLm5hbWU9XCJBc3NlcnRpb25FcnJvclwiO2Z1bmN0aW9uIEFhKGEsYil7dGhyb3cgbmV3IHphKFwiRmFpbHVyZVwiKyhhP1wiOiBcIithOlwiXCIpLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7fTt2YXIgQmE9QXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2M9bnVsbD09Yz8wOjA+Yz9NYXRoLm1heCgwLGEubGVuZ3RoK2MpOmM7aWYobShhKSlyZXR1cm4gbShiKSYmMT09Yi5sZW5ndGg/YS5pbmRleE9mKGIsYyk6LTE7Zm9yKDtjPGEubGVuZ3RoO2MrKylpZihjIGluIGEmJmFbY109PT1iKXJldHVybiBjO3JldHVybi0xfSx3PUFycmF5LnByb3RvdHlwZS5mb3JFYWNoP2Z1bmN0aW9uKGEsYixjKXtBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGEsYixjKX06ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1hLmxlbmd0aCxlPW0oYSk/YS5zcGxpdChcIlwiKTphLGY9MDtmPGQ7ZisrKWYgaW4gZSYmYi5jYWxsKGMsZVtmXSxmLGEpfTtcbmZ1bmN0aW9uIENhKGEsYil7dmFyIGM9YS5sZW5ndGgsZD1tKGEpP2Euc3BsaXQoXCJcIik6YTtmb3IoLS1jOzA8PWM7LS1jKWMgaW4gZCYmYi5jYWxsKHZvaWQgMCxkW2NdLGMsYSl9dmFyIERhPUFycmF5LnByb3RvdHlwZS5tYXA/ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoYSxiLGMpfTpmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWEubGVuZ3RoLGU9QXJyYXkoZCksZj1tKGEpP2Euc3BsaXQoXCJcIik6YSxnPTA7ZzxkO2crKylnIGluIGYmJihlW2ddPWIuY2FsbChjLGZbZ10sZyxhKSk7cmV0dXJuIGV9LEVhPUFycmF5LnByb3RvdHlwZS5zb21lP2Z1bmN0aW9uKGEsYixjKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChhLGIsYyl9OmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9YS5sZW5ndGgsZT1tKGEpP2Euc3BsaXQoXCJcIik6YSxmPTA7ZjxkO2YrKylpZihmIGluIGUmJmIuY2FsbChjLGVbZl0sZixhKSlyZXR1cm4hMDtyZXR1cm4hMX07XG5mdW5jdGlvbiBGYShhKXthOnt2YXIgYj1HYTtmb3IodmFyIGM9YS5sZW5ndGgsZD1tKGEpP2Euc3BsaXQoXCJcIik6YSxlPTA7ZTxjO2UrKylpZihlIGluIGQmJmIuY2FsbCh2b2lkIDAsZFtlXSxlLGEpKXtiPWU7YnJlYWsgYX1iPS0xfXJldHVybiAwPmI/bnVsbDptKGEpP2EuY2hhckF0KGIpOmFbYl19ZnVuY3Rpb24gSGEoYSxiKXtyZXR1cm4gMDw9QmEoYSxiKX1mdW5jdGlvbiBJYShhLGIpe2I9QmEoYSxiKTt2YXIgYzsoYz0wPD1iKSYmQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGEsYiwxKTtyZXR1cm4gY31mdW5jdGlvbiBKYShhLGIpe3ZhciBjPTA7Q2EoYSxmdW5jdGlvbihkLGUpe2IuY2FsbCh2b2lkIDAsZCxlLGEpJiYxPT1BcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYSxlLDEpLmxlbmd0aCYmYysrfSl9ZnVuY3Rpb24gS2EoYSl7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sYXJndW1lbnRzKX1cbmZ1bmN0aW9uIExhKGEpe3ZhciBiPWEubGVuZ3RoO2lmKDA8Yil7Zm9yKHZhciBjPUFycmF5KGIpLGQ9MDtkPGI7ZCsrKWNbZF09YVtkXTtyZXR1cm4gY31yZXR1cm5bXX07dmFyIE1hO2E6e3ZhciBOYT1rLm5hdmlnYXRvcjtpZihOYSl7dmFyIE9hPU5hLnVzZXJBZ2VudDtpZihPYSl7TWE9T2E7YnJlYWsgYX19TWE9XCJcIn1mdW5jdGlvbiB4KGEpe3JldHVybiB2KE1hLGEpfTtmdW5jdGlvbiBQYShhLGIpe2Zvcih2YXIgYyBpbiBhKWIuY2FsbCh2b2lkIDAsYVtjXSxjLGEpfWZ1bmN0aW9uIFFhKGEpe3ZhciBiPVtdLGM9MCxkO2ZvcihkIGluIGEpYltjKytdPWFbZF07cmV0dXJuIGJ9ZnVuY3Rpb24gUmEoYSl7dmFyIGI9W10sYz0wLGQ7Zm9yKGQgaW4gYSliW2MrK109ZDtyZXR1cm4gYn1mdW5jdGlvbiBTYShhKXtmb3IodmFyIGIgaW4gYSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBUYShhLGIpe2Zvcih2YXIgYyBpbiBhKWlmKCEoYyBpbiBiKXx8YVtjXSE9PWJbY10pcmV0dXJuITE7Zm9yKGMgaW4gYilpZighKGMgaW4gYSkpcmV0dXJuITE7cmV0dXJuITB9ZnVuY3Rpb24gVWEoYSl7dmFyIGI9e30sYztmb3IoYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn12YXIgVmE9XCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIik7XG5mdW5jdGlvbiBXYShhLGIpe2Zvcih2YXIgYyxkLGU9MTtlPGFyZ3VtZW50cy5sZW5ndGg7ZSsrKXtkPWFyZ3VtZW50c1tlXTtmb3IoYyBpbiBkKWFbY109ZFtjXTtmb3IodmFyIGY9MDtmPFZhLmxlbmd0aDtmKyspYz1WYVtmXSxPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZCxjKSYmKGFbY109ZFtjXSl9fTtmdW5jdGlvbiBYYShhKXtYYVtcIiBcIl0oYSk7cmV0dXJuIGF9WGFbXCIgXCJdPWNhO2Z1bmN0aW9uIFlhKGEsYil7dmFyIGM9WmE7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjLGEpP2NbYV06Y1thXT1iKGEpfTt2YXIgJGE9eChcIk9wZXJhXCIpLHk9eChcIlRyaWRlbnRcIil8fHgoXCJNU0lFXCIpLGFiPXgoXCJFZGdlXCIpLGJiPWFifHx5LGNiPXgoXCJHZWNrb1wiKSYmISh2KE1hLnRvTG93ZXJDYXNlKCksXCJ3ZWJraXRcIikmJiF4KFwiRWRnZVwiKSkmJiEoeChcIlRyaWRlbnRcIil8fHgoXCJNU0lFXCIpKSYmIXgoXCJFZGdlXCIpLGRiPXYoTWEudG9Mb3dlckNhc2UoKSxcIndlYmtpdFwiKSYmIXgoXCJFZGdlXCIpO2Z1bmN0aW9uIGViKCl7dmFyIGE9ay5kb2N1bWVudDtyZXR1cm4gYT9hLmRvY3VtZW50TW9kZTp2b2lkIDB9dmFyIGZiO1xuYTp7dmFyIGdiPVwiXCIsaGI9ZnVuY3Rpb24oKXt2YXIgYT1NYTtpZihjYilyZXR1cm4vcnZcXDooW15cXCk7XSspKFxcKXw7KS8uZXhlYyhhKTtpZihhYilyZXR1cm4vRWRnZVxcLyhbXFxkXFwuXSspLy5leGVjKGEpO2lmKHkpcmV0dXJuL1xcYig/Ok1TSUV8cnYpWzogXShbXlxcKTtdKykoXFwpfDspLy5leGVjKGEpO2lmKGRiKXJldHVybi9XZWJLaXRcXC8oXFxTKykvLmV4ZWMoYSk7aWYoJGEpcmV0dXJuLyg/OlZlcnNpb24pWyBcXC9dPyhcXFMrKS8uZXhlYyhhKX0oKTtoYiYmKGdiPWhiP2hiWzFdOlwiXCIpO2lmKHkpe3ZhciBpYj1lYigpO2lmKG51bGwhPWliJiZpYj5wYXJzZUZsb2F0KGdiKSl7ZmI9U3RyaW5nKGliKTticmVhayBhfX1mYj1nYn12YXIgWmE9e307XG5mdW5jdGlvbiBqYihhKXtyZXR1cm4gWWEoYSxmdW5jdGlvbigpe2Zvcih2YXIgYj0wLGM9cGEoU3RyaW5nKGZiKSkuc3BsaXQoXCIuXCIpLGQ9cGEoU3RyaW5nKGEpKS5zcGxpdChcIi5cIiksZT1NYXRoLm1heChjLmxlbmd0aCxkLmxlbmd0aCksZj0wOzA9PWImJmY8ZTtmKyspe3ZhciBnPWNbZl18fFwiXCIsbD1kW2ZdfHxcIlwiO2Rve2c9LyhcXGQqKShcXEQqKSguKikvLmV4ZWMoZyl8fFtcIlwiLFwiXCIsXCJcIixcIlwiXTtsPS8oXFxkKikoXFxEKikoLiopLy5leGVjKGwpfHxbXCJcIixcIlwiLFwiXCIsXCJcIl07aWYoMD09Z1swXS5sZW5ndGgmJjA9PWxbMF0ubGVuZ3RoKWJyZWFrO2I9eWEoMD09Z1sxXS5sZW5ndGg/MDpwYXJzZUludChnWzFdLDEwKSwwPT1sWzFdLmxlbmd0aD8wOnBhcnNlSW50KGxbMV0sMTApKXx8eWEoMD09Z1syXS5sZW5ndGgsMD09bFsyXS5sZW5ndGgpfHx5YShnWzJdLGxbMl0pO2c9Z1szXTtsPWxbM119d2hpbGUoMD09Yil9cmV0dXJuIDA8PWJ9KX12YXIga2I7dmFyIGxiPWsuZG9jdW1lbnQ7XG5rYj1sYiYmeT9lYigpfHwoXCJDU1MxQ29tcGF0XCI9PWxiLmNvbXBhdE1vZGU/cGFyc2VJbnQoZmIsMTApOjUpOnZvaWQgMDtmdW5jdGlvbiBtYihhKXthLnByb3RvdHlwZS50aGVuPWEucHJvdG90eXBlLnRoZW47YS5wcm90b3R5cGUuJGdvb2dfVGhlbmFibGU9ITB9ZnVuY3Rpb24gbmIoYSl7aWYoIWEpcmV0dXJuITE7dHJ5e3JldHVybiEhYS4kZ29vZ19UaGVuYWJsZX1jYXRjaChiKXtyZXR1cm4hMX19O2Z1bmN0aW9uIG9iKGEsYixjKXt0aGlzLmY9Yzt0aGlzLmM9YTt0aGlzLmc9Yjt0aGlzLmI9MDt0aGlzLmE9bnVsbH1vYi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7aWYoMDx0aGlzLmIpe3RoaXMuYi0tO3ZhciBhPXRoaXMuYTt0aGlzLmE9YS5uZXh0O2EubmV4dD1udWxsfWVsc2UgYT10aGlzLmMoKTtyZXR1cm4gYX07ZnVuY3Rpb24gcGIoYSxiKXthLmcoYik7YS5iPGEuZiYmKGEuYisrLGIubmV4dD1hLmEsYS5hPWIpfTt2YXIgcmI9bmV3IG9iKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBxYn0sZnVuY3Rpb24oYSl7YS5yZXNldCgpfSwxMDApO2Z1bmN0aW9uIHNiKCl7dmFyIGE9dGIsYj1udWxsO2EuYSYmKGI9YS5hLGEuYT1hLmEubmV4dCxhLmF8fChhLmI9bnVsbCksYi5uZXh0PW51bGwpO3JldHVybiBifWZ1bmN0aW9uIHFiKCl7dGhpcy5uZXh0PXRoaXMuYj10aGlzLmE9bnVsbH1xYi5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKGEsYil7dGhpcy5hPWE7dGhpcy5iPWI7dGhpcy5uZXh0PW51bGx9O3FiLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMubmV4dD10aGlzLmI9dGhpcy5hPW51bGx9O2Z1bmN0aW9uIHViKGEpe2suc2V0VGltZW91dChmdW5jdGlvbigpe3Rocm93IGE7fSwwKX12YXIgd2I7XG5mdW5jdGlvbiB4Yigpe3ZhciBhPWsuTWVzc2FnZUNoYW5uZWw7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmd2luZG93LnBvc3RNZXNzYWdlJiZ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciYmIXgoXCJQcmVzdG9cIikmJihhPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIklGUkFNRVwiKTthLnN0eWxlLmRpc3BsYXk9XCJub25lXCI7YS5zcmM9XCJcIjtkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYSk7dmFyIGI9YS5jb250ZW50V2luZG93O2E9Yi5kb2N1bWVudDthLm9wZW4oKTthLndyaXRlKFwiXCIpO2EuY2xvc2UoKTt2YXIgYz1cImNhbGxJbW1lZGlhdGVcIitNYXRoLnJhbmRvbSgpLGQ9XCJmaWxlOlwiPT1iLmxvY2F0aW9uLnByb3RvY29sP1wiKlwiOmIubG9jYXRpb24ucHJvdG9jb2wrXCIvL1wiK2IubG9jYXRpb24uaG9zdDthPXIoZnVuY3Rpb24oYSl7aWYoKFwiKlwiPT1kfHxhLm9yaWdpbj09ZCkmJmEuZGF0YT09XG5jKXRoaXMucG9ydDEub25tZXNzYWdlKCl9LHRoaXMpO2IuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixhLCExKTt0aGlzLnBvcnQxPXt9O3RoaXMucG9ydDI9e3Bvc3RNZXNzYWdlOmZ1bmN0aW9uKCl7Yi5wb3N0TWVzc2FnZShjLGQpfX19KTtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEmJiF4KFwiVHJpZGVudFwiKSYmIXgoXCJNU0lFXCIpKXt2YXIgYj1uZXcgYSxjPXt9LGQ9YztiLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbigpe2lmKHZvaWQgMCE9PWMubmV4dCl7Yz1jLm5leHQ7dmFyIGE9Yy5wYjtjLnBiPW51bGw7YSgpfX07cmV0dXJuIGZ1bmN0aW9uKGEpe2QubmV4dD17cGI6YX07ZD1kLm5leHQ7Yi5wb3J0Mi5wb3N0TWVzc2FnZSgwKX19cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkb2N1bWVudCYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJTQ1JJUFRcIik/ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKTtcbmIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9bnVsbDtiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik7Yj1udWxsO2EoKTthPW51bGx9O2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChiKX06ZnVuY3Rpb24oYSl7ay5zZXRUaW1lb3V0KGEsMCl9fTtmdW5jdGlvbiB5YihhLGIpe3pifHxBYigpO0JifHwoemIoKSxCYj0hMCk7dmFyIGM9dGIsZD1yYi5nZXQoKTtkLnNldChhLGIpO2MuYj9jLmIubmV4dD1kOmMuYT1kO2MuYj1kfXZhciB6YjtmdW5jdGlvbiBBYigpe2lmKC0xIT1TdHJpbmcoay5Qcm9taXNlKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSl7dmFyIGE9ay5Qcm9taXNlLnJlc29sdmUodm9pZCAwKTt6Yj1mdW5jdGlvbigpe2EudGhlbihDYil9fWVsc2UgemI9ZnVuY3Rpb24oKXt2YXIgYT1DYjshcChrLnNldEltbWVkaWF0ZSl8fGsuV2luZG93JiZrLldpbmRvdy5wcm90b3R5cGUmJiF4KFwiRWRnZVwiKSYmay5XaW5kb3cucHJvdG90eXBlLnNldEltbWVkaWF0ZT09ay5zZXRJbW1lZGlhdGU/KHdifHwod2I9eGIoKSksd2IoYSkpOmsuc2V0SW1tZWRpYXRlKGEpfX12YXIgQmI9ITEsdGI9bmV3IGZ1bmN0aW9uKCl7dGhpcy5iPXRoaXMuYT1udWxsfTtcbmZ1bmN0aW9uIENiKCl7Zm9yKHZhciBhO2E9c2IoKTspe3RyeXthLmEuY2FsbChhLmIpfWNhdGNoKGIpe3ViKGIpfXBiKHJiLGEpfUJiPSExfTtmdW5jdGlvbiB6KGEsYil7dGhpcy5hPURiO3RoaXMuaT12b2lkIDA7dGhpcy5mPXRoaXMuYj10aGlzLmM9bnVsbDt0aGlzLmc9dGhpcy5oPSExO2lmKGEhPWNhKXRyeXt2YXIgYz10aGlzO2EuY2FsbChiLGZ1bmN0aW9uKGEpe0ViKGMsRmIsYSl9LGZ1bmN0aW9uKGEpe2lmKCEoYSBpbnN0YW5jZW9mIEdiKSl0cnl7aWYoYSBpbnN0YW5jZW9mIEVycm9yKXRocm93IGE7dGhyb3cgRXJyb3IoXCJQcm9taXNlIHJlamVjdGVkLlwiKTt9Y2F0Y2goZSl7fUViKGMsSGIsYSl9KX1jYXRjaChkKXtFYih0aGlzLEhiLGQpfX12YXIgRGI9MCxGYj0yLEhiPTM7ZnVuY3Rpb24gSWIoKXt0aGlzLm5leHQ9dGhpcy5mPXRoaXMuYj10aGlzLmc9dGhpcy5hPW51bGw7dGhpcy5jPSExfUliLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuZj10aGlzLmI9dGhpcy5nPXRoaXMuYT1udWxsO3RoaXMuYz0hMX07XG52YXIgSmI9bmV3IG9iKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBJYn0sZnVuY3Rpb24oYSl7YS5yZXNldCgpfSwxMDApO2Z1bmN0aW9uIEtiKGEsYixjKXt2YXIgZD1KYi5nZXQoKTtkLmc9YTtkLmI9YjtkLmY9YztyZXR1cm4gZH1mdW5jdGlvbiBBKGEpe2lmKGEgaW5zdGFuY2VvZiB6KXJldHVybiBhO3ZhciBiPW5ldyB6KGNhKTtFYihiLEZiLGEpO3JldHVybiBifWZ1bmN0aW9uIEIoYSl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIsYyl7YyhhKX0pfWZ1bmN0aW9uIExiKGEsYixjKXtNYihhLGIsYyxudWxsKXx8eWIobWEoYixhKSl9ZnVuY3Rpb24gTmIoYSl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5sZW5ndGgsZT1bXTtpZihkKWZvcih2YXIgZj1mdW5jdGlvbihhLGMpe2QtLTtlW2FdPWM7MD09ZCYmYihlKX0sZz1mdW5jdGlvbihhKXtjKGEpfSxsPTAsbjtsPGEubGVuZ3RoO2wrKyluPWFbbF0sTGIobixtYShmLGwpLGcpO2Vsc2UgYihlKX0pfVxuZnVuY3Rpb24gT2IoYSl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIpe3ZhciBjPWEubGVuZ3RoLGQ9W107aWYoYylmb3IodmFyIGU9ZnVuY3Rpb24oYSxlLGYpe2MtLTtkW2FdPWU/e1ViOiEwLHZhbHVlOmZ9OntVYjohMSxyZWFzb246Zn07MD09YyYmYihkKX0sZj0wLGc7ZjxhLmxlbmd0aDtmKyspZz1hW2ZdLExiKGcsbWEoZSxmLCEwKSxtYShlLGYsITEpKTtlbHNlIGIoZCl9KX16LnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGIodGhpcyxwKGEpP2E6bnVsbCxwKGIpP2I6bnVsbCxjKX07bWIoeik7ZnVuY3Rpb24gUWIoYSxiKXtiPUtiKGIsYix2b2lkIDApO2IuYz0hMDtSYihhLGIpO3JldHVybiBhfWg9ei5wcm90b3R5cGU7aC5zPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFBiKHRoaXMsbnVsbCxhLGIpfTtoLmNhbmNlbD1mdW5jdGlvbihhKXt0aGlzLmE9PURiJiZ5YihmdW5jdGlvbigpe3ZhciBiPW5ldyBHYihhKTtTYih0aGlzLGIpfSx0aGlzKX07XG5mdW5jdGlvbiBTYihhLGIpe2lmKGEuYT09RGIpaWYoYS5jKXt2YXIgYz1hLmM7aWYoYy5iKXtmb3IodmFyIGQ9MCxlPW51bGwsZj1udWxsLGc9Yy5iO2cmJihnLmN8fChkKyssZy5hPT1hJiYoZT1nKSwhKGUmJjE8ZCkpKTtnPWcubmV4dCllfHwoZj1nKTtlJiYoYy5hPT1EYiYmMT09ZD9TYihjLGIpOihmPyhkPWYsZC5uZXh0PT1jLmYmJihjLmY9ZCksZC5uZXh0PWQubmV4dC5uZXh0KTpUYihjKSxVYihjLGUsSGIsYikpKX1hLmM9bnVsbH1lbHNlIEViKGEsSGIsYil9ZnVuY3Rpb24gUmIoYSxiKXthLmJ8fGEuYSE9RmImJmEuYSE9SGJ8fFZiKGEpO2EuZj9hLmYubmV4dD1iOmEuYj1iO2EuZj1ifVxuZnVuY3Rpb24gUGIoYSxiLGMsZCl7dmFyIGU9S2IobnVsbCxudWxsLG51bGwpO2UuYT1uZXcgeihmdW5jdGlvbihhLGcpe2UuZz1iP2Z1bmN0aW9uKGMpe3RyeXt2YXIgZT1iLmNhbGwoZCxjKTthKGUpfWNhdGNoKEQpe2coRCl9fTphO2UuYj1jP2Z1bmN0aW9uKGIpe3RyeXt2YXIgZT1jLmNhbGwoZCxiKTt2b2lkIDA9PT1lJiZiIGluc3RhbmNlb2YgR2I/ZyhiKTphKGUpfWNhdGNoKEQpe2coRCl9fTpnfSk7ZS5hLmM9YTtSYihhLGUpO3JldHVybiBlLmF9aC5BYz1mdW5jdGlvbihhKXt0aGlzLmE9RGI7RWIodGhpcyxGYixhKX07aC5CYz1mdW5jdGlvbihhKXt0aGlzLmE9RGI7RWIodGhpcyxIYixhKX07XG5mdW5jdGlvbiBFYihhLGIsYyl7YS5hPT1EYiYmKGE9PT1jJiYoYj1IYixjPW5ldyBUeXBlRXJyb3IoXCJQcm9taXNlIGNhbm5vdCByZXNvbHZlIHRvIGl0c2VsZlwiKSksYS5hPTEsTWIoYyxhLkFjLGEuQmMsYSl8fChhLmk9YyxhLmE9YixhLmM9bnVsbCxWYihhKSxiIT1IYnx8YyBpbnN0YW5jZW9mIEdifHxXYihhLGMpKSl9ZnVuY3Rpb24gTWIoYSxiLGMsZCl7aWYoYSBpbnN0YW5jZW9mIHopcmV0dXJuIFJiKGEsS2IoYnx8Y2EsY3x8bnVsbCxkKSksITA7aWYobmIoYSkpcmV0dXJuIGEudGhlbihiLGMsZCksITA7aWYocShhKSl0cnl7dmFyIGU9YS50aGVuO2lmKHAoZSkpcmV0dXJuIFhiKGEsZSxiLGMsZCksITB9Y2F0Y2goZil7cmV0dXJuIGMuY2FsbChkLGYpLCEwfXJldHVybiExfVxuZnVuY3Rpb24gWGIoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGEpe2x8fChsPSEwLGQuY2FsbChlLGEpKX1mdW5jdGlvbiBnKGEpe2x8fChsPSEwLGMuY2FsbChlLGEpKX12YXIgbD0hMTt0cnl7Yi5jYWxsKGEsZyxmKX1jYXRjaChuKXtmKG4pfX1mdW5jdGlvbiBWYihhKXthLmh8fChhLmg9ITAseWIoYS5RYixhKSl9ZnVuY3Rpb24gVGIoYSl7dmFyIGI9bnVsbDthLmImJihiPWEuYixhLmI9Yi5uZXh0LGIubmV4dD1udWxsKTthLmJ8fChhLmY9bnVsbCk7cmV0dXJuIGJ9aC5RYj1mdW5jdGlvbigpe2Zvcih2YXIgYTthPVRiKHRoaXMpOylVYih0aGlzLGEsdGhpcy5hLHRoaXMuaSk7dGhpcy5oPSExfTtcbmZ1bmN0aW9uIFViKGEsYixjLGQpe2lmKGM9PUhiJiZiLmImJiFiLmMpZm9yKDthJiZhLmc7YT1hLmMpYS5nPSExO2lmKGIuYSliLmEuYz1udWxsLFliKGIsYyxkKTtlbHNlIHRyeXtiLmM/Yi5nLmNhbGwoYi5mKTpZYihiLGMsZCl9Y2F0Y2goZSl7WmIuY2FsbChudWxsLGUpfXBiKEpiLGIpfWZ1bmN0aW9uIFliKGEsYixjKXtiPT1GYj9hLmcuY2FsbChhLmYsYyk6YS5iJiZhLmIuY2FsbChhLmYsYyl9ZnVuY3Rpb24gV2IoYSxiKXthLmc9ITA7eWIoZnVuY3Rpb24oKXthLmcmJlpiLmNhbGwobnVsbCxiKX0pfXZhciBaYj11YjtmdW5jdGlvbiBHYihhKXt1LmNhbGwodGhpcyxhKX10KEdiLHUpO0diLnByb3RvdHlwZS5uYW1lPVwiY2FuY2VsXCI7dmFyICRiPSF5fHw5PD1OdW1iZXIoa2IpO2Z1bmN0aW9uIGFjKCl7dGhpcy5hPVwiXCI7dGhpcy5iPWJjfWFjLnByb3RvdHlwZS5sYT0hMDthYy5wcm90b3R5cGUuamE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hfTthYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIkNvbnN0e1wiK3RoaXMuYStcIn1cIn07ZnVuY3Rpb24gY2MoYSl7aWYoYSBpbnN0YW5jZW9mIGFjJiZhLmNvbnN0cnVjdG9yPT09YWMmJmEuYj09PWJjKXJldHVybiBhLmE7QWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBDb25zdCwgZ290ICdcIithK1wiJ1wiKTtyZXR1cm5cInR5cGVfZXJyb3I6Q29uc3RcIn12YXIgYmM9e307ZnVuY3Rpb24gZGMoYSl7dmFyIGI9bmV3IGFjO2IuYT1hO3JldHVybiBifWRjKFwiXCIpO2Z1bmN0aW9uIGVjKCl7dGhpcy5hPVwiXCI7dGhpcy5iPWZjfWVjLnByb3RvdHlwZS5sYT0hMDtlYy5wcm90b3R5cGUuamE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hfTtlYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlRydXN0ZWRSZXNvdXJjZVVybHtcIit0aGlzLmErXCJ9XCJ9O2Z1bmN0aW9uIGdjKGEpe2lmKGEgaW5zdGFuY2VvZiBlYyYmYS5jb25zdHJ1Y3Rvcj09PWVjJiZhLmI9PT1mYylyZXR1cm4gYS5hO0FhKFwiZXhwZWN0ZWQgb2JqZWN0IG9mIHR5cGUgVHJ1c3RlZFJlc291cmNlVXJsLCBnb3QgJ1wiK2ErXCInIG9mIHR5cGUgXCIrZGEoYSkpO3JldHVyblwidHlwZV9lcnJvcjpUcnVzdGVkUmVzb3VyY2VVcmxcIn1mdW5jdGlvbiBoYyhhLGIpe2E9aWMoYSxiKTtiPW5ldyBlYztiLmE9YTtyZXR1cm4gYn1cbmZ1bmN0aW9uIGljKGEsYil7dmFyIGM9Y2MoYSk7aWYoIWpjLnRlc3QoYykpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFRydXN0ZWRSZXNvdXJjZVVybCBmb3JtYXQ6IFwiK2MpO3JldHVybiBjLnJlcGxhY2Uoa2MsZnVuY3Rpb24oYSxlKXtpZighT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsZSkpdGhyb3cgRXJyb3IoJ0ZvdW5kIG1hcmtlciwgXCInK2UrJ1wiLCBpbiBmb3JtYXQgc3RyaW5nLCBcIicrYysnXCIsIGJ1dCBubyB2YWxpZCBsYWJlbCBtYXBwaW5nIGZvdW5kIGluIGFyZ3M6ICcrSlNPTi5zdHJpbmdpZnkoYikpO2E9YltlXTtyZXR1cm4gYSBpbnN0YW5jZW9mIGFjP2NjKGEpOmVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYSkpfSl9dmFyIGtjPS8leyhcXHcrKX0vZyxqYz0vXig/Omh0dHBzOik/XFwvXFwvWzAtOWEtei46W1xcXS1dK1xcL3xeXFwvW15cXC9cXFxcXXxeYWJvdXQ6YmxhbmsoI3wkKS9pLGZjPXt9O2Z1bmN0aW9uIGxjKCl7dGhpcy5hPVwiXCI7dGhpcy5iPW1jfWxjLnByb3RvdHlwZS5sYT0hMDtsYy5wcm90b3R5cGUuamE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hfTtsYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlNhZmVVcmx7XCIrdGhpcy5hK1wifVwifTtmdW5jdGlvbiBuYyhhKXtpZihhIGluc3RhbmNlb2YgbGMmJmEuY29uc3RydWN0b3I9PT1sYyYmYS5iPT09bWMpcmV0dXJuIGEuYTtBYShcImV4cGVjdGVkIG9iamVjdCBvZiB0eXBlIFNhZmVVcmwsIGdvdCAnXCIrYStcIicgb2YgdHlwZSBcIitkYShhKSk7cmV0dXJuXCJ0eXBlX2Vycm9yOlNhZmVVcmxcIn12YXIgb2M9L14oPzooPzpodHRwcz98bWFpbHRvfGZ0cCk6fFteOi8/I10qKD86Wy8/I118JCkpL2k7XG5mdW5jdGlvbiBwYyhhKXtpZihhIGluc3RhbmNlb2YgbGMpcmV0dXJuIGE7YT1hLmxhP2EuamEoKTpTdHJpbmcoYSk7b2MudGVzdChhKXx8KGE9XCJhYm91dDppbnZhbGlkI3pDbG9zdXJlelwiKTtyZXR1cm4gcWMoYSl9dmFyIG1jPXt9O2Z1bmN0aW9uIHFjKGEpe3ZhciBiPW5ldyBsYztiLmE9YTtyZXR1cm4gYn1xYyhcImFib3V0OmJsYW5rXCIpO2Z1bmN0aW9uIHJjKCl7dGhpcy5hPVwiXCI7dGhpcy5iPXNjfXJjLnByb3RvdHlwZS5sYT0hMDtyYy5wcm90b3R5cGUuamE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hfTtyYy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm5cIlNhZmVIdG1se1wiK3RoaXMuYStcIn1cIn07ZnVuY3Rpb24gdWMoYSl7aWYoYSBpbnN0YW5jZW9mIHJjJiZhLmNvbnN0cnVjdG9yPT09cmMmJmEuYj09PXNjKXJldHVybiBhLmE7QWEoXCJleHBlY3RlZCBvYmplY3Qgb2YgdHlwZSBTYWZlSHRtbCwgZ290ICdcIithK1wiJyBvZiB0eXBlIFwiK2RhKGEpKTtyZXR1cm5cInR5cGVfZXJyb3I6U2FmZUh0bWxcIn12YXIgc2M9e307ZnVuY3Rpb24gdmMoYSl7dmFyIGI9bmV3IHJjO2IuYT1hO3JldHVybiBifXZjKFwiPCFET0NUWVBFIGh0bWw+XCIpO3ZjKFwiXCIpO3ZjKFwiPGJyPlwiKTtmdW5jdGlvbiB3YyhhKXt2YXIgYj1kb2N1bWVudDtyZXR1cm4gbShhKT9iLmdldEVsZW1lbnRCeUlkKGEpOmF9ZnVuY3Rpb24geGMoYSxiKXtQYShiLGZ1bmN0aW9uKGIsZCl7YiYmYi5sYSYmKGI9Yi5qYSgpKTtcInN0eWxlXCI9PWQ/YS5zdHlsZS5jc3NUZXh0PWI6XCJjbGFzc1wiPT1kP2EuY2xhc3NOYW1lPWI6XCJmb3JcIj09ZD9hLmh0bWxGb3I9Yjp5Yy5oYXNPd25Qcm9wZXJ0eShkKT9hLnNldEF0dHJpYnV0ZSh5Y1tkXSxiKTowPT1kLmxhc3RJbmRleE9mKFwiYXJpYS1cIiwwKXx8MD09ZC5sYXN0SW5kZXhPZihcImRhdGEtXCIsMCk/YS5zZXRBdHRyaWJ1dGUoZCxiKTphW2RdPWJ9KX1cbnZhciB5Yz17Y2VsbHBhZGRpbmc6XCJjZWxsUGFkZGluZ1wiLGNlbGxzcGFjaW5nOlwiY2VsbFNwYWNpbmdcIixjb2xzcGFuOlwiY29sU3BhblwiLGZyYW1lYm9yZGVyOlwiZnJhbWVCb3JkZXJcIixoZWlnaHQ6XCJoZWlnaHRcIixtYXhsZW5ndGg6XCJtYXhMZW5ndGhcIixub25jZTpcIm5vbmNlXCIscm9sZTpcInJvbGVcIixyb3dzcGFuOlwicm93U3BhblwiLHR5cGU6XCJ0eXBlXCIsdXNlbWFwOlwidXNlTWFwXCIsdmFsaWduOlwidkFsaWduXCIsd2lkdGg6XCJ3aWR0aFwifTtcbmZ1bmN0aW9uIHpjKGEsYixjKXt2YXIgZD1hcmd1bWVudHMsZT1kb2N1bWVudCxmPVN0cmluZyhkWzBdKSxnPWRbMV07aWYoISRiJiZnJiYoZy5uYW1lfHxnLnR5cGUpKXtmPVtcIjxcIixmXTtnLm5hbWUmJmYucHVzaCgnIG5hbWU9XCInLHFhKGcubmFtZSksJ1wiJyk7aWYoZy50eXBlKXtmLnB1c2goJyB0eXBlPVwiJyxxYShnLnR5cGUpLCdcIicpO3ZhciBsPXt9O1dhKGwsZyk7ZGVsZXRlIGwudHlwZTtnPWx9Zi5wdXNoKFwiPlwiKTtmPWYuam9pbihcIlwiKX1mPWUuY3JlYXRlRWxlbWVudChmKTtnJiYobShnKT9mLmNsYXNzTmFtZT1nOmZhKGcpP2YuY2xhc3NOYW1lPWcuam9pbihcIiBcIik6eGMoZixnKSk7MjxkLmxlbmd0aCYmQWMoZSxmLGQpO3JldHVybiBmfVxuZnVuY3Rpb24gQWMoYSxiLGMpe2Z1bmN0aW9uIGQoYyl7YyYmYi5hcHBlbmRDaGlsZChtKGMpP2EuY3JlYXRlVGV4dE5vZGUoYyk6Yyl9Zm9yKHZhciBlPTI7ZTxjLmxlbmd0aDtlKyspe3ZhciBmPWNbZV07IWhhKGYpfHxxKGYpJiYwPGYubm9kZVR5cGU/ZChmKTp3KEJjKGYpP0xhKGYpOmYsZCl9fWZ1bmN0aW9uIEJjKGEpe2lmKGEmJlwibnVtYmVyXCI9PXR5cGVvZiBhLmxlbmd0aCl7aWYocShhKSlyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhLml0ZW18fFwic3RyaW5nXCI9PXR5cGVvZiBhLml0ZW07aWYocChhKSlyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBhLml0ZW19cmV0dXJuITF9O2Z1bmN0aW9uIENjKGEpe3ZhciBiPVtdO0RjKG5ldyBFYyxhLGIpO3JldHVybiBiLmpvaW4oXCJcIil9ZnVuY3Rpb24gRWMoKXt9XG5mdW5jdGlvbiBEYyhhLGIsYyl7aWYobnVsbD09YiljLnB1c2goXCJudWxsXCIpO2Vsc2V7aWYoXCJvYmplY3RcIj09dHlwZW9mIGIpe2lmKGZhKGIpKXt2YXIgZD1iO2I9ZC5sZW5ndGg7Yy5wdXNoKFwiW1wiKTtmb3IodmFyIGU9XCJcIixmPTA7ZjxiO2YrKyljLnB1c2goZSksRGMoYSxkW2ZdLGMpLGU9XCIsXCI7Yy5wdXNoKFwiXVwiKTtyZXR1cm59aWYoYiBpbnN0YW5jZW9mIFN0cmluZ3x8YiBpbnN0YW5jZW9mIE51bWJlcnx8YiBpbnN0YW5jZW9mIEJvb2xlYW4pYj1iLnZhbHVlT2YoKTtlbHNle2MucHVzaChcIntcIik7ZT1cIlwiO2ZvcihkIGluIGIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsZCkmJihmPWJbZF0sXCJmdW5jdGlvblwiIT10eXBlb2YgZiYmKGMucHVzaChlKSxGYyhkLGMpLGMucHVzaChcIjpcIiksRGMoYSxmLGMpLGU9XCIsXCIpKTtjLnB1c2goXCJ9XCIpO3JldHVybn19c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwic3RyaW5nXCI6RmMoYixjKTticmVhaztjYXNlIFwibnVtYmVyXCI6Yy5wdXNoKGlzRmluaXRlKGIpJiZcbiFpc05hTihiKT9TdHJpbmcoYik6XCJudWxsXCIpO2JyZWFrO2Nhc2UgXCJib29sZWFuXCI6Yy5wdXNoKFN0cmluZyhiKSk7YnJlYWs7Y2FzZSBcImZ1bmN0aW9uXCI6Yy5wdXNoKFwibnVsbFwiKTticmVhaztkZWZhdWx0OnRocm93IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIit0eXBlb2YgYik7fX19dmFyIEdjPXsnXCInOidcXFxcXCInLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcIi9cIjpcIlxcXFwvXCIsXCJcXGJcIjpcIlxcXFxiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHJcIjpcIlxcXFxyXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LEhjPS9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKT8vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHVmZmZmXS9nOi9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceGZmXS9nO1xuZnVuY3Rpb24gRmMoYSxiKXtiLnB1c2goJ1wiJyxhLnJlcGxhY2UoSGMsZnVuY3Rpb24oYSl7dmFyIGI9R2NbYV07Ynx8KGI9XCJcXFxcdVwiKyhhLmNoYXJDb2RlQXQoMCl8NjU1MzYpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSksR2NbYV09Yik7cmV0dXJuIGJ9KSwnXCInKX07ZnVuY3Rpb24gSWMoKXswIT1KYyYmKEtjW3RoaXNbaWFdfHwodGhpc1tpYV09KytqYSldPXRoaXMpO3RoaXMub2E9dGhpcy5vYTt0aGlzLkZhPXRoaXMuRmF9dmFyIEpjPTAsS2M9e307SWMucHJvdG90eXBlLm9hPSExO2Z1bmN0aW9uIExjKGEpe2Eub2F8fChhLm9hPSEwLGEudGEoKSwwIT1KYyYmKGE9YVtpYV18fChhW2lhXT0rK2phKSxkZWxldGUgS2NbYV0pKX1JYy5wcm90b3R5cGUudGE9ZnVuY3Rpb24oKXtpZih0aGlzLkZhKWZvcig7dGhpcy5GYS5sZW5ndGg7KXRoaXMuRmEuc2hpZnQoKSgpfTt2YXIgTWM9T2JqZWN0LmZyZWV6ZXx8ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O3ZhciBOYz0heXx8OTw9TnVtYmVyKGtiKSxPYz15JiYhamIoXCI5XCIpLFBjPWZ1bmN0aW9uKCl7aWYoIWsuYWRkRXZlbnRMaXN0ZW5lcnx8IU9iamVjdC5kZWZpbmVQcm9wZXJ0eSlyZXR1cm4hMTt2YXIgYT0hMSxiPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSxcInBhc3NpdmVcIix7Z2V0OmZ1bmN0aW9uKCl7YT0hMH19KTtrLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsY2EsYik7ay5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFwiLGNhLGIpO3JldHVybiBhfSgpO2Z1bmN0aW9uIEMoYSxiKXt0aGlzLnR5cGU9YTt0aGlzLmI9dGhpcy50YXJnZXQ9Yjt0aGlzLkJiPSEwfUMucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXt0aGlzLkJiPSExfTtmdW5jdGlvbiBRYyhhLGIpe0MuY2FsbCh0aGlzLGE/YS50eXBlOlwiXCIpO3RoaXMucmVsYXRlZFRhcmdldD10aGlzLmI9dGhpcy50YXJnZXQ9bnVsbDt0aGlzLmJ1dHRvbj10aGlzLnNjcmVlblk9dGhpcy5zY3JlZW5YPXRoaXMuY2xpZW50WT10aGlzLmNsaWVudFg9MDt0aGlzLmtleT1cIlwiO3RoaXMubWV0YUtleT10aGlzLnNoaWZ0S2V5PXRoaXMuYWx0S2V5PXRoaXMuY3RybEtleT0hMTt0aGlzLnBvaW50ZXJJZD0wO3RoaXMucG9pbnRlclR5cGU9XCJcIjt0aGlzLmE9bnVsbDtpZihhKXt2YXIgYz10aGlzLnR5cGU9YS50eXBlLGQ9YS5jaGFuZ2VkVG91Y2hlcz9hLmNoYW5nZWRUb3VjaGVzWzBdOm51bGw7dGhpcy50YXJnZXQ9YS50YXJnZXR8fGEuc3JjRWxlbWVudDt0aGlzLmI9YjtpZihiPWEucmVsYXRlZFRhcmdldCl7aWYoY2Ipe2E6e3RyeXtYYShiLm5vZGVOYW1lKTt2YXIgZT0hMDticmVhayBhfWNhdGNoKGYpe31lPSExfWV8fChiPW51bGwpfX1lbHNlXCJtb3VzZW92ZXJcIj09Yz9iPVxuYS5mcm9tRWxlbWVudDpcIm1vdXNlb3V0XCI9PWMmJihiPWEudG9FbGVtZW50KTt0aGlzLnJlbGF0ZWRUYXJnZXQ9YjtudWxsPT09ZD8odGhpcy5jbGllbnRYPXZvaWQgMCE9PWEuY2xpZW50WD9hLmNsaWVudFg6YS5wYWdlWCx0aGlzLmNsaWVudFk9dm9pZCAwIT09YS5jbGllbnRZP2EuY2xpZW50WTphLnBhZ2VZLHRoaXMuc2NyZWVuWD1hLnNjcmVlblh8fDAsdGhpcy5zY3JlZW5ZPWEuc2NyZWVuWXx8MCk6KHRoaXMuY2xpZW50WD12b2lkIDAhPT1kLmNsaWVudFg/ZC5jbGllbnRYOmQucGFnZVgsdGhpcy5jbGllbnRZPXZvaWQgMCE9PWQuY2xpZW50WT9kLmNsaWVudFk6ZC5wYWdlWSx0aGlzLnNjcmVlblg9ZC5zY3JlZW5YfHwwLHRoaXMuc2NyZWVuWT1kLnNjcmVlbll8fDApO3RoaXMuYnV0dG9uPWEuYnV0dG9uO3RoaXMua2V5PWEua2V5fHxcIlwiO3RoaXMuY3RybEtleT1hLmN0cmxLZXk7dGhpcy5hbHRLZXk9YS5hbHRLZXk7dGhpcy5zaGlmdEtleT1hLnNoaWZ0S2V5O3RoaXMubWV0YUtleT1cbmEubWV0YUtleTt0aGlzLnBvaW50ZXJJZD1hLnBvaW50ZXJJZHx8MDt0aGlzLnBvaW50ZXJUeXBlPW0oYS5wb2ludGVyVHlwZSk/YS5wb2ludGVyVHlwZTpSY1thLnBvaW50ZXJUeXBlXXx8XCJcIjt0aGlzLmE9YTthLmRlZmF1bHRQcmV2ZW50ZWQmJnRoaXMuYygpfX10KFFjLEMpO3ZhciBSYz1NYyh7MjpcInRvdWNoXCIsMzpcInBlblwiLDQ6XCJtb3VzZVwifSk7UWMucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXtRYy5pYi5jLmNhbGwodGhpcyk7dmFyIGE9dGhpcy5hO2lmKGEucHJldmVudERlZmF1bHQpYS5wcmV2ZW50RGVmYXVsdCgpO2Vsc2UgaWYoYS5yZXR1cm5WYWx1ZT0hMSxPYyl0cnl7aWYoYS5jdHJsS2V5fHwxMTI8PWEua2V5Q29kZSYmMTIzPj1hLmtleUNvZGUpYS5rZXlDb2RlPS0xfWNhdGNoKGIpe319O1FjLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYX07dmFyIFNjPVwiY2xvc3VyZV9saXN0ZW5hYmxlX1wiKygxRTYqTWF0aC5yYW5kb20oKXwwKSxUYz0wO2Z1bmN0aW9uIFVjKGEsYixjLGQsZSl7dGhpcy5saXN0ZW5lcj1hO3RoaXMuYT1udWxsO3RoaXMuc3JjPWI7dGhpcy50eXBlPWM7dGhpcy5jYXB0dXJlPSEhZDt0aGlzLkxhPWU7dGhpcy5rZXk9KytUYzt0aGlzLm1hPXRoaXMuSGE9ITF9ZnVuY3Rpb24gVmMoYSl7YS5tYT0hMDthLmxpc3RlbmVyPW51bGw7YS5hPW51bGw7YS5zcmM9bnVsbDthLkxhPW51bGx9O2Z1bmN0aW9uIFdjKGEpe3RoaXMuc3JjPWE7dGhpcy5hPXt9O3RoaXMuYj0wfWZ1bmN0aW9uIFhjKGEsYixjLGQsZSxmKXt2YXIgZz1iLnRvU3RyaW5nKCk7Yj1hLmFbZ107Ynx8KGI9YS5hW2ddPVtdLGEuYisrKTt2YXIgbD1ZYyhiLGMsZSxmKTstMTxsPyhhPWJbbF0sZHx8KGEuSGE9ITEpKTooYT1uZXcgVWMoYyxhLnNyYyxnLCEhZSxmKSxhLkhhPWQsYi5wdXNoKGEpKTtyZXR1cm4gYX1mdW5jdGlvbiBaYyhhLGIpe3ZhciBjPWIudHlwZTtjIGluIGEuYSYmSWEoYS5hW2NdLGIpJiYoVmMoYiksMD09YS5hW2NdLmxlbmd0aCYmKGRlbGV0ZSBhLmFbY10sYS5iLS0pKX1mdW5jdGlvbiBZYyhhLGIsYyxkKXtmb3IodmFyIGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YVtlXTtpZighZi5tYSYmZi5saXN0ZW5lcj09YiYmZi5jYXB0dXJlPT0hIWMmJmYuTGE9PWQpcmV0dXJuIGV9cmV0dXJuLTF9O3ZhciAkYz1cImNsb3N1cmVfbG1fXCIrKDFFNipNYXRoLnJhbmRvbSgpfDApLGFkPXt9LGJkPTA7ZnVuY3Rpb24gY2QoYSxiLGMsZCxlKXtpZihkJiZkLm9uY2UpZGQoYSxiLGMsZCxlKTtlbHNlIGlmKGZhKGIpKWZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKWNkKGEsYltmXSxjLGQsZSk7ZWxzZSBjPWVkKGMpLGEmJmFbU2NdP2ZkKGEsYixjLHEoZCk/ISFkLmNhcHR1cmU6ISFkLGUpOmdkKGEsYixjLCExLGQsZSl9XG5mdW5jdGlvbiBnZChhLGIsYyxkLGUsZil7aWYoIWIpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGV2ZW50IHR5cGVcIik7dmFyIGc9cShlKT8hIWUuY2FwdHVyZTohIWUsbD1oZChhKTtsfHwoYVskY109bD1uZXcgV2MoYSkpO2M9WGMobCxiLGMsZCxnLGYpO2lmKCFjLmEpe2Q9aWQoKTtjLmE9ZDtkLnNyYz1hO2QubGlzdGVuZXI9YztpZihhLmFkZEV2ZW50TGlzdGVuZXIpUGN8fChlPWcpLHZvaWQgMD09PWUmJihlPSExKSxhLmFkZEV2ZW50TGlzdGVuZXIoYi50b1N0cmluZygpLGQsZSk7ZWxzZSBpZihhLmF0dGFjaEV2ZW50KWEuYXR0YWNoRXZlbnQoamQoYi50b1N0cmluZygpKSxkKTtlbHNlIHRocm93IEVycm9yKFwiYWRkRXZlbnRMaXN0ZW5lciBhbmQgYXR0YWNoRXZlbnQgYXJlIHVuYXZhaWxhYmxlLlwiKTtiZCsrfX1cbmZ1bmN0aW9uIGlkKCl7dmFyIGE9a2QsYj1OYz9mdW5jdGlvbihjKXtyZXR1cm4gYS5jYWxsKGIuc3JjLGIubGlzdGVuZXIsYyl9OmZ1bmN0aW9uKGMpe2M9YS5jYWxsKGIuc3JjLGIubGlzdGVuZXIsYyk7aWYoIWMpcmV0dXJuIGN9O3JldHVybiBifWZ1bmN0aW9uIGRkKGEsYixjLGQsZSl7aWYoZmEoYikpZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspZGQoYSxiW2ZdLGMsZCxlKTtlbHNlIGM9ZWQoYyksYSYmYVtTY10/bGQoYSxiLGMscShkKT8hIWQuY2FwdHVyZTohIWQsZSk6Z2QoYSxiLGMsITAsZCxlKX1cbmZ1bmN0aW9uIEUoYSxiLGMsZCxlKXtpZihmYShiKSlmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKylFKGEsYltmXSxjLGQsZSk7ZWxzZShkPXEoZCk/ISFkLmNhcHR1cmU6ISFkLGM9ZWQoYyksYSYmYVtTY10pPyhhPWEudSxiPVN0cmluZyhiKS50b1N0cmluZygpLGIgaW4gYS5hJiYoZj1hLmFbYl0sYz1ZYyhmLGMsZCxlKSwtMTxjJiYoVmMoZltjXSksQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGYsYywxKSwwPT1mLmxlbmd0aCYmKGRlbGV0ZSBhLmFbYl0sYS5iLS0pKSkpOmEmJihhPWhkKGEpKSYmKGI9YS5hW2IudG9TdHJpbmcoKV0sYT0tMSxiJiYoYT1ZYyhiLGMsZCxlKSksKGM9LTE8YT9iW2FdOm51bGwpJiZtZChjKSl9XG5mdW5jdGlvbiBtZChhKXtpZihcIm51bWJlclwiIT10eXBlb2YgYSYmYSYmIWEubWEpe3ZhciBiPWEuc3JjO2lmKGImJmJbU2NdKVpjKGIudSxhKTtlbHNle3ZhciBjPWEudHlwZSxkPWEuYTtiLnJlbW92ZUV2ZW50TGlzdGVuZXI/Yi5yZW1vdmVFdmVudExpc3RlbmVyKGMsZCxhLmNhcHR1cmUpOmIuZGV0YWNoRXZlbnQmJmIuZGV0YWNoRXZlbnQoamQoYyksZCk7YmQtLTsoYz1oZChiKSk/KFpjKGMsYSksMD09Yy5iJiYoYy5zcmM9bnVsbCxiWyRjXT1udWxsKSk6VmMoYSl9fX1mdW5jdGlvbiBqZChhKXtyZXR1cm4gYSBpbiBhZD9hZFthXTphZFthXT1cIm9uXCIrYX1mdW5jdGlvbiBuZChhLGIsYyxkKXt2YXIgZT0hMDtpZihhPWhkKGEpKWlmKGI9YS5hW2IudG9TdHJpbmcoKV0pZm9yKGI9Yi5jb25jYXQoKSxhPTA7YTxiLmxlbmd0aDthKyspe3ZhciBmPWJbYV07ZiYmZi5jYXB0dXJlPT1jJiYhZi5tYSYmKGY9b2QoZixkKSxlPWUmJiExIT09Zil9cmV0dXJuIGV9XG5mdW5jdGlvbiBvZChhLGIpe3ZhciBjPWEubGlzdGVuZXIsZD1hLkxhfHxhLnNyYzthLkhhJiZtZChhKTtyZXR1cm4gYy5jYWxsKGQsYil9XG5mdW5jdGlvbiBrZChhLGIpe2lmKGEubWEpcmV0dXJuITA7aWYoIU5jKXtpZighYilhOntiPVtcIndpbmRvd1wiLFwiZXZlbnRcIl07Zm9yKHZhciBjPWssZD0wO2Q8Yi5sZW5ndGg7ZCsrKWlmKGM9Y1tiW2RdXSxudWxsPT1jKXtiPW51bGw7YnJlYWsgYX1iPWN9ZD1iO2I9bmV3IFFjKGQsdGhpcyk7Yz0hMDtpZighKDA+ZC5rZXlDb2RlfHx2b2lkIDAhPWQucmV0dXJuVmFsdWUpKXthOnt2YXIgZT0hMTtpZigwPT1kLmtleUNvZGUpdHJ5e2Qua2V5Q29kZT0tMTticmVhayBhfWNhdGNoKGcpe2U9ITB9aWYoZXx8dm9pZCAwPT1kLnJldHVyblZhbHVlKWQucmV0dXJuVmFsdWU9ITB9ZD1bXTtmb3IoZT1iLmI7ZTtlPWUucGFyZW50Tm9kZSlkLnB1c2goZSk7YT1hLnR5cGU7Zm9yKGU9ZC5sZW5ndGgtMTswPD1lO2UtLSl7Yi5iPWRbZV07dmFyIGY9bmQoZFtlXSxhLCEwLGIpO2M9YyYmZn1mb3IoZT0wO2U8ZC5sZW5ndGg7ZSsrKWIuYj1kW2VdLGY9bmQoZFtlXSxhLCExLGIpLGM9YyYmZn1yZXR1cm4gY31yZXR1cm4gb2QoYSxcbm5ldyBRYyhiLHRoaXMpKX1mdW5jdGlvbiBoZChhKXthPWFbJGNdO3JldHVybiBhIGluc3RhbmNlb2YgV2M/YTpudWxsfXZhciBwZD1cIl9fY2xvc3VyZV9ldmVudHNfZm5fXCIrKDFFOSpNYXRoLnJhbmRvbSgpPj4+MCk7ZnVuY3Rpb24gZWQoYSl7aWYocChhKSlyZXR1cm4gYTthW3BkXXx8KGFbcGRdPWZ1bmN0aW9uKGIpe3JldHVybiBhLmhhbmRsZUV2ZW50KGIpfSk7cmV0dXJuIGFbcGRdfTtmdW5jdGlvbiBGKCl7SWMuY2FsbCh0aGlzKTt0aGlzLnU9bmV3IFdjKHRoaXMpO3RoaXMuSWI9dGhpczt0aGlzLlJhPW51bGx9dChGLEljKTtGLnByb3RvdHlwZVtTY109ITA7Ri5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyxkKXtFKHRoaXMsYSxiLGMsZCl9O1xuZnVuY3Rpb24gRyhhLGIpe3ZhciBjLGQ9YS5SYTtpZihkKWZvcihjPVtdO2Q7ZD1kLlJhKWMucHVzaChkKTthPWEuSWI7ZD1iLnR5cGV8fGI7aWYobShiKSliPW5ldyBDKGIsYSk7ZWxzZSBpZihiIGluc3RhbmNlb2YgQyliLnRhcmdldD1iLnRhcmdldHx8YTtlbHNle3ZhciBlPWI7Yj1uZXcgQyhkLGEpO1dhKGIsZSl9ZT0hMDtpZihjKWZvcih2YXIgZj1jLmxlbmd0aC0xOzA8PWY7Zi0tKXt2YXIgZz1iLmI9Y1tmXTtlPXFkKGcsZCwhMCxiKSYmZX1nPWIuYj1hO2U9cWQoZyxkLCEwLGIpJiZlO2U9cWQoZyxkLCExLGIpJiZlO2lmKGMpZm9yKGY9MDtmPGMubGVuZ3RoO2YrKylnPWIuYj1jW2ZdLGU9cWQoZyxkLCExLGIpJiZlfVxuRi5wcm90b3R5cGUudGE9ZnVuY3Rpb24oKXtGLmliLnRhLmNhbGwodGhpcyk7aWYodGhpcy51KXt2YXIgYT10aGlzLnUsYj0wLGM7Zm9yKGMgaW4gYS5hKXtmb3IodmFyIGQ9YS5hW2NdLGU9MDtlPGQubGVuZ3RoO2UrKykrK2IsVmMoZFtlXSk7ZGVsZXRlIGEuYVtjXTthLmItLX19dGhpcy5SYT1udWxsfTtmdW5jdGlvbiBmZChhLGIsYyxkLGUpe1hjKGEudSxTdHJpbmcoYiksYywhMSxkLGUpfWZ1bmN0aW9uIGxkKGEsYixjLGQsZSl7WGMoYS51LFN0cmluZyhiKSxjLCEwLGQsZSl9ZnVuY3Rpb24gcWQoYSxiLGMsZCl7Yj1hLnUuYVtTdHJpbmcoYildO2lmKCFiKXJldHVybiEwO2I9Yi5jb25jYXQoKTtmb3IodmFyIGU9ITAsZj0wO2Y8Yi5sZW5ndGg7KytmKXt2YXIgZz1iW2ZdO2lmKGcmJiFnLm1hJiZnLmNhcHR1cmU9PWMpe3ZhciBsPWcubGlzdGVuZXIsbj1nLkxhfHxnLnNyYztnLkhhJiZaYyhhLnUsZyk7ZT0hMSE9PWwuY2FsbChuLGQpJiZlfX1yZXR1cm4gZSYmMCE9ZC5CYn07ZnVuY3Rpb24gcmQoYSxiLGMpe2lmKHAoYSkpYyYmKGE9cihhLGMpKTtlbHNlIGlmKGEmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuaGFuZGxlRXZlbnQpYT1yKGEuaGFuZGxlRXZlbnQsYSk7ZWxzZSB0aHJvdyBFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIik7cmV0dXJuIDIxNDc0ODM2NDc8TnVtYmVyKGIpPy0xOmsuc2V0VGltZW91dChhLGJ8fDApfWZ1bmN0aW9uIHNkKGEpe3ZhciBiPW51bGw7cmV0dXJuKG5ldyB6KGZ1bmN0aW9uKGMsZCl7Yj1yZChmdW5jdGlvbigpe2Modm9pZCAwKX0sYSk7LTE9PWImJmQoRXJyb3IoXCJGYWlsZWQgdG8gc2NoZWR1bGUgdGltZXIuXCIpKX0pKS5zKGZ1bmN0aW9uKGEpe2suY2xlYXJUaW1lb3V0KGIpO3Rocm93IGE7fSl9O2Z1bmN0aW9uIHRkKGEsYixjLGQsZSl7dGhpcy5yZXNldChhLGIsYyxkLGUpfXRkLnByb3RvdHlwZS5hPW51bGw7dmFyIHVkPTA7dGQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGEsYixjLGQsZSl7XCJudW1iZXJcIj09dHlwZW9mIGV8fHVkKys7ZHx8bmEoKTt0aGlzLmI9YjtkZWxldGUgdGhpcy5hfTtmdW5jdGlvbiB2ZChhKXt0aGlzLmY9YTt0aGlzLmI9dGhpcy5jPXRoaXMuYT1udWxsfWZ1bmN0aW9uIHdkKGEsYil7dGhpcy5uYW1lPWE7dGhpcy52YWx1ZT1ifXdkLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm5hbWV9O3ZhciB4ZD1uZXcgd2QoXCJTRVZFUkVcIiwxRTMpLHlkPW5ldyB3ZChcIkNPTkZJR1wiLDcwMCksemQ9bmV3IHdkKFwiRklORVwiLDUwMCk7ZnVuY3Rpb24gQWQoYSl7aWYoYS5jKXJldHVybiBhLmM7aWYoYS5hKXJldHVybiBBZChhLmEpO0FhKFwiUm9vdCBsb2dnZXIgaGFzIG5vIGxldmVsIHNldC5cIik7cmV0dXJuIG51bGx9XG52ZC5wcm90b3R5cGUubG9nPWZ1bmN0aW9uKGEsYixjKXtpZihhLnZhbHVlPj1BZCh0aGlzKS52YWx1ZSlmb3IocChiKSYmKGI9YigpKSxhPW5ldyB0ZChhLFN0cmluZyhiKSx0aGlzLmYpLGMmJihhLmE9YyksYz1cImxvZzpcIithLmIsKGE9ay5jb25zb2xlKSYmYS50aW1lU3RhbXAmJmEudGltZVN0YW1wKGMpLChhPWsubXNXcml0ZVByb2ZpbGVyTWFyaykmJmEoYyksYz10aGlzO2M7KWM9Yy5hfTt2YXIgQmQ9e30sQ2Q9bnVsbDtmdW5jdGlvbiBEZChhKXtDZHx8KENkPW5ldyB2ZChcIlwiKSxCZFtcIlwiXT1DZCxDZC5jPXlkKTt2YXIgYjtpZighKGI9QmRbYV0pKXtiPW5ldyB2ZChhKTt2YXIgYz1hLmxhc3RJbmRleE9mKFwiLlwiKSxkPWEuc3Vic3RyKGMrMSk7Yz1EZChhLnN1YnN0cigwLGMpKTtjLmJ8fChjLmI9e30pO2MuYltkXT1iO2IuYT1jO0JkW2FdPWJ9cmV0dXJuIGJ9O2Z1bmN0aW9uIEVkKGEsYil7dGhpcy5iPXt9O3RoaXMuYT1bXTt0aGlzLmM9MDt2YXIgYz1hcmd1bWVudHMubGVuZ3RoO2lmKDE8Yyl7aWYoYyUyKXRocm93IEVycm9yKFwiVW5ldmVuIG51bWJlciBvZiBhcmd1bWVudHNcIik7Zm9yKHZhciBkPTA7ZDxjO2QrPTIpdGhpcy5zZXQoYXJndW1lbnRzW2RdLGFyZ3VtZW50c1tkKzFdKX1lbHNlIGlmKGEpe2EgaW5zdGFuY2VvZiBFZD8oYz1hLlMoKSxkPWEuUCgpKTooYz1SYShhKSxkPVFhKGEpKTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyl0aGlzLnNldChjW2VdLGRbZV0pfX1oPUVkLnByb3RvdHlwZTtoLlA9ZnVuY3Rpb24oKXtGZCh0aGlzKTtmb3IodmFyIGE9W10sYj0wO2I8dGhpcy5hLmxlbmd0aDtiKyspYS5wdXNoKHRoaXMuYlt0aGlzLmFbYl1dKTtyZXR1cm4gYX07aC5TPWZ1bmN0aW9uKCl7RmQodGhpcyk7cmV0dXJuIHRoaXMuYS5jb25jYXQoKX07XG5oLmNsZWFyPWZ1bmN0aW9uKCl7dGhpcy5iPXt9O3RoaXMuYz10aGlzLmEubGVuZ3RoPTB9O2Z1bmN0aW9uIEZkKGEpe2lmKGEuYyE9YS5hLmxlbmd0aCl7Zm9yKHZhciBiPTAsYz0wO2I8YS5hLmxlbmd0aDspe3ZhciBkPWEuYVtiXTtHZChhLmIsZCkmJihhLmFbYysrXT1kKTtiKyt9YS5hLmxlbmd0aD1jfWlmKGEuYyE9YS5hLmxlbmd0aCl7dmFyIGU9e307Zm9yKGM9Yj0wO2I8YS5hLmxlbmd0aDspZD1hLmFbYl0sR2QoZSxkKXx8KGEuYVtjKytdPWQsZVtkXT0xKSxiKys7YS5hLmxlbmd0aD1jfX1oLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiBHZCh0aGlzLmIsYSk/dGhpcy5iW2FdOmJ9O2guc2V0PWZ1bmN0aW9uKGEsYil7R2QodGhpcy5iLGEpfHwodGhpcy5jKyssdGhpcy5hLnB1c2goYSkpO3RoaXMuYlthXT1ifTtcbmguZm9yRWFjaD1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz10aGlzLlMoKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj10aGlzLmdldChlKTthLmNhbGwoYixmLGUsdGhpcyl9fTtmdW5jdGlvbiBHZChhLGIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxiKX07ZnVuY3Rpb24gSChhLGIpe2EmJmEubG9nKHpkLGIsdm9pZCAwKX07ZnVuY3Rpb24gSGQoYSl7cmV0dXJuIERhKGEsZnVuY3Rpb24oYSl7YT1hLnRvU3RyaW5nKDE2KTtyZXR1cm4gMTxhLmxlbmd0aD9hOlwiMFwiK2F9KS5qb2luKFwiXCIpfTt2YXIgSWQ9bnVsbCxKZD1udWxsO2Z1bmN0aW9uIEtkKGEpe3ZhciBiPVwiXCI7TGQoYSxmdW5jdGlvbihhKXtiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGEpfSk7cmV0dXJuIGJ9ZnVuY3Rpb24gTGQoYSxiKXtmdW5jdGlvbiBjKGIpe2Zvcig7ZDxhLmxlbmd0aDspe3ZhciBjPWEuY2hhckF0KGQrKyksZT1KZFtjXTtpZihudWxsIT1lKXJldHVybiBlO2lmKCEvXltcXHNcXHhhMF0qJC8udGVzdChjKSl0aHJvdyBFcnJvcihcIlVua25vd24gYmFzZTY0IGVuY29kaW5nIGF0IGNoYXI6IFwiK2MpO31yZXR1cm4gYn1NZCgpO2Zvcih2YXIgZD0wOzspe3ZhciBlPWMoLTEpLGY9YygwKSxnPWMoNjQpLGw9Yyg2NCk7aWYoNjQ9PT1sJiYtMT09PWUpYnJlYWs7YihlPDwyfGY+PjQpOzY0IT1nJiYoYihmPDw0JjI0MHxnPj4yKSw2NCE9bCYmYihnPDw2JjE5MnxsKSl9fVxuZnVuY3Rpb24gTWQoKXtpZighSWQpe0lkPXt9O0pkPXt9O2Zvcih2YXIgYT0wOzY1PmE7YSsrKUlkW2FdPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIi5jaGFyQXQoYSksSmRbSWRbYV1dPWEsNjI8PWEmJihKZFtcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8uXCIuY2hhckF0KGEpXT1hKX19Oy8qXG4gUG9ydGlvbnMgb2YgdGhpcyBjb2RlIGFyZSBmcm9tIE1vY2hpS2l0LCByZWNlaXZlZCBieVxuIFRoZSBDbG9zdXJlIEF1dGhvcnMgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBBbGwgb3RoZXIgY29kZSBpcyBDb3B5cmlnaHRcbiAyMDA1LTIwMDkgVGhlIENsb3N1cmUgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiovXG5mdW5jdGlvbiBOZChhLGIpe3RoaXMuZz1bXTt0aGlzLnY9YTt0aGlzLm89Ynx8bnVsbDt0aGlzLmY9dGhpcy5hPSExO3RoaXMuYz12b2lkIDA7dGhpcy51PXRoaXMudz10aGlzLmk9ITE7dGhpcy5oPTA7dGhpcy5iPW51bGw7dGhpcy5sPTB9TmQucHJvdG90eXBlLmNhbmNlbD1mdW5jdGlvbihhKXtpZih0aGlzLmEpdGhpcy5jIGluc3RhbmNlb2YgTmQmJnRoaXMuYy5jYW5jZWwoKTtlbHNle2lmKHRoaXMuYil7dmFyIGI9dGhpcy5iO2RlbGV0ZSB0aGlzLmI7YT9iLmNhbmNlbChhKTooYi5sLS0sMD49Yi5sJiZiLmNhbmNlbCgpKX10aGlzLnY/dGhpcy52LmNhbGwodGhpcy5vLHRoaXMpOnRoaXMudT0hMDt0aGlzLmF8fChhPW5ldyBPZCxQZCh0aGlzKSxRZCh0aGlzLCExLGEpKX19O05kLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEsYil7dGhpcy5pPSExO1FkKHRoaXMsYSxiKX07ZnVuY3Rpb24gUWQoYSxiLGMpe2EuYT0hMDthLmM9YzthLmY9IWI7UmQoYSl9XG5mdW5jdGlvbiBQZChhKXtpZihhLmEpe2lmKCFhLnUpdGhyb3cgbmV3IFNkO2EudT0hMX19TmQucHJvdG90eXBlLkE9ZnVuY3Rpb24oYSl7UGQodGhpcyk7UWQodGhpcywhMCxhKX07ZnVuY3Rpb24gVGQoYSxiKXtVZChhLG51bGwsYix2b2lkIDApfWZ1bmN0aW9uIFVkKGEsYixjLGQpe2EuZy5wdXNoKFtiLGMsZF0pO2EuYSYmUmQoYSl9TmQucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj1uZXcgeihmdW5jdGlvbihhLGIpe2Q9YTtlPWJ9KTtVZCh0aGlzLGQsZnVuY3Rpb24oYSl7YSBpbnN0YW5jZW9mIE9kP2YuY2FuY2VsKCk6ZShhKX0pO3JldHVybiBmLnRoZW4oYSxiLGMpfTttYihOZCk7ZnVuY3Rpb24gVmQoYSl7cmV0dXJuIEVhKGEuZyxmdW5jdGlvbihhKXtyZXR1cm4gcChhWzFdKX0pfVxuZnVuY3Rpb24gUmQoYSl7aWYoYS5oJiZhLmEmJlZkKGEpKXt2YXIgYj1hLmgsYz1XZFtiXTtjJiYoay5jbGVhclRpbWVvdXQoYy5hKSxkZWxldGUgV2RbYl0pO2EuaD0wfWEuYiYmKGEuYi5sLS0sZGVsZXRlIGEuYik7Yj1hLmM7Zm9yKHZhciBkPWM9ITE7YS5nLmxlbmd0aCYmIWEuaTspe3ZhciBlPWEuZy5zaGlmdCgpLGY9ZVswXSxnPWVbMV07ZT1lWzJdO2lmKGY9YS5mP2c6Zil0cnl7dmFyIGw9Zi5jYWxsKGV8fGEubyxiKTt2b2lkIDAhPT1sJiYoYS5mPWEuZiYmKGw9PWJ8fGwgaW5zdGFuY2VvZiBFcnJvciksYS5jPWI9bCk7aWYobmIoYil8fFwiZnVuY3Rpb25cIj09PXR5cGVvZiBrLlByb21pc2UmJmIgaW5zdGFuY2VvZiBrLlByb21pc2UpZD0hMCxhLmk9ITB9Y2F0Y2gobil7Yj1uLGEuZj0hMCxWZChhKXx8KGM9ITApfX1hLmM9YjtkJiYobD1yKGEubSxhLCEwKSxkPXIoYS5tLGEsITEpLGIgaW5zdGFuY2VvZiBOZD8oVWQoYixsLGQpLGIudz0hMCk6Yi50aGVuKGwsZCkpO2MmJihiPVxubmV3IFhkKGIpLFdkW2IuYV09YixhLmg9Yi5hKX1mdW5jdGlvbiBTZCgpe3UuY2FsbCh0aGlzKX10KFNkLHUpO1NkLnByb3RvdHlwZS5tZXNzYWdlPVwiRGVmZXJyZWQgaGFzIGFscmVhZHkgZmlyZWRcIjtTZC5wcm90b3R5cGUubmFtZT1cIkFscmVhZHlDYWxsZWRFcnJvclwiO2Z1bmN0aW9uIE9kKCl7dS5jYWxsKHRoaXMpfXQoT2QsdSk7T2QucHJvdG90eXBlLm1lc3NhZ2U9XCJEZWZlcnJlZCB3YXMgY2FuY2VsZWRcIjtPZC5wcm90b3R5cGUubmFtZT1cIkNhbmNlbGVkRXJyb3JcIjtmdW5jdGlvbiBYZChhKXt0aGlzLmE9ay5zZXRUaW1lb3V0KHIodGhpcy5jLHRoaXMpLDApO3RoaXMuYj1hfVhkLnByb3RvdHlwZS5jPWZ1bmN0aW9uKCl7ZGVsZXRlIFdkW3RoaXMuYV07dGhyb3cgdGhpcy5iO307dmFyIFdkPXt9O2Z1bmN0aW9uIFlkKCl7dGhpcy5iPS0xfTtmdW5jdGlvbiBaZChhLGIpe3RoaXMuYj0tMTt0aGlzLmI9JGQ7dGhpcy5mPWsuVWludDhBcnJheT9uZXcgVWludDhBcnJheSh0aGlzLmIpOkFycmF5KHRoaXMuYik7dGhpcy5nPXRoaXMuYz0wO3RoaXMuYT1bXTt0aGlzLmk9YTt0aGlzLmg9Yjt0aGlzLmw9ay5JbnQzMkFycmF5P25ldyBJbnQzMkFycmF5KDY0KTpBcnJheSg2NCk7YWV8fChrLkludDMyQXJyYXk/YWU9bmV3IEludDMyQXJyYXkoYmUpOmFlPWJlKTt0aGlzLnJlc2V0KCl9dmFyIGFlO3QoWmQsWWQpO2Zvcih2YXIgJGQ9NjQsY2U9JGQtMSxkZT1bXSxlZT0wO2VlPGNlO2VlKyspZGVbZWVdPTA7dmFyIGZlPUthKDEyOCxkZSk7WmQucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5nPXRoaXMuYz0wO3RoaXMuYT1rLkludDMyQXJyYXk/bmV3IEludDMyQXJyYXkodGhpcy5oKTpMYSh0aGlzLmgpfTtcbmZ1bmN0aW9uIGdlKGEpe2Zvcih2YXIgYj1hLmYsYz1hLmwsZD0wLGU9MDtlPGIubGVuZ3RoOyljW2QrK109YltlXTw8MjR8YltlKzFdPDwxNnxiW2UrMl08PDh8YltlKzNdLGU9NCpkO2ZvcihiPTE2OzY0PmI7YisrKXtlPWNbYi0xNV18MDtkPWNbYi0yXXwwO3ZhciBmPShjW2ItMTZdfDApKygoZT4+Pjd8ZTw8MjUpXihlPj4+MTh8ZTw8MTQpXmU+Pj4zKXwwLGc9KGNbYi03XXwwKSsoKGQ+Pj4xN3xkPDwxNSleKGQ+Pj4xOXxkPDwxMyleZD4+PjEwKXwwO2NbYl09ZitnfDB9ZD1hLmFbMF18MDtlPWEuYVsxXXwwO3ZhciBsPWEuYVsyXXwwLG49YS5hWzNdfDAsRD1hLmFbNF18MCx2Yj1hLmFbNV18MCx0Yz1hLmFbNl18MDtmPWEuYVs3XXwwO2ZvcihiPTA7NjQ+YjtiKyspe3ZhciBCaj0oKGQ+Pj4yfGQ8PDMwKV4oZD4+PjEzfGQ8PDE5KV4oZD4+PjIyfGQ8PDEwKSkrKGQmZV5kJmxeZSZsKXwwO2c9RCZ2Yl5+RCZ0YztmPWYrKChEPj4+NnxEPDwyNileKEQ+Pj4xMXxEPDwyMSleKEQ+Pj5cbjI1fEQ8PDcpKXwwO2c9ZysoYWVbYl18MCl8MDtnPWYrKGcrKGNbYl18MCl8MCl8MDtmPXRjO3RjPXZiO3ZiPUQ7RD1uK2d8MDtuPWw7bD1lO2U9ZDtkPWcrQmp8MH1hLmFbMF09YS5hWzBdK2R8MDthLmFbMV09YS5hWzFdK2V8MDthLmFbMl09YS5hWzJdK2x8MDthLmFbM109YS5hWzNdK258MDthLmFbNF09YS5hWzRdK0R8MDthLmFbNV09YS5hWzVdK3ZifDA7YS5hWzZdPWEuYVs2XSt0Y3wwO2EuYVs3XT1hLmFbN10rZnwwfVxuZnVuY3Rpb24gaGUoYSxiLGMpe3ZvaWQgMD09PWMmJihjPWIubGVuZ3RoKTt2YXIgZD0wLGU9YS5jO2lmKG0oYikpZm9yKDtkPGM7KWEuZltlKytdPWIuY2hhckNvZGVBdChkKyspLGU9PWEuYiYmKGdlKGEpLGU9MCk7ZWxzZSBpZihoYShiKSlmb3IoO2Q8Yzspe3ZhciBmPWJbZCsrXTtpZighKFwibnVtYmVyXCI9PXR5cGVvZiBmJiYwPD1mJiYyNTU+PWYmJmY9PShmfDApKSl0aHJvdyBFcnJvcihcIm1lc3NhZ2UgbXVzdCBiZSBhIGJ5dGUgYXJyYXlcIik7YS5mW2UrK109ZjtlPT1hLmImJihnZShhKSxlPTApfWVsc2UgdGhyb3cgRXJyb3IoXCJtZXNzYWdlIG11c3QgYmUgc3RyaW5nIG9yIGFycmF5XCIpO2EuYz1lO2EuZys9Y31cbnZhciBiZT1bMTExNjM1MjQwOCwxODk5NDQ3NDQxLDMwNDkzMjM0NzEsMzkyMTAwOTU3Myw5NjE5ODcxNjMsMTUwODk3MDk5MywyNDUzNjM1NzQ4LDI4NzA3NjMyMjEsMzYyNDM4MTA4MCwzMTA1OTg0MDEsNjA3MjI1Mjc4LDE0MjY4ODE5ODcsMTkyNTA3ODM4OCwyMTYyMDc4MjA2LDI2MTQ4ODgxMDMsMzI0ODIyMjU4MCwzODM1MzkwNDAxLDQwMjIyMjQ3NzQsMjY0MzQ3MDc4LDYwNDgwNzYyOCw3NzAyNTU5ODMsMTI0OTE1MDEyMiwxNTU1MDgxNjkyLDE5OTYwNjQ5ODYsMjU1NDIyMDg4MiwyODIxODM0MzQ5LDI5NTI5OTY4MDgsMzIxMDMxMzY3MSwzMzM2NTcxODkxLDM1ODQ1Mjg3MTEsMTEzOTI2OTkzLDMzODI0MTg5NSw2NjYzMDcyMDUsNzczNTI5OTEyLDEyOTQ3NTczNzIsMTM5NjE4MjI5MSwxNjk1MTgzNzAwLDE5ODY2NjEwNTEsMjE3NzAyNjM1MCwyNDU2OTU2MDM3LDI3MzA0ODU5MjEsMjgyMDMwMjQxMSwzMjU5NzMwODAwLDMzNDU3NjQ3NzEsMzUxNjA2NTgxNywzNjAwMzUyODA0LFxuNDA5NDU3MTkwOSwyNzU0MjMzNDQsNDMwMjI3NzM0LDUwNjk0ODYxNiw2NTkwNjA1NTYsODgzOTk3ODc3LDk1ODEzOTU3MSwxMzIyODIyMjE4LDE1MzcwMDIwNjMsMTc0Nzg3Mzc3OSwxOTU1NTYyMjIyLDIwMjQxMDQ4MTUsMjIyNzczMDQ1MiwyMzYxODUyNDI0LDI0Mjg0MzY0NzQsMjc1NjczNDE4NywzMjA0MDMxNDc5LDMzMjkzMjUyOThdO2Z1bmN0aW9uIGllKCl7WmQuY2FsbCh0aGlzLDgsamUpfXQoaWUsWmQpO3ZhciBqZT1bMTc3OTAzMzcwMywzMTQ0MTM0Mjc3LDEwMTM5MDQyNDIsMjc3MzQ4MDc2MiwxMzU5ODkzMTE5LDI2MDA4MjI5MjQsNTI4NzM0NjM1LDE1NDE0NTkyMjVdO2Z1bmN0aW9uIGtlKGEpe2lmKGEuUCYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5QKXJldHVybiBhLlAoKTtpZihtKGEpKXJldHVybiBhLnNwbGl0KFwiXCIpO2lmKGhhKGEpKXtmb3IodmFyIGI9W10sYz1hLmxlbmd0aCxkPTA7ZDxjO2QrKyliLnB1c2goYVtkXSk7cmV0dXJuIGJ9cmV0dXJuIFFhKGEpfWZ1bmN0aW9uIGxlKGEpe2lmKGEuUyYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5TKXJldHVybiBhLlMoKTtpZighYS5QfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiBhLlApe2lmKGhhKGEpfHxtKGEpKXt2YXIgYj1bXTthPWEubGVuZ3RoO2Zvcih2YXIgYz0wO2M8YTtjKyspYi5wdXNoKGMpO3JldHVybiBifXJldHVybiBSYShhKX19XG5mdW5jdGlvbiBtZShhLGIpe2lmKGEuZm9yRWFjaCYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5mb3JFYWNoKWEuZm9yRWFjaChiLHZvaWQgMCk7ZWxzZSBpZihoYShhKXx8bShhKSl3KGEsYix2b2lkIDApO2Vsc2UgZm9yKHZhciBjPWxlKGEpLGQ9a2UoYSksZT1kLmxlbmd0aCxmPTA7ZjxlO2YrKyliLmNhbGwodm9pZCAwLGRbZl0sYyYmY1tmXSxhKX07dmFyIG5lPS9eKD86KFteOi8/Iy5dKyk6KT8oPzpcXC9cXC8oPzooW14vPyNdKilAKT8oW14vIz9dKj8pKD86OihbMC05XSspKT8oPz1bLyM/XXwkKSk/KFtePyNdKyk/KD86XFw/KFteI10qKSk/KD86IyhbXFxzXFxTXSopKT8kLztmdW5jdGlvbiBvZShhLGIpe2lmKGEpe2E9YS5zcGxpdChcIiZcIik7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBkPWFbY10uaW5kZXhPZihcIj1cIiksZT1udWxsO2lmKDA8PWQpe3ZhciBmPWFbY10uc3Vic3RyaW5nKDAsZCk7ZT1hW2NdLnN1YnN0cmluZyhkKzEpfWVsc2UgZj1hW2NdO2IoZixlP2RlY29kZVVSSUNvbXBvbmVudChlLnJlcGxhY2UoL1xcKy9nLFwiIFwiKSk6XCJcIil9fX07ZnVuY3Rpb24gcGUoYSxiKXt0aGlzLmI9dGhpcy5sPXRoaXMuYz1cIlwiO3RoaXMuaT1udWxsO3RoaXMuaD10aGlzLmc9XCJcIjt0aGlzLmY9ITE7aWYoYSBpbnN0YW5jZW9mIHBlKXt0aGlzLmY9dm9pZCAwIT09Yj9iOmEuZjtxZSh0aGlzLGEuYyk7dGhpcy5sPWEubDt0aGlzLmI9YS5iO3JlKHRoaXMsYS5pKTt0aGlzLmc9YS5nO2I9YS5hO3ZhciBjPW5ldyBzZTtjLmM9Yi5jO2IuYSYmKGMuYT1uZXcgRWQoYi5hKSxjLmI9Yi5iKTt0ZSh0aGlzLGMpO3RoaXMuaD1hLmh9ZWxzZSBhJiYoYz1TdHJpbmcoYSkubWF0Y2gobmUpKT8odGhpcy5mPSEhYixxZSh0aGlzLGNbMV18fFwiXCIsITApLHRoaXMubD11ZShjWzJdfHxcIlwiKSx0aGlzLmI9dWUoY1szXXx8XCJcIiwhMCkscmUodGhpcyxjWzRdKSx0aGlzLmc9dWUoY1s1XXx8XCJcIiwhMCksdGUodGhpcyxjWzZdfHxcIlwiLCEwKSx0aGlzLmg9dWUoY1s3XXx8XCJcIikpOih0aGlzLmY9ISFiLHRoaXMuYT1uZXcgc2UobnVsbCwwLHRoaXMuZikpfVxucGUucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9W10sYj10aGlzLmM7YiYmYS5wdXNoKHZlKGIsd2UsITApLFwiOlwiKTt2YXIgYz10aGlzLmI7aWYoY3x8XCJmaWxlXCI9PWIpYS5wdXNoKFwiLy9cIiksKGI9dGhpcy5sKSYmYS5wdXNoKHZlKGIsd2UsITApLFwiQFwiKSxhLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjKSkucmVwbGFjZSgvJTI1KFswLTlhLWZBLUZdezJ9KS9nLFwiJSQxXCIpKSxjPXRoaXMuaSxudWxsIT1jJiZhLnB1c2goXCI6XCIsU3RyaW5nKGMpKTtpZihjPXRoaXMuZyl0aGlzLmImJlwiL1wiIT1jLmNoYXJBdCgwKSYmYS5wdXNoKFwiL1wiKSxhLnB1c2godmUoYyxcIi9cIj09Yy5jaGFyQXQoMCk/eGU6eWUsITApKTsoYz10aGlzLmEudG9TdHJpbmcoKSkmJmEucHVzaChcIj9cIixjKTsoYz10aGlzLmgpJiZhLnB1c2goXCIjXCIsdmUoYyx6ZSkpO3JldHVybiBhLmpvaW4oXCJcIil9O1xuZnVuY3Rpb24gcWUoYSxiLGMpe2EuYz1jP3VlKGIsITApOmI7YS5jJiYoYS5jPWEuYy5yZXBsYWNlKC86JC8sXCJcIikpfWZ1bmN0aW9uIHJlKGEsYil7aWYoYil7Yj1OdW1iZXIoYik7aWYoaXNOYU4oYil8fDA+Yil0aHJvdyBFcnJvcihcIkJhZCBwb3J0IG51bWJlciBcIitiKTthLmk9Yn1lbHNlIGEuaT1udWxsfWZ1bmN0aW9uIHRlKGEsYixjKXtiIGluc3RhbmNlb2Ygc2U/KGEuYT1iLEFlKGEuYSxhLmYpKTooY3x8KGI9dmUoYixCZSkpLGEuYT1uZXcgc2UoYiwwLGEuZikpfWZ1bmN0aW9uIEkoYSxiLGMpe2EuYS5zZXQoYixjKX1mdW5jdGlvbiBDZShhLGIpe3JldHVybiBhLmEuZ2V0KGIpfWZ1bmN0aW9uIERlKGEpe3JldHVybiBhIGluc3RhbmNlb2YgcGU/bmV3IHBlKGEpOm5ldyBwZShhLHZvaWQgMCl9ZnVuY3Rpb24gRWUoYSxiKXt2YXIgYz1uZXcgcGUobnVsbCx2b2lkIDApO3FlKGMsXCJodHRwc1wiKTthJiYoYy5iPWEpO2ImJihjLmc9Yik7cmV0dXJuIGN9XG5mdW5jdGlvbiB1ZShhLGIpe3JldHVybiBhP2I/ZGVjb2RlVVJJKGEucmVwbGFjZSgvJTI1L2csXCIlMjUyNVwiKSk6ZGVjb2RlVVJJQ29tcG9uZW50KGEpOlwiXCJ9ZnVuY3Rpb24gdmUoYSxiLGMpe3JldHVybiBtKGEpPyhhPWVuY29kZVVSSShhKS5yZXBsYWNlKGIsRmUpLGMmJihhPWEucmVwbGFjZSgvJTI1KFswLTlhLWZBLUZdezJ9KS9nLFwiJSQxXCIpKSxhKTpudWxsfWZ1bmN0aW9uIEZlKGEpe2E9YS5jaGFyQ29kZUF0KDApO3JldHVyblwiJVwiKyhhPj40JjE1KS50b1N0cmluZygxNikrKGEmMTUpLnRvU3RyaW5nKDE2KX12YXIgd2U9L1sjXFwvXFw/QF0vZyx5ZT0vW1xcI1xcPzpdL2cseGU9L1tcXCNcXD9dL2csQmU9L1tcXCNcXD9AXS9nLHplPS8jL2c7ZnVuY3Rpb24gc2UoYSxiLGMpe3RoaXMuYj10aGlzLmE9bnVsbDt0aGlzLmM9YXx8bnVsbDt0aGlzLmY9ISFjfVxuZnVuY3Rpb24gR2UoYSl7YS5hfHwoYS5hPW5ldyBFZCxhLmI9MCxhLmMmJm9lKGEuYyxmdW5jdGlvbihiLGMpe0hlKGEsZGVjb2RlVVJJQ29tcG9uZW50KGIucmVwbGFjZSgvXFwrL2csXCIgXCIpKSxjKX0pKX1mdW5jdGlvbiBJZShhKXt2YXIgYj1sZShhKTtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgYil0aHJvdyBFcnJvcihcIktleXMgYXJlIHVuZGVmaW5lZFwiKTt2YXIgYz1uZXcgc2UobnVsbCwwLHZvaWQgMCk7YT1rZShhKTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXSxmPWFbZF07ZmEoZik/SmUoYyxlLGYpOkhlKGMsZSxmKX1yZXR1cm4gY31mdW5jdGlvbiBIZShhLGIsYyl7R2UoYSk7YS5jPW51bGw7Yj1LZShhLGIpO3ZhciBkPWEuYS5nZXQoYik7ZHx8YS5hLnNldChiLGQ9W10pO2QucHVzaChjKTthLmIrPTF9XG5mdW5jdGlvbiBMZShhLGIpe0dlKGEpO2I9S2UoYSxiKTtHZChhLmEuYixiKSYmKGEuYz1udWxsLGEuYi09YS5hLmdldChiKS5sZW5ndGgsYT1hLmEsR2QoYS5iLGIpJiYoZGVsZXRlIGEuYltiXSxhLmMtLSxhLmEubGVuZ3RoPjIqYS5jJiZGZChhKSkpfWg9c2UucHJvdG90eXBlO2guY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmE9dGhpcy5jPW51bGw7dGhpcy5iPTB9O2Z1bmN0aW9uIE1lKGEsYil7R2UoYSk7Yj1LZShhLGIpO3JldHVybiBHZChhLmEuYixiKX1oLmZvckVhY2g9ZnVuY3Rpb24oYSxiKXtHZSh0aGlzKTt0aGlzLmEuZm9yRWFjaChmdW5jdGlvbihjLGQpe3coYyxmdW5jdGlvbihjKXthLmNhbGwoYixjLGQsdGhpcyl9LHRoaXMpfSx0aGlzKX07aC5TPWZ1bmN0aW9uKCl7R2UodGhpcyk7Zm9yKHZhciBhPXRoaXMuYS5QKCksYj10aGlzLmEuUygpLGM9W10sZD0wO2Q8Yi5sZW5ndGg7ZCsrKWZvcih2YXIgZT1hW2RdLGY9MDtmPGUubGVuZ3RoO2YrKyljLnB1c2goYltkXSk7cmV0dXJuIGN9O1xuaC5QPWZ1bmN0aW9uKGEpe0dlKHRoaXMpO3ZhciBiPVtdO2lmKG0oYSkpTWUodGhpcyxhKSYmKGI9S2EoYix0aGlzLmEuZ2V0KEtlKHRoaXMsYSkpKSk7ZWxzZXthPXRoaXMuYS5QKCk7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYj1LYShiLGFbY10pfXJldHVybiBifTtoLnNldD1mdW5jdGlvbihhLGIpe0dlKHRoaXMpO3RoaXMuYz1udWxsO2E9S2UodGhpcyxhKTtNZSh0aGlzLGEpJiYodGhpcy5iLT10aGlzLmEuZ2V0KGEpLmxlbmd0aCk7dGhpcy5hLnNldChhLFtiXSk7dGhpcy5iKz0xO3JldHVybiB0aGlzfTtoLmdldD1mdW5jdGlvbihhLGIpe2E9YT90aGlzLlAoYSk6W107cmV0dXJuIDA8YS5sZW5ndGg/U3RyaW5nKGFbMF0pOmJ9O2Z1bmN0aW9uIEplKGEsYixjKXtMZShhLGIpOzA8Yy5sZW5ndGgmJihhLmM9bnVsbCxhLmEuc2V0KEtlKGEsYiksTGEoYykpLGEuYis9Yy5sZW5ndGgpfVxuaC50b1N0cmluZz1mdW5jdGlvbigpe2lmKHRoaXMuYylyZXR1cm4gdGhpcy5jO2lmKCF0aGlzLmEpcmV0dXJuXCJcIjtmb3IodmFyIGE9W10sYj10aGlzLmEuUygpLGM9MDtjPGIubGVuZ3RoO2MrKyl7dmFyIGQ9YltjXSxlPWVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZCkpO2Q9dGhpcy5QKGQpO2Zvcih2YXIgZj0wO2Y8ZC5sZW5ndGg7ZisrKXt2YXIgZz1lO1wiXCIhPT1kW2ZdJiYoZys9XCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkW2ZdKSkpO2EucHVzaChnKX19cmV0dXJuIHRoaXMuYz1hLmpvaW4oXCImXCIpfTtmdW5jdGlvbiBLZShhLGIpe2I9U3RyaW5nKGIpO2EuZiYmKGI9Yi50b0xvd2VyQ2FzZSgpKTtyZXR1cm4gYn1mdW5jdGlvbiBBZShhLGIpe2ImJiFhLmYmJihHZShhKSxhLmM9bnVsbCxhLmEuZm9yRWFjaChmdW5jdGlvbihhLGIpe3ZhciBjPWIudG9Mb3dlckNhc2UoKTtiIT1jJiYoTGUodGhpcyxiKSxKZSh0aGlzLGMsYSkpfSxhKSk7YS5mPWJ9O2Z1bmN0aW9uIE5lKCl7fU5lLnByb3RvdHlwZS5jPW51bGw7ZnVuY3Rpb24gT2UoYSl7cmV0dXJuIGEuY3x8KGEuYz1hLmIoKSl9O3ZhciBQZTtmdW5jdGlvbiBRZSgpe310KFFlLE5lKTtRZS5wcm90b3R5cGUuYT1mdW5jdGlvbigpe3ZhciBhPVJlKHRoaXMpO3JldHVybiBhP25ldyBBY3RpdmVYT2JqZWN0KGEpOm5ldyBYTUxIdHRwUmVxdWVzdH07UWUucHJvdG90eXBlLmI9ZnVuY3Rpb24oKXt2YXIgYT17fTtSZSh0aGlzKSYmKGFbMF09ITAsYVsxXT0hMCk7cmV0dXJuIGF9O1xuZnVuY3Rpb24gUmUoYSl7aWYoIWEuZiYmXCJ1bmRlZmluZWRcIj09dHlwZW9mIFhNTEh0dHBSZXF1ZXN0JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgQWN0aXZlWE9iamVjdCl7Zm9yKHZhciBiPVtcIk1TWE1MMi5YTUxIVFRQLjYuMFwiLFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIsXCJNU1hNTDIuWE1MSFRUUFwiLFwiTWljcm9zb2Z0LlhNTEhUVFBcIl0sYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1iW2NdO3RyeXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoZCksYS5mPWR9Y2F0Y2goZSl7fX10aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgQWN0aXZlWE9iamVjdC4gQWN0aXZlWCBtaWdodCBiZSBkaXNhYmxlZCwgb3IgTVNYTUwgbWlnaHQgbm90IGJlIGluc3RhbGxlZFwiKTt9cmV0dXJuIGEuZn1QZT1uZXcgUWU7ZnVuY3Rpb24gU2UoYSl7Ri5jYWxsKHRoaXMpO3RoaXMuaGVhZGVycz1uZXcgRWQ7dGhpcy53PWF8fG51bGw7dGhpcy5iPSExO3RoaXMudj10aGlzLmE9bnVsbDt0aGlzLmc9dGhpcy5JPXRoaXMuaT1cIlwiO3RoaXMuYz10aGlzLkc9dGhpcy5oPXRoaXMuQT0hMTt0aGlzLmY9MDt0aGlzLm09bnVsbDt0aGlzLmw9VGU7dGhpcy5vPXRoaXMuTj0hMX10KFNlLEYpO3ZhciBUZT1cIlwiLFVlPVNlLnByb3RvdHlwZSxWZT1EZChcImdvb2cubmV0LlhocklvXCIpO1VlLko9VmU7dmFyIFdlPS9eaHR0cHM/JC9pLFhlPVtcIlBPU1RcIixcIlBVVFwiXTtcbmZ1bmN0aW9uIFllKGEsYixjLGQsZSl7aWYoYS5hKXRocm93IEVycm9yKFwiW2dvb2cubmV0LlhocklvXSBPYmplY3QgaXMgYWN0aXZlIHdpdGggYW5vdGhlciByZXF1ZXN0PVwiK2EuaStcIjsgbmV3VXJpPVwiK2IpO2M9Yz9jLnRvVXBwZXJDYXNlKCk6XCJHRVRcIjthLmk9YjthLmc9XCJcIjthLkk9YzthLkE9ITE7YS5iPSEwO2EuYT1hLnc/YS53LmEoKTpQZS5hKCk7YS52PWEudz9PZShhLncpOk9lKFBlKTthLmEub25yZWFkeXN0YXRlY2hhbmdlPXIoYS5BYixhKTt0cnl7SChhLkosWmUoYSxcIk9wZW5pbmcgWGhyXCIpKSxhLkc9ITAsYS5hLm9wZW4oYyxTdHJpbmcoYiksITApLGEuRz0hMX1jYXRjaChnKXtIKGEuSixaZShhLFwiRXJyb3Igb3BlbmluZyBYaHI6IFwiK2cubWVzc2FnZSkpOyRlKGEsZyk7cmV0dXJufWI9ZHx8XCJcIjt2YXIgZj1uZXcgRWQoYS5oZWFkZXJzKTtlJiZtZShlLGZ1bmN0aW9uKGEsYil7Zi5zZXQoYixhKX0pO2U9RmEoZi5TKCkpO2Q9ay5Gb3JtRGF0YSYmYiBpbnN0YW5jZW9mXG5rLkZvcm1EYXRhOyFIYShYZSxjKXx8ZXx8ZHx8Zi5zZXQoXCJDb250ZW50LVR5cGVcIixcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04XCIpO2YuZm9yRWFjaChmdW5jdGlvbihhLGIpe3RoaXMuYS5zZXRSZXF1ZXN0SGVhZGVyKGIsYSl9LGEpO2EubCYmKGEuYS5yZXNwb25zZVR5cGU9YS5sKTtcIndpdGhDcmVkZW50aWFsc1wiaW4gYS5hJiZhLmEud2l0aENyZWRlbnRpYWxzIT09YS5OJiYoYS5hLndpdGhDcmVkZW50aWFscz1hLk4pO3RyeXthZihhKSwwPGEuZiYmKGEubz1iZihhLmEpLEgoYS5KLFplKGEsXCJXaWxsIGFib3J0IGFmdGVyIFwiK2EuZitcIm1zIGlmIGluY29tcGxldGUsIHhocjIgXCIrYS5vKSksYS5vPyhhLmEudGltZW91dD1hLmYsYS5hLm9udGltZW91dD1yKGEuRWEsYSkpOmEubT1yZChhLkVhLGEuZixhKSksSChhLkosWmUoYSxcIlNlbmRpbmcgcmVxdWVzdFwiKSksYS5oPSEwLGEuYS5zZW5kKGIpLGEuaD0hMX1jYXRjaChnKXtIKGEuSixaZShhLFxuXCJTZW5kIGVycm9yOiBcIitnLm1lc3NhZ2UpKSwkZShhLGcpfX1mdW5jdGlvbiBiZihhKXtyZXR1cm4geSYmamIoOSkmJlwibnVtYmVyXCI9PXR5cGVvZiBhLnRpbWVvdXQmJnZvaWQgMCE9PWEub250aW1lb3V0fWZ1bmN0aW9uIEdhKGEpe3JldHVyblwiY29udGVudC10eXBlXCI9PWEudG9Mb3dlckNhc2UoKX1oPVNlLnByb3RvdHlwZTtoLkVhPWZ1bmN0aW9uKCl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGFhJiZ0aGlzLmEmJih0aGlzLmc9XCJUaW1lZCBvdXQgYWZ0ZXIgXCIrdGhpcy5mK1wibXMsIGFib3J0aW5nXCIsSCh0aGlzLkosWmUodGhpcyx0aGlzLmcpKSxHKHRoaXMsXCJ0aW1lb3V0XCIpLHRoaXMuYWJvcnQoOCkpfTtmdW5jdGlvbiAkZShhLGIpe2EuYj0hMTthLmEmJihhLmM9ITAsYS5hLmFib3J0KCksYS5jPSExKTthLmc9YjtjZihhKTtkZihhKX1mdW5jdGlvbiBjZihhKXthLkF8fChhLkE9ITAsRyhhLFwiY29tcGxldGVcIiksRyhhLFwiZXJyb3JcIikpfVxuaC5hYm9ydD1mdW5jdGlvbigpe3RoaXMuYSYmdGhpcy5iJiYoSCh0aGlzLkosWmUodGhpcyxcIkFib3J0aW5nXCIpKSx0aGlzLmI9ITEsdGhpcy5jPSEwLHRoaXMuYS5hYm9ydCgpLHRoaXMuYz0hMSxHKHRoaXMsXCJjb21wbGV0ZVwiKSxHKHRoaXMsXCJhYm9ydFwiKSxkZih0aGlzKSl9O2gudGE9ZnVuY3Rpb24oKXt0aGlzLmEmJih0aGlzLmImJih0aGlzLmI9ITEsdGhpcy5jPSEwLHRoaXMuYS5hYm9ydCgpLHRoaXMuYz0hMSksZGYodGhpcywhMCkpO1NlLmliLnRhLmNhbGwodGhpcyl9O2guQWI9ZnVuY3Rpb24oKXt0aGlzLm9hfHwodGhpcy5HfHx0aGlzLmh8fHRoaXMuYz9lZih0aGlzKTp0aGlzLmpjKCkpfTtoLmpjPWZ1bmN0aW9uKCl7ZWYodGhpcyl9O1xuZnVuY3Rpb24gZWYoYSl7aWYoYS5iJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYWEpaWYoYS52WzFdJiY0PT1mZihhKSYmMj09Z2YoYSkpSChhLkosWmUoYSxcIkxvY2FsIHJlcXVlc3QgZXJyb3IgZGV0ZWN0ZWQgYW5kIGlnbm9yZWRcIikpO2Vsc2UgaWYoYS5oJiY0PT1mZihhKSlyZChhLkFiLDAsYSk7ZWxzZSBpZihHKGEsXCJyZWFkeXN0YXRlY2hhbmdlXCIpLDQ9PWZmKGEpKXtIKGEuSixaZShhLFwiUmVxdWVzdCBjb21wbGV0ZVwiKSk7YS5iPSExO3RyeXt2YXIgYj1nZihhKTthOnN3aXRjaChiKXtjYXNlIDIwMDpjYXNlIDIwMTpjYXNlIDIwMjpjYXNlIDIwNDpjYXNlIDIwNjpjYXNlIDMwNDpjYXNlIDEyMjM6dmFyIGM9ITA7YnJlYWsgYTtkZWZhdWx0OmM9ITF9dmFyIGQ7aWYoIShkPWMpKXt2YXIgZTtpZihlPTA9PT1iKXt2YXIgZj1TdHJpbmcoYS5pKS5tYXRjaChuZSlbMV18fG51bGw7aWYoIWYmJmsuc2VsZiYmay5zZWxmLmxvY2F0aW9uKXt2YXIgZz1rLnNlbGYubG9jYXRpb24ucHJvdG9jb2w7XG5mPWcuc3Vic3RyKDAsZy5sZW5ndGgtMSl9ZT0hV2UudGVzdChmP2YudG9Mb3dlckNhc2UoKTpcIlwiKX1kPWV9aWYoZClHKGEsXCJjb21wbGV0ZVwiKSxHKGEsXCJzdWNjZXNzXCIpO2Vsc2V7dHJ5e3ZhciBsPTI8ZmYoYSk/YS5hLnN0YXR1c1RleHQ6XCJcIn1jYXRjaChuKXtIKGEuSixcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIrbi5tZXNzYWdlKSxsPVwiXCJ9YS5nPWwrXCIgW1wiK2dmKGEpK1wiXVwiO2NmKGEpfX1maW5hbGx5e2RmKGEpfX19ZnVuY3Rpb24gZGYoYSxiKXtpZihhLmEpe2FmKGEpO3ZhciBjPWEuYSxkPWEudlswXT9jYTpudWxsO2EuYT1udWxsO2Eudj1udWxsO2J8fEcoYSxcInJlYWR5XCIpO3RyeXtjLm9ucmVhZHlzdGF0ZWNoYW5nZT1kfWNhdGNoKGUpeyhhPWEuSikmJmEubG9nKHhkLFwiUHJvYmxlbSBlbmNvdW50ZXJlZCByZXNldHRpbmcgb25yZWFkeXN0YXRlY2hhbmdlOiBcIitlLm1lc3NhZ2Usdm9pZCAwKX19fVxuZnVuY3Rpb24gYWYoYSl7YS5hJiZhLm8mJihhLmEub250aW1lb3V0PW51bGwpO1wibnVtYmVyXCI9PXR5cGVvZiBhLm0mJihrLmNsZWFyVGltZW91dChhLm0pLGEubT1udWxsKX1mdW5jdGlvbiBmZihhKXtyZXR1cm4gYS5hP2EuYS5yZWFkeVN0YXRlOjB9ZnVuY3Rpb24gZ2YoYSl7dHJ5e3JldHVybiAyPGZmKGEpP2EuYS5zdGF0dXM6LTF9Y2F0Y2goYil7cmV0dXJuLTF9fWZ1bmN0aW9uIGhmKGEpe3RyeXtyZXR1cm4gYS5hP2EuYS5yZXNwb25zZVRleHQ6XCJcIn1jYXRjaChiKXtyZXR1cm4gSChhLkosXCJDYW4gbm90IGdldCByZXNwb25zZVRleHQ6IFwiK2IubWVzc2FnZSksXCJcIn19XG5oLmdldFJlc3BvbnNlPWZ1bmN0aW9uKCl7dHJ5e2lmKCF0aGlzLmEpcmV0dXJuIG51bGw7aWYoXCJyZXNwb25zZVwiaW4gdGhpcy5hKXJldHVybiB0aGlzLmEucmVzcG9uc2U7c3dpdGNoKHRoaXMubCl7Y2FzZSBUZTpjYXNlIFwidGV4dFwiOnJldHVybiB0aGlzLmEucmVzcG9uc2VUZXh0O2Nhc2UgXCJhcnJheWJ1ZmZlclwiOmlmKFwibW96UmVzcG9uc2VBcnJheUJ1ZmZlclwiaW4gdGhpcy5hKXJldHVybiB0aGlzLmEubW96UmVzcG9uc2VBcnJheUJ1ZmZlcn12YXIgYT10aGlzLko7YSYmYS5sb2coeGQsXCJSZXNwb25zZSB0eXBlIFwiK3RoaXMubCtcIiBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlclwiLHZvaWQgMCk7cmV0dXJuIG51bGx9Y2F0Y2goYil7cmV0dXJuIEgodGhpcy5KLFwiQ2FuIG5vdCBnZXQgcmVzcG9uc2U6IFwiK2IubWVzc2FnZSksbnVsbH19O2Z1bmN0aW9uIFplKGEsYil7cmV0dXJuIGIrXCIgW1wiK2EuSStcIiBcIithLmkrXCIgXCIrZ2YoYSkrXCJdXCJ9O3ZhciBqZj0vXlsrYS16QS1aMC05Xy4hIyQlJicqXFwvPT9eYHt8fX4tXStAKFthLXpBLVowLTktXStcXC4pK1thLXpBLVowLTldezIsNjN9JC87ZnVuY3Rpb24ga2YoYSl7dmFyIGI9e30sYz1iLmRvY3VtZW50fHxkb2N1bWVudCxkPWdjKGEpLGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIlNDUklQVFwiKSxmPXtDYjplLEVhOnZvaWQgMH0sZz1uZXcgTmQobGYsZiksbD1udWxsLG49bnVsbCE9Yi50aW1lb3V0P2IudGltZW91dDo1RTM7MDxuJiYobD13aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe21mKGUsITApO3ZhciBhPW5ldyBuZihvZixcIlRpbWVvdXQgcmVhY2hlZCBmb3IgbG9hZGluZyBzY3JpcHQgXCIrZCk7UGQoZyk7UWQoZywhMSxhKX0sbiksZi5FYT1sKTtlLm9ubG9hZD1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2UucmVhZHlTdGF0ZSYmXCJsb2FkZWRcIiE9ZS5yZWFkeVN0YXRlJiZcImNvbXBsZXRlXCIhPWUucmVhZHlTdGF0ZXx8KG1mKGUsYi5TY3x8ITEsbCksZy5BKG51bGwpKX07ZS5vbmVycm9yPWZ1bmN0aW9uKCl7bWYoZSwhMCxsKTt2YXIgYT1uZXcgbmYocGYsXCJFcnJvciB3aGlsZSBsb2FkaW5nIHNjcmlwdCBcIitcbmQpO1BkKGcpO1FkKGcsITEsYSl9O2Y9Yi5hdHRyaWJ1dGVzfHx7fTtXYShmLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCIsY2hhcnNldDpcIlVURi04XCJ9KTt4YyhlLGYpO2Uuc3JjPWdjKGEpO3FmKGMpLmFwcGVuZENoaWxkKGUpO3JldHVybiBnfWZ1bmN0aW9uIHFmKGEpe3ZhciBiO3JldHVybihiPShhfHxkb2N1bWVudCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJIRUFEXCIpKSYmMCE9Yi5sZW5ndGg/YlswXTphLmRvY3VtZW50RWxlbWVudH1mdW5jdGlvbiBsZigpe2lmKHRoaXMmJnRoaXMuQ2Ipe3ZhciBhPXRoaXMuQ2I7YSYmXCJTQ1JJUFRcIj09YS50YWdOYW1lJiZtZihhLCEwLHRoaXMuRWEpfX1cbmZ1bmN0aW9uIG1mKGEsYixjKXtudWxsIT1jJiZrLmNsZWFyVGltZW91dChjKTthLm9ubG9hZD1jYTthLm9uZXJyb3I9Y2E7YS5vbnJlYWR5c3RhdGVjaGFuZ2U9Y2E7YiYmd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXthJiZhLnBhcmVudE5vZGUmJmEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhKX0sMCl9dmFyIHBmPTAsb2Y9MTtmdW5jdGlvbiBuZihhLGIpe3ZhciBjPVwiSnNsb2FkZXIgZXJyb3IgKGNvZGUgI1wiK2ErXCIpXCI7YiYmKGMrPVwiOiBcIitiKTt1LmNhbGwodGhpcyxjKTt0aGlzLmNvZGU9YX10KG5mLHUpO2Z1bmN0aW9uIHJmKCl7fXQocmYsTmUpO3JmLnByb3RvdHlwZS5hPWZ1bmN0aW9uKCl7dmFyIGE9bmV3IFhNTEh0dHBSZXF1ZXN0O2lmKFwid2l0aENyZWRlbnRpYWxzXCJpbiBhKXJldHVybiBhO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBYRG9tYWluUmVxdWVzdClyZXR1cm4gbmV3IHNmO3Rocm93IEVycm9yKFwiVW5zdXBwb3J0ZWQgYnJvd3NlclwiKTt9O3JmLnByb3RvdHlwZS5iPWZ1bmN0aW9uKCl7cmV0dXJue319O1xuZnVuY3Rpb24gc2YoKXt0aGlzLmE9bmV3IFhEb21haW5SZXF1ZXN0O3RoaXMucmVhZHlTdGF0ZT0wO3RoaXMub25yZWFkeXN0YXRlY2hhbmdlPW51bGw7dGhpcy5yZXNwb25zZVRleHQ9XCJcIjt0aGlzLnN0YXR1cz0tMTt0aGlzLnN0YXR1c1RleHQ9dGhpcy5yZXNwb25zZVhNTD1udWxsO3RoaXMuYS5vbmxvYWQ9cih0aGlzLldiLHRoaXMpO3RoaXMuYS5vbmVycm9yPXIodGhpcy54Yix0aGlzKTt0aGlzLmEub25wcm9ncmVzcz1yKHRoaXMuWGIsdGhpcyk7dGhpcy5hLm9udGltZW91dD1yKHRoaXMuWWIsdGhpcyl9aD1zZi5wcm90b3R5cGU7aC5vcGVuPWZ1bmN0aW9uKGEsYixjKXtpZihudWxsIT1jJiYhYyl0aHJvdyBFcnJvcihcIk9ubHkgYXN5bmMgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZC5cIik7dGhpcy5hLm9wZW4oYSxiKX07XG5oLnNlbmQ9ZnVuY3Rpb24oYSl7aWYoYSlpZihcInN0cmluZ1wiPT10eXBlb2YgYSl0aGlzLmEuc2VuZChhKTtlbHNlIHRocm93IEVycm9yKFwiT25seSBzdHJpbmcgZGF0YSBpcyBzdXBwb3J0ZWRcIik7ZWxzZSB0aGlzLmEuc2VuZCgpfTtoLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5hLmFib3J0KCl9O2guc2V0UmVxdWVzdEhlYWRlcj1mdW5jdGlvbigpe307aC5nZXRSZXNwb25zZUhlYWRlcj1mdW5jdGlvbihhKXtyZXR1cm5cImNvbnRlbnQtdHlwZVwiPT1hLnRvTG93ZXJDYXNlKCk/dGhpcy5hLmNvbnRlbnRUeXBlOlwiXCJ9O2guV2I9ZnVuY3Rpb24oKXt0aGlzLnN0YXR1cz0yMDA7dGhpcy5yZXNwb25zZVRleHQ9dGhpcy5hLnJlc3BvbnNlVGV4dDt0Zih0aGlzLDQpfTtoLnhiPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXM9NTAwO3RoaXMucmVzcG9uc2VUZXh0PVwiXCI7dGYodGhpcyw0KX07aC5ZYj1mdW5jdGlvbigpe3RoaXMueGIoKX07XG5oLlhiPWZ1bmN0aW9uKCl7dGhpcy5zdGF0dXM9MjAwO3RmKHRoaXMsMSl9O2Z1bmN0aW9uIHRmKGEsYil7YS5yZWFkeVN0YXRlPWI7aWYoYS5vbnJlYWR5c3RhdGVjaGFuZ2UpYS5vbnJlYWR5c3RhdGVjaGFuZ2UoKX1oLmdldEFsbFJlc3BvbnNlSGVhZGVycz1mdW5jdGlvbigpe3JldHVyblwiY29udGVudC10eXBlOiBcIit0aGlzLmEuY29udGVudFR5cGV9O2Z1bmN0aW9uIHVmKCl7dmFyIGE9SigpO3JldHVybiB5JiYhIWtiJiYxMT09a2J8fC9FZGdlXFwvXFxkKy8udGVzdChhKX1mdW5jdGlvbiB2Zigpe3JldHVybiBrLndpbmRvdyYmay53aW5kb3cubG9jYXRpb24uaHJlZnx8XCJcIn1mdW5jdGlvbiB3ZihhLGIpe2I9Ynx8ay53aW5kb3c7dmFyIGM9XCJhYm91dDpibGFua1wiO2EmJihjPW5jKHBjKGEpKSk7Yi5sb2NhdGlvbi5ocmVmPWN9ZnVuY3Rpb24geGYoYSxiKXt2YXIgYz1bXSxkO2ZvcihkIGluIGEpZCBpbiBiP3R5cGVvZiBhW2RdIT10eXBlb2YgYltkXT9jLnB1c2goZCk6ZmEoYVtkXSk/VGEoYVtkXSxiW2RdKXx8Yy5wdXNoKGQpOlwib2JqZWN0XCI9PXR5cGVvZiBhW2RdJiZudWxsIT1hW2RdJiZudWxsIT1iW2RdPzA8eGYoYVtkXSxiW2RdKS5sZW5ndGgmJmMucHVzaChkKTphW2RdIT09YltkXSYmYy5wdXNoKGQpOmMucHVzaChkKTtmb3IoZCBpbiBiKWQgaW4gYXx8Yy5wdXNoKGQpO3JldHVybiBjfVxuZnVuY3Rpb24geWYoKXt2YXIgYT1KKCk7YT16ZihhKSE9QWY/bnVsbDooYT1hLm1hdGNoKC9cXHNDaHJvbWVcXC8oXFxkKykvaSkpJiYyPT1hLmxlbmd0aD9wYXJzZUludChhWzFdLDEwKTpudWxsO3JldHVybiBhJiYzMD5hPyExOiF5fHwha2J8fDk8a2J9ZnVuY3Rpb24gQmYoYSl7YT0oYXx8SigpKS50b0xvd2VyQ2FzZSgpO3JldHVybiBhLm1hdGNoKC9hbmRyb2lkLyl8fGEubWF0Y2goL3dlYm9zLyl8fGEubWF0Y2goL2lwaG9uZXxpcGFkfGlwb2QvKXx8YS5tYXRjaCgvYmxhY2tiZXJyeS8pfHxhLm1hdGNoKC93aW5kb3dzIHBob25lLyl8fGEubWF0Y2goL2llbW9iaWxlLyk/ITA6ITF9ZnVuY3Rpb24gQ2YoYSl7YT1hfHxrLndpbmRvdzt0cnl7YS5jbG9zZSgpfWNhdGNoKGIpe319XG5mdW5jdGlvbiBEZihhLGIsYyl7dmFyIGQ9TWF0aC5mbG9vcigxRTkqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtiPWJ8fDUwMDtjPWN8fDYwMDt2YXIgZT0od2luZG93LnNjcmVlbi5hdmFpbEhlaWdodC1jKS8yLGY9KHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aC1iKS8yO2I9e3dpZHRoOmIsaGVpZ2h0OmMsdG9wOjA8ZT9lOjAsbGVmdDowPGY/ZjowLGxvY2F0aW9uOiEwLHJlc2l6YWJsZTohMCxzdGF0dXNiYXI6ITAsdG9vbGJhcjohMX07Yz1KKCkudG9Mb3dlckNhc2UoKTtkJiYoYi50YXJnZXQ9ZCx2KGMsXCJjcmlvcy9cIikmJihiLnRhcmdldD1cIl9ibGFua1wiKSk7emYoSigpKT09RWYmJihhPWF8fFwiaHR0cDovL2xvY2FsaG9zdFwiLGIuc2Nyb2xsYmFycz0hMCk7Yz1hfHxcIlwiOyhkPWIpfHwoZD17fSk7YT13aW5kb3c7Yj1jIGluc3RhbmNlb2YgbGM/YzpwYyhcInVuZGVmaW5lZFwiIT10eXBlb2YgYy5ocmVmP2MuaHJlZjpTdHJpbmcoYykpO2M9ZC50YXJnZXR8fGMudGFyZ2V0O2U9W107XG5mb3IoZyBpbiBkKXN3aXRjaChnKXtjYXNlIFwid2lkdGhcIjpjYXNlIFwiaGVpZ2h0XCI6Y2FzZSBcInRvcFwiOmNhc2UgXCJsZWZ0XCI6ZS5wdXNoKGcrXCI9XCIrZFtnXSk7YnJlYWs7Y2FzZSBcInRhcmdldFwiOmNhc2UgXCJub3JlZmVycmVyXCI6YnJlYWs7ZGVmYXVsdDplLnB1c2goZytcIj1cIisoZFtnXT8xOjApKX12YXIgZz1lLmpvaW4oXCIsXCIpOyh4KFwiaVBob25lXCIpJiYheChcImlQb2RcIikmJiF4KFwiaVBhZFwiKXx8eChcImlQYWRcIil8fHgoXCJpUG9kXCIpKSYmYS5uYXZpZ2F0b3ImJmEubmF2aWdhdG9yLnN0YW5kYWxvbmUmJmMmJlwiX3NlbGZcIiE9Yz8oZz1hLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJBXCIpLGIgaW5zdGFuY2VvZiBsY3x8YiBpbnN0YW5jZW9mIGxjfHwoYj1iLmxhP2IuamEoKTpTdHJpbmcoYiksb2MudGVzdChiKXx8KGI9XCJhYm91dDppbnZhbGlkI3pDbG9zdXJlelwiKSxiPXFjKGIpKSxnLmhyZWY9bmMoYiksZy5zZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIixjKSxkLm5vcmVmZXJyZXImJmcuc2V0QXR0cmlidXRlKFwicmVsXCIsXG5cIm5vcmVmZXJyZXJcIiksZD1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIiksZC5pbml0TW91c2VFdmVudChcImNsaWNrXCIsITAsITAsYSwxKSxnLmRpc3BhdGNoRXZlbnQoZCksZz17fSk6ZC5ub3JlZmVycmVyPyhnPWEub3BlbihcIlwiLGMsZyksYT1uYyhiKSxnJiYoYmImJnYoYSxcIjtcIikmJihhPVwiJ1wiK2EucmVwbGFjZSgvJy9nLFwiJTI3XCIpK1wiJ1wiKSxnLm9wZW5lcj1udWxsLGRjKFwiYi8xMjAxNDQxMiwgbWV0YSB0YWcgd2l0aCBzYW5pdGl6ZWQgVVJMXCIpLGE9JzxNRVRBIEhUVFAtRVFVSVY9XCJyZWZyZXNoXCIgY29udGVudD1cIjA7IHVybD0nK3FhKGEpKydcIj4nLGE9dmMoYSksZy5kb2N1bWVudC53cml0ZSh1YyhhKSksZy5kb2N1bWVudC5jbG9zZSgpKSk6Zz1hLm9wZW4obmMoYiksYyxnKTtpZihnKXRyeXtnLmZvY3VzKCl9Y2F0Y2gobCl7fXJldHVybiBnfVxuZnVuY3Rpb24gRmYoYSl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtzZCgyRTMpLnRoZW4oZnVuY3Rpb24oKXtpZighYXx8YS5jbG9zZWQpYigpO2Vsc2UgcmV0dXJuIGMoKX0pfXJldHVybiBjKCl9KX12YXIgR2Y9L15cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvO2Z1bmN0aW9uIEhmKCl7dmFyIGE9bnVsbDtyZXR1cm4obmV3IHooZnVuY3Rpb24oYil7XCJjb21wbGV0ZVwiPT1rLmRvY3VtZW50LnJlYWR5U3RhdGU/YigpOihhPWZ1bmN0aW9uKCl7YigpfSxkZCh3aW5kb3csXCJsb2FkXCIsYSkpfSkpLnMoZnVuY3Rpb24oYil7RSh3aW5kb3csXCJsb2FkXCIsYSk7dGhyb3cgYjt9KX1cbmZ1bmN0aW9uIElmKCl7cmV0dXJuIEpmKHZvaWQgMCk/SGYoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGEsYil7dmFyIGM9ay5kb2N1bWVudCxkPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKEVycm9yKFwiQ29yZG92YSBmcmFtZXdvcmsgaXMgbm90IHJlYWR5LlwiKSl9LDFFMyk7Yy5hZGRFdmVudExpc3RlbmVyKFwiZGV2aWNlcmVhZHlcIixmdW5jdGlvbigpe2NsZWFyVGltZW91dChkKTthKCl9LCExKX0pfSk6QihFcnJvcihcIkNvcmRvdmEgbXVzdCBydW4gaW4gYW4gQW5kcm9pZCBvciBpT1MgZmlsZSBzY2hlbWUuXCIpKX1mdW5jdGlvbiBKZihhKXthPWF8fEooKTtyZXR1cm4hKFwiZmlsZTpcIiE9PUtmKCl8fCFhLnRvTG93ZXJDYXNlKCkubWF0Y2goL2lwaG9uZXxpcGFkfGlwb2R8YW5kcm9pZC8pKX1mdW5jdGlvbiBMZigpe3ZhciBhPWsud2luZG93O3RyeXtyZXR1cm4hKCFhfHxhPT1hLnRvcCl9Y2F0Y2goYil7cmV0dXJuITF9fVxuZnVuY3Rpb24gSygpe3JldHVybiBmaXJlYmFzZS5JTlRFUk5BTC5oYXNPd25Qcm9wZXJ0eShcInJlYWN0TmF0aXZlXCIpP1wiUmVhY3ROYXRpdmVcIjpmaXJlYmFzZS5JTlRFUk5BTC5oYXNPd25Qcm9wZXJ0eShcIm5vZGVcIik/XCJOb2RlXCI6XCJCcm93c2VyXCJ9ZnVuY3Rpb24gTWYoKXt2YXIgYT1LKCk7cmV0dXJuXCJSZWFjdE5hdGl2ZVwiPT09YXx8XCJOb2RlXCI9PT1hfXZhciBFZj1cIkZpcmVmb3hcIixBZj1cIkNocm9tZVwiO1xuZnVuY3Rpb24gemYoYSl7dmFyIGI9YS50b0xvd2VyQ2FzZSgpO2lmKHYoYixcIm9wZXJhL1wiKXx8dihiLFwib3ByL1wiKXx8dihiLFwib3Bpb3MvXCIpKXJldHVyblwiT3BlcmFcIjtpZih2KGIsXCJpZW1vYmlsZVwiKSlyZXR1cm5cIklFTW9iaWxlXCI7aWYodihiLFwibXNpZVwiKXx8dihiLFwidHJpZGVudC9cIikpcmV0dXJuXCJJRVwiO2lmKHYoYixcImVkZ2UvXCIpKXJldHVyblwiRWRnZVwiO2lmKHYoYixcImZpcmVmb3gvXCIpKXJldHVybiBFZjtpZih2KGIsXCJzaWxrL1wiKSlyZXR1cm5cIlNpbGtcIjtpZih2KGIsXCJibGFja2JlcnJ5XCIpKXJldHVyblwiQmxhY2tiZXJyeVwiO2lmKHYoYixcIndlYm9zXCIpKXJldHVyblwiV2Vib3NcIjtpZighdihiLFwic2FmYXJpL1wiKXx8dihiLFwiY2hyb21lL1wiKXx8dihiLFwiY3Jpb3MvXCIpfHx2KGIsXCJhbmRyb2lkXCIpKWlmKCF2KGIsXCJjaHJvbWUvXCIpJiYhdihiLFwiY3Jpb3MvXCIpfHx2KGIsXCJlZGdlL1wiKSl7aWYodihiLFwiYW5kcm9pZFwiKSlyZXR1cm5cIkFuZHJvaWRcIjtpZigoYT1hLm1hdGNoKC8oW2EtekEtWlxcZFxcLl0rKVxcL1thLXpBLVpcXGRcXC5dKiQvKSkmJlxuMj09YS5sZW5ndGgpcmV0dXJuIGFbMV19ZWxzZSByZXR1cm4gQWY7ZWxzZSByZXR1cm5cIlNhZmFyaVwiO3JldHVyblwiT3RoZXJcIn12YXIgTmY9e0djOlwiRmlyZWJhc2VDb3JlLXdlYlwiLEljOlwiRmlyZWJhc2VVSS13ZWJcIn07ZnVuY3Rpb24gT2YoYSxiKXtiPWJ8fFtdO3ZhciBjPVtdLGQ9e30sZTtmb3IoZSBpbiBOZilkW05mW2VdXT0hMDtmb3IoZT0wO2U8Yi5sZW5ndGg7ZSsrKVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZFtiW2VdXSYmKGRlbGV0ZSBkW2JbZV1dLGMucHVzaChiW2VdKSk7Yy5zb3J0KCk7Yj1jO2IubGVuZ3RofHwoYj1bXCJGaXJlYmFzZUNvcmUtd2ViXCJdKTtjPUsoKTtkPVwiXCI7XCJCcm93c2VyXCI9PT1jP2Q9emYoSigpKTpkPWM7cmV0dXJuIGQrXCIvSnNDb3JlL1wiK2ErXCIvXCIrYi5qb2luKFwiLFwiKX1mdW5jdGlvbiBKKCl7cmV0dXJuIGsubmF2aWdhdG9yJiZrLm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCJ9XG5mdW5jdGlvbiBMKGEsYil7YT1hLnNwbGl0KFwiLlwiKTtiPWJ8fGs7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aCYmXCJvYmplY3RcIj09dHlwZW9mIGImJm51bGwhPWI7YysrKWI9YlthW2NdXTtjIT1hLmxlbmd0aCYmKGI9dm9pZCAwKTtyZXR1cm4gYn1mdW5jdGlvbiBQZigpe3RyeXt2YXIgYT1rLmxvY2FsU3RvcmFnZSxiPVFmKCk7aWYoYSlyZXR1cm4gYS5zZXRJdGVtKGIsXCIxXCIpLGEucmVtb3ZlSXRlbShiKSx1ZigpPyEhay5pbmRleGVkREI6ITB9Y2F0Y2goYyl7fXJldHVybiExfWZ1bmN0aW9uIFJmKCl7cmV0dXJuKFNmKCl8fFwiY2hyb21lLWV4dGVuc2lvbjpcIj09PUtmKCl8fEpmKCkpJiYhTWYoKSYmUGYoKX1mdW5jdGlvbiBTZigpe3JldHVyblwiaHR0cDpcIj09PUtmKCl8fFwiaHR0cHM6XCI9PT1LZigpfWZ1bmN0aW9uIEtmKCl7cmV0dXJuIGsubG9jYXRpb24mJmsubG9jYXRpb24ucHJvdG9jb2x8fG51bGx9XG5mdW5jdGlvbiBUZihhKXthPWF8fEooKTtyZXR1cm4gQmYoYSl8fHpmKGEpPT1FZj8hMTohMH1mdW5jdGlvbiBVZihhKXtyZXR1cm5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/bnVsbDpDYyhhKX1mdW5jdGlvbiBWZihhKXt2YXIgYj17fSxjO2ZvcihjIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShjKSYmbnVsbCE9PWFbY10mJnZvaWQgMCE9PWFbY10mJihiW2NdPWFbY10pO3JldHVybiBifWZ1bmN0aW9uIFdmKGEpe2lmKG51bGwhPT1hKXJldHVybiBKU09OLnBhcnNlKGEpfWZ1bmN0aW9uIFFmKGEpe3JldHVybiBhP2E6XCJcIitNYXRoLmZsb29yKDFFOSpNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpfWZ1bmN0aW9uIFhmKGEpe2E9YXx8SigpO3JldHVyblwiU2FmYXJpXCI9PXpmKGEpfHxhLnRvTG93ZXJDYXNlKCkubWF0Y2goL2lwaG9uZXxpcGFkfGlwb2QvKT8hMTohMH1cbmZ1bmN0aW9uIFlmKCl7dmFyIGE9ay5fX19qc2w7aWYoYSYmYS5IKWZvcih2YXIgYiBpbiBhLkgpaWYoYS5IW2JdLnI9YS5IW2JdLnJ8fFtdLGEuSFtiXS5MPWEuSFtiXS5MfHxbXSxhLkhbYl0ucj1hLkhbYl0uTC5jb25jYXQoKSxhLkNQKWZvcih2YXIgYz0wO2M8YS5DUC5sZW5ndGg7YysrKWEuQ1BbY109bnVsbH1mdW5jdGlvbiBaZigpe3ZhciBhPWsubmF2aWdhdG9yO3JldHVybiBhJiZcImJvb2xlYW5cIj09PXR5cGVvZiBhLm9uTGluZSYmKFNmKCl8fFwiY2hyb21lLWV4dGVuc2lvbjpcIj09PUtmKCl8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS5jb25uZWN0aW9uKT9hLm9uTGluZTohMH1mdW5jdGlvbiAkZihhLGIsYyxkKXtpZihhPmIpdGhyb3cgRXJyb3IoXCJTaG9ydCBkZWxheSBzaG91bGQgYmUgbGVzcyB0aGFuIGxvbmcgZGVsYXkhXCIpO3RoaXMuYz1hO3RoaXMuYj1iO2E9Y3x8SigpO2Q9ZHx8SygpO3RoaXMuYT1CZihhKXx8XCJSZWFjdE5hdGl2ZVwiPT09ZH1cbiRmLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hP3RoaXMuYjp0aGlzLmN9O2Z1bmN0aW9uIGFnKCl7dmFyIGE9ay5kb2N1bWVudDtyZXR1cm4gYSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLnZpc2liaWxpdHlTdGF0ZT9cInZpc2libGVcIj09YS52aXNpYmlsaXR5U3RhdGU6ITB9ZnVuY3Rpb24gYmcoKXt2YXIgYT1rLmRvY3VtZW50LGI9bnVsbDtyZXR1cm4gYWcoKXx8IWE/QSgpOihuZXcgeihmdW5jdGlvbihjKXtiPWZ1bmN0aW9uKCl7YWcoKSYmKGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixiLCExKSxjKCkpfTthLmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYiwhMSl9KSkucyhmdW5jdGlvbihjKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsYiwhMSk7dGhyb3cgYzt9KX1cbmZ1bmN0aW9uIGNnKGEpe3RyeXt2YXIgYj1uZXcgRGF0ZShwYXJzZUludChhLDEwKSk7aWYoIWlzTmFOKGIuZ2V0VGltZSgpKSYmIS9bXjAtOV0vLnRlc3QoYSkpcmV0dXJuIGIudG9VVENTdHJpbmcoKX1jYXRjaChjKXt9cmV0dXJuIG51bGx9O3ZhciBkZz17fTt2YXIgZWc7dHJ5e3ZhciBmZz17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZmcsXCJhYmNkXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOjF9KTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZmcsXCJhYmNkXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOjJ9KTtlZz0yPT1mZy5hYmNkfWNhdGNoKGEpe2VnPSExfWZ1bmN0aW9uIE0oYSxiLGMpe2VnP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOmN9KTphW2JdPWN9ZnVuY3Rpb24gZ2coYSxiKXtpZihiKWZvcih2YXIgYyBpbiBiKWIuaGFzT3duUHJvcGVydHkoYykmJk0oYSxjLGJbY10pfWZ1bmN0aW9uIGhnKGEpe3ZhciBiPXt9O2dnKGIsYSk7cmV0dXJuIGJ9ZnVuY3Rpb24gaWcoYSl7dmFyIGI9e30sYztmb3IoYyBpbiBhKWEuaGFzT3duUHJvcGVydHkoYykmJihiW2NdPWFbY10pO3JldHVybiBifVxuZnVuY3Rpb24gamcoYSxiKXtpZighYnx8IWIubGVuZ3RoKXJldHVybiEwO2lmKCFhKXJldHVybiExO2Zvcih2YXIgYz0wO2M8Yi5sZW5ndGg7YysrKXt2YXIgZD1hW2JbY11dO2lmKHZvaWQgMD09PWR8fG51bGw9PT1kfHxcIlwiPT09ZClyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBrZyhhKXt2YXIgYj1hO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZudWxsIT1hKXtiPVwibGVuZ3RoXCJpbiBhP1tdOnt9O2Zvcih2YXIgYyBpbiBhKU0oYixjLGtnKGFbY10pKX1yZXR1cm4gYn07ZnVuY3Rpb24gbGcoYSl7dmFyIGI9e30sYz1hW21nXSxkPWFbbmddO2E9YVtvZ107aWYoIWN8fCFhKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciB1c2VyIGluZm8hXCIpO2JbcGddPWR8fG51bGw7YltxZ109YztNKHRoaXMscmcsYSk7TSh0aGlzLHNnLGtnKGIpKX12YXIgbWc9XCJlbWFpbFwiLG5nPVwibmV3RW1haWxcIixvZz1cInJlcXVlc3RUeXBlXCIscWc9XCJlbWFpbFwiLHBnPVwiZnJvbUVtYWlsXCIsc2c9XCJkYXRhXCIscmc9XCJvcGVyYXRpb25cIjtmdW5jdGlvbiBOKGEsYil7dGhpcy5jb2RlPXRnK2E7dGhpcy5tZXNzYWdlPWJ8fHVnW2FdfHxcIlwifXQoTixFcnJvcik7Ti5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3JldHVybntjb2RlOnRoaXMuY29kZSxtZXNzYWdlOnRoaXMubWVzc2FnZX19O04ucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLkIoKX07ZnVuY3Rpb24gdmcoYSl7dmFyIGI9YSYmYS5jb2RlO3JldHVybiBiP25ldyBOKGIuc3Vic3RyaW5nKHRnLmxlbmd0aCksYS5tZXNzYWdlKTpudWxsfVxudmFyIHRnPVwiYXV0aC9cIix1Zz17XCJhcmd1bWVudC1lcnJvclwiOlwiXCIsXCJhcHAtbm90LWF1dGhvcml6ZWRcIjpcIlRoaXMgYXBwLCBpZGVudGlmaWVkIGJ5IHRoZSBkb21haW4gd2hlcmUgaXQncyBob3N0ZWQsIGlzIG5vdCBhdXRob3JpemVkIHRvIHVzZSBGaXJlYmFzZSBBdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBBUEkga2V5LiBSZXZpZXcgeW91ciBrZXkgY29uZmlndXJhdGlvbiBpbiB0aGUgR29vZ2xlIEFQSSBjb25zb2xlLlwiLFwiYXBwLW5vdC1pbnN0YWxsZWRcIjpcIlRoZSByZXF1ZXN0ZWQgbW9iaWxlIGFwcGxpY2F0aW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGlkZW50aWZpZXIgKEFuZHJvaWQgcGFja2FnZSBuYW1lIG9yIGlPUyBidW5kbGUgSUQpIHByb3ZpZGVkIGlzIG5vdCBpbnN0YWxsZWQgb24gdGhpcyBkZXZpY2UuXCIsXCJjYXB0Y2hhLWNoZWNrLWZhaWxlZFwiOlwiVGhlIHJlQ0FQVENIQSByZXNwb25zZSB0b2tlbiBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCwgZXhwaXJlZCwgYWxyZWFkeSB1c2VkIG9yIHRoZSBkb21haW4gYXNzb2NpYXRlZCB3aXRoIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBsaXN0IG9mIHdoaXRlbGlzdGVkIGRvbWFpbnMuXCIsXG5cImNvZGUtZXhwaXJlZFwiOlwiVGhlIFNNUyBjb2RlIGhhcyBleHBpcmVkLiBQbGVhc2UgcmUtc2VuZCB0aGUgdmVyaWZpY2F0aW9uIGNvZGUgdG8gdHJ5IGFnYWluLlwiLFwiY29yZG92YS1ub3QtcmVhZHlcIjpcIkNvcmRvdmEgZnJhbWV3b3JrIGlzIG5vdCByZWFkeS5cIixcImNvcnMtdW5zdXBwb3J0ZWRcIjpcIlRoaXMgYnJvd3NlciBpcyBub3Qgc3VwcG9ydGVkLlwiLFwiY3JlZGVudGlhbC1hbHJlYWR5LWluLXVzZVwiOlwiVGhpcyBjcmVkZW50aWFsIGlzIGFscmVhZHkgYXNzb2NpYXRlZCB3aXRoIGEgZGlmZmVyZW50IHVzZXIgYWNjb3VudC5cIixcImN1c3RvbS10b2tlbi1taXNtYXRjaFwiOlwiVGhlIGN1c3RvbSB0b2tlbiBjb3JyZXNwb25kcyB0byBhIGRpZmZlcmVudCBhdWRpZW5jZS5cIixcInJlcXVpcmVzLXJlY2VudC1sb2dpblwiOlwiVGhpcyBvcGVyYXRpb24gaXMgc2Vuc2l0aXZlIGFuZCByZXF1aXJlcyByZWNlbnQgYXV0aGVudGljYXRpb24uIExvZyBpbiBhZ2FpbiBiZWZvcmUgcmV0cnlpbmcgdGhpcyByZXF1ZXN0LlwiLFxuXCJkeW5hbWljLWxpbmstbm90LWFjdGl2YXRlZFwiOlwiUGxlYXNlIGFjdGl2YXRlIER5bmFtaWMgTGlua3MgaW4gdGhlIEZpcmViYXNlIENvbnNvbGUgYW5kIGFncmVlIHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucy5cIixcImVtYWlsLWFscmVhZHktaW4tdXNlXCI6XCJUaGUgZW1haWwgYWRkcmVzcyBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyIGFjY291bnQuXCIsXCJleHBpcmVkLWFjdGlvbi1jb2RlXCI6XCJUaGUgYWN0aW9uIGNvZGUgaGFzIGV4cGlyZWQuIFwiLFwiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIjpcIlRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCBkdWUgdG8gYW5vdGhlciBjb25mbGljdGluZyBwb3B1cCBiZWluZyBvcGVuZWQuXCIsXCJpbnRlcm5hbC1lcnJvclwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwiaW52YWxpZC1hcHAtY3JlZGVudGlhbFwiOlwiVGhlIHBob25lIHZlcmlmaWNhdGlvbiByZXF1ZXN0IGNvbnRhaW5zIGFuIGludmFsaWQgYXBwbGljYXRpb24gdmVyaWZpZXIuIFRoZSByZUNBUFRDSEEgdG9rZW4gcmVzcG9uc2UgaXMgZWl0aGVyIGludmFsaWQgb3IgZXhwaXJlZC5cIixcblwiaW52YWxpZC1hcHAtaWRcIjpcIlRoZSBtb2JpbGUgYXBwIGlkZW50aWZpZXIgaXMgbm90IHJlZ2lzdGVkIGZvciB0aGUgY3VycmVudCBwcm9qZWN0LlwiLFwiaW52YWxpZC11c2VyLXRva2VuXCI6XCJUaGUgdXNlcidzIGNyZWRlbnRpYWwgaXMgbm8gbG9uZ2VyIHZhbGlkLiBUaGUgdXNlciBtdXN0IHNpZ24gaW4gYWdhaW4uXCIsXCJpbnZhbGlkLWF1dGgtZXZlbnRcIjpcIkFuIGludGVybmFsIGVycm9yIGhhcyBvY2N1cnJlZC5cIixcImludmFsaWQtdmVyaWZpY2F0aW9uLWNvZGVcIjpcIlRoZSBTTVMgdmVyaWZpY2F0aW9uIGNvZGUgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLiBQbGVhc2UgcmVzZW5kIHRoZSB2ZXJpZmljYXRpb24gY29kZSBzbXMgYW5kIGJlIHN1cmUgdXNlIHRoZSB2ZXJpZmljYXRpb24gY29kZSBwcm92aWRlZCBieSB0aGUgdXNlci5cIixcImludmFsaWQtY29udGludWUtdXJpXCI6XCJUaGUgY29udGludWUgVVJMIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0IGlzIGludmFsaWQuXCIsXG5cImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCI6XCJUaGUgZm9sbG93aW5nIENvcmRvdmEgcGx1Z2lucyBtdXN0IGJlIGluc3RhbGxlZCB0byBlbmFibGUgT0F1dGggc2lnbi1pbjogY29yZG92YS1wbHVnaW4tYnVpbGRpbmZvLCBjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4sIGNvcmRvdmEtcGx1Z2luLWJyb3dzZXJ0YWIsIGNvcmRvdmEtcGx1Z2luLWluYXBwYnJvd3NlciBhbmQgY29yZG92YS1wbHVnaW4tY3VzdG9tdXJsc2NoZW1lLlwiLFwiaW52YWxpZC1jdXN0b20tdG9rZW5cIjpcIlRoZSBjdXN0b20gdG9rZW4gZm9ybWF0IGlzIGluY29ycmVjdC4gUGxlYXNlIGNoZWNrIHRoZSBkb2N1bWVudGF0aW9uLlwiLFwiaW52YWxpZC1lbWFpbFwiOlwiVGhlIGVtYWlsIGFkZHJlc3MgaXMgYmFkbHkgZm9ybWF0dGVkLlwiLFwiaW52YWxpZC1hcGkta2V5XCI6XCJZb3VyIEFQSSBrZXkgaXMgaW52YWxpZCwgcGxlYXNlIGNoZWNrIHlvdSBoYXZlIGNvcGllZCBpdCBjb3JyZWN0bHkuXCIsXCJpbnZhbGlkLWNlcnQtaGFzaFwiOlwiVGhlIFNIQS0xIGNlcnRpZmljYXRlIGhhc2ggcHJvdmlkZWQgaXMgaW52YWxpZC5cIixcblwiaW52YWxpZC1jcmVkZW50aWFsXCI6XCJUaGUgc3VwcGxpZWQgYXV0aCBjcmVkZW50aWFsIGlzIG1hbGZvcm1lZCBvciBoYXMgZXhwaXJlZC5cIixcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiOlwiVGhlIHNwZWNpZmllZCBwZXJzaXN0ZW5jZSB0eXBlIGlzIGludmFsaWQuIEl0IGNhbiBvbmx5IGJlIGxvY2FsLCBzZXNzaW9uIG9yIG5vbmUuXCIsXCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiOlwiVGhlIGVtYWlsIHRlbXBsYXRlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3Rpb24gY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIGluIGl0cyBtZXNzYWdlLiBQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLlwiLFwiaW52YWxpZC1vYXV0aC1wcm92aWRlclwiOlwiRW1haWxBdXRoUHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhpcyBvcGVyYXRpb24uIFRoaXMgb3BlcmF0aW9uIG9ubHkgc3VwcG9ydHMgT0F1dGggcHJvdmlkZXJzLlwiLFxuXCJpbnZhbGlkLW9hdXRoLWNsaWVudC1pZFwiOlwiVGhlIE9BdXRoIGNsaWVudCBJRCBwcm92aWRlZCBpcyBlaXRoZXIgaW52YWxpZCBvciBkb2VzIG5vdCBtYXRjaCB0aGUgc3BlY2lmaWVkIEFQSSBrZXkuXCIsXCJ1bmF1dGhvcml6ZWQtZG9tYWluXCI6XCJUaGlzIGRvbWFpbiBpcyBub3QgYXV0aG9yaXplZCBmb3IgT0F1dGggb3BlcmF0aW9ucyBmb3IgeW91ciBGaXJlYmFzZSBwcm9qZWN0LiBFZGl0IHRoZSBsaXN0IG9mIGF1dGhvcml6ZWQgZG9tYWlucyBmcm9tIHRoZSBGaXJlYmFzZSBjb25zb2xlLlwiLFwiaW52YWxpZC1hY3Rpb24tY29kZVwiOlwiVGhlIGFjdGlvbiBjb2RlIGlzIGludmFsaWQuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgY29kZSBpcyBtYWxmb3JtZWQsIGV4cGlyZWQsIG9yIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIixcIndyb25nLXBhc3N3b3JkXCI6XCJUaGUgcGFzc3dvcmQgaXMgaW52YWxpZCBvciB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIGEgcGFzc3dvcmQuXCIsXCJpbnZhbGlkLXBob25lLW51bWJlclwiOlwiVGhlIGZvcm1hdCBvZiB0aGUgcGhvbmUgbnVtYmVyIHByb3ZpZGVkIGlzIGluY29ycmVjdC4gUGxlYXNlIGVudGVyIHRoZSBwaG9uZSBudW1iZXIgaW4gYSBmb3JtYXQgdGhhdCBjYW4gYmUgcGFyc2VkIGludG8gRS4xNjQgZm9ybWF0LiBFLjE2NCBwaG9uZSBudW1iZXJzIGFyZSB3cml0dGVuIGluIHRoZSBmb3JtYXQgWytdW2NvdW50cnkgY29kZV1bc3Vic2NyaWJlciBudW1iZXIgaW5jbHVkaW5nIGFyZWEgY29kZV0uXCIsXG5cImludmFsaWQtcmVjaXBpZW50LWVtYWlsXCI6XCJUaGUgZW1haWwgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBmYWlsZWQgdG8gc2VuZCBhcyB0aGUgcHJvdmlkZWQgcmVjaXBpZW50IGVtYWlsIGFkZHJlc3MgaXMgaW52YWxpZC5cIixcImludmFsaWQtc2VuZGVyXCI6XCJUaGUgZW1haWwgdGVtcGxhdGUgY29ycmVzcG9uZGluZyB0byB0aGlzIGFjdGlvbiBjb250YWlucyBhbiBpbnZhbGlkIHNlbmRlciBlbWFpbCBvciBuYW1lLiBQbGVhc2UgZml4IGJ5IGdvaW5nIHRvIHRoZSBBdXRoIGVtYWlsIHRlbXBsYXRlcyBzZWN0aW9uIGluIHRoZSBGaXJlYmFzZSBDb25zb2xlLlwiLFwiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIjpcIlRoZSB2ZXJpZmljYXRpb24gSUQgdXNlZCB0byBjcmVhdGUgdGhlIHBob25lIGF1dGggY3JlZGVudGlhbCBpcyBpbnZhbGlkLlwiLFwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCI6XCJBbiBBbmRyb2lkIFBhY2thZ2UgTmFtZSBtdXN0IGJlIHByb3ZpZGVkIGlmIHRoZSBBbmRyb2lkIEFwcCBpcyByZXF1aXJlZCB0byBiZSBpbnN0YWxsZWQuXCIsXG5cImF1dGgtZG9tYWluLWNvbmZpZy1yZXF1aXJlZFwiOlwiQmUgc3VyZSB0byBpbmNsdWRlIGF1dGhEb21haW4gd2hlbiBjYWxsaW5nIGZpcmViYXNlLmluaXRpYWxpemVBcHAoKSwgYnkgZm9sbG93aW5nIHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUuXCIsXCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCI6XCJUaGUgcGhvbmUgdmVyaWZpY2F0aW9uIHJlcXVlc3QgaXMgbWlzc2luZyBhbiBhcHBsaWNhdGlvbiB2ZXJpZmllciBhc3NlcnRpb24uIEEgcmVDQVBUQ0hBIHJlc3BvbnNlIHRva2VuIG5lZWRzIHRvIGJlIHByb3ZpZGVkLlwiLFwibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiOlwiVGhlIHBob25lIGF1dGggY3JlZGVudGlhbCB3YXMgY3JlYXRlZCB3aXRoIGFuIGVtcHR5IFNNUyB2ZXJpZmljYXRpb24gY29kZS5cIixcIm1pc3NpbmctY29udGludWUtdXJpXCI6XCJBIGNvbnRpbnVlIFVSTCBtdXN0IGJlIHByb3ZpZGVkIGluIHRoZSByZXF1ZXN0LlwiLFwibWlzc2luZy1pZnJhbWUtc3RhcnRcIjpcIkFuIGludGVybmFsIGVycm9yIGhhcyBvY2N1cnJlZC5cIixcblwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCI6XCJBbiBpT1MgQnVuZGxlIElEIG11c3QgYmUgcHJvdmlkZWQgaWYgYW4gQXBwIFN0b3JlIElEIGlzIHByb3ZpZGVkLlwiLFwibWlzc2luZy1waG9uZS1udW1iZXJcIjpcIlRvIHNlbmQgdmVyaWZpY2F0aW9uIGNvZGVzLCBwcm92aWRlIGEgcGhvbmUgbnVtYmVyIGZvciB0aGUgcmVjaXBpZW50LlwiLFwibWlzc2luZy12ZXJpZmljYXRpb24taWRcIjpcIlRoZSBwaG9uZSBhdXRoIGNyZWRlbnRpYWwgd2FzIGNyZWF0ZWQgd2l0aCBhbiBlbXB0eSB2ZXJpZmljYXRpb24gSUQuXCIsXCJhcHAtZGVsZXRlZFwiOlwiVGhpcyBpbnN0YW5jZSBvZiBGaXJlYmFzZUFwcCBoYXMgYmVlbiBkZWxldGVkLlwiLFwiYWNjb3VudC1leGlzdHMtd2l0aC1kaWZmZXJlbnQtY3JlZGVudGlhbFwiOlwiQW4gYWNjb3VudCBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGVtYWlsIGFkZHJlc3MgYnV0IGRpZmZlcmVudCBzaWduLWluIGNyZWRlbnRpYWxzLiBTaWduIGluIHVzaW5nIGEgcHJvdmlkZXIgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZW1haWwgYWRkcmVzcy5cIixcblwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiOlwiQSBuZXR3b3JrIGVycm9yIChzdWNoIGFzIHRpbWVvdXQsIGludGVycnVwdGVkIGNvbm5lY3Rpb24gb3IgdW5yZWFjaGFibGUgaG9zdCkgaGFzIG9jY3VycmVkLlwiLFwibm8tYXV0aC1ldmVudFwiOlwiQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLlwiLFwibm8tc3VjaC1wcm92aWRlclwiOlwiVXNlciB3YXMgbm90IGxpbmtlZCB0byBhbiBhY2NvdW50IHdpdGggdGhlIGdpdmVuIHByb3ZpZGVyLlwiLFwib3BlcmF0aW9uLW5vdC1hbGxvd2VkXCI6XCJUaGUgZ2l2ZW4gc2lnbi1pbiBwcm92aWRlciBpcyBkaXNhYmxlZCBmb3IgdGhpcyBGaXJlYmFzZSBwcm9qZWN0LiBFbmFibGUgaXQgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUsIHVuZGVyIHRoZSBzaWduLWluIG1ldGhvZCB0YWIgb2YgdGhlIEF1dGggc2VjdGlvbi5cIixcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIjonVGhpcyBvcGVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgZW52aXJvbm1lbnQgdGhpcyBhcHBsaWNhdGlvbiBpcyBydW5uaW5nIG9uLiBcImxvY2F0aW9uLnByb3RvY29sXCIgbXVzdCBiZSBodHRwLCBodHRwcyBvciBjaHJvbWUtZXh0ZW5zaW9uIGFuZCB3ZWIgc3RvcmFnZSBtdXN0IGJlIGVuYWJsZWQuJyxcblwicG9wdXAtYmxvY2tlZFwiOlwiVW5hYmxlIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcG9wdXAuIEl0IG1heSBoYXZlIGJlZW4gYmxvY2tlZCBieSB0aGUgYnJvd3Nlci5cIixcInBvcHVwLWNsb3NlZC1ieS11c2VyXCI6XCJUaGUgcG9wdXAgaGFzIGJlZW4gY2xvc2VkIGJ5IHRoZSB1c2VyIGJlZm9yZSBmaW5hbGl6aW5nIHRoZSBvcGVyYXRpb24uXCIsXCJwcm92aWRlci1hbHJlYWR5LWxpbmtlZFwiOlwiVXNlciBjYW4gb25seSBiZSBsaW5rZWQgdG8gb25lIGlkZW50aXR5IGZvciB0aGUgZ2l2ZW4gcHJvdmlkZXIuXCIsXCJxdW90YS1leGNlZWRlZFwiOlwiVGhlIHByb2plY3QncyBxdW90YSBmb3IgdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gZXhjZWVkZWQuXCIsXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiOlwiVGhlIHJlZGlyZWN0IG9wZXJhdGlvbiBoYXMgYmVlbiBjYW5jZWxsZWQgYnkgdGhlIHVzZXIgYmVmb3JlIGZpbmFsaXppbmcuXCIsXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiOlwiQSByZWRpcmVjdCBzaWduLWluIG9wZXJhdGlvbiBpcyBhbHJlYWR5IHBlbmRpbmcuXCIsXG50aW1lb3V0OlwiVGhlIG9wZXJhdGlvbiBoYXMgdGltZWQgb3V0LlwiLFwidXNlci10b2tlbi1leHBpcmVkXCI6XCJUaGUgdXNlcidzIGNyZWRlbnRpYWwgaXMgbm8gbG9uZ2VyIHZhbGlkLiBUaGUgdXNlciBtdXN0IHNpZ24gaW4gYWdhaW4uXCIsXCJ0b28tbWFueS1yZXF1ZXN0c1wiOlwiV2UgaGF2ZSBibG9ja2VkIGFsbCByZXF1ZXN0cyBmcm9tIHRoaXMgZGV2aWNlIGR1ZSB0byB1bnVzdWFsIGFjdGl2aXR5LiBUcnkgYWdhaW4gbGF0ZXIuXCIsXCJ1bmF1dGhvcml6ZWQtY29udGludWUtdXJpXCI6XCJUaGUgZG9tYWluIG9mIHRoZSBjb250aW51ZSBVUkwgaXMgbm90IHdoaXRlbGlzdGVkLiAgUGxlYXNlIHdoaXRlbGlzdCB0aGUgZG9tYWluIGluIHRoZSBGaXJlYmFzZSBjb25zb2xlLlwiLFwidW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiOlwiVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc3BlY2lmaWVkIHBlcnNpc3RlbmNlIHR5cGUuXCIsXCJ1c2VyLWNhbmNlbGxlZFwiOlwiVXNlciBkaWQgbm90IGdyYW50IHlvdXIgYXBwbGljYXRpb24gdGhlIHBlcm1pc3Npb25zIGl0IHJlcXVlc3RlZC5cIixcblwidXNlci1ub3QtZm91bmRcIjpcIlRoZXJlIGlzIG5vIHVzZXIgcmVjb3JkIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBpZGVudGlmaWVyLiBUaGUgdXNlciBtYXkgaGF2ZSBiZWVuIGRlbGV0ZWQuXCIsXCJ1c2VyLWRpc2FibGVkXCI6XCJUaGUgdXNlciBhY2NvdW50IGhhcyBiZWVuIGRpc2FibGVkIGJ5IGFuIGFkbWluaXN0cmF0b3IuXCIsXCJ1c2VyLW1pc21hdGNoXCI6XCJUaGUgc3VwcGxpZWQgY3JlZGVudGlhbHMgZG8gbm90IGNvcnJlc3BvbmQgdG8gdGhlIHByZXZpb3VzbHkgc2lnbmVkIGluIHVzZXIuXCIsXCJ1c2VyLXNpZ25lZC1vdXRcIjpcIlwiLFwid2Vhay1wYXNzd29yZFwiOlwiVGhlIHBhc3N3b3JkIG11c3QgYmUgNiBjaGFyYWN0ZXJzIGxvbmcgb3IgbW9yZS5cIixcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCI6XCJUaGlzIGJyb3dzZXIgaXMgbm90IHN1cHBvcnRlZCBvciAzcmQgcGFydHkgY29va2llcyBhbmQgZGF0YSBtYXkgYmUgZGlzYWJsZWQuXCJ9O2Z1bmN0aW9uIHdnKGEpe3ZhciBiPWFbeGddO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYil0aHJvdyBuZXcgTihcIm1pc3NpbmctY29udGludWUtdXJpXCIpO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYnx8XCJzdHJpbmdcIj09PXR5cGVvZiBiJiYhYi5sZW5ndGgpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWNvbnRpbnVlLXVyaVwiKTt0aGlzLmg9Yjt0aGlzLmM9dGhpcy5hPW51bGw7dGhpcy5nPSExO3ZhciBjPWFbeWddO2lmKGMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl7Yj1jW3pnXTt2YXIgZD1jW0FnXTtjPWNbQmddO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYiYmYi5sZW5ndGgpe3RoaXMuYT1iO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZCYmXCJib29sZWFuXCIhPT10eXBlb2YgZCl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsQWcrXCIgcHJvcGVydHkgbXVzdCBiZSBhIGJvb2xlYW4gd2hlbiBzcGVjaWZpZWQuXCIpO3RoaXMuZz0hIWQ7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjJiYoXCJzdHJpbmdcIiE9PVxudHlwZW9mIGN8fFwic3RyaW5nXCI9PT10eXBlb2YgYyYmIWMubGVuZ3RoKSl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsQmcrXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbiBlbXB0eSBzdHJpbmcgd2hlbiBzcGVjaWZpZWQuXCIpO3RoaXMuYz1jfHxudWxsfWVsc2V7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIix6ZytcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgbm9uIGVtcHR5IHN0cmluZyB3aGVuIHNwZWNpZmllZC5cIik7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBkfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IE4oXCJtaXNzaW5nLWFuZHJvaWQtcGtnLW5hbWVcIik7fX1lbHNlIGlmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYyl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIseWcrXCIgcHJvcGVydHkgbXVzdCBiZSBhIG5vbiBudWxsIG9iamVjdCB3aGVuIHNwZWNpZmllZC5cIik7dGhpcy5iPW51bGw7aWYoKGI9YVtDZ10pJiZcIm9iamVjdFwiPT09XG50eXBlb2YgYilpZihiPWJbRGddLFwic3RyaW5nXCI9PT10eXBlb2YgYiYmYi5sZW5ndGgpdGhpcy5iPWI7ZWxzZXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLERnK1wiIHByb3BlcnR5IG11c3QgYmUgYSBub24gZW1wdHkgc3RyaW5nIHdoZW4gc3BlY2lmaWVkLlwiKTt9ZWxzZSBpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLENnK1wiIHByb3BlcnR5IG11c3QgYmUgYSBub24gbnVsbCBvYmplY3Qgd2hlbiBzcGVjaWZpZWQuXCIpO2E9YVtFZ107aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiZcImJvb2xlYW5cIiE9PXR5cGVvZiBhKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixFZytcIiBwcm9wZXJ0eSBtdXN0IGJlIGEgYm9vbGVhbiB3aGVuIHNwZWNpZmllZC5cIik7aWYoKHRoaXMuZj0hIWEpJiYhdGhpcy5iJiYhdGhpcy5hKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixFZytcIiBwcm9wZXJ0eSBjYW4ndCBiZSB0cnVlIHdoZW4gbm8gbW9iaWxlIGFwcGxpY2F0aW9uIGlzIHByb3ZpZGVkLlwiKTtcbn12YXIgeWc9XCJhbmRyb2lkXCIsRWc9XCJoYW5kbGVDb2RlSW5BcHBcIixDZz1cImlPU1wiLHhnPVwidXJsXCIsQWc9XCJpbnN0YWxsQXBwXCIsQmc9XCJtaW5pbXVtVmVyc2lvblwiLHpnPVwicGFja2FnZU5hbWVcIixEZz1cImJ1bmRsZUlkXCI7ZnVuY3Rpb24gRmcoYSl7dmFyIGI9e307Yi5jb250aW51ZVVybD1hLmg7Yi5jYW5IYW5kbGVDb2RlSW5BcHA9YS5mO2lmKGIuYW5kcm9pZFBhY2thZ2VOYW1lPWEuYSliLmFuZHJvaWRNaW5pbXVtVmVyc2lvbj1hLmMsYi5hbmRyb2lkSW5zdGFsbEFwcD1hLmc7Yi5pT1NCdW5kbGVJZD1hLmI7Zm9yKHZhciBjIGluIGIpbnVsbD09PWJbY10mJmRlbGV0ZSBiW2NdO3JldHVybiBifTtmdW5jdGlvbiBHZyhhKXt0aGlzLmI9YS5zdWI7bmEoKTt0aGlzLmE9YS5wcm92aWRlcl9pZHx8YS5maXJlYmFzZSYmYS5maXJlYmFzZS5zaWduX2luX3Byb3ZpZGVyfHxudWxsfWZ1bmN0aW9uIEhnKGEpe2E9YS5zcGxpdChcIi5cIik7aWYoMyE9YS5sZW5ndGgpcmV0dXJuIG51bGw7YT1hWzFdO2Zvcih2YXIgYj0oNC1hLmxlbmd0aCU0KSU0LGM9MDtjPGI7YysrKWErPVwiLlwiO3RyeXt2YXIgZD1KU09OLnBhcnNlKEtkKGEpKTtpZihkLnN1YiYmZC5pc3MmJmQuYXVkJiZkLmV4cClyZXR1cm4gbmV3IEdnKGQpfWNhdGNoKGUpe31yZXR1cm4gbnVsbH07dmFyIElnPVwib2F1dGhfY29uc3VtZXJfa2V5IG9hdXRoX25vbmNlIG9hdXRoX3NpZ25hdHVyZSBvYXV0aF9zaWduYXR1cmVfbWV0aG9kIG9hdXRoX3RpbWVzdGFtcCBvYXV0aF90b2tlbiBvYXV0aF92ZXJzaW9uXCIuc3BsaXQoXCIgXCIpLEpnPVtcImNsaWVudF9pZFwiLFwicmVzcG9uc2VfdHlwZVwiLFwic2NvcGVcIixcInJlZGlyZWN0X3VyaVwiLFwic3RhdGVcIl0sS2c9e0hjOntNYTpcImxvY2FsZVwiLHphOjUwMCx5YTo2MDAsTmE6XCJmYWNlYm9vay5jb21cIiwkYTpKZ30sSmM6e01hOm51bGwsemE6NTAwLHlhOjYyMCxOYTpcImdpdGh1Yi5jb21cIiwkYTpKZ30sS2M6e01hOlwiaGxcIix6YTo1MTUseWE6NjgwLE5hOlwiZ29vZ2xlLmNvbVwiLCRhOkpnfSxRYzp7TWE6XCJsYW5nXCIsemE6NDg1LHlhOjcwNSxOYTpcInR3aXR0ZXIuY29tXCIsJGE6SWd9fTtmdW5jdGlvbiBMZyhhKXtmb3IodmFyIGIgaW4gS2cpaWYoS2dbYl0uTmE9PWEpcmV0dXJuIEtnW2JdO3JldHVybiBudWxsfTtmdW5jdGlvbiBNZyhhKXt2YXIgYj17fTtiW1wiZmFjZWJvb2suY29tXCJdPU5nO2JbXCJnb29nbGUuY29tXCJdPU9nO2JbXCJnaXRodWIuY29tXCJdPVBnO2JbXCJ0d2l0dGVyLmNvbVwiXT1RZzt2YXIgYz1hJiZhW1JnXTt0cnl7aWYoYylyZXR1cm4gYltjXT9uZXcgYltjXShhKTpuZXcgU2coYSk7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhW1RnXSlyZXR1cm4gbmV3IFVnKGEpfWNhdGNoKGQpe31yZXR1cm4gbnVsbH12YXIgVGc9XCJpZFRva2VuXCIsUmc9XCJwcm92aWRlcklkXCI7XG5mdW5jdGlvbiBVZyhhKXt2YXIgYj1hW1JnXTtpZighYiYmYVtUZ10pe3ZhciBjPUhnKGFbVGddKTtjJiZjLmEmJihiPWMuYSl9aWYoIWIpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGFkZGl0aW9uYWwgdXNlciBpbmZvIVwiKTtpZihcImFub255bW91c1wiPT1ifHxcImN1c3RvbVwiPT1iKWI9bnVsbDtjPSExO1widW5kZWZpbmVkXCIhPT10eXBlb2YgYS5pc05ld1VzZXI/Yz0hIWEuaXNOZXdVc2VyOlwiaWRlbnRpdHl0b29sa2l0I1NpZ251cE5ld1VzZXJSZXNwb25zZVwiPT09YS5raW5kJiYoYz0hMCk7TSh0aGlzLFwicHJvdmlkZXJJZFwiLGIpO00odGhpcyxcImlzTmV3VXNlclwiLGMpfWZ1bmN0aW9uIFNnKGEpe1VnLmNhbGwodGhpcyxhKTthPVdmKGEucmF3VXNlckluZm98fFwie31cIik7TSh0aGlzLFwicHJvZmlsZVwiLGtnKGF8fHt9KSl9dChTZyxVZyk7XG5mdW5jdGlvbiBOZyhhKXtTZy5jYWxsKHRoaXMsYSk7aWYoXCJmYWNlYm9vay5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBJRCFcIik7fXQoTmcsU2cpO2Z1bmN0aW9uIFBnKGEpe1NnLmNhbGwodGhpcyxhKTtpZihcImdpdGh1Yi5jb21cIiE9dGhpcy5wcm92aWRlcklkKXRocm93IEVycm9yKFwiSW52YWxpZCBwcm92aWRlciBJRCFcIik7TSh0aGlzLFwidXNlcm5hbWVcIix0aGlzLnByb2ZpbGUmJnRoaXMucHJvZmlsZS5sb2dpbnx8bnVsbCl9dChQZyxTZyk7ZnVuY3Rpb24gT2coYSl7U2cuY2FsbCh0aGlzLGEpO2lmKFwiZ29vZ2xlLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIElEIVwiKTt9dChPZyxTZyk7XG5mdW5jdGlvbiBRZyhhKXtTZy5jYWxsKHRoaXMsYSk7aWYoXCJ0d2l0dGVyLmNvbVwiIT10aGlzLnByb3ZpZGVySWQpdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHByb3ZpZGVyIElEIVwiKTtNKHRoaXMsXCJ1c2VybmFtZVwiLGEuc2NyZWVuTmFtZXx8bnVsbCl9dChRZyxTZyk7ZnVuY3Rpb24gVmcoYSxiKXtyZXR1cm4gYS50aGVuKGZ1bmN0aW9uKGEpe2lmKGFbT10pe3ZhciBjPUhnKGFbT10pO2lmKCFjfHxiIT1jLmIpdGhyb3cgbmV3IE4oXCJ1c2VyLW1pc21hdGNoXCIpO3JldHVybiBhfXRocm93IG5ldyBOKFwidXNlci1taXNtYXRjaFwiKTt9KS5zKGZ1bmN0aW9uKGEpe3Rocm93IGEmJmEuY29kZSYmYS5jb2RlPT10ZytcInVzZXItbm90LWZvdW5kXCI/bmV3IE4oXCJ1c2VyLW1pc21hdGNoXCIpOmE7fSl9XG5mdW5jdGlvbiBXZyhhLGIpe2lmKGIuaWRUb2tlbnx8Yi5hY2Nlc3NUb2tlbiliLmlkVG9rZW4mJk0odGhpcyxcImlkVG9rZW5cIixiLmlkVG9rZW4pLGIuYWNjZXNzVG9rZW4mJk0odGhpcyxcImFjY2Vzc1Rva2VuXCIsYi5hY2Nlc3NUb2tlbik7ZWxzZSBpZihiLm9hdXRoVG9rZW4mJmIub2F1dGhUb2tlblNlY3JldClNKHRoaXMsXCJhY2Nlc3NUb2tlblwiLGIub2F1dGhUb2tlbiksTSh0aGlzLFwic2VjcmV0XCIsYi5vYXV0aFRva2VuU2VjcmV0KTtlbHNlIHRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcImZhaWxlZCB0byBjb25zdHJ1Y3QgYSBjcmVkZW50aWFsXCIpO00odGhpcyxcInByb3ZpZGVySWRcIixhKX1XZy5wcm90b3R5cGUud2E9ZnVuY3Rpb24oYSl7cmV0dXJuIFhnKGEsWWcodGhpcykpfTtXZy5wcm90b3R5cGUuYj1mdW5jdGlvbihhLGIpe3ZhciBjPVlnKHRoaXMpO2MuaWRUb2tlbj1iO3JldHVybiBaZyhhLGMpfTtcbldnLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEsYil7dmFyIGM9WWcodGhpcyk7cmV0dXJuIFZnKCRnKGEsYyksYil9O2Z1bmN0aW9uIFlnKGEpe3ZhciBiPXt9O2EuaWRUb2tlbiYmKGIuaWRfdG9rZW49YS5pZFRva2VuKTthLmFjY2Vzc1Rva2VuJiYoYi5hY2Nlc3NfdG9rZW49YS5hY2Nlc3NUb2tlbik7YS5zZWNyZXQmJihiLm9hdXRoX3Rva2VuX3NlY3JldD1hLnNlY3JldCk7Yi5wcm92aWRlcklkPWEucHJvdmlkZXJJZDtyZXR1cm57cG9zdEJvZHk6SWUoYikudG9TdHJpbmcoKSxyZXF1ZXN0VXJpOlwiaHR0cDovL2xvY2FsaG9zdFwifX1cbldnLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7dmFyIGE9e3Byb3ZpZGVySWQ6dGhpcy5wcm92aWRlcklkfTt0aGlzLmlkVG9rZW4mJihhLm9hdXRoSWRUb2tlbj10aGlzLmlkVG9rZW4pO3RoaXMuYWNjZXNzVG9rZW4mJihhLm9hdXRoQWNjZXNzVG9rZW49dGhpcy5hY2Nlc3NUb2tlbik7dGhpcy5zZWNyZXQmJihhLm9hdXRoVG9rZW5TZWNyZXQ9dGhpcy5zZWNyZXQpO3JldHVybiBhfTtmdW5jdGlvbiBhaChhLGIpe3RoaXMucmM9Ynx8W107Z2codGhpcyx7cHJvdmlkZXJJZDphLGlzT0F1dGhQcm92aWRlcjohMH0pO3RoaXMucmI9e307dGhpcy5XYT0oTGcoYSl8fHt9KS5NYXx8bnVsbDt0aGlzLlVhPW51bGx9YWgucHJvdG90eXBlLkJhPWZ1bmN0aW9uKGEpe3RoaXMucmI9VWEoYSk7cmV0dXJuIHRoaXN9O2Z1bmN0aW9uIFAoYSl7YWguY2FsbCh0aGlzLGEsSmcpO3RoaXMuYT1bXX10KFAsYWgpO1xuUC5wcm90b3R5cGUuc2E9ZnVuY3Rpb24oYSl7SGEodGhpcy5hLGEpfHx0aGlzLmEucHVzaChhKTtyZXR1cm4gdGhpc307UC5wcm90b3R5cGUud2I9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5hKX07UC5wcm90b3R5cGUuY3JlZGVudGlhbD1mdW5jdGlvbihhLGIpe2lmKCFhJiYhYil0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogbXVzdCBwcm92aWRlIHRoZSBJRCB0b2tlbiBhbmQvb3IgdGhlIGFjY2VzcyB0b2tlbi5cIik7cmV0dXJuIG5ldyBXZyh0aGlzLnByb3ZpZGVySWQse2lkVG9rZW46YXx8bnVsbCxhY2Nlc3NUb2tlbjpifHxudWxsfSl9O2Z1bmN0aW9uIGJoKCl7UC5jYWxsKHRoaXMsXCJmYWNlYm9vay5jb21cIil9dChiaCxQKTtNKGJoLFwiUFJPVklERVJfSURcIixcImZhY2Vib29rLmNvbVwiKTtcbmZ1bmN0aW9uIGNoKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcImNyZWRlbnRpYWwgZmFpbGVkOiBleHBlY3RlZCAxIGFyZ3VtZW50ICh0aGUgT0F1dGggYWNjZXNzIHRva2VuKS5cIik7dmFyIGI9YTtxKGEpJiYoYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IGJoKS5jcmVkZW50aWFsKG51bGwsYil9ZnVuY3Rpb24gZGgoKXtQLmNhbGwodGhpcyxcImdpdGh1Yi5jb21cIil9dChkaCxQKTtNKGRoLFwiUFJPVklERVJfSURcIixcImdpdGh1Yi5jb21cIik7ZnVuY3Rpb24gZWgoYSl7aWYoIWEpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwiY3JlZGVudGlhbCBmYWlsZWQ6IGV4cGVjdGVkIDEgYXJndW1lbnQgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4pLlwiKTt2YXIgYj1hO3EoYSkmJihiPWEuYWNjZXNzVG9rZW4pO3JldHVybihuZXcgZGgpLmNyZWRlbnRpYWwobnVsbCxiKX1cbmZ1bmN0aW9uIGZoKCl7UC5jYWxsKHRoaXMsXCJnb29nbGUuY29tXCIpO3RoaXMuc2EoXCJwcm9maWxlXCIpfXQoZmgsUCk7TShmaCxcIlBST1ZJREVSX0lEXCIsXCJnb29nbGUuY29tXCIpO2Z1bmN0aW9uIGdoKGEsYil7dmFyIGM9YTtxKGEpJiYoYz1hLmlkVG9rZW4sYj1hLmFjY2Vzc1Rva2VuKTtyZXR1cm4obmV3IGZoKS5jcmVkZW50aWFsKGMsYil9ZnVuY3Rpb24gaGgoKXthaC5jYWxsKHRoaXMsXCJ0d2l0dGVyLmNvbVwiLElnKX10KGhoLGFoKTtNKGhoLFwiUFJPVklERVJfSURcIixcInR3aXR0ZXIuY29tXCIpO1xuZnVuY3Rpb24gaWgoYSxiKXt2YXIgYz1hO3EoYyl8fChjPXtvYXV0aFRva2VuOmEsb2F1dGhUb2tlblNlY3JldDpifSk7aWYoIWMub2F1dGhUb2tlbnx8IWMub2F1dGhUb2tlblNlY3JldCl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsXCJjcmVkZW50aWFsIGZhaWxlZDogZXhwZWN0ZWQgMiBhcmd1bWVudHMgKHRoZSBPQXV0aCBhY2Nlc3MgdG9rZW4gYW5kIHNlY3JldCkuXCIpO3JldHVybiBuZXcgV2coXCJ0d2l0dGVyLmNvbVwiLGMpfWZ1bmN0aW9uIGpoKGEsYil7dGhpcy5hPWE7dGhpcy5mPWI7TSh0aGlzLFwicHJvdmlkZXJJZFwiLFwicGFzc3dvcmRcIil9amgucHJvdG90eXBlLndhPWZ1bmN0aW9uKGEpe3JldHVybiBRKGEsa2gse2VtYWlsOnRoaXMuYSxwYXNzd29yZDp0aGlzLmZ9KX07amgucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gUShhLGxoLHtpZFRva2VuOmIsZW1haWw6dGhpcy5hLHBhc3N3b3JkOnRoaXMuZn0pfTtcbmpoLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFZnKHRoaXMud2EoYSksYil9O2poLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7cmV0dXJue2VtYWlsOnRoaXMuYSxwYXNzd29yZDp0aGlzLmZ9fTtmdW5jdGlvbiBtaCgpe2dnKHRoaXMse3Byb3ZpZGVySWQ6XCJwYXNzd29yZFwiLGlzT0F1dGhQcm92aWRlcjohMX0pfWdnKG1oLHtQUk9WSURFUl9JRDpcInBhc3N3b3JkXCJ9KTtmdW5jdGlvbiBuaChhKXtpZighKGEuUGEmJmEuT2F8fGEuRGEmJmEuWSkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt0aGlzLmE9YTtNKHRoaXMsXCJwcm92aWRlcklkXCIsXCJwaG9uZVwiKX1uaC5wcm90b3R5cGUud2E9ZnVuY3Rpb24oYSl7cmV0dXJuIGEuUWEob2godGhpcykpfTtuaC5wcm90b3R5cGUuYj1mdW5jdGlvbihhLGIpe3ZhciBjPW9oKHRoaXMpO2MuaWRUb2tlbj1iO3JldHVybiBRKGEscGgsYyl9O1xubmgucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1vaCh0aGlzKTtjLm9wZXJhdGlvbj1cIlJFQVVUSFwiO2E9UShhLHFoLGMpO3JldHVybiBWZyhhLGIpfTtuaC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3ZhciBhPXtwcm92aWRlcklkOlwicGhvbmVcIn07dGhpcy5hLlBhJiYoYS52ZXJpZmljYXRpb25JZD10aGlzLmEuUGEpO3RoaXMuYS5PYSYmKGEudmVyaWZpY2F0aW9uQ29kZT10aGlzLmEuT2EpO3RoaXMuYS5EYSYmKGEudGVtcG9yYXJ5UHJvb2Y9dGhpcy5hLkRhKTt0aGlzLmEuWSYmKGEucGhvbmVOdW1iZXI9dGhpcy5hLlkpO3JldHVybiBhfTtmdW5jdGlvbiBvaChhKXtyZXR1cm4gYS5hLkRhJiZhLmEuWT97dGVtcG9yYXJ5UHJvb2Y6YS5hLkRhLHBob25lTnVtYmVyOmEuYS5ZfTp7c2Vzc2lvbkluZm86YS5hLlBhLGNvZGU6YS5hLk9hfX1cbmZ1bmN0aW9uIHJoKGEpe3RyeXt0aGlzLmE9YXx8ZmlyZWJhc2UuYXV0aCgpfWNhdGNoKGIpe3Rocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcIkVpdGhlciBhbiBpbnN0YW5jZSBvZiBmaXJlYmFzZS5hdXRoLkF1dGggbXVzdCBiZSBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGZpcmViYXNlLmF1dGguUGhvbmVBdXRoUHJvdmlkZXIgY29uc3RydWN0b3IsIG9yIHRoZSBkZWZhdWx0IGZpcmViYXNlIEFwcCBpbnN0YW5jZSBtdXN0IGJlIGluaXRpYWxpemVkIHZpYSBmaXJlYmFzZS5pbml0aWFsaXplQXBwKCkuXCIpO31nZyh0aGlzLHtwcm92aWRlcklkOlwicGhvbmVcIixpc09BdXRoUHJvdmlkZXI6ITF9KX1cbnJoLnByb3RvdHlwZS5RYT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuYS5jO3JldHVybiBBKGIudmVyaWZ5KCkpLnRoZW4oZnVuY3Rpb24oZCl7aWYoIW0oZCkpdGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFwiQW4gaW1wbGVtZW50YXRpb24gb2YgZmlyZWJhc2UuYXV0aC5BcHBsaWNhdGlvblZlcmlmaWVyLnByb3RvdHlwZS52ZXJpZnkoKSBtdXN0IHJldHVybiBhIGZpcmViYXNlLlByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIGEgc3RyaW5nLlwiKTtzd2l0Y2goYi50eXBlKXtjYXNlIFwicmVjYXB0Y2hhXCI6cmV0dXJuIHNoKGMse3Bob25lTnVtYmVyOmEscmVjYXB0Y2hhVG9rZW46ZH0pLnRoZW4oZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVzZXQmJmIucmVzZXQoKTtyZXR1cm4gYX0sZnVuY3Rpb24oYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIGIucmVzZXQmJmIucmVzZXQoKTt0aHJvdyBhO30pO2RlZmF1bHQ6dGhyb3cgbmV3IE4oXCJhcmd1bWVudC1lcnJvclwiLFxuJ09ubHkgZmlyZWJhc2UuYXV0aC5BcHBsaWNhdGlvblZlcmlmaWVycyB3aXRoIHR5cGU9XCJyZWNhcHRjaGFcIiBhcmUgY3VycmVudGx5IHN1cHBvcnRlZC4nKTt9fSl9O2Z1bmN0aW9uIHRoKGEsYil7aWYoIWEpdGhyb3cgbmV3IE4oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1pZFwiKTtpZighYil0aHJvdyBuZXcgTihcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWNvZGVcIik7cmV0dXJuIG5ldyBuaCh7UGE6YSxPYTpifSl9Z2cocmgse1BST1ZJREVSX0lEOlwicGhvbmVcIn0pO1xuZnVuY3Rpb24gdWgoYSl7aWYoYS50ZW1wb3JhcnlQcm9vZiYmYS5waG9uZU51bWJlcilyZXR1cm4gbmV3IG5oKHtEYTphLnRlbXBvcmFyeVByb29mLFk6YS5waG9uZU51bWJlcn0pO3ZhciBiPWEmJmEucHJvdmlkZXJJZDtpZighYnx8XCJwYXNzd29yZFwiPT09YilyZXR1cm4gbnVsbDt2YXIgYz1hJiZhLm9hdXRoQWNjZXNzVG9rZW4sZD1hJiZhLm9hdXRoVG9rZW5TZWNyZXQ7YT1hJiZhLm9hdXRoSWRUb2tlbjt0cnl7c3dpdGNoKGIpe2Nhc2UgXCJnb29nbGUuY29tXCI6cmV0dXJuIGdoKGEsYyk7Y2FzZSBcImZhY2Vib29rLmNvbVwiOnJldHVybiBjaChjKTtjYXNlIFwiZ2l0aHViLmNvbVwiOnJldHVybiBlaChjKTtjYXNlIFwidHdpdHRlci5jb21cIjpyZXR1cm4gaWgoYyxkKTtkZWZhdWx0OnJldHVybihuZXcgUChiKSkuY3JlZGVudGlhbChhLGMpfX1jYXRjaChlKXtyZXR1cm4gbnVsbH19XG5mdW5jdGlvbiB2aChhKXtpZighYS5pc09BdXRoUHJvdmlkZXIpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLW9hdXRoLXByb3ZpZGVyXCIpO307ZnVuY3Rpb24gd2goYSxiLGMsZCxlKXt0aGlzLmI9YTt0aGlzLmM9Ynx8bnVsbDt0aGlzLmY9Y3x8bnVsbDt0aGlzLmc9ZHx8bnVsbDt0aGlzLmE9ZXx8bnVsbDtpZih0aGlzLmZ8fHRoaXMuYSl7aWYodGhpcy5mJiZ0aGlzLmEpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWF1dGgtZXZlbnRcIik7aWYodGhpcy5mJiYhdGhpcy5nKXRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO31lbHNlIHRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO313aC5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3JldHVybnt0eXBlOnRoaXMuYixldmVudElkOnRoaXMuYyx1cmxSZXNwb25zZTp0aGlzLmYsc2Vzc2lvbklkOnRoaXMuZyxlcnJvcjp0aGlzLmEmJnRoaXMuYS5CKCl9fTtmdW5jdGlvbiB4aChhKXthPWF8fHt9O3JldHVybiBhLnR5cGU/bmV3IHdoKGEudHlwZSxhLmV2ZW50SWQsYS51cmxSZXNwb25zZSxhLnNlc3Npb25JZCxhLmVycm9yJiZ2ZyhhLmVycm9yKSk6bnVsbH07ZnVuY3Rpb24geWgoYSl7dmFyIGI9XCJ1bmF1dGhvcml6ZWQtZG9tYWluXCIsYz12b2lkIDAsZD1EZShhKTthPWQuYjtkPWQuYztcImNocm9tZS1leHRlbnNpb25cIj09ZD9jPW9hKFwiVGhpcyBjaHJvbWUgZXh0ZW5zaW9uIElEIChjaHJvbWUtZXh0ZW5zaW9uOi8vJXMpIGlzIG5vdCBhdXRob3JpemVkIHRvIHJ1biB0aGlzIG9wZXJhdGlvbi4gQWRkIGl0IHRvIHRoZSBPQXV0aCByZWRpcmVjdCBkb21haW5zIGxpc3QgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUgLT4gQXV0aCBzZWN0aW9uIC0+IFNpZ24gaW4gbWV0aG9kIHRhYi5cIixhKTpcImh0dHBcIj09ZHx8XCJodHRwc1wiPT1kP2M9b2EoXCJUaGlzIGRvbWFpbiAoJXMpIGlzIG5vdCBhdXRob3JpemVkIHRvIHJ1biB0aGlzIG9wZXJhdGlvbi4gQWRkIGl0IHRvIHRoZSBPQXV0aCByZWRpcmVjdCBkb21haW5zIGxpc3QgaW4gdGhlIEZpcmViYXNlIGNvbnNvbGUgLT4gQXV0aCBzZWN0aW9uIC0+IFNpZ24gaW4gbWV0aG9kIHRhYi5cIixhKTpiPVwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiO1xuTi5jYWxsKHRoaXMsYixjKX10KHloLE4pO2Z1bmN0aW9uIHpoKGEsYixjKXtOLmNhbGwodGhpcyxhLGMpO2E9Ynx8e307YS5zYiYmTSh0aGlzLFwiZW1haWxcIixhLnNiKTthLlkmJk0odGhpcyxcInBob25lTnVtYmVyXCIsYS5ZKTthLmNyZWRlbnRpYWwmJk0odGhpcyxcImNyZWRlbnRpYWxcIixhLmNyZWRlbnRpYWwpfXQoemgsTik7emgucHJvdG90eXBlLkI9ZnVuY3Rpb24oKXt2YXIgYT17Y29kZTp0aGlzLmNvZGUsbWVzc2FnZTp0aGlzLm1lc3NhZ2V9O3RoaXMuZW1haWwmJihhLmVtYWlsPXRoaXMuZW1haWwpO3RoaXMucGhvbmVOdW1iZXImJihhLnBob25lTnVtYmVyPXRoaXMucGhvbmVOdW1iZXIpO3ZhciBiPXRoaXMuY3JlZGVudGlhbCYmdGhpcy5jcmVkZW50aWFsLkIoKTtiJiZXYShhLGIpO3JldHVybiBhfTt6aC5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQigpfTtcbmZ1bmN0aW9uIEFoKGEpe2lmKGEuY29kZSl7dmFyIGI9YS5jb2RlfHxcIlwiOzA9PWIuaW5kZXhPZih0ZykmJihiPWIuc3Vic3RyaW5nKHRnLmxlbmd0aCkpO3ZhciBjPXtjcmVkZW50aWFsOnVoKGEpfTtpZihhLmVtYWlsKWMuc2I9YS5lbWFpbDtlbHNlIGlmKGEucGhvbmVOdW1iZXIpYy5ZPWEucGhvbmVOdW1iZXI7ZWxzZSByZXR1cm4gbmV3IE4oYixhLm1lc3NhZ2V8fHZvaWQgMCk7cmV0dXJuIG5ldyB6aChiLGMsYS5tZXNzYWdlKX1yZXR1cm4gbnVsbH07ZnVuY3Rpb24gQmgoYSl7dGhpcy5mPWF9dChCaCxOZSk7QmgucHJvdG90eXBlLmE9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHRoaXMuZn07QmgucHJvdG90eXBlLmI9ZnVuY3Rpb24oKXtyZXR1cm57fX07XG5mdW5jdGlvbiBDaChhLGIsYyl7dmFyIGQ9XCJOb2RlXCI9PUsoKTtkPWsuWE1MSHR0cFJlcXVlc3R8fGQmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUuWE1MSHR0cFJlcXVlc3Q7aWYoIWQpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFwiVGhlIFhNTEh0dHBSZXF1ZXN0IGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt0aGlzLmI9YTthPWJ8fHt9O3RoaXMuaT1hLnNlY3VyZVRva2VuRW5kcG9pbnR8fFwiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbS92MS90b2tlblwiO3RoaXMubD1hLnNlY3VyZVRva2VuVGltZW91dHx8RGg7dGhpcy5jPVVhKGEuc2VjdXJlVG9rZW5IZWFkZXJzfHxFaCk7dGhpcy5nPWEuZmlyZWJhc2VFbmRwb2ludHx8XCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiO3RoaXMuaD1hLmZpcmViYXNlVGltZW91dHx8Rmg7dGhpcy5hPVxuVWEoYS5maXJlYmFzZUhlYWRlcnN8fEdoKTtjJiYodGhpcy5hW1wiWC1DbGllbnQtVmVyc2lvblwiXT1jLHRoaXMuY1tcIlgtQ2xpZW50LVZlcnNpb25cIl09Yyk7dGhpcy5mPW5ldyByZjt0aGlzLm89bmV3IEJoKGQpfXZhciBIaCxPPVwiaWRUb2tlblwiLERoPW5ldyAkZigzRTQsNkU0KSxFaD17XCJDb250ZW50LVR5cGVcIjpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwifSxGaD1uZXcgJGYoM0U0LDZFNCksR2g9e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9O2Z1bmN0aW9uIEloKGEsYil7Yj9hLmFbXCJYLUZpcmViYXNlLUxvY2FsZVwiXT1iOmRlbGV0ZSBhLmFbXCJYLUZpcmViYXNlLUxvY2FsZVwiXX1mdW5jdGlvbiBKaChhLGIpe2I/KGEuYVtcIlgtQ2xpZW50LVZlcnNpb25cIl09YixhLmNbXCJYLUNsaWVudC1WZXJzaW9uXCJdPWIpOihkZWxldGUgYS5hW1wiWC1DbGllbnQtVmVyc2lvblwiXSxkZWxldGUgYS5jW1wiWC1DbGllbnQtVmVyc2lvblwiXSl9XG5mdW5jdGlvbiBLaChhLGIsYyxkLGUsZixnKXtaZigpPyh5ZigpP2E9cihhLm0sYSk6KEhofHwoSGg9bmV3IHooZnVuY3Rpb24oYSxiKXtMaChhLGIpfSkpLGE9cihhLnUsYSkpLGEoYixjLGQsZSxmLGcpKTpjJiZjKG51bGwpfVxuQ2gucHJvdG90eXBlLm09ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3ZhciBnPVwiTm9kZVwiPT1LKCksbD1NZigpP2c/bmV3IFNlKHRoaXMubyk6bmV3IFNlOm5ldyBTZSh0aGlzLmYpO2lmKGYpe2wuZj1NYXRoLm1heCgwLGYpO3ZhciBuPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtHKGwsXCJ0aW1lb3V0XCIpfSxmKX1mZChsLFwiY29tcGxldGVcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTt2YXIgYT1udWxsO3RyeXthPUpTT04ucGFyc2UoaGYodGhpcykpfHxudWxsfWNhdGNoKHZiKXthPW51bGx9YiYmYihhKX0pO2xkKGwsXCJyZWFkeVwiLGZ1bmN0aW9uKCl7biYmY2xlYXJUaW1lb3V0KG4pO0xjKHRoaXMpfSk7bGQobCxcInRpbWVvdXRcIixmdW5jdGlvbigpe24mJmNsZWFyVGltZW91dChuKTtMYyh0aGlzKTtiJiZiKG51bGwpfSk7WWUobCxhLGMsZCxlKX07XG52YXIgTWg9ZGMoXCJodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9jbGllbnQuanM/b25sb2FkPSV7b25sb2FkfVwiKSxOaD1cIl9fZmNiXCIrTWF0aC5mbG9vcigxRTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKTtmdW5jdGlvbiBMaChhLGIpe2lmKCgod2luZG93LmdhcGl8fHt9KS5jbGllbnR8fHt9KS5yZXF1ZXN0KWEoKTtlbHNle2tbTmhdPWZ1bmN0aW9uKCl7KCh3aW5kb3cuZ2FwaXx8e30pLmNsaWVudHx8e30pLnJlcXVlc3Q/YSgpOmIoRXJyb3IoXCJDT1JTX1VOU1VQUE9SVEVEXCIpKX07dmFyIGM9aGMoTWgse29ubG9hZDpOaH0pO1RkKGtmKGMpLGZ1bmN0aW9uKCl7YihFcnJvcihcIkNPUlNfVU5TVVBQT1JURURcIikpfSl9fVxuQ2gucHJvdG90eXBlLnU9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj10aGlzO0hoLnRoZW4oZnVuY3Rpb24oKXt3aW5kb3cuZ2FwaS5jbGllbnQuc2V0QXBpS2V5KGYuYik7dmFyIGc9d2luZG93LmdhcGkuYXV0aC5nZXRUb2tlbigpO3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4obnVsbCk7d2luZG93LmdhcGkuY2xpZW50LnJlcXVlc3Qoe3BhdGg6YSxtZXRob2Q6Yyxib2R5OmQsaGVhZGVyczplLGF1dGhUeXBlOlwibm9uZVwiLGNhbGxiYWNrOmZ1bmN0aW9uKGEpe3dpbmRvdy5nYXBpLmF1dGguc2V0VG9rZW4oZyk7YiYmYihhKX19KX0pLnMoZnVuY3Rpb24oYSl7YiYmYih7ZXJyb3I6e21lc3NhZ2U6YSYmYS5tZXNzYWdlfHxcIkNPUlNfVU5TVVBQT1JURURcIn19KX0pfTtcbmZ1bmN0aW9uIE9oKGEsYil7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGMsZCl7XCJyZWZyZXNoX3Rva2VuXCI9PWIuZ3JhbnRfdHlwZSYmYi5yZWZyZXNoX3Rva2VufHxcImF1dGhvcml6YXRpb25fY29kZVwiPT1iLmdyYW50X3R5cGUmJmIuY29kZT9LaChhLGEuaStcIj9rZXk9XCIrZW5jb2RlVVJJQ29tcG9uZW50KGEuYiksZnVuY3Rpb24oYSl7YT9hLmVycm9yP2QoUGgoYSkpOmEuYWNjZXNzX3Rva2VuJiZhLnJlZnJlc2hfdG9rZW4/YyhhKTpkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpOmQobmV3IE4oXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIpKX0sXCJQT1NUXCIsSWUoYikudG9TdHJpbmcoKSxhLmMsYS5sLmdldCgpKTpkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpfSl9XG5mdW5jdGlvbiBRaChhLGIsYyxkLGUsZil7dmFyIGc9RGUoYS5nK2IpO0koZyxcImtleVwiLGEuYik7ZiYmSShnLFwiY2JcIixuYSgpLnRvU3RyaW5nKCkpO3ZhciBsPVwiR0VUXCI9PWM7aWYobClmb3IodmFyIG4gaW4gZClkLmhhc093blByb3BlcnR5KG4pJiZJKGcsbixkW25dKTtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYixmKXtLaChhLGcudG9TdHJpbmcoKSxmdW5jdGlvbihhKXthP2EuZXJyb3I/ZihQaChhLGV8fHt9KSk6YihhKTpmKG5ldyBOKFwibmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiKSl9LGMsbD92b2lkIDA6Q2MoVmYoZCkpLGEuYSxhLmguZ2V0KCkpfSl9ZnVuY3Rpb24gUmgoYSl7aWYoIWpmLnRlc3QoYS5lbWFpbCkpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWVtYWlsXCIpO31mdW5jdGlvbiBTaChhKXtcImVtYWlsXCJpbiBhJiZSaChhKX1cbmZ1bmN0aW9uIFRoKGEsYil7cmV0dXJuIFEoYSxVaCx7aWRlbnRpZmllcjpiLGNvbnRpbnVlVXJpOlNmKCk/dmYoKTpcImh0dHA6Ly9sb2NhbGhvc3RcIn0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYWxsUHJvdmlkZXJzfHxbXX0pfWZ1bmN0aW9uIFZoKGEpe3JldHVybiBRKGEsV2gse30pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEuYXV0aG9yaXplZERvbWFpbnN8fFtdfSl9ZnVuY3Rpb24gWGgoYSl7aWYoIWFbT10pdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9XG5mdW5jdGlvbiBZaChhKXtpZihhLnBob25lTnVtYmVyfHxhLnRlbXBvcmFyeVByb29mKXtpZighYS5waG9uZU51bWJlcnx8IWEudGVtcG9yYXJ5UHJvb2YpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9ZWxzZXtpZighYS5zZXNzaW9uSW5mbyl0aHJvdyBuZXcgTihcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIpO2lmKCFhLmNvZGUpdGhyb3cgbmV3IE4oXCJtaXNzaW5nLXZlcmlmaWNhdGlvbi1jb2RlXCIpO319Q2gucHJvdG90eXBlLmdiPWZ1bmN0aW9uKCl7cmV0dXJuIFEodGhpcyxaaCx7fSl9O0NoLnByb3RvdHlwZS5rYj1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsJGgse2lkVG9rZW46YSxlbWFpbDpifSl9O0NoLnByb3RvdHlwZS5sYj1mdW5jdGlvbihhLGIpe3JldHVybiBRKHRoaXMsbGgse2lkVG9rZW46YSxwYXNzd29yZDpifSl9O3ZhciBhaT17ZGlzcGxheU5hbWU6XCJESVNQTEFZX05BTUVcIixwaG90b1VybDpcIlBIT1RPX1VSTFwifTtoPUNoLnByb3RvdHlwZTtcbmgubWI9ZnVuY3Rpb24oYSxiKXt2YXIgYz17aWRUb2tlbjphfSxkPVtdO1BhKGFpLGZ1bmN0aW9uKGEsZil7dmFyIGU9YltmXTtudWxsPT09ZT9kLnB1c2goYSk6ZiBpbiBiJiYoY1tmXT1lKX0pO2QubGVuZ3RoJiYoYy5kZWxldGVBdHRyaWJ1dGU9ZCk7cmV0dXJuIFEodGhpcywkaCxjKX07aC5jYj1mdW5jdGlvbihhLGIpe2E9e3JlcXVlc3RUeXBlOlwiUEFTU1dPUkRfUkVTRVRcIixlbWFpbDphfTtXYShhLGIpO3JldHVybiBRKHRoaXMsYmksYSl9O2guYmI9ZnVuY3Rpb24oYSxiKXthPXtyZXF1ZXN0VHlwZTpcIlZFUklGWV9FTUFJTFwiLGlkVG9rZW46YX07V2EoYSxiKTtyZXR1cm4gUSh0aGlzLGNpLGEpfTtmdW5jdGlvbiBzaChhLGIpe3JldHVybiBRKGEsZGksYil9aC5RYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLGVpLGEpfTtmdW5jdGlvbiBmaShhLGIsYyl7cmV0dXJuIFEoYSxnaSx7aWRUb2tlbjpiLGRlbGV0ZVByb3ZpZGVyOmN9KX1cbmZ1bmN0aW9uIGhpKGEpe2lmKCFhLnJlcXVlc3RVcml8fCFhLnNlc3Npb25JZCYmIWEucG9zdEJvZHkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9ZnVuY3Rpb24gaWkoYSl7dmFyIGI9bnVsbDthLm5lZWRDb25maXJtYXRpb24/KGEuY29kZT1cImFjY291bnQtZXhpc3RzLXdpdGgtZGlmZmVyZW50LWNyZWRlbnRpYWxcIixiPUFoKGEpKTpcIkZFREVSQVRFRF9VU0VSX0lEX0FMUkVBRFlfTElOS0VEXCI9PWEuZXJyb3JNZXNzYWdlPyhhLmNvZGU9XCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIsYj1BaChhKSk6XCJFTUFJTF9FWElTVFNcIj09YS5lcnJvck1lc3NhZ2U/KGEuY29kZT1cImVtYWlsLWFscmVhZHktaW4tdXNlXCIsYj1BaChhKSk6YS5lcnJvck1lc3NhZ2UmJihiPWppKGEuZXJyb3JNZXNzYWdlKSk7aWYoYil0aHJvdyBiO2lmKCFhW09dKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7fVxuZnVuY3Rpb24gWGcoYSxiKXtiLnJldHVybklkcENyZWRlbnRpYWw9ITA7cmV0dXJuIFEoYSxraSxiKX1mdW5jdGlvbiBaZyhhLGIpe2IucmV0dXJuSWRwQ3JlZGVudGlhbD0hMDtyZXR1cm4gUShhLGxpLGIpfWZ1bmN0aW9uICRnKGEsYil7Yi5yZXR1cm5JZHBDcmVkZW50aWFsPSEwO2IuYXV0b0NyZWF0ZT0hMTtyZXR1cm4gUShhLG1pLGIpfWZ1bmN0aW9uIG5pKGEpe2lmKCFhLm9vYkNvZGUpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIpO31oLlRhPWZ1bmN0aW9uKGEsYil7cmV0dXJuIFEodGhpcyxvaSx7b29iQ29kZTphLG5ld1Bhc3N3b3JkOmJ9KX07aC5JYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLHBpLHtvb2JDb2RlOmF9KX07aC5TYT1mdW5jdGlvbihhKXtyZXR1cm4gUSh0aGlzLHFpLHtvb2JDb2RlOmF9KX07XG52YXIgcWk9e2VuZHBvaW50Olwic2V0QWNjb3VudEluZm9cIixEOm5pLGdhOlwiZW1haWxcIn0scGk9e2VuZHBvaW50OlwicmVzZXRQYXNzd29yZFwiLEQ6bmksTzpmdW5jdGlvbihhKXtpZighYS5lbWFpbHx8IWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxyaT17ZW5kcG9pbnQ6XCJzaWdudXBOZXdVc2VyXCIsRDpmdW5jdGlvbihhKXtSaChhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgTihcIndlYWstcGFzc3dvcmRcIik7fSxPOlhoLFQ6ITB9LFVoPXtlbmRwb2ludDpcImNyZWF0ZUF1dGhVcmlcIn0sc2k9e2VuZHBvaW50OlwiZGVsZXRlQWNjb3VudFwiLGVhOltcImlkVG9rZW5cIl19LGdpPXtlbmRwb2ludDpcInNldEFjY291bnRJbmZvXCIsZWE6W1wiaWRUb2tlblwiLFwiZGVsZXRlUHJvdmlkZXJcIl0sRDpmdW5jdGlvbihhKXtpZighZmEoYS5kZWxldGVQcm92aWRlcikpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSx0aT17ZW5kcG9pbnQ6XCJnZXRBY2NvdW50SW5mb1wifSxcbmNpPXtlbmRwb2ludDpcImdldE9vYkNvbmZpcm1hdGlvbkNvZGVcIixlYTpbXCJpZFRva2VuXCIsXCJyZXF1ZXN0VHlwZVwiXSxEOmZ1bmN0aW9uKGEpe2lmKFwiVkVSSUZZX0VNQUlMXCIhPWEucmVxdWVzdFR5cGUpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9LGdhOlwiZW1haWxcIn0sYmk9e2VuZHBvaW50OlwiZ2V0T29iQ29uZmlybWF0aW9uQ29kZVwiLGVhOltcInJlcXVlc3RUeXBlXCJdLEQ6ZnVuY3Rpb24oYSl7aWYoXCJQQVNTV09SRF9SRVNFVFwiIT1hLnJlcXVlc3RUeXBlKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7UmgoYSl9LGdhOlwiZW1haWxcIn0sV2g9e25iOiEwLGVuZHBvaW50OlwiZ2V0UHJvamVjdENvbmZpZ1wiLHpiOlwiR0VUXCJ9LHVpPXtuYjohMCxlbmRwb2ludDpcImdldFJlY2FwdGNoYVBhcmFtXCIsemI6XCJHRVRcIixPOmZ1bmN0aW9uKGEpe2lmKCFhLnJlY2FwdGNoYVNpdGVLZXkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiKTt9fSxvaT17ZW5kcG9pbnQ6XCJyZXNldFBhc3N3b3JkXCIsXG5EOm5pLGdhOlwiZW1haWxcIn0sZGk9e2VuZHBvaW50Olwic2VuZFZlcmlmaWNhdGlvbkNvZGVcIixlYTpbXCJwaG9uZU51bWJlclwiLFwicmVjYXB0Y2hhVG9rZW5cIl0sZ2E6XCJzZXNzaW9uSW5mb1wifSwkaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLGVhOltcImlkVG9rZW5cIl0sRDpTaCxUOiEwfSxsaD17ZW5kcG9pbnQ6XCJzZXRBY2NvdW50SW5mb1wiLGVhOltcImlkVG9rZW5cIl0sRDpmdW5jdGlvbihhKXtTaChhKTtpZighYS5wYXNzd29yZCl0aHJvdyBuZXcgTihcIndlYWstcGFzc3dvcmRcIik7fSxPOlhoLFQ6ITB9LFpoPXtlbmRwb2ludDpcInNpZ251cE5ld1VzZXJcIixPOlhoLFQ6ITB9LGtpPXtlbmRwb2ludDpcInZlcmlmeUFzc2VydGlvblwiLEQ6aGksTzppaSxUOiEwfSxtaT17ZW5kcG9pbnQ6XCJ2ZXJpZnlBc3NlcnRpb25cIixEOmhpLE86ZnVuY3Rpb24oYSl7aWYoYS5lcnJvck1lc3NhZ2UmJlwiVVNFUl9OT1RfRk9VTkRcIj09YS5lcnJvck1lc3NhZ2UpdGhyb3cgbmV3IE4oXCJ1c2VyLW5vdC1mb3VuZFwiKTtcbmlmKGEuZXJyb3JNZXNzYWdlKXRocm93IGppKGEuZXJyb3JNZXNzYWdlKTtpZighYVtPXSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIpO30sVDohMH0sbGk9e2VuZHBvaW50OlwidmVyaWZ5QXNzZXJ0aW9uXCIsRDpmdW5jdGlvbihhKXtoaShhKTtpZighYS5pZFRva2VuKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7fSxPOmlpLFQ6ITB9LHZpPXtlbmRwb2ludDpcInZlcmlmeUN1c3RvbVRva2VuXCIsRDpmdW5jdGlvbihhKXtpZighYS50b2tlbil0aHJvdyBuZXcgTihcImludmFsaWQtY3VzdG9tLXRva2VuXCIpO30sTzpYaCxUOiEwfSxraD17ZW5kcG9pbnQ6XCJ2ZXJpZnlQYXNzd29yZFwiLEQ6ZnVuY3Rpb24oYSl7UmgoYSk7aWYoIWEucGFzc3dvcmQpdGhyb3cgbmV3IE4oXCJ3cm9uZy1wYXNzd29yZFwiKTt9LE86WGgsVDohMH0sZWk9e2VuZHBvaW50OlwidmVyaWZ5UGhvbmVOdW1iZXJcIixEOlloLE86WGh9LHBoPXtlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRDpmdW5jdGlvbihhKXtpZighYS5pZFRva2VuKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7XG5ZaChhKX0sTzpmdW5jdGlvbihhKXtpZihhLnRlbXBvcmFyeVByb29mKXRocm93IGEuY29kZT1cImNyZWRlbnRpYWwtYWxyZWFkeS1pbi11c2VcIixBaChhKTtYaChhKX19LHFoPXtQYjp7VVNFUl9OT1RfRk9VTkQ6XCJ1c2VyLW5vdC1mb3VuZFwifSxlbmRwb2ludDpcInZlcmlmeVBob25lTnVtYmVyXCIsRDpZaCxPOlhofTtcbmZ1bmN0aW9uIFEoYSxiLGMpe2lmKCFqZyhjLGIuZWEpKXJldHVybiBCKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpO3ZhciBkPWIuemJ8fFwiUE9TVFwiLGU7cmV0dXJuIEEoYykudGhlbihiLkQpLnRoZW4oZnVuY3Rpb24oKXtiLlQmJihjLnJldHVyblNlY3VyZVRva2VuPSEwKTtyZXR1cm4gUWgoYSxiLmVuZHBvaW50LGQsYyxiLlBiLGIubmJ8fCExKX0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGU9YX0pLnRoZW4oYi5PKS50aGVuKGZ1bmN0aW9uKCl7aWYoIWIuZ2EpcmV0dXJuIGU7aWYoIShiLmdhIGluIGUpKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7cmV0dXJuIGVbYi5nYV19KX1mdW5jdGlvbiBqaShhKXtyZXR1cm4gUGgoe2Vycm9yOntlcnJvcnM6W3ttZXNzYWdlOmF9XSxjb2RlOjQwMCxtZXNzYWdlOmF9fSl9XG5mdW5jdGlvbiBQaChhLGIpe3ZhciBjPShhLmVycm9yJiZhLmVycm9yLmVycm9ycyYmYS5lcnJvci5lcnJvcnNbMF18fHt9KS5yZWFzb258fFwiXCI7dmFyIGQ9e2tleUludmFsaWQ6XCJpbnZhbGlkLWFwaS1rZXlcIixpcFJlZmVyZXJCbG9ja2VkOlwiYXBwLW5vdC1hdXRob3JpemVkXCJ9O2lmKGM9ZFtjXT9uZXcgTihkW2NdKTpudWxsKXJldHVybiBjO2M9YS5lcnJvciYmYS5lcnJvci5tZXNzYWdlfHxcIlwiO2Q9e0lOVkFMSURfQ1VTVE9NX1RPS0VOOlwiaW52YWxpZC1jdXN0b20tdG9rZW5cIixDUkVERU5USUFMX01JU01BVENIOlwiY3VzdG9tLXRva2VuLW1pc21hdGNoXCIsTUlTU0lOR19DVVNUT01fVE9LRU46XCJpbnRlcm5hbC1lcnJvclwiLElOVkFMSURfSURFTlRJRklFUjpcImludmFsaWQtZW1haWxcIixNSVNTSU5HX0NPTlRJTlVFX1VSSTpcImludGVybmFsLWVycm9yXCIsSU5WQUxJRF9FTUFJTDpcImludmFsaWQtZW1haWxcIixJTlZBTElEX1BBU1NXT1JEOlwid3JvbmctcGFzc3dvcmRcIixVU0VSX0RJU0FCTEVEOlwidXNlci1kaXNhYmxlZFwiLFxuTUlTU0lOR19QQVNTV09SRDpcImludGVybmFsLWVycm9yXCIsRU1BSUxfRVhJU1RTOlwiZW1haWwtYWxyZWFkeS1pbi11c2VcIixQQVNTV09SRF9MT0dJTl9ESVNBQkxFRDpcIm9wZXJhdGlvbi1ub3QtYWxsb3dlZFwiLElOVkFMSURfSURQX1JFU1BPTlNFOlwiaW52YWxpZC1jcmVkZW50aWFsXCIsRkVERVJBVEVEX1VTRVJfSURfQUxSRUFEWV9MSU5LRUQ6XCJjcmVkZW50aWFsLWFscmVhZHktaW4tdXNlXCIsSU5WQUxJRF9NRVNTQUdFX1BBWUxPQUQ6XCJpbnZhbGlkLW1lc3NhZ2UtcGF5bG9hZFwiLElOVkFMSURfUkVDSVBJRU5UX0VNQUlMOlwiaW52YWxpZC1yZWNpcGllbnQtZW1haWxcIixJTlZBTElEX1NFTkRFUjpcImludmFsaWQtc2VuZGVyXCIsRU1BSUxfTk9UX0ZPVU5EOlwidXNlci1ub3QtZm91bmRcIixFWFBJUkVEX09PQl9DT0RFOlwiZXhwaXJlZC1hY3Rpb24tY29kZVwiLElOVkFMSURfT09CX0NPREU6XCJpbnZhbGlkLWFjdGlvbi1jb2RlXCIsTUlTU0lOR19PT0JfQ09ERTpcImludGVybmFsLWVycm9yXCIsQ1JFREVOVElBTF9UT09fT0xEX0xPR0lOX0FHQUlOOlwicmVxdWlyZXMtcmVjZW50LWxvZ2luXCIsXG5JTlZBTElEX0lEX1RPS0VOOlwiaW52YWxpZC11c2VyLXRva2VuXCIsVE9LRU5fRVhQSVJFRDpcInVzZXItdG9rZW4tZXhwaXJlZFwiLFVTRVJfTk9UX0ZPVU5EOlwidXNlci10b2tlbi1leHBpcmVkXCIsQ09SU19VTlNVUFBPUlRFRDpcImNvcnMtdW5zdXBwb3J0ZWRcIixEWU5BTUlDX0xJTktfTk9UX0FDVElWQVRFRDpcImR5bmFtaWMtbGluay1ub3QtYWN0aXZhdGVkXCIsSU5WQUxJRF9BUFBfSUQ6XCJpbnZhbGlkLWFwcC1pZFwiLFRPT19NQU5ZX0FUVEVNUFRTX1RSWV9MQVRFUjpcInRvby1tYW55LXJlcXVlc3RzXCIsV0VBS19QQVNTV09SRDpcIndlYWstcGFzc3dvcmRcIixPUEVSQVRJT05fTk9UX0FMTE9XRUQ6XCJvcGVyYXRpb24tbm90LWFsbG93ZWRcIixVU0VSX0NBTkNFTExFRDpcInVzZXItY2FuY2VsbGVkXCIsQ0FQVENIQV9DSEVDS19GQUlMRUQ6XCJjYXB0Y2hhLWNoZWNrLWZhaWxlZFwiLElOVkFMSURfQVBQX0NSRURFTlRJQUw6XCJpbnZhbGlkLWFwcC1jcmVkZW50aWFsXCIsSU5WQUxJRF9DT0RFOlwiaW52YWxpZC12ZXJpZmljYXRpb24tY29kZVwiLFxuSU5WQUxJRF9QSE9ORV9OVU1CRVI6XCJpbnZhbGlkLXBob25lLW51bWJlclwiLElOVkFMSURfU0VTU0lPTl9JTkZPOlwiaW52YWxpZC12ZXJpZmljYXRpb24taWRcIixJTlZBTElEX1RFTVBPUkFSWV9QUk9PRjpcImludmFsaWQtY3JlZGVudGlhbFwiLE1JU1NJTkdfQVBQX0NSRURFTlRJQUw6XCJtaXNzaW5nLWFwcC1jcmVkZW50aWFsXCIsTUlTU0lOR19DT0RFOlwibWlzc2luZy12ZXJpZmljYXRpb24tY29kZVwiLE1JU1NJTkdfUEhPTkVfTlVNQkVSOlwibWlzc2luZy1waG9uZS1udW1iZXJcIixNSVNTSU5HX1NFU1NJT05fSU5GTzpcIm1pc3NpbmctdmVyaWZpY2F0aW9uLWlkXCIsUVVPVEFfRVhDRUVERUQ6XCJxdW90YS1leGNlZWRlZFwiLFNFU1NJT05fRVhQSVJFRDpcImNvZGUtZXhwaXJlZFwiLElOVkFMSURfQ09OVElOVUVfVVJJOlwiaW52YWxpZC1jb250aW51ZS11cmlcIixNSVNTSU5HX0FORFJPSURfUEFDS0FHRV9OQU1FOlwibWlzc2luZy1hbmRyb2lkLXBrZy1uYW1lXCIsTUlTU0lOR19JT1NfQlVORExFX0lEOlwibWlzc2luZy1pb3MtYnVuZGxlLWlkXCIsXG5VTkFVVEhPUklaRURfRE9NQUlOOlwidW5hdXRob3JpemVkLWNvbnRpbnVlLXVyaVwiLElOVkFMSURfT0FVVEhfQ0xJRU5UX0lEOlwiaW52YWxpZC1vYXV0aC1jbGllbnQtaWRcIixJTlZBTElEX0NFUlRfSEFTSDpcImludmFsaWQtY2VydC1oYXNoXCJ9O1dhKGQsYnx8e30pO2I9KGI9Yy5tYXRjaCgvXlteXFxzXStcXHMqOlxccyooLiopJC8pKSYmMTxiLmxlbmd0aD9iWzFdOnZvaWQgMDtmb3IodmFyIGUgaW4gZClpZigwPT09Yy5pbmRleE9mKGUpKXJldHVybiBuZXcgTihkW2VdLGIpOyFiJiZhJiYoYj1VZihhKSk7cmV0dXJuIG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixiKX07dmFyIHdpPXtNYzp7VmE6XCJodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9pZGVudGl0eXRvb2xraXQvdjMvcmVseWluZ3BhcnR5L1wiLGFiOlwiaHR0cHM6Ly9zZWN1cmV0b2tlbi5nb29nbGVhcGlzLmNvbS92MS90b2tlblwiLGlkOlwicFwifSxPYzp7VmE6XCJodHRwczovL3N0YWdpbmctd3d3LnNhbmRib3guZ29vZ2xlYXBpcy5jb20vaWRlbnRpdHl0b29sa2l0L3YzL3JlbHlpbmdwYXJ0eS9cIixhYjpcImh0dHBzOi8vc3RhZ2luZy1zZWN1cmV0b2tlbi5zYW5kYm94Lmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCIsaWQ6XCJzXCJ9LFBjOntWYTpcImh0dHBzOi8vd3d3LWdvb2dsZWFwaXMtdGVzdC5zYW5kYm94Lmdvb2dsZS5jb20vaWRlbnRpdHl0b29sa2l0L3YzL3JlbHlpbmdwYXJ0eS9cIixhYjpcImh0dHBzOi8vdGVzdC1zZWN1cmV0b2tlbi5zYW5kYm94Lmdvb2dsZWFwaXMuY29tL3YxL3Rva2VuXCIsaWQ6XCJ0XCJ9fTtcbmZ1bmN0aW9uIHhpKGEpe2Zvcih2YXIgYiBpbiB3aSlpZih3aVtiXS5pZD09PWEpcmV0dXJuIGE9d2lbYl0se2ZpcmViYXNlRW5kcG9pbnQ6YS5WYSxzZWN1cmVUb2tlbkVuZHBvaW50OmEuYWJ9O3JldHVybiBudWxsfXZhciB5aTt5aT14aShcIl9fRUlEX19cIik/XCJfX0VJRF9fXCI6dm9pZCAwO2Z1bmN0aW9uIHppKGEpe3RoaXMuYj1hO3RoaXMuYT1udWxsO3RoaXMuWWE9QWkodGhpcyl9XG5mdW5jdGlvbiBBaShhKXtyZXR1cm4gQmkoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIsYyl7TChcImdhcGkuaWZyYW1lcy5nZXRDb250ZXh0XCIpKCkub3Blbih7d2hlcmU6ZG9jdW1lbnQuYm9keSx1cmw6YS5iLG1lc3NhZ2VIYW5kbGVyc0ZpbHRlcjpMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSxhdHRyaWJ1dGVzOntzdHlsZTp7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi0xMDBweFwiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCJ9fSxkb250Y2xlYXI6ITB9LGZ1bmN0aW9uKGQpe2Z1bmN0aW9uIGUoKXtjbGVhclRpbWVvdXQoZik7YigpfWEuYT1kO2EuYS5yZXN0eWxlKHtzZXRIaWRlT25MZWF2ZTohMX0pO3ZhciBmPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtjKEVycm9yKFwiTmV0d29yayBFcnJvclwiKSl9LENpLmdldCgpKTtkLnBpbmcoZSkudGhlbihlLGZ1bmN0aW9uKCl7YyhFcnJvcihcIk5ldHdvcmsgRXJyb3JcIikpfSl9KX0pfSl9XG5mdW5jdGlvbiBEaShhLGIpe3JldHVybiBhLllhLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHooZnVuY3Rpb24oYyl7YS5hLnNlbmQoYi50eXBlLGIsYyxMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSl9KX0pfWZ1bmN0aW9uIEVpKGEsYil7YS5ZYS50aGVuKGZ1bmN0aW9uKCl7YS5hLnJlZ2lzdGVyKFwiYXV0aEV2ZW50XCIsYixMKFwiZ2FwaS5pZnJhbWVzLkNST1NTX09SSUdJTl9JRlJBTUVTX0ZJTFRFUlwiKSl9KX12YXIgRmk9ZGMoXCJodHRwczovL2FwaXMuZ29vZ2xlLmNvbS9qcy9hcGkuanM/b25sb2FkPSV7b25sb2FkfVwiKSxHaT1uZXcgJGYoM0U0LDZFNCksQ2k9bmV3ICRmKDVFMywxNUUzKSxIaT1udWxsO1xuZnVuY3Rpb24gQmkoKXtyZXR1cm4gSGk/SGk6SGk9KG5ldyB6KGZ1bmN0aW9uKGEsYil7aWYoWmYoKSl7dmFyIGM9ZnVuY3Rpb24oKXtZZigpO0woXCJnYXBpLmxvYWRcIikoXCJnYXBpLmlmcmFtZXNcIix7Y2FsbGJhY2s6YSxvbnRpbWVvdXQ6ZnVuY3Rpb24oKXtZZigpO2IoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0sdGltZW91dDpHaS5nZXQoKX0pfTtpZihMKFwiZ2FwaS5pZnJhbWVzLklmcmFtZVwiKSlhKCk7ZWxzZSBpZihMKFwiZ2FwaS5sb2FkXCIpKWMoKTtlbHNle3ZhciBkPVwiX19pZnJhbWVmY2JcIitNYXRoLmZsb29yKDFFNipNYXRoLnJhbmRvbSgpKS50b1N0cmluZygpO2tbZF09ZnVuY3Rpb24oKXtMKFwiZ2FwaS5sb2FkXCIpP2MoKTpiKEVycm9yKFwiTmV0d29yayBFcnJvclwiKSl9O2Q9aGMoRmkse29ubG9hZDpkfSk7QShrZihkKSkucyhmdW5jdGlvbigpe2IoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0pfX1lbHNlIGIoRXJyb3IoXCJOZXR3b3JrIEVycm9yXCIpKX0pKS5zKGZ1bmN0aW9uKGEpe0hpPVxubnVsbDt0aHJvdyBhO30pfTtmdW5jdGlvbiBJaShhLGIsYyl7dGhpcy5pPWE7dGhpcy5nPWI7dGhpcy5oPWM7dGhpcy5mPW51bGw7dGhpcy5hPUVlKHRoaXMuaSxcIi9fXy9hdXRoL2lmcmFtZVwiKTtJKHRoaXMuYSxcImFwaUtleVwiLHRoaXMuZyk7SSh0aGlzLmEsXCJhcHBOYW1lXCIsdGhpcy5oKTt0aGlzLmI9bnVsbDt0aGlzLmM9W119SWkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dGhpcy5mP0kodGhpcy5hLFwidlwiLHRoaXMuZik6TGUodGhpcy5hLmEsXCJ2XCIpO3RoaXMuYj9JKHRoaXMuYSxcImVpZFwiLHRoaXMuYik6TGUodGhpcy5hLmEsXCJlaWRcIik7dGhpcy5jLmxlbmd0aD9JKHRoaXMuYSxcImZ3XCIsdGhpcy5jLmpvaW4oXCIsXCIpKTpMZSh0aGlzLmEuYSxcImZ3XCIpO3JldHVybiB0aGlzLmEudG9TdHJpbmcoKX07ZnVuY3Rpb24gSmkoYSxiLGMsZCxlKXt0aGlzLm09YTt0aGlzLnU9Yjt0aGlzLmM9Yzt0aGlzLmw9ZDt0aGlzLmk9dGhpcy5nPXRoaXMuaD1udWxsO3RoaXMuYT1lO3RoaXMuZj1udWxsfVxuSmkucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGE9RWUodGhpcy5tLFwiL19fL2F1dGgvaGFuZGxlclwiKTtJKGEsXCJhcGlLZXlcIix0aGlzLnUpO0koYSxcImFwcE5hbWVcIix0aGlzLmMpO0koYSxcImF1dGhUeXBlXCIsdGhpcy5sKTtpZih0aGlzLmEuaXNPQXV0aFByb3ZpZGVyKXt2YXIgYj10aGlzLmE7dHJ5e3ZhciBjPWZpcmViYXNlLmFwcCh0aGlzLmMpLmF1dGgoKS4kKCl9Y2F0Y2gobCl7Yz1udWxsfWIuVWE9YztJKGEsXCJwcm92aWRlcklkXCIsdGhpcy5hLnByb3ZpZGVySWQpO2I9dGhpcy5hO2M9VmYoYi5yYik7Zm9yKHZhciBkIGluIGMpY1tkXT1jW2RdLnRvU3RyaW5nKCk7ZD1iLnJjO2M9VWEoYyk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspe3ZhciBmPWRbZV07ZiBpbiBjJiZkZWxldGUgY1tmXX1iLldhJiZiLlVhJiYhY1tiLldhXSYmKGNbYi5XYV09Yi5VYSk7U2EoYyl8fEkoYSxcImN1c3RvbVBhcmFtZXRlcnNcIixVZihjKSl9XCJmdW5jdGlvblwiPT09dHlwZW9mIHRoaXMuYS53YiYmXG4oYj10aGlzLmEud2IoKSxiLmxlbmd0aCYmSShhLFwic2NvcGVzXCIsYi5qb2luKFwiLFwiKSkpO3RoaXMuaD9JKGEsXCJyZWRpcmVjdFVybFwiLHRoaXMuaCk6TGUoYS5hLFwicmVkaXJlY3RVcmxcIik7dGhpcy5nP0koYSxcImV2ZW50SWRcIix0aGlzLmcpOkxlKGEuYSxcImV2ZW50SWRcIik7dGhpcy5pP0koYSxcInZcIix0aGlzLmkpOkxlKGEuYSxcInZcIik7aWYodGhpcy5iKWZvcih2YXIgZyBpbiB0aGlzLmIpdGhpcy5iLmhhc093blByb3BlcnR5KGcpJiYhQ2UoYSxnKSYmSShhLGcsdGhpcy5iW2ddKTt0aGlzLmY/SShhLFwiZWlkXCIsdGhpcy5mKTpMZShhLmEsXCJlaWRcIik7Zz1LaSh0aGlzLmMpO2cubGVuZ3RoJiZJKGEsXCJmd1wiLGcuam9pbihcIixcIikpO3JldHVybiBhLnRvU3RyaW5nKCl9O2Z1bmN0aW9uIEtpKGEpe3RyeXtyZXR1cm4gZmlyZWJhc2UuYXBwKGEpLmF1dGgoKS5LYSgpfWNhdGNoKGIpe3JldHVybltdfX1cbmZ1bmN0aW9uIExpKGEsYixjLGQsZSl7dGhpcy51PWE7dGhpcy5mPWI7dGhpcy5iPWM7dGhpcy5jPWR8fG51bGw7dGhpcy5oPWV8fG51bGw7dGhpcy5tPXRoaXMubz10aGlzLnY9bnVsbDt0aGlzLmc9W107dGhpcy5sPXRoaXMuYT1udWxsfVxuZnVuY3Rpb24gTWkoYSl7dmFyIGI9dmYoKTtyZXR1cm4gVmgoYSkudGhlbihmdW5jdGlvbihhKXthOnt2YXIgYz1EZShiKSxlPWMuYztjPWMuYjtmb3IodmFyIGY9MDtmPGEubGVuZ3RoO2YrKyl7dmFyIGc9YVtmXTt2YXIgbD1jO3ZhciBuPWU7MD09Zy5pbmRleE9mKFwiY2hyb21lLWV4dGVuc2lvbjovL1wiKT9sPURlKGcpLmI9PWwmJlwiY2hyb21lLWV4dGVuc2lvblwiPT1uOlwiaHR0cFwiIT1uJiZcImh0dHBzXCIhPW4/bD0hMTpHZi50ZXN0KGcpP2w9bD09ZzooZz1nLnNwbGl0KFwiLlwiKS5qb2luKFwiXFxcXC5cIiksbD0obmV3IFJlZ0V4cChcIl4oLitcXFxcLlwiK2crXCJ8XCIrZytcIikkXCIsXCJpXCIpKS50ZXN0KGwpKTtpZihsKXthPSEwO2JyZWFrIGF9fWE9ITF9aWYoIWEpdGhyb3cgbmV3IHloKHZmKCkpO30pfVxuZnVuY3Rpb24gTmkoYSl7aWYoYS5sKXJldHVybiBhLmw7YS5sPUhmKCkudGhlbihmdW5jdGlvbigpe2lmKCFhLm8pe3ZhciBiPWEuYyxjPWEuaCxkPUtpKGEuYiksZT1uZXcgSWkoYS51LGEuZixhLmIpO2UuZj1iO2UuYj1jO2UuYz1MYShkfHxbXSk7YS5vPWUudG9TdHJpbmcoKX1hLmk9bmV3IHppKGEubyk7T2koYSl9KTtyZXR1cm4gYS5sfWg9TGkucHJvdG90eXBlO2guQ2E9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPW5ldyBOKFwicG9wdXAtY2xvc2VkLWJ5LXVzZXJcIiksZT1uZXcgTihcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIpLGY9dGhpcyxnPSExO3JldHVybiB0aGlzLmJhKCkudGhlbihmdW5jdGlvbigpe1BpKGYpLnRoZW4oZnVuY3Rpb24oYyl7Y3x8KGEmJkNmKGEpLGIoZSksZz0hMCl9KX0pLnMoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWcpcmV0dXJuIEZmKGEpfSkudGhlbihmdW5jdGlvbigpe2lmKCFnKXJldHVybiBzZChjKS50aGVuKGZ1bmN0aW9uKCl7YihkKX0pfSl9O1xuaC5EYj1mdW5jdGlvbigpe3ZhciBhPUooKTtyZXR1cm4hVGYoYSkmJiFYZihhKX07aC55Yj1mdW5jdGlvbigpe3JldHVybiExfTtcbmgudmI9ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyl7aWYoIWEpcmV0dXJuIEIobmV3IE4oXCJwb3B1cC1ibG9ja2VkXCIpKTtpZihnJiYhVGYoKSlyZXR1cm4gdGhpcy5iYSgpLnMoZnVuY3Rpb24oYil7Q2YoYSk7ZShiKX0pLGQoKSxBKCk7dGhpcy5hfHwodGhpcy5hPU1pKFFpKHRoaXMpKSk7dmFyIGw9dGhpcztyZXR1cm4gdGhpcy5hLnRoZW4oZnVuY3Rpb24oKXt2YXIgYj1sLmJhKCkucyhmdW5jdGlvbihiKXtDZihhKTtlKGIpO3Rocm93IGI7fSk7ZCgpO3JldHVybiBifSkudGhlbihmdW5jdGlvbigpe3ZoKGMpO2lmKCFnKXt2YXIgZD1SaShsLnUsbC5mLGwuYixiLGMsbnVsbCxmLGwuYyx2b2lkIDAsbC5oKTt3ZihkLGEpfX0pLnMoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYobC5hPW51bGwpO3Rocm93IGE7fSl9O1xuZnVuY3Rpb24gUWkoYSl7YS5tfHwoYS52PWEuYz9PZihhLmMsS2koYS5iKSk6bnVsbCxhLm09bmV3IENoKGEuZix4aShhLmgpLGEudikpO3JldHVybiBhLm19aC5BYT1mdW5jdGlvbihhLGIsYyl7dGhpcy5hfHwodGhpcy5hPU1pKFFpKHRoaXMpKSk7dmFyIGQ9dGhpcztyZXR1cm4gdGhpcy5hLnRoZW4oZnVuY3Rpb24oKXt2aChiKTt2YXIgZT1SaShkLnUsZC5mLGQuYixhLGIsdmYoKSxjLGQuYyx2b2lkIDAsZC5oKTt3ZihlKX0pLnMoZnVuY3Rpb24oYSl7XCJhdXRoL25ldHdvcmstcmVxdWVzdC1mYWlsZWRcIj09YS5jb2RlJiYoZC5hPW51bGwpO3Rocm93IGE7fSl9O2guYmE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBOaSh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuaS5ZYX0pLnMoZnVuY3Rpb24oKXthLmE9bnVsbDt0aHJvdyBuZXcgTihcIm5ldHdvcmstcmVxdWVzdC1mYWlsZWRcIik7fSl9O2guSGI9ZnVuY3Rpb24oKXtyZXR1cm4hMH07XG5mdW5jdGlvbiBSaShhLGIsYyxkLGUsZixnLGwsbixEKXthPW5ldyBKaShhLGIsYyxkLGUpO2EuaD1mO2EuZz1nO2EuaT1sO2EuYj1VYShufHxudWxsKTthLmY9RDtyZXR1cm4gYS50b1N0cmluZygpfWZ1bmN0aW9uIE9pKGEpe2lmKCFhLmkpdGhyb3cgRXJyb3IoXCJJZmNIYW5kbGVyIG11c3QgYmUgaW5pdGlhbGl6ZWQhXCIpO0VpKGEuaSxmdW5jdGlvbihiKXt2YXIgYz17fTtpZihiJiZiLmF1dGhFdmVudCl7dmFyIGQ9ITE7Yj14aChiLmF1dGhFdmVudCk7Zm9yKGM9MDtjPGEuZy5sZW5ndGg7YysrKWQ9YS5nW2NdKGIpfHxkO2M9e307Yy5zdGF0dXM9ZD9cIkFDS1wiOlwiRVJST1JcIjtyZXR1cm4gQShjKX1jLnN0YXR1cz1cIkVSUk9SXCI7cmV0dXJuIEEoYyl9KX1cbmZ1bmN0aW9uIFBpKGEpe3ZhciBiPXt0eXBlOlwid2ViU3RvcmFnZVN1cHBvcnRcIn07cmV0dXJuIE5pKGEpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gRGkoYS5pLGIpfSkudGhlbihmdW5jdGlvbihhKXtpZihhJiZhLmxlbmd0aCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhWzBdLndlYlN0b3JhZ2VTdXBwb3J0KXJldHVybiBhWzBdLndlYlN0b3JhZ2VTdXBwb3J0O3Rocm93IEVycm9yKCk7fSl9aC51YT1mdW5jdGlvbihhKXt0aGlzLmcucHVzaChhKX07aC5KYT1mdW5jdGlvbihhKXtKYSh0aGlzLmcsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07ZnVuY3Rpb24gU2koYSl7dGhpcy5hPWF8fGZpcmViYXNlLklOVEVSTkFMLnJlYWN0TmF0aXZlJiZmaXJlYmFzZS5JTlRFUk5BTC5yZWFjdE5hdGl2ZS5Bc3luY1N0b3JhZ2U7aWYoIXRoaXMuYSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJUaGUgUmVhY3QgTmF0aXZlIGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt9aD1TaS5wcm90b3R5cGU7aC5nZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEEodGhpcy5hLmdldEl0ZW0oYSkpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEmJldmKGEpfSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7cmV0dXJuIEEodGhpcy5hLnNldEl0ZW0oYSxVZihiKSkpfTtoLlg9ZnVuY3Rpb24oYSl7cmV0dXJuIEEodGhpcy5hLnJlbW92ZUl0ZW0oYSkpfTtoLmlhPWZ1bmN0aW9uKCl7fTtoLmRhPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBUaSgpe3RoaXMuYT17fX1oPVRpLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gQSh0aGlzLmFbYV0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3RoaXMuYVthXT1iO3JldHVybiBBKCl9O2guWD1mdW5jdGlvbihhKXtkZWxldGUgdGhpcy5hW2FdO3JldHVybiBBKCl9O2guaWE9ZnVuY3Rpb24oKXt9O2guZGE9ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIFVpKGEsYixjLGQsZSxmKXt0cnl7dmFyIGc9ISFrLmluZGV4ZWREQn1jYXRjaChsKXtnPSExfWlmKCFnKXRocm93IG5ldyBOKFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIik7dGhpcy51PWE7dGhpcy5oPWI7dGhpcy5nPWM7dGhpcy5sPWQ7dGhpcy5tPWU7dGhpcy5mPXt9O3RoaXMuYz1bXTt0aGlzLmE9MDt0aGlzLm89Znx8ay5pbmRleGVkREJ9dmFyIFZpO2Z1bmN0aW9uIFdpKGEpe3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe3ZhciBkPWEuby5vcGVuKGEudSxhLm0pO2Qub25lcnJvcj1mdW5jdGlvbihhKXtjKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfTtkLm9udXBncmFkZW5lZWRlZD1mdW5jdGlvbihiKXtiPWIudGFyZ2V0LnJlc3VsdDt0cnl7Yi5jcmVhdGVPYmplY3RTdG9yZShhLmgse2tleVBhdGg6YS5nfSl9Y2F0Y2goZil7YyhmKX19O2Qub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2IoYS50YXJnZXQucmVzdWx0KX19KX1cbmZ1bmN0aW9uIFhpKGEpe2EuaXx8KGEuaT1XaShhKSk7cmV0dXJuIGEuaX1mdW5jdGlvbiBZaShhLGIpe3JldHVybiBiLm9iamVjdFN0b3JlKGEuaCl9ZnVuY3Rpb24gWmkoYSxiLGMpe3JldHVybiBiLnRyYW5zYWN0aW9uKFthLmhdLGM/XCJyZWFkd3JpdGVcIjpcInJlYWRvbmx5XCIpfWZ1bmN0aW9uICRpKGEpe3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe2Eub25zdWNjZXNzPWZ1bmN0aW9uKGEpe2EmJmEudGFyZ2V0P2IoYS50YXJnZXQucmVzdWx0KTpiKCl9O2Eub25lcnJvcj1mdW5jdGlvbihhKXtjKEVycm9yKGEudGFyZ2V0LmVycm9yQ29kZSkpfX0pfWg9VWkucHJvdG90eXBlO1xuaC5zZXQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz0hMSxkLGU9dGhpcztyZXR1cm4gUWIoWGkodGhpcykudGhlbihmdW5jdGlvbihiKXtkPWI7Yj1ZaShlLFppKGUsZCwhMCkpO3JldHVybiAkaShiLmdldChhKSl9KS50aGVuKGZ1bmN0aW9uKGYpe3ZhciBnPVlpKGUsWmkoZSxkLCEwKSk7aWYoZilyZXR1cm4gZi52YWx1ZT1iLCRpKGcucHV0KGYpKTtlLmErKztjPSEwO2Y9e307ZltlLmddPWE7ZltlLmxdPWI7cmV0dXJuICRpKGcuYWRkKGYpKX0pLnRoZW4oZnVuY3Rpb24oKXtlLmZbYV09Yn0pLGZ1bmN0aW9uKCl7YyYmZS5hLS19KX07aC5nZXQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gWGkodGhpcykudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gJGkoWWkoYixaaShiLGMsITEpKS5nZXQoYSkpfSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYSYmYS52YWx1ZX0pfTtcbmguWD1mdW5jdGlvbihhKXt2YXIgYj0hMSxjPXRoaXM7cmV0dXJuIFFiKFhpKHRoaXMpLnRoZW4oZnVuY3Rpb24oZCl7Yj0hMDtjLmErKztyZXR1cm4gJGkoWWkoYyxaaShjLGQsITApKVtcImRlbGV0ZVwiXShhKSl9KS50aGVuKGZ1bmN0aW9uKCl7ZGVsZXRlIGMuZlthXX0pLGZ1bmN0aW9uKCl7YiYmYy5hLS19KX07XG5oLnpjPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gWGkodGhpcykudGhlbihmdW5jdGlvbihiKXt2YXIgYz1ZaShhLFppKGEsYiwhMSkpO3JldHVybiBjLmdldEFsbD8kaShjLmdldEFsbCgpKTpuZXcgeihmdW5jdGlvbihhLGIpe3ZhciBkPVtdLGU9Yy5vcGVuQ3Vyc29yKCk7ZS5vbnN1Y2Nlc3M9ZnVuY3Rpb24oYil7KGI9Yi50YXJnZXQucmVzdWx0KT8oZC5wdXNoKGIudmFsdWUpLGJbXCJjb250aW51ZVwiXSgpKTphKGQpfTtlLm9uZXJyb3I9ZnVuY3Rpb24oYSl7YihFcnJvcihhLnRhcmdldC5lcnJvckNvZGUpKX19KX0pLnRoZW4oZnVuY3Rpb24oYil7dmFyIGM9e30sZD1bXTtpZigwPT1hLmEpe2ZvcihkPTA7ZDxiLmxlbmd0aDtkKyspY1tiW2RdW2EuZ11dPWJbZF1bYS5sXTtkPXhmKGEuZixjKTthLmY9Y31yZXR1cm4gZH0pfTtoLmlhPWZ1bmN0aW9uKGEpezA9PXRoaXMuYy5sZW5ndGgmJmFqKHRoaXMpO3RoaXMuYy5wdXNoKGEpfTtcbmguZGE9ZnVuY3Rpb24oYSl7SmEodGhpcy5jLGZ1bmN0aW9uKGIpe3JldHVybiBiPT1hfSk7MD09dGhpcy5jLmxlbmd0aCYmdGhpcy5iJiZ0aGlzLmIuY2FuY2VsKFwiU1RPUF9FVkVOVFwiKX07ZnVuY3Rpb24gYWooYSl7ZnVuY3Rpb24gYigpe2EuYj1zZCg4MDApLnRoZW4ocihhLnpjLGEpKS50aGVuKGZ1bmN0aW9uKGIpezA8Yi5sZW5ndGgmJncoYS5jLGZ1bmN0aW9uKGEpe2EoYil9KX0pLnRoZW4oYikucyhmdW5jdGlvbihhKXtcIlNUT1BfRVZFTlRcIiE9YS5tZXNzYWdlJiZiKCl9KTtyZXR1cm4gYS5ifWEuYiYmYS5iLmNhbmNlbChcIlNUT1BfRVZFTlRcIik7YigpfTtmdW5jdGlvbiBiaigpe2lmKCFjaigpKXtpZihcIk5vZGVcIj09SygpKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcIlRoZSBMb2NhbFN0b3JhZ2UgY29tcGF0aWJpbGl0eSBsaWJyYXJ5IHdhcyBub3QgZm91bmQuXCIpO3Rocm93IG5ldyBOKFwid2ViLXN0b3JhZ2UtdW5zdXBwb3J0ZWRcIik7fXRoaXMuYT1kaigpfHxmaXJlYmFzZS5JTlRFUk5BTC5ub2RlLmxvY2FsU3RvcmFnZX1mdW5jdGlvbiBkaigpe3RyeXt2YXIgYT1rLmxvY2FsU3RvcmFnZSxiPVFmKCk7YSYmKGEuc2V0SXRlbShiLFwiMVwiKSxhLnJlbW92ZUl0ZW0oYikpO3JldHVybiBhfWNhdGNoKGMpe3JldHVybiBudWxsfX1cbmZ1bmN0aW9uIGNqKCl7dmFyIGE9XCJOb2RlXCI9PUsoKTthPWRqKCl8fGEmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUmJmZpcmViYXNlLklOVEVSTkFMLm5vZGUubG9jYWxTdG9yYWdlO2lmKCFhKXJldHVybiExO3RyeXtyZXR1cm4gYS5zZXRJdGVtKFwiX19zYWtcIixcIjFcIiksYS5yZW1vdmVJdGVtKFwiX19zYWtcIiksITB9Y2F0Y2goYil7cmV0dXJuITF9fWg9YmoucHJvdG90eXBlO2guZ2V0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGM9Yi5hLmdldEl0ZW0oYSk7cmV0dXJuIFdmKGMpfSl9O2guc2V0PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztyZXR1cm4gQSgpLnRoZW4oZnVuY3Rpb24oKXt2YXIgZD1VZihiKTtudWxsPT09ZD9jLlgoYSk6Yy5hLnNldEl0ZW0oYSxkKX0pfTtoLlg9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gQSgpLnRoZW4oZnVuY3Rpb24oKXtiLmEucmVtb3ZlSXRlbShhKX0pfTtcbmguaWE9ZnVuY3Rpb24oYSl7ay53aW5kb3cmJmNkKGsud2luZG93LFwic3RvcmFnZVwiLGEpfTtoLmRhPWZ1bmN0aW9uKGEpe2sud2luZG93JiZFKGsud2luZG93LFwic3RvcmFnZVwiLGEpfTtmdW5jdGlvbiBlaigpe31oPWVqLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbigpe3JldHVybiBBKG51bGwpfTtoLnNldD1mdW5jdGlvbigpe3JldHVybiBBKCl9O2guWD1mdW5jdGlvbigpe3JldHVybiBBKCl9O2guaWE9ZnVuY3Rpb24oKXt9O2guZGE9ZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIGZqKCl7aWYoIWdqKCkpe2lmKFwiTm9kZVwiPT1LKCkpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFwiVGhlIFNlc3Npb25TdG9yYWdlIGNvbXBhdGliaWxpdHkgbGlicmFyeSB3YXMgbm90IGZvdW5kLlwiKTt0aHJvdyBuZXcgTihcIndlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCIpO310aGlzLmE9aGooKXx8ZmlyZWJhc2UuSU5URVJOQUwubm9kZS5zZXNzaW9uU3RvcmFnZX1mdW5jdGlvbiBoaigpe3RyeXt2YXIgYT1rLnNlc3Npb25TdG9yYWdlLGI9UWYoKTthJiYoYS5zZXRJdGVtKGIsXCIxXCIpLGEucmVtb3ZlSXRlbShiKSk7cmV0dXJuIGF9Y2F0Y2goYyl7cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gZ2ooKXt2YXIgYT1cIk5vZGVcIj09SygpO2E9aGooKXx8YSYmZmlyZWJhc2UuSU5URVJOQUwubm9kZSYmZmlyZWJhc2UuSU5URVJOQUwubm9kZS5zZXNzaW9uU3RvcmFnZTtpZighYSlyZXR1cm4hMTt0cnl7cmV0dXJuIGEuc2V0SXRlbShcIl9fc2FrXCIsXCIxXCIpLGEucmVtb3ZlSXRlbShcIl9fc2FrXCIpLCEwfWNhdGNoKGIpe3JldHVybiExfX1oPWZqLnByb3RvdHlwZTtoLmdldD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe3ZhciBjPWIuYS5nZXRJdGVtKGEpO3JldHVybiBXZihjKX0pfTtoLnNldD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGQ9VWYoYik7bnVsbD09PWQ/Yy5YKGEpOmMuYS5zZXRJdGVtKGEsZCl9KX07aC5YPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIEEoKS50aGVuKGZ1bmN0aW9uKCl7Yi5hLnJlbW92ZUl0ZW0oYSl9KX07aC5pYT1mdW5jdGlvbigpe307XG5oLmRhPWZ1bmN0aW9uKCl7fTtmdW5jdGlvbiBpaigpe3ZhciBhPXt9O2EuQnJvd3Nlcj1qajthLk5vZGU9a2o7YS5SZWFjdE5hdGl2ZT1sajt0aGlzLmE9YVtLKCldfXZhciBtaixqaj17QzpiaixqYjpman0sa2o9e0M6YmosamI6Zmp9LGxqPXtDOlNpLGpiOmVqfTt2YXIgbmo9e0xjOlwibG9jYWxcIixOT05FOlwibm9uZVwiLE5jOlwic2Vzc2lvblwifTtmdW5jdGlvbiBvaihhKXt2YXIgYj1uZXcgTihcImludmFsaWQtcGVyc2lzdGVuY2UtdHlwZVwiKSxjPW5ldyBOKFwidW5zdXBwb3J0ZWQtcGVyc2lzdGVuY2UtdHlwZVwiKTthOntmb3IoZCBpbiBuailpZihualtkXT09YSl7dmFyIGQ9ITA7YnJlYWsgYX1kPSExfWlmKCFkfHxcInN0cmluZ1wiIT09dHlwZW9mIGEpdGhyb3cgYjtzd2l0Y2goSygpKXtjYXNlIFwiUmVhY3ROYXRpdmVcIjppZihcInNlc3Npb25cIj09PWEpdGhyb3cgYzticmVhaztjYXNlIFwiTm9kZVwiOmlmKFwibm9uZVwiIT09YSl0aHJvdyBjO2JyZWFrO2RlZmF1bHQ6aWYoIVBmKCkmJlwibm9uZVwiIT09YSl0aHJvdyBjO319XG5mdW5jdGlvbiBwaihhLGIsYyxkLGUpe3RoaXMuaT1hO3RoaXMuZz1iO3RoaXMuQT1jO3RoaXMudT1kO3RoaXMudj1lO3RoaXMuYT17fTttanx8KG1qPW5ldyBpaik7YT1tajt0cnl7aWYodWYoKSl7Vml8fChWaT1uZXcgVWkoXCJmaXJlYmFzZUxvY2FsU3RvcmFnZURiXCIsXCJmaXJlYmFzZUxvY2FsU3RvcmFnZVwiLFwiZmJhc2Vfa2V5XCIsXCJ2YWx1ZVwiLDEpKTt2YXIgZj1WaX1lbHNlIGY9bmV3IGEuYS5DO3RoaXMubD1mfWNhdGNoKGcpe3RoaXMubD1uZXcgVGksdGhpcy51PSEwfXRyeXt0aGlzLm89bmV3IGEuYS5qYn1jYXRjaChnKXt0aGlzLm89bmV3IFRpfXRoaXMudz1uZXcgVGk7dGhpcy5oPXIodGhpcy5tLHRoaXMpO3RoaXMuYj17fX12YXIgcWo7ZnVuY3Rpb24gcmooKXtxanx8KHFqPW5ldyBwaihcImZpcmViYXNlXCIsXCI6XCIsIVhmKEooKSkmJkxmKCk/ITA6ITEsVGYoKSxQZigpKSk7cmV0dXJuIHFqfVxuZnVuY3Rpb24gc2ooYSxiKXtzd2l0Y2goYil7Y2FzZSBcInNlc3Npb25cIjpyZXR1cm4gYS5vO2Nhc2UgXCJub25lXCI6cmV0dXJuIGEudztkZWZhdWx0OnJldHVybiBhLmx9fWZ1bmN0aW9uIHRqKGEsYixjKXtyZXR1cm4gYS5pK2EuZytiLm5hbWUrKGM/YS5nK2M6XCJcIil9cGoucHJvdG90eXBlLmdldD1mdW5jdGlvbihhLGIpe3JldHVybiBzaih0aGlzLGEuQykuZ2V0KHRqKHRoaXMsYSxiKSl9O2Z1bmN0aW9uIHVqKGEsYixjKXtjPXRqKGEsYixjKTtcImxvY2FsXCI9PWIuQyYmKGEuYltjXT1udWxsKTtyZXR1cm4gc2ooYSxiLkMpLlgoYyl9cGoucHJvdG90eXBlLnNldD1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGoodGhpcyxhLGMpLGU9dGhpcyxmPXNqKHRoaXMsYS5DKTtyZXR1cm4gZi5zZXQoZCxiKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGYuZ2V0KGQpfSkudGhlbihmdW5jdGlvbihiKXtcImxvY2FsXCI9PWEuQyYmKGUuYltkXT1iKX0pfTtcbmZ1bmN0aW9uIHZqKGEsYixjLGQpe2I9dGooYSxiLGMpO2EudiYmKGEuYltiXT1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpKTtTYShhLmEpJiYoc2ooYSxcImxvY2FsXCIpLmlhKGEuaCksYS51fHx1ZigpfHwhYS52fHx3aihhKSk7YS5hW2JdfHwoYS5hW2JdPVtdKTthLmFbYl0ucHVzaChkKX1mdW5jdGlvbiB4aihhLGIsYyl7Yj10aihhLHlqKFwibG9jYWxcIiksYik7YS5hW2JdJiYoSmEoYS5hW2JdLGZ1bmN0aW9uKGEpe3JldHVybiBhPT1jfSksMD09YS5hW2JdLmxlbmd0aCYmZGVsZXRlIGEuYVtiXSk7U2EoYS5hKSYmemooYSl9XG5mdW5jdGlvbiB3aihhKXtBaihhKTthLmY9c2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtmb3IodmFyIGIgaW4gYS5hKXt2YXIgYz1rLmxvY2FsU3RvcmFnZS5nZXRJdGVtKGIpLGQ9YS5iW2JdO2MhPWQmJihhLmJbYl09YyxjPW5ldyBRYyh7dHlwZTpcInN0b3JhZ2VcIixrZXk6Yix0YXJnZXQ6d2luZG93LG9sZFZhbHVlOmQsbmV3VmFsdWU6YyxhOiEwfSksYS5tKGMpKX19LDFFMyl9ZnVuY3Rpb24gQWooYSl7YS5mJiYoY2xlYXJJbnRlcnZhbChhLmYpLGEuZj1udWxsKX1mdW5jdGlvbiB6aihhKXtzaihhLFwibG9jYWxcIikuZGEoYS5oKTtBaihhKX1cbnBqLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe2lmKGEmJmEuZyl7dmFyIGI9YS5hLmtleTtpZihudWxsPT1iKWZvcih2YXIgYyBpbiB0aGlzLmEpe3ZhciBkPXRoaXMuYltjXTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIGQmJihkPW51bGwpO3ZhciBlPWsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYyk7ZSE9PWQmJih0aGlzLmJbY109ZSx0aGlzLmMoYykpfWVsc2UgaWYoMD09Yi5pbmRleE9mKHRoaXMuaSt0aGlzLmcpJiZ0aGlzLmFbYl0pe1widW5kZWZpbmVkXCIhPT10eXBlb2YgYS5hLmE/c2oodGhpcyxcImxvY2FsXCIpLmRhKHRoaXMuaCk6QWoodGhpcyk7aWYodGhpcy5BKWlmKGM9ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxkPWEuYS5uZXdWYWx1ZSxkIT09YyludWxsIT09ZD9rLmxvY2FsU3RvcmFnZS5zZXRJdGVtKGIsZCk6ay5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShiKTtlbHNlIGlmKHRoaXMuYltiXT09PWQmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgYS5hLmEpcmV0dXJuO3ZhciBmPXRoaXM7XG5jPWZ1bmN0aW9uKCl7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLmEuYXx8Zi5iW2JdIT09ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSlmLmJbYl09ay5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShiKSxmLmMoYil9O3kmJmtiJiYxMD09a2ImJmsubG9jYWxTdG9yYWdlLmdldEl0ZW0oYikhPT1hLmEubmV3VmFsdWUmJmEuYS5uZXdWYWx1ZSE9PWEuYS5vbGRWYWx1ZT9zZXRUaW1lb3V0KGMsMTApOmMoKX19ZWxzZSB3KGEscih0aGlzLmMsdGhpcykpfTtwai5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXt0aGlzLmFbYV0mJncodGhpcy5hW2FdLGZ1bmN0aW9uKGEpe2EoKX0pfTtmdW5jdGlvbiBDaihhKXt0aGlzLmE9YTt0aGlzLmI9cmooKX12YXIgRGo9e25hbWU6XCJhdXRoRXZlbnRcIixDOlwibG9jYWxcIn07ZnVuY3Rpb24gRWooYSl7cmV0dXJuIGEuYi5nZXQoRGosYS5hKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiB4aChhKX0pfTtmdW5jdGlvbiBGaigpe3RoaXMuYT1yaigpfTtmdW5jdGlvbiBHaihhLGIsYyxkLGUsZixnKXt0aGlzLnU9YTt0aGlzLmk9Yjt0aGlzLmw9Yzt0aGlzLm09ZHx8bnVsbDt0aGlzLm89Z3x8bnVsbDt0aGlzLmg9YitcIjpcIitjO3RoaXMuQT1uZXcgRmo7dGhpcy5nPW5ldyBDaih0aGlzLmgpO3RoaXMuZj1udWxsO3RoaXMuYj1bXTt0aGlzLnY9ZXx8NTAwO3RoaXMudz1mfHwyRTM7dGhpcy5hPXRoaXMuYz1udWxsfWZ1bmN0aW9uIEhqKGEpe3JldHVybiBuZXcgTihcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIsYSl9aD1Hai5wcm90b3R5cGU7XG5oLmJhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMueGE/dGhpcy54YTp0aGlzLnhhPUlmKCkudGhlbihmdW5jdGlvbigpe2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwidW5pdmVyc2FsTGlua3Muc3Vic2NyaWJlXCIsaykpdGhyb3cgSGooXCJjb3Jkb3ZhLXVuaXZlcnNhbC1saW5rcy1wbHVnaW4gaXMgbm90IGluc3RhbGxlZFwiKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIEwoXCJCdWlsZEluZm8ucGFja2FnZU5hbWVcIixrKSl0aHJvdyBIaihcImNvcmRvdmEtcGx1Z2luLWJ1aWxkaW5mbyBpcyBub3QgaW5zdGFsbGVkXCIpO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIub3BlblVybFwiLGspKXRocm93IEhqKFwiY29yZG92YS1wbHVnaW4tYnJvd3NlcnRhYiBpcyBub3QgaW5zdGFsbGVkXCIpO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBMKFwiY29yZG92YS5JbkFwcEJyb3dzZXIub3BlblwiLGspKXRocm93IEhqKFwiY29yZG92YS1wbHVnaW4taW5hcHBicm93c2VyIGlzIG5vdCBpbnN0YWxsZWRcIik7XG59LGZ1bmN0aW9uKCl7dGhyb3cgbmV3IE4oXCJjb3Jkb3ZhLW5vdC1yZWFkeVwiKTt9KX07ZnVuY3Rpb24gSWooKXtmb3IodmFyIGE9MjAsYj1bXTswPGE7KWIucHVzaChcIjEyMzQ1Njc4OTBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIuY2hhckF0KE1hdGguZmxvb3IoNjIqTWF0aC5yYW5kb20oKSkpKSxhLS07cmV0dXJuIGIuam9pbihcIlwiKX1mdW5jdGlvbiBKaihhKXt2YXIgYj1uZXcgaWU7aGUoYixhKTthPVtdO3ZhciBjPTgqYi5nOzU2PmIuYz9oZShiLGZlLDU2LWIuYyk6aGUoYixmZSxiLmItKGIuYy01NikpO2Zvcih2YXIgZD02Mzs1Njw9ZDtkLS0pYi5mW2RdPWMmMjU1LGMvPTI1NjtnZShiKTtmb3IoZD1jPTA7ZDxiLmk7ZCsrKWZvcih2YXIgZT0yNDswPD1lO2UtPTgpYVtjKytdPWIuYVtkXT4+ZSYyNTU7cmV0dXJuIEhkKGEpfVxuaC5DYT1mdW5jdGlvbihhLGIpe2IobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtyZXR1cm4gQSgpfTtoLnZiPWZ1bmN0aW9uKCl7cmV0dXJuIEIobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKX07aC5IYj1mdW5jdGlvbigpe3JldHVybiExfTtoLkRiPWZ1bmN0aW9uKCl7cmV0dXJuITB9O2gueWI9ZnVuY3Rpb24oKXtyZXR1cm4hMH07XG5oLkFhPWZ1bmN0aW9uKGEsYixjKXtpZih0aGlzLmMpcmV0dXJuIEIobmV3IE4oXCJyZWRpcmVjdC1vcGVyYXRpb24tcGVuZGluZ1wiKSk7dmFyIGQ9dGhpcyxlPWsuZG9jdW1lbnQsZj1udWxsLGc9bnVsbCxsPW51bGwsbj1udWxsO3JldHVybiB0aGlzLmM9UWIoQSgpLnRoZW4oZnVuY3Rpb24oKXt2aChiKTtyZXR1cm4gS2ooZCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIExqKGQsYSxiLGMpfSkudGhlbihmdW5jdGlvbigpe3JldHVybihuZXcgeihmdW5jdGlvbihhLGIpe2c9ZnVuY3Rpb24oKXt2YXIgYj1MKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuY2xvc2VcIixrKTthKCk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGImJmIoKTtkLmEmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmEuY2xvc2UmJihkLmEuY2xvc2UoKSxkLmE9bnVsbCk7cmV0dXJuITF9O2QudWEoZyk7bD1mdW5jdGlvbigpe2Z8fChmPXNkKGQudykudGhlbihmdW5jdGlvbigpe2IobmV3IE4oXCJyZWRpcmVjdC1jYW5jZWxsZWQtYnktdXNlclwiKSl9KSl9O1xubj1mdW5jdGlvbigpe2FnKCkmJmwoKX07ZS5hZGRFdmVudExpc3RlbmVyKFwicmVzdW1lXCIsbCwhMSk7SigpLnRvTG93ZXJDYXNlKCkubWF0Y2goL2FuZHJvaWQvKXx8ZS5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLG4sITEpfSkpLnMoZnVuY3Rpb24oYSl7cmV0dXJuIE1qKGQpLnRoZW4oZnVuY3Rpb24oKXt0aHJvdyBhO30pfSl9KSxmdW5jdGlvbigpe2wmJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc3VtZVwiLGwsITEpO24mJmUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIixuLCExKTtmJiZmLmNhbmNlbCgpO2cmJmQuSmEoZyk7ZC5jPW51bGx9KX07XG5mdW5jdGlvbiBMaihhLGIsYyxkKXt2YXIgZT1JaigpLGY9bmV3IHdoKGIsZCxudWxsLGUsbmV3IE4oXCJuby1hdXRoLWV2ZW50XCIpKSxnPUwoXCJCdWlsZEluZm8ucGFja2FnZU5hbWVcIixrKTtpZihcInN0cmluZ1wiIT09dHlwZW9mIGcpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiKTt2YXIgbD1MKFwiQnVpbGRJbmZvLmRpc3BsYXlOYW1lXCIsayksbj17fTtpZihKKCkudG9Mb3dlckNhc2UoKS5tYXRjaCgvaXBob25lfGlwYWR8aXBvZC8pKW4uaWJpPWc7ZWxzZSBpZihKKCkudG9Mb3dlckNhc2UoKS5tYXRjaCgvYW5kcm9pZC8pKW4uYXBuPWc7ZWxzZSByZXR1cm4gQihuZXcgTihcIm9wZXJhdGlvbi1ub3Qtc3VwcG9ydGVkLWluLXRoaXMtZW52aXJvbm1lbnRcIikpO2wmJihuLmFwcERpc3BsYXlOYW1lPWwpO2U9SmooZSk7bi5zZXNzaW9uSWQ9ZTt2YXIgRD1SaShhLnUsYS5pLGEubCxiLGMsbnVsbCxkLGEubSxuLGEubyk7cmV0dXJuIGEuYmEoKS50aGVuKGZ1bmN0aW9uKCl7dmFyIGI9XG5hLmg7cmV0dXJuIGEuQS5hLnNldChEaixmLkIoKSxiKX0pLnRoZW4oZnVuY3Rpb24oKXt2YXIgYj1MKFwiY29yZG92YS5wbHVnaW5zLmJyb3dzZXJ0YWIuaXNBdmFpbGFibGVcIixrKTtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYil0aHJvdyBuZXcgTihcImludmFsaWQtY29yZG92YS1jb25maWd1cmF0aW9uXCIpO3ZhciBjPW51bGw7YihmdW5jdGlvbihiKXtpZihiKXtjPUwoXCJjb3Jkb3ZhLnBsdWdpbnMuYnJvd3NlcnRhYi5vcGVuVXJsXCIsayk7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpdGhyb3cgbmV3IE4oXCJpbnZhbGlkLWNvcmRvdmEtY29uZmlndXJhdGlvblwiKTtjKEQpfWVsc2V7Yz1MKFwiY29yZG92YS5JbkFwcEJyb3dzZXIub3BlblwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXRocm93IG5ldyBOKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7Yj1KKCk7Yj0hKCFiLm1hdGNoKC8oaVBhZHxpUGhvbmV8aVBvZCkuKk9TIDdfXFxkL2kpJiYhYi5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QpLipPUyA4X1xcZC9pKSk7XG5hLmE9YyhELGI/XCJfYmxhbmtcIjpcIl9zeXN0ZW1cIixcImxvY2F0aW9uPXllc1wiKX19KX0pfWZ1bmN0aW9uIE5qKGEsYil7Zm9yKHZhciBjPTA7YzxhLmIubGVuZ3RoO2MrKyl0cnl7YS5iW2NdKGIpfWNhdGNoKGQpe319ZnVuY3Rpb24gS2ooYSl7YS5mfHwoYS5mPWEuYmEoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoZCl7YihkKTthLkphKGMpO3JldHVybiExfWEudWEoYyk7T2ooYSl9KX0pKTtyZXR1cm4gYS5mfWZ1bmN0aW9uIE1qKGEpe3ZhciBiPW51bGw7cmV0dXJuIEVqKGEuZykudGhlbihmdW5jdGlvbihjKXtiPWM7Yz1hLmc7cmV0dXJuIHVqKGMuYixEaixjLmEpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBifSl9XG5mdW5jdGlvbiBPaihhKXtmdW5jdGlvbiBiKGIpe2U9ITA7ZiYmZi5jYW5jZWwoKTtNaihhKS50aGVuKGZ1bmN0aW9uKGMpe3ZhciBlPWQ7aWYoYyYmYiYmYi51cmwpe2U9bnVsbDt2YXIgZj1iLnVybDt2YXIgZz1EZShmKSxsPUNlKGcsXCJsaW5rXCIpLG49Q2UoRGUobCksXCJsaW5rXCIpO2c9Q2UoZyxcImRlZXBfbGlua19pZFwiKTtmPUNlKERlKGcpLFwibGlua1wiKXx8Z3x8bnx8bHx8ZjstMSE9Zi5pbmRleE9mKFwiL19fL2F1dGgvY2FsbGJhY2tcIikmJihlPURlKGYpLGU9V2YoQ2UoZSxcImZpcmViYXNlRXJyb3JcIil8fG51bGwpLGU9KGU9XCJvYmplY3RcIj09PXR5cGVvZiBlP3ZnKGUpOm51bGwpP25ldyB3aChjLmIsYy5jLG51bGwsbnVsbCxlKTpuZXcgd2goYy5iLGMuYyxmLGMuZykpO2U9ZXx8ZH1OaihhLGUpfSl9dmFyIGM9TChcInVuaXZlcnNhbExpbmtzLnN1YnNjcmliZVwiLGspO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXRocm93IG5ldyBOKFwiaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIik7XG52YXIgZD1uZXcgd2goXCJ1bmtub3duXCIsbnVsbCxudWxsLG51bGwsbmV3IE4oXCJuby1hdXRoLWV2ZW50XCIpKSxlPSExLGY9c2QoYS52KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIE1qKGEpLnRoZW4oZnVuY3Rpb24oKXtlfHxOaihhLGQpfSl9KSxnPWsuaGFuZGxlT3BlblVSTDtrLmhhbmRsZU9wZW5VUkw9ZnVuY3Rpb24oYSl7MD09YS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoTChcIkJ1aWxkSW5mby5wYWNrYWdlTmFtZVwiLGspLnRvTG93ZXJDYXNlKCkrXCI6Ly9cIikmJmIoe3VybDphfSk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGcpdHJ5e2coYSl9Y2F0Y2gobil7Y29uc29sZS5lcnJvcihuKX19O2MobnVsbCxiKX1cbmgudWE9ZnVuY3Rpb24oYSl7dGhpcy5iLnB1c2goYSk7S2oodGhpcykucyhmdW5jdGlvbihiKXtcImF1dGgvaW52YWxpZC1jb3Jkb3ZhLWNvbmZpZ3VyYXRpb25cIj09PWIuY29kZSYmKGI9bmV3IHdoKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBOKFwibm8tYXV0aC1ldmVudFwiKSksYShiKSl9KX07aC5KYT1mdW5jdGlvbihhKXtKYSh0aGlzLmIsZnVuY3Rpb24oYil7cmV0dXJuIGI9PWF9KX07ZnVuY3Rpb24gUGooYSl7dGhpcy5hPWE7dGhpcy5iPXJqKCl9dmFyIFFqPXtuYW1lOlwicGVuZGluZ1JlZGlyZWN0XCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24gUmooYSl7cmV0dXJuIGEuYi5zZXQoUWosXCJwZW5kaW5nXCIsYS5hKX1mdW5jdGlvbiBTaihhKXtyZXR1cm4gdWooYS5iLFFqLGEuYSl9ZnVuY3Rpb24gVGooYSl7cmV0dXJuIGEuYi5nZXQoUWosYS5hKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVyblwicGVuZGluZ1wiPT1hfSl9O2Z1bmN0aW9uIFVqKGEsYixjKXt0aGlzLnY9YTt0aGlzLmw9Yjt0aGlzLnU9Yzt0aGlzLmg9W107dGhpcy5mPSExO3RoaXMuaT1yKHRoaXMubSx0aGlzKTt0aGlzLmM9bmV3IFZqO3RoaXMubz1uZXcgV2o7dGhpcy5nPW5ldyBQaih0aGlzLmwrXCI6XCIrdGhpcy51KTt0aGlzLmI9e307dGhpcy5iLnVua25vd249dGhpcy5jO3RoaXMuYi5zaWduSW5WaWFSZWRpcmVjdD10aGlzLmM7dGhpcy5iLmxpbmtWaWFSZWRpcmVjdD10aGlzLmM7dGhpcy5iLnJlYXV0aFZpYVJlZGlyZWN0PXRoaXMuYzt0aGlzLmIuc2lnbkluVmlhUG9wdXA9dGhpcy5vO3RoaXMuYi5saW5rVmlhUG9wdXA9dGhpcy5vO3RoaXMuYi5yZWF1dGhWaWFQb3B1cD10aGlzLm87dGhpcy5hPVhqKHRoaXMudix0aGlzLmwsdGhpcy51LHlpKX1cbmZ1bmN0aW9uIFhqKGEsYixjLGQpe3ZhciBlPWZpcmViYXNlLlNES19WRVJTSU9OfHxudWxsO3JldHVybiBKZigpP25ldyBHaihhLGIsYyxlLHZvaWQgMCx2b2lkIDAsZCk6bmV3IExpKGEsYixjLGUsZCl9VWoucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5mPSExO3RoaXMuYS5KYSh0aGlzLmkpO3RoaXMuYT1Yaih0aGlzLnYsdGhpcy5sLHRoaXMudSl9O2Z1bmN0aW9uIFlqKGEpe2EuZnx8KGEuZj0hMCxhLmEudWEoYS5pKSk7dmFyIGI9YS5hO3JldHVybiBhLmEuYmEoKS5zKGZ1bmN0aW9uKGMpe2EuYT09YiYmYS5yZXNldCgpO3Rocm93IGM7fSl9ZnVuY3Rpb24gWmooYSl7YS5hLkRiKCkmJllqKGEpLnMoZnVuY3Rpb24oYil7dmFyIGM9bmV3IHdoKFwidW5rbm93blwiLG51bGwsbnVsbCxudWxsLG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7YWsoYikmJmEubShjKX0pO2EuYS55YigpfHxiayhhLmMpfVxuVWoucHJvdG90eXBlLnN1YnNjcmliZT1mdW5jdGlvbihhKXtIYSh0aGlzLmgsYSl8fHRoaXMuaC5wdXNoKGEpO2lmKCF0aGlzLmYpe3ZhciBiPXRoaXM7VGoodGhpcy5nKS50aGVuKGZ1bmN0aW9uKGEpe2E/U2ooYi5nKS50aGVuKGZ1bmN0aW9uKCl7WWooYikucyhmdW5jdGlvbihhKXt2YXIgYz1uZXcgd2goXCJ1bmtub3duXCIsbnVsbCxudWxsLG51bGwsbmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTthayhhKSYmYi5tKGMpfSl9KTpaaihiKX0pLnMoZnVuY3Rpb24oKXtaaihiKX0pfX07VWoucHJvdG90eXBlLnVuc3Vic2NyaWJlPWZ1bmN0aW9uKGEpe0phKHRoaXMuaCxmdW5jdGlvbihiKXtyZXR1cm4gYj09YX0pfTtcblVqLnByb3RvdHlwZS5tPWZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpO2Zvcih2YXIgYj0hMSxjPTA7Yzx0aGlzLmgubGVuZ3RoO2MrKyl7dmFyIGQ9dGhpcy5oW2NdO2lmKGQub2IoYS5iLGEuYykpeyhiPXRoaXMuYlthLmJdKSYmYi5oKGEsZCk7Yj0hMDticmVha319YmsodGhpcy5jKTtyZXR1cm4gYn07dmFyIGNrPW5ldyAkZigyRTMsMUU0KSxkaz1uZXcgJGYoM0U0LDZFNCk7VWoucHJvdG90eXBlLmFhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYy5hYSgpfTtmdW5jdGlvbiBlayhhLGIsYyxkLGUsZil7cmV0dXJuIGEuYS52YihiLGMsZCxmdW5jdGlvbigpe2EuZnx8KGEuZj0hMCxhLmEudWEoYS5pKSl9LGZ1bmN0aW9uKCl7YS5yZXNldCgpfSxlLGYpfWZ1bmN0aW9uIGFrKGEpe3JldHVybiBhJiZcImF1dGgvY29yZG92YS1ub3QtcmVhZHlcIj09YS5jb2RlPyEwOiExfVxuVWoucHJvdG90eXBlLkFhPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLGU7cmV0dXJuIFJqKHRoaXMuZykudGhlbihmdW5jdGlvbigpe3JldHVybiBkLmEuQWEoYSxiLGMpLnMoZnVuY3Rpb24oYSl7aWYoYWsoYSkpdGhyb3cgbmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpO2U9YTtyZXR1cm4gU2ooZC5nKS50aGVuKGZ1bmN0aW9uKCl7dGhyb3cgZTt9KX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5hLkhiKCk/bmV3IHooZnVuY3Rpb24oKXt9KTpTaihkLmcpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZC5hYSgpfSkudGhlbihmdW5jdGlvbigpe30pLnMoZnVuY3Rpb24oKXt9KX0pfSl9O1VqLnByb3RvdHlwZS5DYT1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5hLkNhKGMsZnVuY3Rpb24oYyl7YS5mYShiLG51bGwsYyxkKX0sY2suZ2V0KCkpfTt2YXIgZms9e307XG5mdW5jdGlvbiBnayhhLGIsYyl7dmFyIGQ9YitcIjpcIitjO2ZrW2RdfHwoZmtbZF09bmV3IFVqKGEsYixjKSk7cmV0dXJuIGZrW2RdfWZ1bmN0aW9uIFZqKCl7dGhpcy5iPW51bGw7dGhpcy5mPVtdO3RoaXMuYz1bXTt0aGlzLmE9bnVsbDt0aGlzLmc9ITF9VmoucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5iPW51bGw7dGhpcy5hJiYodGhpcy5hLmNhbmNlbCgpLHRoaXMuYT1udWxsKX07XG5Wai5wcm90b3R5cGUuaD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBCKG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpKTt0aGlzLnJlc2V0KCk7dGhpcy5nPSEwO3ZhciBjPWEuYixkPWEuYyxlPWEuYSYmXCJhdXRoL3dlYi1zdG9yYWdlLXVuc3VwcG9ydGVkXCI9PWEuYS5jb2RlLGY9YS5hJiZcImF1dGgvb3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiPT1hLmEuY29kZTtcInVua25vd25cIiE9Y3x8ZXx8Zj9hLmE/KGhrKHRoaXMsITAsbnVsbCxhLmEpLGE9QSgpKTphPWIudmEoYyxkKT9payh0aGlzLGEsYik6QihuZXcgTihcImludmFsaWQtYXV0aC1ldmVudFwiKSk6KGhrKHRoaXMsITEsbnVsbCxudWxsKSxhPUEoKSk7cmV0dXJuIGF9O2Z1bmN0aW9uIGJrKGEpe2EuZ3x8KGEuZz0hMCxoayhhLCExLG51bGwsbnVsbCkpfVxuZnVuY3Rpb24gaWsoYSxiLGMpe2M9Yy52YShiLmIsYi5jKTt2YXIgZD1iLmYsZT1iLmcsZj0hIWIuYi5tYXRjaCgvUmVkaXJlY3QkLyk7cmV0dXJuIGMoZCxlKS50aGVuKGZ1bmN0aW9uKGIpe2hrKGEsZixiLG51bGwpfSkucyhmdW5jdGlvbihiKXtoayhhLGYsbnVsbCxiKX0pfWZ1bmN0aW9uIGprKGEsYil7YS5iPWZ1bmN0aW9uKCl7cmV0dXJuIEIoYil9O2lmKGEuYy5sZW5ndGgpZm9yKHZhciBjPTA7YzxhLmMubGVuZ3RoO2MrKylhLmNbY10oYil9ZnVuY3Rpb24ga2soYSxiKXthLmI9ZnVuY3Rpb24oKXtyZXR1cm4gQShiKX07aWYoYS5mLmxlbmd0aClmb3IodmFyIGM9MDtjPGEuZi5sZW5ndGg7YysrKWEuZltjXShiKX1mdW5jdGlvbiBoayhhLGIsYyxkKXtiP2Q/amsoYSxkKTprayhhLGMpOmtrKGEse3VzZXI6bnVsbH0pO2EuZj1bXTthLmM9W119XG5Wai5wcm90b3R5cGUuYWE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiBuZXcgeihmdW5jdGlvbihiLGMpe2EuYj9hLmIoKS50aGVuKGIsYyk6KGEuZi5wdXNoKGIpLGEuYy5wdXNoKGMpLGxrKGEpKX0pfTtmdW5jdGlvbiBsayhhKXt2YXIgYj1uZXcgTihcInRpbWVvdXRcIik7YS5hJiZhLmEuY2FuY2VsKCk7YS5hPXNkKGRrLmdldCgpKS50aGVuKGZ1bmN0aW9uKCl7YS5ifHxoayhhLCEwLG51bGwsYil9KX1mdW5jdGlvbiBXaigpe31Xai5wcm90b3R5cGUuaD1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBCKG5ldyBOKFwiaW52YWxpZC1hdXRoLWV2ZW50XCIpKTt2YXIgYz1hLmIsZD1hLmM7YS5hPyhiLmZhKGEuYixudWxsLGEuYSxhLmMpLGE9QSgpKTphPWIudmEoYyxkKT9tayhhLGIpOkIobmV3IE4oXCJpbnZhbGlkLWF1dGgtZXZlbnRcIikpO3JldHVybiBhfTtcbmZ1bmN0aW9uIG1rKGEsYil7dmFyIGM9YS5jLGQ9YS5iO3JldHVybiBiLnZhKGQsYykoYS5mLGEuZykudGhlbihmdW5jdGlvbihhKXtiLmZhKGQsYSxudWxsLGMpfSkucyhmdW5jdGlvbihhKXtiLmZhKGQsbnVsbCxhLGMpfSl9O2Z1bmN0aW9uIG5rKGEsYil7dGhpcy5hPWI7TSh0aGlzLFwidmVyaWZpY2F0aW9uSWRcIixhKX1uay5wcm90b3R5cGUuY29uZmlybT1mdW5jdGlvbihhKXthPXRoKHRoaXMudmVyaWZpY2F0aW9uSWQsYSk7cmV0dXJuIHRoaXMuYShhKX07ZnVuY3Rpb24gb2soYSxiLGMsZCl7cmV0dXJuKG5ldyByaChhKSkuUWEoYixjKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgbmsoYSxkKX0pfTtmdW5jdGlvbiBwayhhLGIsYyxkLGUsZil7dGhpcy5oPWE7dGhpcy5pPWI7dGhpcy5nPWM7dGhpcy5jPWQ7dGhpcy5mPWU7dGhpcy5sPSEhZjt0aGlzLmI9bnVsbDt0aGlzLmE9dGhpcy5jO2lmKHRoaXMuZjx0aGlzLmMpdGhyb3cgRXJyb3IoXCJQcm9hY3RpdmUgcmVmcmVzaCBsb3dlciBib3VuZCBncmVhdGVyIHRoYW4gdXBwZXIgYm91bmQhXCIpO31way5wcm90b3R5cGUuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmE9dGhpcy5jO3FrKHRoaXMsITApfTtmdW5jdGlvbiByayhhLGIpe2lmKGIpcmV0dXJuIGEuYT1hLmMsYS5nKCk7Yj1hLmE7YS5hKj0yO2EuYT5hLmYmJihhLmE9YS5mKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHFrKGEsYil7c2soYSk7YS5iPXNkKHJrKGEsYikpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5sP0EoKTpiZygpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmgoKX0pLnRoZW4oZnVuY3Rpb24oKXtxayhhLCEwKX0pLnMoZnVuY3Rpb24oYil7YS5pKGIpJiZxayhhLCExKX0pfWZ1bmN0aW9uIHNrKGEpe2EuYiYmKGEuYi5jYW5jZWwoKSxhLmI9bnVsbCl9O2Z1bmN0aW9uIHRrKGEpe3RoaXMuZj1hO3RoaXMuYj10aGlzLmE9bnVsbDt0aGlzLmM9MH10ay5wcm90b3R5cGUuQj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6dGhpcy5mLmIscmVmcmVzaFRva2VuOnRoaXMuYSxhY2Nlc3NUb2tlbjp0aGlzLmIsZXhwaXJhdGlvblRpbWU6dGhpcy5jfX07ZnVuY3Rpb24gdWsoYSxiKXt2YXIgYz1iW09dLGQ9Yi5yZWZyZXNoVG9rZW47Yj12ayhiLmV4cGlyZXNJbik7YS5iPWM7YS5jPWI7YS5hPWR9ZnVuY3Rpb24gdmsoYSl7cmV0dXJuIG5hKCkrMUUzKnBhcnNlSW50KGEsMTApfVxuZnVuY3Rpb24gd2soYSxiKXtyZXR1cm4gT2goYS5mLGIpLnRoZW4oZnVuY3Rpb24oYil7YS5iPWIuYWNjZXNzX3Rva2VuO2EuYz12ayhiLmV4cGlyZXNfaW4pO2EuYT1iLnJlZnJlc2hfdG9rZW47cmV0dXJue2FjY2Vzc1Rva2VuOmEuYixleHBpcmF0aW9uVGltZTphLmMscmVmcmVzaFRva2VuOmEuYX19KS5zKGZ1bmN0aW9uKGIpe1wiYXV0aC91c2VyLXRva2VuLWV4cGlyZWRcIj09Yi5jb2RlJiYoYS5hPW51bGwpO3Rocm93IGI7fSl9dGsucHJvdG90eXBlLmdldFRva2VuPWZ1bmN0aW9uKGEpe2E9ISFhO3JldHVybiB0aGlzLmImJiF0aGlzLmE/QihuZXcgTihcInVzZXItdG9rZW4tZXhwaXJlZFwiKSk6YXx8IXRoaXMuYnx8bmEoKT50aGlzLmMtM0U0P3RoaXMuYT93ayh0aGlzLHtncmFudF90eXBlOlwicmVmcmVzaF90b2tlblwiLHJlZnJlc2hfdG9rZW46dGhpcy5hfSk6QShudWxsKTpBKHthY2Nlc3NUb2tlbjp0aGlzLmIsZXhwaXJhdGlvblRpbWU6dGhpcy5jLHJlZnJlc2hUb2tlbjp0aGlzLmF9KX07ZnVuY3Rpb24geGsoYSxiKXt0aGlzLmE9YXx8bnVsbDt0aGlzLmI9Ynx8bnVsbDtnZyh0aGlzLHtsYXN0U2lnbkluVGltZTpjZyhifHxudWxsKSxjcmVhdGlvblRpbWU6Y2coYXx8bnVsbCl9KX1mdW5jdGlvbiB5ayhhKXtyZXR1cm4gbmV3IHhrKGEuYSxhLmIpfXhrLnByb3RvdHlwZS5CPWZ1bmN0aW9uKCl7cmV0dXJue2xhc3RMb2dpbkF0OnRoaXMuYixjcmVhdGVkQXQ6dGhpcy5hfX07ZnVuY3Rpb24gemsoYSxiLGMsZCxlLGYpe2dnKHRoaXMse3VpZDphLGRpc3BsYXlOYW1lOmR8fG51bGwscGhvdG9VUkw6ZXx8bnVsbCxlbWFpbDpjfHxudWxsLHBob25lTnVtYmVyOmZ8fG51bGwscHJvdmlkZXJJZDpifSl9ZnVuY3Rpb24gQWsoYSxiKXtDLmNhbGwodGhpcyxhKTtmb3IodmFyIGMgaW4gYil0aGlzW2NdPWJbY119dChBayxDKTtcbmZ1bmN0aW9uIEJrKGEsYixjKXt0aGlzLkE9W107dGhpcy5HPWEuYXBpS2V5O3RoaXMubz1hLmFwcE5hbWU7dGhpcy53PWEuYXV0aERvbWFpbnx8bnVsbDthPWZpcmViYXNlLlNES19WRVJTSU9OP09mKGZpcmViYXNlLlNES19WRVJTSU9OKTpudWxsO3RoaXMuYz1uZXcgQ2godGhpcy5HLHhpKHlpKSxhKTt0aGlzLmg9bmV3IHRrKHRoaXMuYyk7Q2sodGhpcyxiW09dKTt1ayh0aGlzLmgsYik7TSh0aGlzLFwicmVmcmVzaFRva2VuXCIsdGhpcy5oLmEpO0RrKHRoaXMsY3x8e30pO0YuY2FsbCh0aGlzKTt0aGlzLkk9ITE7dGhpcy53JiZSZigpJiYodGhpcy5hPWdrKHRoaXMudyx0aGlzLkcsdGhpcy5vKSk7dGhpcy5OPVtdO3RoaXMuaT1udWxsO3RoaXMubD1Fayh0aGlzKTt0aGlzLlU9cih0aGlzLkdhLHRoaXMpO3ZhciBkPXRoaXM7dGhpcy5oYT1udWxsO3RoaXMucmE9ZnVuY3Rpb24oYSl7ZC5uYShhLmgpfTt0aGlzLlc9bnVsbDt0aGlzLlI9W107dGhpcy5xYT1mdW5jdGlvbihhKXtGayhkLFxuYS5mKX07dGhpcy5WPW51bGx9dChCayxGKTtCay5wcm90b3R5cGUubmE9ZnVuY3Rpb24oYSl7dGhpcy5oYT1hO0loKHRoaXMuYyxhKX07QmsucHJvdG90eXBlLiQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYX07ZnVuY3Rpb24gR2soYSxiKXthLlcmJkUoYS5XLFwibGFuZ3VhZ2VDb2RlQ2hhbmdlZFwiLGEucmEpOyhhLlc9YikmJmNkKGIsXCJsYW5ndWFnZUNvZGVDaGFuZ2VkXCIsYS5yYSl9ZnVuY3Rpb24gRmsoYSxiKXthLlI9YjtKaChhLmMsZmlyZWJhc2UuU0RLX1ZFUlNJT04/T2YoZmlyZWJhc2UuU0RLX1ZFUlNJT04sYS5SKTpudWxsKX1Cay5wcm90b3R5cGUuS2E9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5SKX07ZnVuY3Rpb24gSGsoYSxiKXthLlYmJkUoYS5WLFwiZnJhbWV3b3JrQ2hhbmdlZFwiLGEucWEpOyhhLlY9YikmJmNkKGIsXCJmcmFtZXdvcmtDaGFuZ2VkXCIsYS5xYSl9QmsucHJvdG90eXBlLkdhPWZ1bmN0aW9uKCl7dGhpcy5sLmImJihzayh0aGlzLmwpLHRoaXMubC5zdGFydCgpKX07XG5mdW5jdGlvbiBJayhhKXt0cnl7cmV0dXJuIGZpcmViYXNlLmFwcChhLm8pLmF1dGgoKX1jYXRjaChiKXt0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJObyBmaXJlYmFzZS5hdXRoLkF1dGggaW5zdGFuY2UgaXMgYXZhaWxhYmxlIGZvciB0aGUgRmlyZWJhc2UgQXBwICdcIithLm8rXCInIVwiKTt9fWZ1bmN0aW9uIEVrKGEpe3JldHVybiBuZXcgcGsoZnVuY3Rpb24oKXtyZXR1cm4gYS5GKCEwKX0sZnVuY3Rpb24oYSl7cmV0dXJuIGEmJlwiYXV0aC9uZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCI9PWEuY29kZT8hMDohMX0sZnVuY3Rpb24oKXt2YXIgYj1hLmguYy1uYSgpLTNFNTtyZXR1cm4gMDxiP2I6MH0sM0U0LDk2RTQsITEpfWZ1bmN0aW9uIEprKGEpe2EubXx8YS5sLmJ8fChhLmwuc3RhcnQoKSxFKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpLGNkKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpKX1mdW5jdGlvbiBLayhhKXtFKGEsXCJ0b2tlbkNoYW5nZWRcIixhLlUpO3NrKGEubCl9XG5mdW5jdGlvbiBDayhhLGIpe2EucGE9YjtNKGEsXCJfbGF0XCIsYil9ZnVuY3Rpb24gTGsoYSxiKXtKYShhLk4sZnVuY3Rpb24oYSl7cmV0dXJuIGE9PWJ9KX1mdW5jdGlvbiBNayhhKXtmb3IodmFyIGI9W10sYz0wO2M8YS5OLmxlbmd0aDtjKyspYi5wdXNoKGEuTltjXShhKSk7cmV0dXJuIE9iKGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYX0pfWZ1bmN0aW9uIE5rKGEpe2EuYSYmIWEuSSYmKGEuST0hMCxhLmEuc3Vic2NyaWJlKGEpKX1cbmZ1bmN0aW9uIERrKGEsYil7Z2coYSx7dWlkOmIudWlkLGRpc3BsYXlOYW1lOmIuZGlzcGxheU5hbWV8fG51bGwscGhvdG9VUkw6Yi5waG90b1VSTHx8bnVsbCxlbWFpbDpiLmVtYWlsfHxudWxsLGVtYWlsVmVyaWZpZWQ6Yi5lbWFpbFZlcmlmaWVkfHwhMSxwaG9uZU51bWJlcjpiLnBob25lTnVtYmVyfHxudWxsLGlzQW5vbnltb3VzOmIuaXNBbm9ueW1vdXN8fCExLG1ldGFkYXRhOm5ldyB4ayhiLmNyZWF0ZWRBdCxiLmxhc3RMb2dpbkF0KSxwcm92aWRlckRhdGE6W119KX1NKEJrLnByb3RvdHlwZSxcInByb3ZpZGVySWRcIixcImZpcmViYXNlXCIpO2Z1bmN0aW9uIE9rKCl7fWZ1bmN0aW9uIFBrKGEpe3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe2lmKGEubSl0aHJvdyBuZXcgTihcImFwcC1kZWxldGVkXCIpO30pfWZ1bmN0aW9uIFFrKGEpe3JldHVybiBEYShhLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wcm92aWRlcklkfSl9XG5mdW5jdGlvbiBSayhhLGIpe2ImJihTayhhLGIucHJvdmlkZXJJZCksYS5wcm92aWRlckRhdGEucHVzaChiKSl9ZnVuY3Rpb24gU2soYSxiKXtKYShhLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtyZXR1cm4gYS5wcm92aWRlcklkPT1ifSl9ZnVuY3Rpb24gVGsoYSxiLGMpeyhcInVpZFwiIT1ifHxjKSYmYS5oYXNPd25Qcm9wZXJ0eShiKSYmTShhLGIsYyl9XG5mdW5jdGlvbiBVayhhLGIpe2EhPWImJihnZyhhLHt1aWQ6Yi51aWQsZGlzcGxheU5hbWU6Yi5kaXNwbGF5TmFtZSxwaG90b1VSTDpiLnBob3RvVVJMLGVtYWlsOmIuZW1haWwsZW1haWxWZXJpZmllZDpiLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6Yi5waG9uZU51bWJlcixpc0Fub255bW91czpiLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXX0pLGIubWV0YWRhdGE/TShhLFwibWV0YWRhdGFcIix5ayhiLm1ldGFkYXRhKSk6TShhLFwibWV0YWRhdGFcIixuZXcgeGspLHcoYi5wcm92aWRlckRhdGEsZnVuY3Rpb24oYil7UmsoYSxiKX0pLGEuaD1iLmgsTShhLFwicmVmcmVzaFRva2VuXCIsYS5oLmEpKX1oPUJrLnByb3RvdHlwZTtoLnJlbG9hZD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIFIodGhpcyxQayh0aGlzKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFZrKGEpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gTWsoYSl9KS50aGVuKE9rKX0pKX07XG5mdW5jdGlvbiBWayhhKXtyZXR1cm4gYS5GKCkudGhlbihmdW5jdGlvbihiKXt2YXIgYz1hLmlzQW5vbnltb3VzO3JldHVybiBXayhhLGIpLnRoZW4oZnVuY3Rpb24oKXtjfHxUayhhLFwiaXNBbm9ueW1vdXNcIiwhMSk7cmV0dXJuIGJ9KX0pfWguRj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBSKHRoaXMsUGsodGhpcykudGhlbihmdW5jdGlvbigpe3JldHVybiBiLmguZ2V0VG9rZW4oYSl9KS50aGVuKGZ1bmN0aW9uKGEpe2lmKCFhKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7YS5hY2Nlc3NUb2tlbiE9Yi5wYSYmKENrKGIsYS5hY2Nlc3NUb2tlbiksRyhiLG5ldyBBayhcInRva2VuQ2hhbmdlZFwiKSkpO1RrKGIsXCJyZWZyZXNoVG9rZW5cIixhLnJlZnJlc2hUb2tlbik7cmV0dXJuIGEuYWNjZXNzVG9rZW59KSl9O1xuaC5nZXRUb2tlbj1mdW5jdGlvbihhKXtkZ1tcImZpcmViYXNlLlVzZXIucHJvdG90eXBlLmdldFRva2VuIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0SWRUb2tlbiBpbnN0ZWFkLlwiXXx8KGRnW1wiZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0VG9rZW4gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBmaXJlYmFzZS5Vc2VyLnByb3RvdHlwZS5nZXRJZFRva2VuIGluc3RlYWQuXCJdPSEwLFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY29uc29sZSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKFwiZmlyZWJhc2UuVXNlci5wcm90b3R5cGUuZ2V0VG9rZW4gaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBmaXJlYmFzZS5Vc2VyLnByb3RvdHlwZS5nZXRJZFRva2VuIGluc3RlYWQuXCIpKTtyZXR1cm4gdGhpcy5GKGEpfTtcbmZ1bmN0aW9uIFhrKGEsYil7YltPXSYmYS5wYSE9YltPXSYmKHVrKGEuaCxiKSxHKGEsbmV3IEFrKFwidG9rZW5DaGFuZ2VkXCIpKSxDayhhLGJbT10pLFRrKGEsXCJyZWZyZXNoVG9rZW5cIixhLmguYSkpfWZ1bmN0aW9uIFdrKGEsYil7cmV0dXJuIFEoYS5jLHRpLHtpZFRva2VuOmJ9KS50aGVuKHIoYS5rYyxhKSl9XG5oLmtjPWZ1bmN0aW9uKGEpe2E9YS51c2VycztpZighYXx8IWEubGVuZ3RoKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIik7YT1hWzBdO0RrKHRoaXMse3VpZDphLmxvY2FsSWQsZGlzcGxheU5hbWU6YS5kaXNwbGF5TmFtZSxwaG90b1VSTDphLnBob3RvVXJsLGVtYWlsOmEuZW1haWwsZW1haWxWZXJpZmllZDohIWEuZW1haWxWZXJpZmllZCxwaG9uZU51bWJlcjphLnBob25lTnVtYmVyLGxhc3RMb2dpbkF0OmEubGFzdExvZ2luQXQsY3JlYXRlZEF0OmEuY3JlYXRlZEF0fSk7Zm9yKHZhciBiPVlrKGEpLGM9MDtjPGIubGVuZ3RoO2MrKylSayh0aGlzLGJbY10pO1RrKHRoaXMsXCJpc0Fub255bW91c1wiLCEodGhpcy5lbWFpbCYmYS5wYXNzd29yZEhhc2gpJiYhKHRoaXMucHJvdmlkZXJEYXRhJiZ0aGlzLnByb3ZpZGVyRGF0YS5sZW5ndGgpKX07XG5mdW5jdGlvbiBZayhhKXtyZXR1cm4oYT1hLnByb3ZpZGVyVXNlckluZm8pJiZhLmxlbmd0aD9EYShhLGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgemsoYS5yYXdJZCxhLnByb3ZpZGVySWQsYS5lbWFpbCxhLmRpc3BsYXlOYW1lLGEucGhvdG9VcmwsYS5waG9uZU51bWJlcil9KTpbXX1oLlphPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsO3JldHVybiBSKHRoaXMsYS5jKHRoaXMuYyx0aGlzLnVpZCkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO2M9WmsoYixhLFwicmVhdXRoZW50aWNhdGVcIik7Yi5pPW51bGw7cmV0dXJuIGIucmVsb2FkKCl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSwhMCl9O2gubWM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWmEoYSkudGhlbihmdW5jdGlvbigpe30pfTtcbmZ1bmN0aW9uICRrKGEsYil7cmV0dXJuIFZrKGEpLnRoZW4oZnVuY3Rpb24oKXtpZihIYShRayhhKSxiKSlyZXR1cm4gTWsoYSkudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBOKFwicHJvdmlkZXItYWxyZWFkeS1saW5rZWRcIik7fSl9KX1oLlhhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1udWxsO3JldHVybiBSKHRoaXMsJGsodGhpcyxhLnByb3ZpZGVySWQpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5GKCl9KS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBhLmIoYi5jLGMpfSkudGhlbihmdW5jdGlvbihhKXtjPVprKGIsYSxcImxpbmtcIik7cmV0dXJuIGFsKGIsYSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGN9KSl9O2guY2M9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuWGEoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O1xuaC5kYz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIFIodGhpcywkayh0aGlzLFwicGhvbmVcIikudGhlbihmdW5jdGlvbigpe3JldHVybiBvayhJayhjKSxhLGIscihjLlhhLGMpKX0pKX07aC5uYz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIFIodGhpcyxBKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBvayhJayhjKSxhLGIscihjLlphLGMpKX0pLCEwKX07ZnVuY3Rpb24gWmsoYSxiLGMpe3ZhciBkPXVoKGIpO2I9TWcoYik7cmV0dXJuIGhnKHt1c2VyOmEsY3JlZGVudGlhbDpkLGFkZGl0aW9uYWxVc2VySW5mbzpiLG9wZXJhdGlvblR5cGU6Y30pfWZ1bmN0aW9uIGFsKGEsYil7WGsoYSxiKTtyZXR1cm4gYS5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGF9KX1cbmgua2I9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gUih0aGlzLHRoaXMuRigpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGIuYy5rYihjLGEpfSkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtoLkRjPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBhLmIoYi5jLGMpfSkudGhlbihmdW5jdGlvbihhKXtYayhiLGEpO3JldHVybiBiLnJlbG9hZCgpfSkpfTtoLmxiPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMubGIoYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7WGsoYixhKTtyZXR1cm4gYi5yZWxvYWQoKX0pKX07XG5oLm1iPWZ1bmN0aW9uKGEpe2lmKHZvaWQgMD09PWEuZGlzcGxheU5hbWUmJnZvaWQgMD09PWEucGhvdG9VUkwpcmV0dXJuIFBrKHRoaXMpO3ZhciBiPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGMpe3JldHVybiBiLmMubWIoYyx7ZGlzcGxheU5hbWU6YS5kaXNwbGF5TmFtZSxwaG90b1VybDphLnBob3RvVVJMfSl9KS50aGVuKGZ1bmN0aW9uKGEpe1hrKGIsYSk7VGsoYixcImRpc3BsYXlOYW1lXCIsYS5kaXNwbGF5TmFtZXx8bnVsbCk7VGsoYixcInBob3RvVVJMXCIsYS5waG90b1VybHx8bnVsbCk7dyhiLnByb3ZpZGVyRGF0YSxmdW5jdGlvbihhKXtcInBhc3N3b3JkXCI9PT1hLnByb3ZpZGVySWQmJihNKGEsXCJkaXNwbGF5TmFtZVwiLGIuZGlzcGxheU5hbWUpLE0oYSxcInBob3RvVVJMXCIsYi5waG90b1VSTCkpfSk7cmV0dXJuIE1rKGIpfSkudGhlbihPaykpfTtcbmguQ2M9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gUih0aGlzLFZrKHRoaXMpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIEhhKFFrKGIpLGEpP2ZpKGIuYyxjLFthXSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz17fTt3KGEucHJvdmlkZXJVc2VySW5mb3x8W10sZnVuY3Rpb24oYSl7Y1thLnByb3ZpZGVySWRdPSEwfSk7dyhRayhiKSxmdW5jdGlvbihhKXtjW2FdfHxTayhiLGEpfSk7Y1tyaC5QUk9WSURFUl9JRF18fE0oYixcInBob25lTnVtYmVyXCIsbnVsbCk7cmV0dXJuIE1rKGIpfSk6TWsoYikudGhlbihmdW5jdGlvbigpe3Rocm93IG5ldyBOKFwibm8tc3VjaC1wcm92aWRlclwiKTt9KX0pKX07XG5oLmRlbGV0ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGIpe3JldHVybiBRKGEuYyxzaSx7aWRUb2tlbjpifSl9KS50aGVuKGZ1bmN0aW9uKCl7RyhhLG5ldyBBayhcInVzZXJEZWxldGVkXCIpKX0pKS50aGVuKGZ1bmN0aW9uKCl7Zm9yKHZhciBiPTA7YjxhLkEubGVuZ3RoO2IrKylhLkFbYl0uY2FuY2VsKFwiYXBwLWRlbGV0ZWRcIik7R2soYSxudWxsKTtIayhhLG51bGwpO2EuQT1bXTthLm09ITA7S2soYSk7TShhLFwicmVmcmVzaFRva2VuXCIsbnVsbCk7YS5hJiZhLmEudW5zdWJzY3JpYmUoYSl9KX07XG5oLm9iPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJsaW5rVmlhUG9wdXBcIj09YSYmKHRoaXMuZ3x8bnVsbCk9PWImJnRoaXMuZnx8XCJyZWF1dGhWaWFQb3B1cFwiPT1hJiYodGhpcy5nfHxudWxsKT09YiYmdGhpcy5mfHxcImxpbmtWaWFSZWRpcmVjdFwiPT1hJiYodGhpcy5afHxudWxsKT09Ynx8XCJyZWF1dGhWaWFSZWRpcmVjdFwiPT1hJiYodGhpcy5afHxudWxsKT09Yj8hMDohMX07aC5mYT1mdW5jdGlvbihhLGIsYyxkKXtcImxpbmtWaWFQb3B1cFwiIT1hJiZcInJlYXV0aFZpYVBvcHVwXCIhPWF8fGQhPSh0aGlzLmd8fG51bGwpfHwoYyYmdGhpcy52P3RoaXMudihjKTpiJiYhYyYmdGhpcy5mJiZ0aGlzLmYoYiksdGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKSxkZWxldGUgdGhpcy5mLGRlbGV0ZSB0aGlzLnYpfTtcbmgudmE9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cImxpbmtWaWFQb3B1cFwiPT1hJiZiPT0odGhpcy5nfHxudWxsKT9yKHRoaXMudGIsdGhpcyk6XCJyZWF1dGhWaWFQb3B1cFwiPT1hJiZiPT0odGhpcy5nfHxudWxsKT9yKHRoaXMudWIsdGhpcyk6XCJsaW5rVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuWnx8bnVsbCk9PWI/cih0aGlzLnRiLHRoaXMpOlwicmVhdXRoVmlhUmVkaXJlY3RcIj09YSYmKHRoaXMuWnx8bnVsbCk9PWI/cih0aGlzLnViLHRoaXMpOm51bGx9O2guZWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztyZXR1cm4gYmwodGhpcyxcImxpbmtWaWFQb3B1cFwiLGEsZnVuY3Rpb24oKXtyZXR1cm4gJGsoYixhLnByb3ZpZGVySWQpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gTWsoYil9KX0sITEpfTtoLm9jPWZ1bmN0aW9uKGEpe3JldHVybiBibCh0aGlzLFwicmVhdXRoVmlhUG9wdXBcIixhLGZ1bmN0aW9uKCl7cmV0dXJuIEEoKX0sITApfTtcbmZ1bmN0aW9uIGJsKGEsYixjLGQsZSl7aWYoIVJmKCkpcmV0dXJuIEIobmV3IE4oXCJvcGVyYXRpb24tbm90LXN1cHBvcnRlZC1pbi10aGlzLWVudmlyb25tZW50XCIpKTtpZihhLmkmJiFlKXJldHVybiBCKGEuaSk7dmFyIGY9TGcoYy5wcm92aWRlcklkKSxnPVFmKGEudWlkK1wiOjo6XCIpLGw9bnVsbDsoIVRmKCl8fExmKCkpJiZhLncmJmMuaXNPQXV0aFByb3ZpZGVyJiYobD1SaShhLncsYS5HLGEubyxiLGMsbnVsbCxnLGZpcmViYXNlLlNES19WRVJTSU9OfHxudWxsKSk7dmFyIG49RGYobCxmJiZmLnphLGYmJmYueWEpO2Q9ZCgpLnRoZW4oZnVuY3Rpb24oKXtjbChhKTtpZighZSlyZXR1cm4gYS5GKCkudGhlbihmdW5jdGlvbigpe30pfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBlayhhLmEsbixiLGMsZywhIWwpfSkudGhlbihmdW5jdGlvbigpe3JldHVybiBuZXcgeihmdW5jdGlvbihjLGQpe2EuZmEoYixudWxsLG5ldyBOKFwiY2FuY2VsbGVkLXBvcHVwLXJlcXVlc3RcIiksYS5nfHxudWxsKTtcbmEuZj1jO2Eudj1kO2EuZz1nO2EuYj1hLmEuQ2EoYSxiLG4sZyl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7biYmQ2Yobik7cmV0dXJuIGE/aGcoYSk6bnVsbH0pLnMoZnVuY3Rpb24oYSl7biYmQ2Yobik7dGhyb3cgYTt9KTtyZXR1cm4gUihhLGQsZSl9aC5mYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiBkbCh0aGlzLFwibGlua1ZpYVJlZGlyZWN0XCIsYSxmdW5jdGlvbigpe3JldHVybiAkayhiLGEucHJvdmlkZXJJZCl9LCExKX07aC5wYz1mdW5jdGlvbihhKXtyZXR1cm4gZGwodGhpcyxcInJlYXV0aFZpYVJlZGlyZWN0XCIsYSxmdW5jdGlvbigpe3JldHVybiBBKCl9LCEwKX07XG5mdW5jdGlvbiBkbChhLGIsYyxkLGUpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7aWYoYS5pJiYhZSlyZXR1cm4gQihhLmkpO3ZhciBmPW51bGwsZz1RZihhLnVpZCtcIjo6OlwiKTtkPWQoKS50aGVuKGZ1bmN0aW9uKCl7Y2woYSk7aWYoIWUpcmV0dXJuIGEuRigpLnRoZW4oZnVuY3Rpb24oKXt9KX0pLnRoZW4oZnVuY3Rpb24oKXthLlo9ZztyZXR1cm4gTWsoYSl9KS50aGVuKGZ1bmN0aW9uKGIpe2EuY2EmJihiPWEuY2EsYj1iLmIuc2V0KGVsLGEuQigpLGIuYSkpO3JldHVybiBifSkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmEuQWEoYixjLGcpfSkucyhmdW5jdGlvbihiKXtmPWI7aWYoYS5jYSlyZXR1cm4gZmwoYS5jYSk7dGhyb3cgZjt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoZil0aHJvdyBmO30pO3JldHVybiBSKGEsZCxlKX1cbmZ1bmN0aW9uIGNsKGEpe2lmKCFhLmF8fCFhLkkpe2lmKGEuYSYmIWEuSSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIpO3Rocm93IG5ldyBOKFwiYXV0aC1kb21haW4tY29uZmlnLXJlcXVpcmVkXCIpO319aC50Yj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9dGhpcy5GKCkudGhlbihmdW5jdGlvbihkKXtyZXR1cm4gWmcoYy5jLHtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmIsaWRUb2tlbjpkfSl9KS50aGVuKGZ1bmN0aW9uKGEpe2Q9WmsoYyxhLFwibGlua1wiKTtyZXR1cm4gYWwoYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3JldHVybiBSKHRoaXMsZSl9O1xuaC51Yj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9QSgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gVmcoJGcoYy5jLHtyZXF1ZXN0VXJpOmEsc2Vzc2lvbklkOmJ9KSxjLnVpZCl9KS50aGVuKGZ1bmN0aW9uKGEpe2Q9WmsoYyxhLFwicmVhdXRoZW50aWNhdGVcIik7WGsoYyxhKTtjLmk9bnVsbDtyZXR1cm4gYy5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZH0pO3JldHVybiBSKHRoaXMsZSwhMCl9O2guYmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPW51bGw7cmV0dXJuIFIodGhpcyx0aGlzLkYoKS50aGVuKGZ1bmN0aW9uKGIpe2M9YjtyZXR1cm5cInVuZGVmaW5lZFwiPT09dHlwZW9mIGF8fFNhKGEpP3t9OkZnKG5ldyB3ZyhhKSl9KS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBiLmMuYmIoYyxhKX0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoYi5lbWFpbCE9YSlyZXR1cm4gYi5yZWxvYWQoKX0pLnRoZW4oZnVuY3Rpb24oKXt9KSl9O1xuZnVuY3Rpb24gUihhLGIsYyl7dmFyIGQ9Z2woYSxiLGMpO2EuQS5wdXNoKGQpO1FiKGQsZnVuY3Rpb24oKXtJYShhLkEsZCl9KTtyZXR1cm4gZH1mdW5jdGlvbiBnbChhLGIsYyl7cmV0dXJuIGEuaSYmIWM/KGIuY2FuY2VsKCksQihhLmkpKTpiLnMoZnVuY3Rpb24oYil7IWJ8fFwiYXV0aC91c2VyLWRpc2FibGVkXCIhPWIuY29kZSYmXCJhdXRoL3VzZXItdG9rZW4tZXhwaXJlZFwiIT1iLmNvZGV8fChhLml8fEcoYSxuZXcgQWsoXCJ1c2VySW52YWxpZGF0ZWRcIikpLGEuaT1iKTt0aHJvdyBiO30pfWgudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuQigpfTtcbmguQj1mdW5jdGlvbigpe3ZhciBhPXt1aWQ6dGhpcy51aWQsZGlzcGxheU5hbWU6dGhpcy5kaXNwbGF5TmFtZSxwaG90b1VSTDp0aGlzLnBob3RvVVJMLGVtYWlsOnRoaXMuZW1haWwsZW1haWxWZXJpZmllZDp0aGlzLmVtYWlsVmVyaWZpZWQscGhvbmVOdW1iZXI6dGhpcy5waG9uZU51bWJlcixpc0Fub255bW91czp0aGlzLmlzQW5vbnltb3VzLHByb3ZpZGVyRGF0YTpbXSxhcGlLZXk6dGhpcy5HLGFwcE5hbWU6dGhpcy5vLGF1dGhEb21haW46dGhpcy53LHN0c1Rva2VuTWFuYWdlcjp0aGlzLmguQigpLHJlZGlyZWN0RXZlbnRJZDp0aGlzLlp8fG51bGx9O3RoaXMubWV0YWRhdGEmJldhKGEsdGhpcy5tZXRhZGF0YS5CKCkpO3codGhpcy5wcm92aWRlckRhdGEsZnVuY3Rpb24oYil7YS5wcm92aWRlckRhdGEucHVzaChpZyhiKSl9KTtyZXR1cm4gYX07XG5mdW5jdGlvbiBobChhKXtpZighYS5hcGlLZXkpcmV0dXJuIG51bGw7dmFyIGI9e2FwaUtleTphLmFwaUtleSxhdXRoRG9tYWluOmEuYXV0aERvbWFpbixhcHBOYW1lOmEuYXBwTmFtZX0sYz17fTtpZihhLnN0c1Rva2VuTWFuYWdlciYmYS5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4mJmEuc3RzVG9rZW5NYW5hZ2VyLmV4cGlyYXRpb25UaW1lKWNbT109YS5zdHNUb2tlbk1hbmFnZXIuYWNjZXNzVG9rZW4sYy5yZWZyZXNoVG9rZW49YS5zdHNUb2tlbk1hbmFnZXIucmVmcmVzaFRva2VufHxudWxsLGMuZXhwaXJlc0luPShhLnN0c1Rva2VuTWFuYWdlci5leHBpcmF0aW9uVGltZS1uYSgpKS8xRTM7ZWxzZSByZXR1cm4gbnVsbDt2YXIgZD1uZXcgQmsoYixjLGEpO2EucHJvdmlkZXJEYXRhJiZ3KGEucHJvdmlkZXJEYXRhLGZ1bmN0aW9uKGEpe2EmJlJrKGQsaGcoYSkpfSk7YS5yZWRpcmVjdEV2ZW50SWQmJihkLlo9YS5yZWRpcmVjdEV2ZW50SWQpO3JldHVybiBkfVxuZnVuY3Rpb24gaWwoYSxiLGMsZCl7dmFyIGU9bmV3IEJrKGEsYik7YyYmKGUuY2E9Yyk7ZCYmRmsoZSxkKTtyZXR1cm4gZS5yZWxvYWQoKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX07ZnVuY3Rpb24gamwoYSl7dGhpcy5hPWE7dGhpcy5iPXJqKCl9dmFyIGVsPXtuYW1lOlwicmVkaXJlY3RVc2VyXCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24gZmwoYSl7cmV0dXJuIHVqKGEuYixlbCxhLmEpfWZ1bmN0aW9uIGtsKGEsYil7cmV0dXJuIGEuYi5nZXQoZWwsYS5hKS50aGVuKGZ1bmN0aW9uKGEpe2EmJmImJihhLmF1dGhEb21haW49Yik7cmV0dXJuIGhsKGF8fHt9KX0pfTtmdW5jdGlvbiBsbChhLGIpe3RoaXMuYT1hO3RoaXMuYj1ifHxyaigpO3RoaXMuYz1udWxsO3RoaXMuZj1tbCh0aGlzKTt2aih0aGlzLmIseWooXCJsb2NhbFwiKSx0aGlzLmEscih0aGlzLmcsdGhpcykpfWxsLnByb3RvdHlwZS5nPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXlqKFwibG9jYWxcIik7bmwodGhpcyxmdW5jdGlvbigpe3JldHVybiBBKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBhLmMmJlwibG9jYWxcIiE9YS5jLkM/YS5iLmdldChiLGEuYSk6bnVsbH0pLnRoZW4oZnVuY3Rpb24oYyl7aWYoYylyZXR1cm4gb2woYSxcImxvY2FsXCIpLnRoZW4oZnVuY3Rpb24oKXthLmM9Yn0pfSl9KX07ZnVuY3Rpb24gb2woYSxiKXt2YXIgYz1bXSxkO2ZvcihkIGluIG5qKW5qW2RdIT09YiYmYy5wdXNoKHVqKGEuYix5aihualtkXSksYS5hKSk7Yy5wdXNoKHVqKGEuYixwbCxhLmEpKTtyZXR1cm4gTmIoYyl9XG5mdW5jdGlvbiBtbChhKXt2YXIgYj15aihcImxvY2FsXCIpLGM9eWooXCJzZXNzaW9uXCIpLGQ9eWooXCJub25lXCIpO3JldHVybiBhLmIuZ2V0KGMsYS5hKS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBlP2M6YS5iLmdldChkLGEuYSkudGhlbihmdW5jdGlvbihjKXtyZXR1cm4gYz9kOmEuYi5nZXQoYixhLmEpLnRoZW4oZnVuY3Rpb24oYyl7cmV0dXJuIGM/YjphLmIuZ2V0KHBsLGEuYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYT95aihhKTpifSl9KX0pfSkudGhlbihmdW5jdGlvbihiKXthLmM9YjtyZXR1cm4gb2woYSxiLkMpfSkucyhmdW5jdGlvbigpe2EuY3x8KGEuYz1iKX0pfXZhciBwbD17bmFtZTpcInBlcnNpc3RlbmNlXCIsQzpcInNlc3Npb25cIn07ZnVuY3Rpb24geWooYSl7cmV0dXJue25hbWU6XCJhdXRoVXNlclwiLEM6YX19XG5sbC5wcm90b3R5cGUuZWI9ZnVuY3Rpb24oYSl7dmFyIGI9bnVsbCxjPXRoaXM7b2ooYSk7cmV0dXJuIG5sKHRoaXMsZnVuY3Rpb24oKXtyZXR1cm4gYSE9Yy5jLkM/Yy5iLmdldChjLmMsYy5hKS50aGVuKGZ1bmN0aW9uKGQpe2I9ZDtyZXR1cm4gb2woYyxhKX0pLnRoZW4oZnVuY3Rpb24oKXtjLmM9eWooYSk7aWYoYilyZXR1cm4gYy5iLnNldChjLmMsYixjLmEpfSk6QSgpfSl9O2Z1bmN0aW9uIHFsKGEpe3JldHVybiBubChhLGZ1bmN0aW9uKCl7cmV0dXJuIGEuYi5zZXQocGwsYS5jLkMsYS5hKX0pfWZ1bmN0aW9uIHJsKGEsYil7cmV0dXJuIG5sKGEsZnVuY3Rpb24oKXtyZXR1cm4gYS5iLnNldChhLmMsYi5CKCksYS5hKX0pfWZ1bmN0aW9uIHNsKGEpe3JldHVybiBubChhLGZ1bmN0aW9uKCl7cmV0dXJuIHVqKGEuYixhLmMsYS5hKX0pfVxuZnVuY3Rpb24gdGwoYSxiKXtyZXR1cm4gbmwoYSxmdW5jdGlvbigpe3JldHVybiBhLmIuZ2V0KGEuYyxhLmEpLnRoZW4oZnVuY3Rpb24oYSl7YSYmYiYmKGEuYXV0aERvbWFpbj1iKTtyZXR1cm4gaGwoYXx8e30pfSl9KX1mdW5jdGlvbiBubChhLGIpe2EuZj1hLmYudGhlbihiLGIpO3JldHVybiBhLmZ9O2Z1bmN0aW9uIHVsKGEpe3RoaXMubD0hMTtNKHRoaXMsXCJhcHBcIixhKTtpZihTKHRoaXMpLm9wdGlvbnMmJlModGhpcykub3B0aW9ucy5hcGlLZXkpYT1maXJlYmFzZS5TREtfVkVSU0lPTj9PZihmaXJlYmFzZS5TREtfVkVSU0lPTik6bnVsbCx0aGlzLmM9bmV3IENoKFModGhpcykub3B0aW9ucyYmUyh0aGlzKS5vcHRpb25zLmFwaUtleSx4aSh5aSksYSk7ZWxzZSB0aHJvdyBuZXcgTihcImludmFsaWQtYXBpLWtleVwiKTt0aGlzLk49W107dGhpcy5tPVtdO3RoaXMuST1bXTt0aGlzLktiPWZpcmViYXNlLklOVEVSTkFMLmNyZWF0ZVN1YnNjcmliZShyKHRoaXMuYWMsdGhpcykpO3RoaXMuUj12b2lkIDA7dGhpcy5MYj1maXJlYmFzZS5JTlRFUk5BTC5jcmVhdGVTdWJzY3JpYmUocih0aGlzLmJjLHRoaXMpKTt2bCh0aGlzLG51bGwpO3RoaXMuaD1uZXcgbGwoUyh0aGlzKS5vcHRpb25zLmFwaUtleStcIjpcIitTKHRoaXMpLm5hbWUpO3RoaXMuRz1uZXcgamwoUyh0aGlzKS5vcHRpb25zLmFwaUtleStcblwiOlwiK1ModGhpcykubmFtZSk7dGhpcy5VPVQodGhpcyx3bCh0aGlzKSk7dGhpcy5pPVQodGhpcyx4bCh0aGlzKSk7dGhpcy5XPSExO3RoaXMuaGE9cih0aGlzLnljLHRoaXMpO3RoaXMuR2E9cih0aGlzLmthLHRoaXMpO3RoaXMucGE9cih0aGlzLlRiLHRoaXMpO3RoaXMucWE9cih0aGlzLlpiLHRoaXMpO3RoaXMucmE9cih0aGlzLiRiLHRoaXMpO3lsKHRoaXMpO3RoaXMuSU5URVJOQUw9e307dGhpcy5JTlRFUk5BTFtcImRlbGV0ZVwiXT1yKHRoaXMuZGVsZXRlLHRoaXMpO3RoaXMuSU5URVJOQUwubG9nRnJhbWV3b3JrPXIodGhpcy5nYyx0aGlzKTt0aGlzLm89MDtGLmNhbGwodGhpcyk7emwodGhpcyk7dGhpcy5BPVtdfXQodWwsRik7ZnVuY3Rpb24gQWwoYSl7Qy5jYWxsKHRoaXMsXCJsYW5ndWFnZUNvZGVDaGFuZ2VkXCIpO3RoaXMuaD1hfXQoQWwsQyk7ZnVuY3Rpb24gQmwoYSl7Qy5jYWxsKHRoaXMsXCJmcmFtZXdvcmtDaGFuZ2VkXCIpO3RoaXMuZj1hfXQoQmwsQyk7aD11bC5wcm90b3R5cGU7XG5oLmViPWZ1bmN0aW9uKGEpe2E9dGhpcy5oLmViKGEpO3JldHVybiBUKHRoaXMsYSl9O2gubmE9ZnVuY3Rpb24oYSl7dGhpcy5WPT09YXx8dGhpcy5sfHwodGhpcy5WPWEsSWgodGhpcy5jLHRoaXMuViksRyh0aGlzLG5ldyBBbCh0aGlzLiQoKSkpKX07aC4kPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuVn07aC5FYz1mdW5jdGlvbigpe3ZhciBhPWsubmF2aWdhdG9yO3RoaXMubmEoYT9hLmxhbmd1YWdlcyYmYS5sYW5ndWFnZXNbMF18fGEubGFuZ3VhZ2V8fGEudXNlckxhbmd1YWdlfHxudWxsOm51bGwpfTtoLmdjPWZ1bmN0aW9uKGEpe3RoaXMuQS5wdXNoKGEpO0poKHRoaXMuYyxmaXJlYmFzZS5TREtfVkVSU0lPTj9PZihmaXJlYmFzZS5TREtfVkVSU0lPTix0aGlzLkEpOm51bGwpO0codGhpcyxuZXcgQmwodGhpcy5BKSl9O2guS2E9ZnVuY3Rpb24oKXtyZXR1cm4gTGEodGhpcy5BKX07XG5mdW5jdGlvbiB6bChhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImxjXCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLiQoKX0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMubmEoYSl9LGVudW1lcmFibGU6ITF9KTthLlY9bnVsbH1oLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnthcGlLZXk6Uyh0aGlzKS5vcHRpb25zLmFwaUtleSxhdXRoRG9tYWluOlModGhpcykub3B0aW9ucy5hdXRoRG9tYWluLGFwcE5hbWU6Uyh0aGlzKS5uYW1lLGN1cnJlbnRVc2VyOlUodGhpcykmJlUodGhpcykuQigpfX07ZnVuY3Rpb24gQ2woYSl7cmV0dXJuIGEuSmJ8fEIobmV3IE4oXCJhdXRoLWRvbWFpbi1jb25maWctcmVxdWlyZWRcIikpfVxuZnVuY3Rpb24geWwoYSl7dmFyIGI9UyhhKS5vcHRpb25zLmF1dGhEb21haW4sYz1TKGEpLm9wdGlvbnMuYXBpS2V5O2ImJlJmKCkmJihhLkpiPWEuVS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEubCl7YS5hPWdrKGIsYyxTKGEpLm5hbWUpO2EuYS5zdWJzY3JpYmUoYSk7VShhKSYmTmsoVShhKSk7aWYoYS53KXtOayhhLncpO3ZhciBkPWEudztkLm5hKGEuJCgpKTtHayhkLGEpO2Q9YS53O0ZrKGQsYS5BKTtIayhkLGEpO2Eudz1udWxsfXJldHVybiBhLmF9fSkpfWgub2I9ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInVua25vd25cIjpjYXNlIFwic2lnbkluVmlhUmVkaXJlY3RcIjpyZXR1cm4hMDtjYXNlIFwic2lnbkluVmlhUG9wdXBcIjpyZXR1cm4gdGhpcy5nPT1iJiYhIXRoaXMuZjtkZWZhdWx0OnJldHVybiExfX07XG5oLmZhPWZ1bmN0aW9uKGEsYixjLGQpe1wic2lnbkluVmlhUG9wdXBcIj09YSYmdGhpcy5nPT1kJiYoYyYmdGhpcy52P3RoaXMudihjKTpiJiYhYyYmdGhpcy5mJiZ0aGlzLmYoYiksdGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKSxkZWxldGUgdGhpcy5mLGRlbGV0ZSB0aGlzLnYpfTtoLnZhPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJzaWduSW5WaWFSZWRpcmVjdFwiPT1hfHxcInNpZ25JblZpYVBvcHVwXCI9PWEmJnRoaXMuZz09YiYmdGhpcy5mP3IodGhpcy5TYix0aGlzKTpudWxsfTtcbmguU2I9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2E9e3JlcXVlc3RVcmk6YSxzZXNzaW9uSWQ6Yn07dGhpcy5iJiYodGhpcy5iLmNhbmNlbCgpLHRoaXMuYj1udWxsKTt2YXIgZD1udWxsLGU9bnVsbCxmPVhnKGMuYyxhKS50aGVuKGZ1bmN0aW9uKGEpe2Q9dWgoYSk7ZT1NZyhhKTtyZXR1cm4gYX0pO2E9Yy5VLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gZn0pLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIERsKGMsYSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGhnKHt1c2VyOlUoYyksY3JlZGVudGlhbDpkLGFkZGl0aW9uYWxVc2VySW5mbzplLG9wZXJhdGlvblR5cGU6XCJzaWduSW5cIn0pfSk7cmV0dXJuIFQodGhpcyxhKX07XG5oLndjPWZ1bmN0aW9uKGEpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGI9dGhpcyxjPUxnKGEucHJvdmlkZXJJZCksZD1RZigpLGU9bnVsbDsoIVRmKCl8fExmKCkpJiZTKHRoaXMpLm9wdGlvbnMuYXV0aERvbWFpbiYmYS5pc09BdXRoUHJvdmlkZXImJihlPVJpKFModGhpcykub3B0aW9ucy5hdXRoRG9tYWluLFModGhpcykub3B0aW9ucy5hcGlLZXksUyh0aGlzKS5uYW1lLFwic2lnbkluVmlhUG9wdXBcIixhLG51bGwsZCxmaXJlYmFzZS5TREtfVkVSU0lPTnx8bnVsbCkpO3ZhciBmPURmKGUsYyYmYy56YSxjJiZjLnlhKTtjPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGVrKGIsZixcInNpZ25JblZpYVBvcHVwXCIsYSxkLCEhZSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGEsYyl7Yi5mYShcInNpZ25JblZpYVBvcHVwXCIsbnVsbCxuZXcgTihcImNhbmNlbGxlZC1wb3B1cC1yZXF1ZXN0XCIpLFxuYi5nKTtiLmY9YTtiLnY9YztiLmc9ZDtiLmI9Yi5hLkNhKGIsXCJzaWduSW5WaWFQb3B1cFwiLGYsZCl9KX0pLnRoZW4oZnVuY3Rpb24oYSl7ZiYmQ2YoZik7cmV0dXJuIGE/aGcoYSk6bnVsbH0pLnMoZnVuY3Rpb24oYSl7ZiYmQ2YoZik7dGhyb3cgYTt9KTtyZXR1cm4gVCh0aGlzLGMpfTtoLnhjPWZ1bmN0aW9uKGEpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGI9dGhpcyxjPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcWwoYi5oKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYi5hLkFhKFwic2lnbkluVmlhUmVkaXJlY3RcIixhKX0pO3JldHVybiBUKHRoaXMsYyl9O1xuaC5hYT1mdW5jdGlvbigpe2lmKCFSZigpKXJldHVybiBCKG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiKSk7dmFyIGE9dGhpcyxiPUNsKHRoaXMpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYS5hLmFhKCl9KS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhP2hnKGEpOm51bGx9KTtyZXR1cm4gVCh0aGlzLGIpfTtmdW5jdGlvbiBEbChhLGIpe3ZhciBjPXt9O2MuYXBpS2V5PVMoYSkub3B0aW9ucy5hcGlLZXk7Yy5hdXRoRG9tYWluPVMoYSkub3B0aW9ucy5hdXRoRG9tYWluO2MuYXBwTmFtZT1TKGEpLm5hbWU7cmV0dXJuIGEuVS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGlsKGMsYixhLkcsYS5LYSgpKX0pLnRoZW4oZnVuY3Rpb24oYil7aWYoVShhKSYmYi51aWQ9PVUoYSkudWlkKXJldHVybiBVayhVKGEpLGIpLGEua2EoYik7dmwoYSxiKTtOayhiKTtyZXR1cm4gYS5rYShiKX0pLnRoZW4oZnVuY3Rpb24oKXtFbChhKX0pfVxuZnVuY3Rpb24gdmwoYSxiKXtVKGEpJiYoTGsoVShhKSxhLkdhKSxFKFUoYSksXCJ0b2tlbkNoYW5nZWRcIixhLnBhKSxFKFUoYSksXCJ1c2VyRGVsZXRlZFwiLGEucWEpLEUoVShhKSxcInVzZXJJbnZhbGlkYXRlZFwiLGEucmEpLEtrKFUoYSkpKTtiJiYoYi5OLnB1c2goYS5HYSksY2QoYixcInRva2VuQ2hhbmdlZFwiLGEucGEpLGNkKGIsXCJ1c2VyRGVsZXRlZFwiLGEucWEpLGNkKGIsXCJ1c2VySW52YWxpZGF0ZWRcIixhLnJhKSwwPGEubyYmSmsoYikpO00oYSxcImN1cnJlbnRVc2VyXCIsYik7YiYmKGIubmEoYS4kKCkpLEdrKGIsYSksRmsoYixhLkEpLEhrKGIsYSkpfWguaGI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5pLnRoZW4oZnVuY3Rpb24oKXtpZighVShhKSlyZXR1cm4gQSgpO3ZsKGEsbnVsbCk7cmV0dXJuIHNsKGEuaCkudGhlbihmdW5jdGlvbigpe0VsKGEpfSl9KTtyZXR1cm4gVCh0aGlzLGIpfTtcbmZ1bmN0aW9uIEZsKGEpe3ZhciBiPWtsKGEuRyxTKGEpLm9wdGlvbnMuYXV0aERvbWFpbikudGhlbihmdW5jdGlvbihiKXtpZihhLnc9YiliLmNhPWEuRztyZXR1cm4gZmwoYS5HKX0pO3JldHVybiBUKGEsYil9ZnVuY3Rpb24gd2woYSl7dmFyIGI9UyhhKS5vcHRpb25zLmF1dGhEb21haW4sYz1GbChhKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHRsKGEuaCxiKX0pLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGI/KGIuY2E9YS5HLGEudyYmKGEudy5afHxudWxsKT09KGIuWnx8bnVsbCk/YjpiLnJlbG9hZCgpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gcmwoYS5oLGIpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYn0pfSkucyhmdW5jdGlvbihjKXtyZXR1cm5cImF1dGgvbmV0d29yay1yZXF1ZXN0LWZhaWxlZFwiPT1jLmNvZGU/YjpzbChhLmgpfSkpOm51bGx9KS50aGVuKGZ1bmN0aW9uKGIpe3ZsKGEsYnx8bnVsbCl9KTtyZXR1cm4gVChhLGMpfVxuZnVuY3Rpb24geGwoYSl7cmV0dXJuIGEuVS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGEuYWEoKX0pLnMoZnVuY3Rpb24oKXt9KS50aGVuKGZ1bmN0aW9uKCl7aWYoIWEubClyZXR1cm4gYS5oYSgpfSkucyhmdW5jdGlvbigpe30pLnRoZW4oZnVuY3Rpb24oKXtpZighYS5sKXthLlc9ITA7dmFyIGI9YS5oO3ZqKGIuYix5aihcImxvY2FsXCIpLGIuYSxhLmhhKX19KX1cbmgueWM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO3JldHVybiB0bCh0aGlzLmgsUyh0aGlzKS5vcHRpb25zLmF1dGhEb21haW4pLnRoZW4oZnVuY3Rpb24oYil7aWYoIWEubCl7dmFyIGM7aWYoYz1VKGEpJiZiKXtjPVUoYSkudWlkO3ZhciBkPWIudWlkO2M9dm9pZCAwPT09Y3x8bnVsbD09PWN8fFwiXCI9PT1jfHx2b2lkIDA9PT1kfHxudWxsPT09ZHx8XCJcIj09PWQ/ITE6Yz09ZH1pZihjKXJldHVybiBVayhVKGEpLGIpLFUoYSkuRigpO2lmKFUoYSl8fGIpdmwoYSxiKSxiJiYoTmsoYiksYi5jYT1hLkcpLGEuYSYmYS5hLnN1YnNjcmliZShhKSxFbChhKX19KX07aC5rYT1mdW5jdGlvbihhKXtyZXR1cm4gcmwodGhpcy5oLGEpfTtoLlRiPWZ1bmN0aW9uKCl7RWwodGhpcyk7dGhpcy5rYShVKHRoaXMpKX07aC5aYj1mdW5jdGlvbigpe3RoaXMuaGIoKX07aC4kYj1mdW5jdGlvbigpe3RoaXMuaGIoKX07XG5mdW5jdGlvbiBHbChhLGIpe3ZhciBjPW51bGwsZD1udWxsO3JldHVybiBUKGEsYi50aGVuKGZ1bmN0aW9uKGIpe2M9dWgoYik7ZD1NZyhiKTtyZXR1cm4gRGwoYSxiKX0pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gaGcoe3VzZXI6VShhKSxjcmVkZW50aWFsOmMsYWRkaXRpb25hbFVzZXJJbmZvOmQsb3BlcmF0aW9uVHlwZTpcInNpZ25JblwifSl9KSl9aC5hYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3RoaXMuYWRkQXV0aFRva2VuTGlzdGVuZXIoZnVuY3Rpb24oKXthLm5leHQoVShiKSl9KX07aC5iYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO0hsKHRoaXMsZnVuY3Rpb24oKXthLm5leHQoVShiKSl9KX07aC5pYz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpczt0aGlzLlcmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtwKGEpP2EoVShkKSk6cChhLm5leHQpJiZhLm5leHQoVShkKSl9KTtyZXR1cm4gdGhpcy5LYihhLGIsYyl9O1xuaC5oYz1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9dGhpczt0aGlzLlcmJmZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKXtkLlI9ZC5nZXRVaWQoKTtwKGEpP2EoVShkKSk6cChhLm5leHQpJiZhLm5leHQoVShkKSl9KTtyZXR1cm4gdGhpcy5MYihhLGIsYyl9O2guVmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFUoYik/VShiKS5GKGEpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJue2FjY2Vzc1Rva2VuOmF9fSk6bnVsbH0pO3JldHVybiBUKHRoaXMsYyl9O2gudGM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuRWIoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O1xuaC5FYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO3JldHVybiB0aGlzLmkudGhlbihmdW5jdGlvbigpe3JldHVybiBHbChiLFEoYi5jLHZpLHt0b2tlbjphfSkpfSkudGhlbihmdW5jdGlvbihhKXt2YXIgYz1hLnVzZXI7VGsoYyxcImlzQW5vbnltb3VzXCIsITEpO2Iua2EoYyk7cmV0dXJuIGF9KX07aC5GYj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEdsKGMsUShjLmMsa2gse2VtYWlsOmEscGFzc3dvcmQ6Yn0pKX0pfTtoLnVjPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuRmIoYSxiKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhLnVzZXJ9KX07aC5PYj1mdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLnFiKGEsYikudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS51c2VyfSl9O1xuaC5xYj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEdsKGMsUShjLmMscmkse2VtYWlsOmEscGFzc3dvcmQ6Yn0pKX0pfTtoLnNjPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmZiKGEpLnRoZW4oZnVuY3Rpb24oYSl7cmV0dXJuIGEudXNlcn0pfTtoLmZiPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7cmV0dXJuIHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIEdsKGIsYS53YShiLmMpKX0pfTtoLmdiPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuR2IoKS50aGVuKGZ1bmN0aW9uKGEpe3JldHVybiBhLnVzZXJ9KX07XG5oLkdiPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztyZXR1cm4gdGhpcy5pLnRoZW4oZnVuY3Rpb24oKXt2YXIgYj1VKGEpO2lmKGImJmIuaXNBbm9ueW1vdXMpe3ZhciBjPWhnKHtwcm92aWRlcklkOm51bGwsaXNOZXdVc2VyOiExfSk7cmV0dXJuIGhnKHt1c2VyOmIsY3JlZGVudGlhbDpudWxsLGFkZGl0aW9uYWxVc2VySW5mbzpjLG9wZXJhdGlvblR5cGU6XCJzaWduSW5cIn0pfXJldHVybiBHbChhLGEuYy5nYigpKS50aGVuKGZ1bmN0aW9uKGIpe3ZhciBjPWIudXNlcjtUayhjLFwiaXNBbm9ueW1vdXNcIiwhMCk7YS5rYShjKTtyZXR1cm4gYn0pfSl9O2Z1bmN0aW9uIFMoYSl7cmV0dXJuIGEuYXBwfWZ1bmN0aW9uIFUoYSl7cmV0dXJuIGEuY3VycmVudFVzZXJ9aC5nZXRVaWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVSh0aGlzKSYmVSh0aGlzKS51aWR8fG51bGx9O2Z1bmN0aW9uIElsKGEpe3JldHVybiBVKGEpJiZVKGEpLl9sYXR8fG51bGx9XG5mdW5jdGlvbiBFbChhKXtpZihhLlcpe2Zvcih2YXIgYj0wO2I8YS5tLmxlbmd0aDtiKyspaWYoYS5tW2JdKWEubVtiXShJbChhKSk7aWYoYS5SIT09YS5nZXRVaWQoKSYmYS5JLmxlbmd0aClmb3IoYS5SPWEuZ2V0VWlkKCksYj0wO2I8YS5JLmxlbmd0aDtiKyspaWYoYS5JW2JdKWEuSVtiXShJbChhKSl9fWguTWI9ZnVuY3Rpb24oYSl7dGhpcy5hZGRBdXRoVG9rZW5MaXN0ZW5lcihhKTt0aGlzLm8rKzswPHRoaXMubyYmVSh0aGlzKSYmSmsoVSh0aGlzKSl9O2gucWM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczt3KHRoaXMubSxmdW5jdGlvbihjKXtjPT1hJiZiLm8tLX0pOzA+dGhpcy5vJiYodGhpcy5vPTApOzA9PXRoaXMubyYmVSh0aGlzKSYmS2soVSh0aGlzKSk7dGhpcy5yZW1vdmVBdXRoVG9rZW5MaXN0ZW5lcihhKX07XG5oLmFkZEF1dGhUb2tlbkxpc3RlbmVyPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7dGhpcy5tLnB1c2goYSk7VCh0aGlzLHRoaXMuaS50aGVuKGZ1bmN0aW9uKCl7Yi5sfHxIYShiLm0sYSkmJmEoSWwoYikpfSkpfTtoLnJlbW92ZUF1dGhUb2tlbkxpc3RlbmVyPWZ1bmN0aW9uKGEpe0phKHRoaXMubSxmdW5jdGlvbihiKXtyZXR1cm4gYj09YX0pfTtmdW5jdGlvbiBIbChhLGIpe2EuSS5wdXNoKGIpO1QoYSxhLmkudGhlbihmdW5jdGlvbigpeyFhLmwmJkhhKGEuSSxiKSYmYS5SIT09YS5nZXRVaWQoKSYmKGEuUj1hLmdldFVpZCgpLGIoSWwoYSkpKX0pKX1oLmRlbGV0ZT1mdW5jdGlvbigpe3RoaXMubD0hMDtmb3IodmFyIGE9MDthPHRoaXMuTi5sZW5ndGg7YSsrKXRoaXMuTlthXS5jYW5jZWwoXCJhcHAtZGVsZXRlZFwiKTt0aGlzLk49W107dGhpcy5oJiYoYT10aGlzLmgseGooYS5iLGEuYSx0aGlzLmhhKSk7dGhpcy5hJiZ0aGlzLmEudW5zdWJzY3JpYmUodGhpcyk7cmV0dXJuIGZpcmViYXNlLlByb21pc2UucmVzb2x2ZSgpfTtcbmZ1bmN0aW9uIFQoYSxiKXthLk4ucHVzaChiKTtRYihiLGZ1bmN0aW9uKCl7SWEoYS5OLGIpfSk7cmV0dXJuIGJ9aC5SYj1mdW5jdGlvbihhKXtyZXR1cm4gVCh0aGlzLFRoKHRoaXMuYyxhKSl9O2guRmM9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuSWEoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gYS5kYXRhLmVtYWlsfSl9O2guVGE9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVCh0aGlzLHRoaXMuYy5UYShhLGIpLnRoZW4oZnVuY3Rpb24oKXt9KSl9O2guSWE9ZnVuY3Rpb24oYSl7cmV0dXJuIFQodGhpcyx0aGlzLmMuSWEoYSkudGhlbihmdW5jdGlvbihhKXtyZXR1cm4gbmV3IGxnKGEpfSkpfTtoLlNhPWZ1bmN0aW9uKGEpe3JldHVybiBUKHRoaXMsdGhpcy5jLlNhKGEpLnRoZW4oZnVuY3Rpb24oKXt9KSl9O1xuaC5jYj1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7cmV0dXJuIFQodGhpcyxBKCkudGhlbihmdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCI9PT10eXBlb2YgYnx8U2EoYik/e306RmcobmV3IHdnKGIpKX0pLnRoZW4oZnVuY3Rpb24oYil7cmV0dXJuIGMuYy5jYihhLGIpfSkudGhlbihmdW5jdGlvbigpe30pKX07aC52Yz1mdW5jdGlvbihhLGIpe3JldHVybiBUKHRoaXMsb2sodGhpcyxhLGIscih0aGlzLmZiLHRoaXMpKSl9O2Z1bmN0aW9uIEpsKGEsYixjLGQpe2E6e2M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYyk7dmFyIGU9MDtmb3IodmFyIGY9ITEsZz0wO2c8Yi5sZW5ndGg7ZysrKWlmKGJbZ10ub3B0aW9uYWwpZj0hMDtlbHNle2lmKGYpdGhyb3cgbmV3IE4oXCJpbnRlcm5hbC1lcnJvclwiLFwiQXJndW1lbnQgdmFsaWRhdG9yIGVuY291bnRlcmVkIGEgcmVxdWlyZWQgYXJndW1lbnQgYWZ0ZXIgYW4gb3B0aW9uYWwgYXJndW1lbnQuXCIpO2UrK31mPWIubGVuZ3RoO2lmKGMubGVuZ3RoPGV8fGY8Yy5sZW5ndGgpZD1cIkV4cGVjdGVkIFwiKyhlPT1mPzE9PWU/XCIxIGFyZ3VtZW50XCI6ZStcIiBhcmd1bWVudHNcIjplK1wiLVwiK2YrXCIgYXJndW1lbnRzXCIpK1wiIGJ1dCBnb3QgXCIrYy5sZW5ndGgrXCIuXCI7ZWxzZXtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKWlmKGY9YltlXS5vcHRpb25hbCYmdm9pZCAwPT09Y1tlXSwhYltlXS5NKGNbZV0pJiYhZil7Yj1iW2VdO2lmKDA+ZXx8ZT49S2wubGVuZ3RoKXRocm93IG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIixcblwiQXJndW1lbnQgdmFsaWRhdG9yIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO2M9S2xbZV07ZD0oZD9cIlwiOmMrXCIgYXJndW1lbnQgXCIpKyhiLm5hbWU/J1wiJytiLm5hbWUrJ1wiICc6XCJcIikrXCJtdXN0IGJlIFwiK2IuSytcIi5cIjticmVhayBhfWQ9bnVsbH19aWYoZCl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsYStcIiBmYWlsZWQ6IFwiK2QpO312YXIgS2w9XCJGaXJzdCBTZWNvbmQgVGhpcmQgRm91cnRoIEZpZnRoIFNpeHRoIFNldmVudGggRWlnaHRoIE5pbnRoXCIuc3BsaXQoXCIgXCIpO2Z1bmN0aW9uIFYoYSxiKXtyZXR1cm57bmFtZTphfHxcIlwiLEs6XCJhIHZhbGlkIHN0cmluZ1wiLG9wdGlvbmFsOiEhYixNOm19fWZ1bmN0aW9uIExsKCl7cmV0dXJue25hbWU6XCJvcHRfZm9yY2VSZWZyZXNoXCIsSzpcImEgYm9vbGVhblwiLG9wdGlvbmFsOiEwLE06YmF9fVxuZnVuY3Rpb24gVyhhLGIpe3JldHVybntuYW1lOmF8fFwiXCIsSzpcImEgdmFsaWQgb2JqZWN0XCIsb3B0aW9uYWw6ISFiLE06cX19ZnVuY3Rpb24gTWwoYSxiKXtyZXR1cm57bmFtZTphfHxcIlwiLEs6XCJhIGZ1bmN0aW9uXCIsb3B0aW9uYWw6ISFiLE06cH19ZnVuY3Rpb24gTmwoYSxiKXtyZXR1cm57bmFtZTphfHxcIlwiLEs6XCJudWxsXCIsb3B0aW9uYWw6ISFiLE06ZWF9fWZ1bmN0aW9uIE9sKCl7cmV0dXJue25hbWU6XCJcIixLOlwiYW4gSFRNTCBlbGVtZW50XCIsb3B0aW9uYWw6ITEsTTpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgRWxlbWVudCl9fX1mdW5jdGlvbiBQbCgpe3JldHVybntuYW1lOlwiYXV0aFwiLEs6XCJhbiBpbnN0YW5jZSBvZiBGaXJlYmFzZSBBdXRoXCIsb3B0aW9uYWw6ITAsTTpmdW5jdGlvbihhKXtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgdWwpfX19XG5mdW5jdGlvbiBRbCgpe3JldHVybntuYW1lOlwiYXBwXCIsSzpcImFuIGluc3RhbmNlIG9mIEZpcmViYXNlIEFwcFwiLG9wdGlvbmFsOiEwLE06ZnVuY3Rpb24oYSl7cmV0dXJuISEoYSYmYSBpbnN0YW5jZW9mIGZpcmViYXNlLmFwcC5BcHApfX19ZnVuY3Rpb24gUmwoYSl7cmV0dXJue25hbWU6YT9hK1wiQ3JlZGVudGlhbFwiOlwiY3JlZGVudGlhbFwiLEs6YT9cImEgdmFsaWQgXCIrYStcIiBjcmVkZW50aWFsXCI6XCJhIHZhbGlkIGNyZWRlbnRpYWxcIixvcHRpb25hbDohMSxNOmZ1bmN0aW9uKGIpe2lmKCFiKXJldHVybiExO3ZhciBjPSFhfHxiLnByb3ZpZGVySWQ9PT1hO3JldHVybiEoIWIud2F8fCFjKX19fVxuZnVuY3Rpb24gU2woKXtyZXR1cm57bmFtZTpcImF1dGhQcm92aWRlclwiLEs6XCJhIHZhbGlkIEF1dGggcHJvdmlkZXJcIixvcHRpb25hbDohMSxNOmZ1bmN0aW9uKGEpe3JldHVybiEhKGEmJmEucHJvdmlkZXJJZCYmYS5oYXNPd25Qcm9wZXJ0eSYmYS5oYXNPd25Qcm9wZXJ0eShcImlzT0F1dGhQcm92aWRlclwiKSl9fX1mdW5jdGlvbiBUbCgpe3JldHVybntuYW1lOlwiYXBwbGljYXRpb25WZXJpZmllclwiLEs6XCJhbiBpbXBsZW1lbnRhdGlvbiBvZiBmaXJlYmFzZS5hdXRoLkFwcGxpY2F0aW9uVmVyaWZpZXJcIixvcHRpb25hbDohMSxNOmZ1bmN0aW9uKGEpe3JldHVybiEhKGEmJm0oYS50eXBlKSYmcChhLnZlcmlmeSkpfX19ZnVuY3Rpb24gWChhLGIsYyxkKXtyZXR1cm57bmFtZTpjfHxcIlwiLEs6YS5LK1wiIG9yIFwiK2IuSyxvcHRpb25hbDohIWQsTTpmdW5jdGlvbihjKXtyZXR1cm4gYS5NKGMpfHxiLk0oYyl9fX07ZnVuY3Rpb24gVWwoYSxiLGMsZCxlLGYpe00odGhpcyxcInR5cGVcIixcInJlY2FwdGNoYVwiKTt0aGlzLmI9dGhpcy5jPW51bGw7dGhpcy5tPSExO3RoaXMubD1iO3RoaXMuYT1jfHx7dGhlbWU6XCJsaWdodFwiLHR5cGU6XCJpbWFnZVwifTt0aGlzLmc9W107aWYodGhpcy5hW1ZsXSl0aHJvdyBuZXcgTihcImFyZ3VtZW50LWVycm9yXCIsXCJzaXRla2V5IHNob3VsZCBub3QgYmUgcHJvdmlkZWQgZm9yIHJlQ0FQVENIQSBhcyBvbmUgaXMgYXV0b21hdGljYWxseSBwcm92aXNpb25lZCBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdC5cIik7dGhpcy5oPVwiaW52aXNpYmxlXCI9PT10aGlzLmFbV2xdO2lmKCF3YyhiKXx8IXRoaXMuaCYmd2MoYikuaGFzQ2hpbGROb2RlcygpKXRocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcInJlQ0FQVENIQSBjb250YWluZXIgaXMgZWl0aGVyIG5vdCBmb3VuZCBvciBhbHJlYWR5IGNvbnRhaW5zIGlubmVyIGVsZW1lbnRzIVwiKTt0aGlzLnU9bmV3IENoKGEsZnx8bnVsbCxlfHxudWxsKTtcbnRoaXMubz1kfHxmdW5jdGlvbigpe3JldHVybiBudWxsfTt2YXIgZz10aGlzO3RoaXMuaT1bXTt2YXIgbD10aGlzLmFbWGxdO3RoaXMuYVtYbF09ZnVuY3Rpb24oYSl7WWwoZyxhKTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgbClsKGEpO2Vsc2UgaWYoXCJzdHJpbmdcIj09PXR5cGVvZiBsKXt2YXIgYj1MKGwsayk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGImJmIoYSl9fTt2YXIgbj10aGlzLmFbWmxdO3RoaXMuYVtabF09ZnVuY3Rpb24oKXtZbChnLG51bGwpO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBuKW4oKTtlbHNlIGlmKFwic3RyaW5nXCI9PT10eXBlb2Ygbil7dmFyIGE9TChuLGspO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiZhKCl9fX12YXIgWGw9XCJjYWxsYmFja1wiLFpsPVwiZXhwaXJlZC1jYWxsYmFja1wiLFZsPVwic2l0ZWtleVwiLFdsPVwic2l6ZVwiO2Z1bmN0aW9uIFlsKGEsYil7Zm9yKHZhciBjPTA7YzxhLmkubGVuZ3RoO2MrKyl0cnl7YS5pW2NdKGIpfWNhdGNoKGQpe319XG5mdW5jdGlvbiAkbChhLGIpe0phKGEuaSxmdW5jdGlvbihhKXtyZXR1cm4gYT09Yn0pfWZ1bmN0aW9uIGFtKGEsYil7YS5nLnB1c2goYik7UWIoYixmdW5jdGlvbigpe0lhKGEuZyxiKX0pO3JldHVybiBifWg9VWwucHJvdG90eXBlO1xuaC54YT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7cmV0dXJuIHRoaXMuYz90aGlzLmM6dGhpcy5jPWFtKHRoaXMsQSgpLnRoZW4oZnVuY3Rpb24oKXtpZihTZigpKXJldHVybiBIZigpO3Rocm93IG5ldyBOKFwib3BlcmF0aW9uLW5vdC1zdXBwb3J0ZWQtaW4tdGhpcy1lbnZpcm9ubWVudFwiLFwiUmVjYXB0Y2hhVmVyaWZpZXIgaXMgb25seSBzdXBwb3J0ZWQgaW4gYSBicm93c2VyIEhUVFAvSFRUUFMgZW52aXJvbm1lbnQuXCIpO30pLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gYm0oY20oKSxhLm8oKSl9KS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIFEoYS51LHVpLHt9KX0pLnRoZW4oZnVuY3Rpb24oYil7YS5hW1ZsXT1iLnJlY2FwdGNoYVNpdGVLZXl9KS5zKGZ1bmN0aW9uKGIpe2EuYz1udWxsO3Rocm93IGI7fSkpfTtcbmgucmVuZGVyPWZ1bmN0aW9uKCl7ZG0odGhpcyk7dmFyIGE9dGhpcztyZXR1cm4gYW0odGhpcyx0aGlzLnhhKCkudGhlbihmdW5jdGlvbigpe2lmKG51bGw9PT1hLmIpe3ZhciBiPWEubDtpZighYS5oKXt2YXIgYz13YyhiKTtiPXpjKFwiRElWXCIpO2MuYXBwZW5kQ2hpbGQoYil9YS5iPWdyZWNhcHRjaGEucmVuZGVyKGIsYS5hKX1yZXR1cm4gYS5ifSkpfTtoLnZlcmlmeT1mdW5jdGlvbigpe2RtKHRoaXMpO3ZhciBhPXRoaXM7cmV0dXJuIGFtKHRoaXMsdGhpcy5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uKGIpe3JldHVybiBuZXcgeihmdW5jdGlvbihjKXt2YXIgZD1ncmVjYXB0Y2hhLmdldFJlc3BvbnNlKGIpO2lmKGQpYyhkKTtlbHNle3ZhciBlPWZ1bmN0aW9uKGIpe2ImJigkbChhLGUpLGMoYikpfTthLmkucHVzaChlKTthLmgmJmdyZWNhcHRjaGEuZXhlY3V0ZShhLmIpfX0pfSkpfTtoLnJlc2V0PWZ1bmN0aW9uKCl7ZG0odGhpcyk7bnVsbCE9PXRoaXMuYiYmZ3JlY2FwdGNoYS5yZXNldCh0aGlzLmIpfTtcbmZ1bmN0aW9uIGRtKGEpe2lmKGEubSl0aHJvdyBuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJSZWNhcHRjaGFWZXJpZmllciBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQuXCIpO31oLmNsZWFyPWZ1bmN0aW9uKCl7ZG0odGhpcyk7dGhpcy5tPSEwO2NtKCkuYi0tO2Zvcih2YXIgYT0wO2E8dGhpcy5nLmxlbmd0aDthKyspdGhpcy5nW2FdLmNhbmNlbChcIlJlY2FwdGNoYVZlcmlmaWVyIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZC5cIik7aWYoIXRoaXMuaCl7YT13Yyh0aGlzLmwpO2Zvcih2YXIgYjtiPWEuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChiKX19O3ZhciBlbT1kYyhcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhL2FwaS5qcz9vbmxvYWQ9JXtvbmxvYWR9JnJlbmRlcj1leHBsaWNpdCZobD0le2hsfVwiKTtcbmZ1bmN0aW9uIGZtKCl7dGhpcy5iPWsuZ3JlY2FwdGNoYT9JbmZpbml0eTowO3RoaXMuYz1udWxsO3RoaXMuYT1cIl9fcmNiXCIrTWF0aC5mbG9vcigxRTYqTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoKX1cbmZ1bmN0aW9uIGJtKGEsYil7cmV0dXJuIG5ldyB6KGZ1bmN0aW9uKGMsZCl7aWYoWmYoKSlpZighay5ncmVjYXB0Y2hhfHxiIT09YS5jJiYhYS5iKXtrW2EuYV09ZnVuY3Rpb24oKXtpZihrLmdyZWNhcHRjaGEpe2EuYz1iO3ZhciBlPWsuZ3JlY2FwdGNoYS5yZW5kZXI7ay5ncmVjYXB0Y2hhLnJlbmRlcj1mdW5jdGlvbihiLGMpe2I9ZShiLGMpO2EuYisrO3JldHVybiBifTtjKCl9ZWxzZSBkKG5ldyBOKFwiaW50ZXJuYWwtZXJyb3JcIikpO2RlbGV0ZSBrW2EuYV19O3ZhciBlPWhjKGVtLHtvbmxvYWQ6YS5hLGhsOmJ8fFwiXCJ9KTtBKGtmKGUpKS5zKGZ1bmN0aW9uKCl7ZChuZXcgTihcImludGVybmFsLWVycm9yXCIsXCJVbmFibGUgdG8gbG9hZCBleHRlcm5hbCByZUNBUFRDSEEgZGVwZW5kZW5jaWVzIVwiKSl9KX1lbHNlIGMoKTtlbHNlIGQobmV3IE4oXCJuZXR3b3JrLXJlcXVlc3QtZmFpbGVkXCIpKX0pfXZhciBnbT1udWxsO1xuZnVuY3Rpb24gY20oKXtnbXx8KGdtPW5ldyBmbSk7cmV0dXJuIGdtfWZ1bmN0aW9uIGhtKGEsYixjKXt0cnl7dGhpcy5mPWN8fGZpcmViYXNlLmFwcCgpfWNhdGNoKGYpe3Rocm93IG5ldyBOKFwiYXJndW1lbnQtZXJyb3JcIixcIk5vIGZpcmViYXNlLmFwcC5BcHAgaW5zdGFuY2UgaXMgY3VycmVudGx5IGluaXRpYWxpemVkLlwiKTt9aWYodGhpcy5mLm9wdGlvbnMmJnRoaXMuZi5vcHRpb25zLmFwaUtleSljPXRoaXMuZi5vcHRpb25zLmFwaUtleTtlbHNlIHRocm93IG5ldyBOKFwiaW52YWxpZC1hcGkta2V5XCIpO3ZhciBkPXRoaXMsZT1udWxsO3RyeXtlPXRoaXMuZi5hdXRoKCkuS2EoKX1jYXRjaChmKXt9ZT1maXJlYmFzZS5TREtfVkVSU0lPTj9PZihmaXJlYmFzZS5TREtfVkVSU0lPTixlKTpudWxsO1VsLmNhbGwodGhpcyxjLGEsYixmdW5jdGlvbigpe3RyeXt2YXIgYT1kLmYuYXV0aCgpLiQoKX1jYXRjaChnKXthPW51bGx9cmV0dXJuIGF9LGUseGkoeWkpKX10KGhtLFVsKTtmdW5jdGlvbiBZKGEsYil7Zm9yKHZhciBjIGluIGIpe3ZhciBkPWJbY10ubmFtZTthW2RdPWltKGQsYVtjXSxiW2NdLmopfX1mdW5jdGlvbiBaKGEsYixjLGQpe2FbYl09aW0oYixjLGQpfWZ1bmN0aW9uIGltKGEsYixjKXtmdW5jdGlvbiBkKCl7dmFyIGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtKbChlLGMsYSk7cmV0dXJuIGIuYXBwbHkodGhpcyxhKX1pZighYylyZXR1cm4gYjt2YXIgZT1qbShhKSxmO2ZvcihmIGluIGIpZFtmXT1iW2ZdO2ZvcihmIGluIGIucHJvdG90eXBlKWQucHJvdG90eXBlW2ZdPWIucHJvdG90eXBlW2ZdO3JldHVybiBkfWZ1bmN0aW9uIGptKGEpe2E9YS5zcGxpdChcIi5cIik7cmV0dXJuIGFbYS5sZW5ndGgtMV19O1kodWwucHJvdG90eXBlLHtTYTp7bmFtZTpcImFwcGx5QWN0aW9uQ29kZVwiLGo6W1YoXCJjb2RlXCIpXX0sSWE6e25hbWU6XCJjaGVja0FjdGlvbkNvZGVcIixqOltWKFwiY29kZVwiKV19LFRhOntuYW1lOlwiY29uZmlybVBhc3N3b3JkUmVzZXRcIixqOltWKFwiY29kZVwiKSxWKFwibmV3UGFzc3dvcmRcIildfSxPYjp7bmFtZTpcImNyZWF0ZVVzZXJXaXRoRW1haWxBbmRQYXNzd29yZFwiLGo6W1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildfSxxYjp7bmFtZTpcImNyZWF0ZVVzZXJBbmRSZXRyaWV2ZURhdGFXaXRoRW1haWxBbmRQYXNzd29yZFwiLGo6W1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildfSxSYjp7bmFtZTpcImZldGNoUHJvdmlkZXJzRm9yRW1haWxcIixqOltWKFwiZW1haWxcIildfSxhYTp7bmFtZTpcImdldFJlZGlyZWN0UmVzdWx0XCIsajpbXX0saGM6e25hbWU6XCJvbkF1dGhTdGF0ZUNoYW5nZWRcIixqOltYKFcoKSxNbCgpLFwibmV4dE9yT2JzZXJ2ZXJcIiksTWwoXCJvcHRfZXJyb3JcIiwhMCksTWwoXCJvcHRfY29tcGxldGVkXCIsXG4hMCldfSxpYzp7bmFtZTpcIm9uSWRUb2tlbkNoYW5nZWRcIixqOltYKFcoKSxNbCgpLFwibmV4dE9yT2JzZXJ2ZXJcIiksTWwoXCJvcHRfZXJyb3JcIiwhMCksTWwoXCJvcHRfY29tcGxldGVkXCIsITApXX0sY2I6e25hbWU6XCJzZW5kUGFzc3dvcmRSZXNldEVtYWlsXCIsajpbVihcImVtYWlsXCIpLFgoVyhcIm9wdF9hY3Rpb25Db2RlU2V0dGluZ3NcIiwhMCksTmwobnVsbCwhMCksXCJvcHRfYWN0aW9uQ29kZVNldHRpbmdzXCIsITApXX0sZWI6e25hbWU6XCJzZXRQZXJzaXN0ZW5jZVwiLGo6W1YoXCJwZXJzaXN0ZW5jZVwiKV19LGZiOntuYW1lOlwic2lnbkluQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sZ2I6e25hbWU6XCJzaWduSW5Bbm9ueW1vdXNseVwiLGo6W119LEdiOntuYW1lOlwic2lnbkluQW5vbnltb3VzbHlBbmRSZXRyaWV2ZURhdGFcIixqOltdfSxzYzp7bmFtZTpcInNpZ25JbldpdGhDcmVkZW50aWFsXCIsajpbUmwoKV19LHRjOntuYW1lOlwic2lnbkluV2l0aEN1c3RvbVRva2VuXCIsajpbVihcInRva2VuXCIpXX0sXG5FYjp7bmFtZTpcInNpZ25JbkFuZFJldHJpZXZlRGF0YVdpdGhDdXN0b21Ub2tlblwiLGo6W1YoXCJ0b2tlblwiKV19LHVjOntuYW1lOlwic2lnbkluV2l0aEVtYWlsQW5kUGFzc3dvcmRcIixqOltWKFwiZW1haWxcIiksVihcInBhc3N3b3JkXCIpXX0sRmI6e25hbWU6XCJzaWduSW5BbmRSZXRyaWV2ZURhdGFXaXRoRW1haWxBbmRQYXNzd29yZFwiLGo6W1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildfSx2Yzp7bmFtZTpcInNpZ25JbldpdGhQaG9uZU51bWJlclwiLGo6W1YoXCJwaG9uZU51bWJlclwiKSxUbCgpXX0sd2M6e25hbWU6XCJzaWduSW5XaXRoUG9wdXBcIixqOltTbCgpXX0seGM6e25hbWU6XCJzaWduSW5XaXRoUmVkaXJlY3RcIixqOltTbCgpXX0saGI6e25hbWU6XCJzaWduT3V0XCIsajpbXX0sdG9KU09OOntuYW1lOlwidG9KU09OXCIsajpbVihudWxsLCEwKV19LEVjOntuYW1lOlwidXNlRGV2aWNlTGFuZ3VhZ2VcIixqOltdfSxGYzp7bmFtZTpcInZlcmlmeVBhc3N3b3JkUmVzZXRDb2RlXCIsajpbVihcImNvZGVcIildfX0pO1xuKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjIGluIGIpe3ZhciBkPWJbY10ubmFtZTtpZihkIT09Yyl7dmFyIGU9YltjXS5OYjtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tjXX0sc2V0OmZ1bmN0aW9uKGEpe0psKGQsW2VdLFthXSwhMCk7dGhpc1tjXT1hfSxlbnVtZXJhYmxlOiEwfSl9fX0pKHVsLnByb3RvdHlwZSx7bGM6e25hbWU6XCJsYW5ndWFnZUNvZGVcIixOYjpYKFYoKSxObCgpLFwibGFuZ3VhZ2VDb2RlXCIpfX0pO3VsLlBlcnNpc3RlbmNlPW5qO3VsLlBlcnNpc3RlbmNlLkxPQ0FMPVwibG9jYWxcIjt1bC5QZXJzaXN0ZW5jZS5TRVNTSU9OPVwic2Vzc2lvblwiO3VsLlBlcnNpc3RlbmNlLk5PTkU9XCJub25lXCI7XG5ZKEJrLnByb3RvdHlwZSx7XCJkZWxldGVcIjp7bmFtZTpcImRlbGV0ZVwiLGo6W119LEY6e25hbWU6XCJnZXRJZFRva2VuXCIsajpbTGwoKV19LGdldFRva2VuOntuYW1lOlwiZ2V0VG9rZW5cIixqOltMbCgpXX0sWGE6e25hbWU6XCJsaW5rQW5kUmV0cmlldmVEYXRhV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sY2M6e25hbWU6XCJsaW5rV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sZGM6e25hbWU6XCJsaW5rV2l0aFBob25lTnVtYmVyXCIsajpbVihcInBob25lTnVtYmVyXCIpLFRsKCldfSxlYzp7bmFtZTpcImxpbmtXaXRoUG9wdXBcIixqOltTbCgpXX0sZmM6e25hbWU6XCJsaW5rV2l0aFJlZGlyZWN0XCIsajpbU2woKV19LFphOntuYW1lOlwicmVhdXRoZW50aWNhdGVBbmRSZXRyaWV2ZURhdGFXaXRoQ3JlZGVudGlhbFwiLGo6W1JsKCldfSxtYzp7bmFtZTpcInJlYXV0aGVudGljYXRlV2l0aENyZWRlbnRpYWxcIixqOltSbCgpXX0sbmM6e25hbWU6XCJyZWF1dGhlbnRpY2F0ZVdpdGhQaG9uZU51bWJlclwiLGo6W1YoXCJwaG9uZU51bWJlclwiKSxcblRsKCldfSxvYzp7bmFtZTpcInJlYXV0aGVudGljYXRlV2l0aFBvcHVwXCIsajpbU2woKV19LHBjOntuYW1lOlwicmVhdXRoZW50aWNhdGVXaXRoUmVkaXJlY3RcIixqOltTbCgpXX0scmVsb2FkOntuYW1lOlwicmVsb2FkXCIsajpbXX0sYmI6e25hbWU6XCJzZW5kRW1haWxWZXJpZmljYXRpb25cIixqOltYKFcoXCJvcHRfYWN0aW9uQ29kZVNldHRpbmdzXCIsITApLE5sKG51bGwsITApLFwib3B0X2FjdGlvbkNvZGVTZXR0aW5nc1wiLCEwKV19LHRvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGo6W1YobnVsbCwhMCldfSxDYzp7bmFtZTpcInVubGlua1wiLGo6W1YoXCJwcm92aWRlclwiKV19LGtiOntuYW1lOlwidXBkYXRlRW1haWxcIixqOltWKFwiZW1haWxcIildfSxsYjp7bmFtZTpcInVwZGF0ZVBhc3N3b3JkXCIsajpbVihcInBhc3N3b3JkXCIpXX0sRGM6e25hbWU6XCJ1cGRhdGVQaG9uZU51bWJlclwiLGo6W1JsKFwicGhvbmVcIildfSxtYjp7bmFtZTpcInVwZGF0ZVByb2ZpbGVcIixqOltXKFwicHJvZmlsZVwiKV19fSk7XG5ZKHoucHJvdG90eXBlLHtzOntuYW1lOlwiY2F0Y2hcIn0sdGhlbjp7bmFtZTpcInRoZW5cIn19KTtZKG5rLnByb3RvdHlwZSx7Y29uZmlybTp7bmFtZTpcImNvbmZpcm1cIixqOltWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV19fSk7WihtaCxcImNyZWRlbnRpYWxcIixmdW5jdGlvbihhLGIpe3JldHVybiBuZXcgamgoYSxiKX0sW1YoXCJlbWFpbFwiKSxWKFwicGFzc3dvcmRcIildKTtZKGJoLnByb3RvdHlwZSx7c2E6e25hbWU6XCJhZGRTY29wZVwiLGo6W1YoXCJzY29wZVwiKV19LEJhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1ooYmgsXCJjcmVkZW50aWFsXCIsY2gsW1goVigpLFcoKSxcInRva2VuXCIpXSk7WShkaC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxCYTp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixqOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtcblooZGgsXCJjcmVkZW50aWFsXCIsZWgsW1goVigpLFcoKSxcInRva2VuXCIpXSk7WShmaC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxCYTp7bmFtZTpcInNldEN1c3RvbVBhcmFtZXRlcnNcIixqOltXKFwiY3VzdG9tT0F1dGhQYXJhbWV0ZXJzXCIpXX19KTtaKGZoLFwiY3JlZGVudGlhbFwiLGdoLFtYKFYoKSxYKFcoKSxObCgpKSxcImlkVG9rZW5cIiksWChWKCksTmwoKSxcImFjY2Vzc1Rva2VuXCIsITApXSk7WShoaC5wcm90b3R5cGUse0JhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1ooaGgsXCJjcmVkZW50aWFsXCIsaWgsW1goVigpLFcoKSxcInRva2VuXCIpLFYoXCJzZWNyZXRcIiwhMCldKTtcblkoUC5wcm90b3R5cGUse3NhOntuYW1lOlwiYWRkU2NvcGVcIixqOltWKFwic2NvcGVcIildfSxjcmVkZW50aWFsOntuYW1lOlwiY3JlZGVudGlhbFwiLGo6W1goVigpLE5sKCksXCJpZFRva2VuXCIsITApLFgoVigpLE5sKCksXCJhY2Nlc3NUb2tlblwiLCEwKV19LEJhOntuYW1lOlwic2V0Q3VzdG9tUGFyYW1ldGVyc1wiLGo6W1coXCJjdXN0b21PQXV0aFBhcmFtZXRlcnNcIildfX0pO1oocmgsXCJjcmVkZW50aWFsXCIsdGgsW1YoXCJ2ZXJpZmljYXRpb25JZFwiKSxWKFwidmVyaWZpY2F0aW9uQ29kZVwiKV0pO1kocmgucHJvdG90eXBlLHtRYTp7bmFtZTpcInZlcmlmeVBob25lTnVtYmVyXCIsajpbVihcInBob25lTnVtYmVyXCIpLFRsKCldfX0pO1koTi5wcm90b3R5cGUse3RvSlNPTjp7bmFtZTpcInRvSlNPTlwiLGo6W1YobnVsbCwhMCldfX0pO1koemgucHJvdG90eXBlLHt0b0pTT046e25hbWU6XCJ0b0pTT05cIixqOltWKG51bGwsITApXX19KTtcblkoeWgucHJvdG90eXBlLHt0b0pTT046e25hbWU6XCJ0b0pTT05cIixqOltWKG51bGwsITApXX19KTtZKGhtLnByb3RvdHlwZSx7Y2xlYXI6e25hbWU6XCJjbGVhclwiLGo6W119LHJlbmRlcjp7bmFtZTpcInJlbmRlclwiLGo6W119LHZlcmlmeTp7bmFtZTpcInZlcmlmeVwiLGo6W119fSk7XG4oZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGZpcmViYXNlJiZmaXJlYmFzZS5JTlRFUk5BTCYmZmlyZWJhc2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKXt2YXIgYT17QXV0aDp1bCxFcnJvcjpOfTtaKGEsXCJFbWFpbEF1dGhQcm92aWRlclwiLG1oLFtdKTtaKGEsXCJGYWNlYm9va0F1dGhQcm92aWRlclwiLGJoLFtdKTtaKGEsXCJHaXRodWJBdXRoUHJvdmlkZXJcIixkaCxbXSk7WihhLFwiR29vZ2xlQXV0aFByb3ZpZGVyXCIsZmgsW10pO1ooYSxcIlR3aXR0ZXJBdXRoUHJvdmlkZXJcIixoaCxbXSk7WihhLFwiT0F1dGhQcm92aWRlclwiLFAsW1YoXCJwcm92aWRlcklkXCIpXSk7WihhLFwiUGhvbmVBdXRoUHJvdmlkZXJcIixyaCxbUGwoKV0pO1ooYSxcIlJlY2FwdGNoYVZlcmlmaWVyXCIsaG0sW1goVigpLE9sKCksXCJyZWNhcHRjaGFDb250YWluZXJcIiksVyhcInJlY2FwdGNoYVBhcmFtZXRlcnNcIiwhMCksUWwoKV0pO2ZpcmViYXNlLklOVEVSTkFMLnJlZ2lzdGVyU2VydmljZShcImF1dGhcIixmdW5jdGlvbihhLFxuYyl7YT1uZXcgdWwoYSk7Yyh7SU5URVJOQUw6e2dldFVpZDpyKGEuZ2V0VWlkLGEpLGdldFRva2VuOnIoYS5WYixhKSxhZGRBdXRoVG9rZW5MaXN0ZW5lcjpyKGEuTWIsYSkscmVtb3ZlQXV0aFRva2VuTGlzdGVuZXI6cihhLnFjLGEpfX0pO3JldHVybiBhfSxhLGZ1bmN0aW9uKGEsYyl7aWYoXCJjcmVhdGVcIj09PWEpdHJ5e2MuYXV0aCgpfWNhdGNoKGQpe319KTtmaXJlYmFzZS5JTlRFUk5BTC5leHRlbmROYW1lc3BhY2Uoe1VzZXI6Qmt9KX1lbHNlIHRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgdGhlIGZpcmViYXNlIG5hbWVzcGFjZTsgYmUgc3VyZSB0byBpbmNsdWRlIGZpcmViYXNlLWFwcC5qcyBiZWZvcmUgdGhpcyBsaWJyYXJ5LlwiKTt9KSgpO1xufSkuY2FsbCh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9hdXRoL2Rpc3QvYXV0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFwcF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS9hcHBcIik7XG52YXIgRGF0YWJhc2VfMSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvRGF0YWJhc2VcIik7XG5leHBvcnRzLkRhdGFiYXNlID0gRGF0YWJhc2VfMS5EYXRhYmFzZTtcbnZhciBRdWVyeV8xID0gcmVxdWlyZShcIi4vc3JjL2FwaS9RdWVyeVwiKTtcbmV4cG9ydHMuUXVlcnkgPSBRdWVyeV8xLlF1ZXJ5O1xudmFyIFJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vc3JjL2FwaS9SZWZlcmVuY2VcIik7XG5leHBvcnRzLlJlZmVyZW5jZSA9IFJlZmVyZW5jZV8xLlJlZmVyZW5jZTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi9zcmMvY29yZS91dGlsL3V0aWxcIik7XG5leHBvcnRzLmVuYWJsZUxvZ2dpbmcgPSB1dGlsXzEuZW5hYmxlTG9nZ2luZztcbnZhciBSZXBvTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vc3JjL2NvcmUvUmVwb01hbmFnZXJcIik7XG52YXIgSU5URVJOQUwgPSByZXF1aXJlKFwiLi9zcmMvYXBpL2ludGVybmFsXCIpO1xudmFyIFRFU1RfQUNDRVNTID0gcmVxdWlyZShcIi4vc3JjL2FwaS90ZXN0X2FjY2Vzc1wiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgU2VydmVyVmFsdWUgPSBEYXRhYmFzZV8xLkRhdGFiYXNlLlNlcnZlclZhbHVlO1xuZXhwb3J0cy5TZXJ2ZXJWYWx1ZSA9IFNlcnZlclZhbHVlO1xuZnVuY3Rpb24gcmVnaXN0ZXJEYXRhYmFzZShpbnN0YW5jZSkge1xuICAgIC8vIFJlZ2lzdGVyIHRoZSBEYXRhYmFzZSBTZXJ2aWNlIHdpdGggdGhlICdmaXJlYmFzZScgbmFtZXNwYWNlLlxuICAgIHZhciBuYW1lc3BhY2UgPSBpbnN0YW5jZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UoJ2RhdGFiYXNlJywgZnVuY3Rpb24gKGFwcCwgdW51c2VkLCB1cmwpIHsgcmV0dXJuIFJlcG9NYW5hZ2VyXzEuUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5kYXRhYmFzZUZyb21BcHAoYXBwLCB1cmwpOyB9LCBcbiAgICAvLyBmaXJlYmFzZS5kYXRhYmFzZSBuYW1lc3BhY2UgcHJvcGVydGllc1xuICAgIHtcbiAgICAgICAgUmVmZXJlbmNlOiBSZWZlcmVuY2VfMS5SZWZlcmVuY2UsXG4gICAgICAgIFF1ZXJ5OiBRdWVyeV8xLlF1ZXJ5LFxuICAgICAgICBEYXRhYmFzZTogRGF0YWJhc2VfMS5EYXRhYmFzZSxcbiAgICAgICAgZW5hYmxlTG9nZ2luZzogdXRpbF8xLmVuYWJsZUxvZ2dpbmcsXG4gICAgICAgIElOVEVSTkFMOiBJTlRFUk5BTCxcbiAgICAgICAgU2VydmVyVmFsdWU6IFNlcnZlclZhbHVlLFxuICAgICAgICBURVNUX0FDQ0VTUzogVEVTVF9BQ0NFU1NcbiAgICB9LCBudWxsLCB0cnVlKTtcbiAgICBpZiAodXRpbF8yLmlzTm9kZVNkaygpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbmFtZXNwYWNlO1xuICAgIH1cbn1cbmV4cG9ydHMucmVnaXN0ZXJEYXRhYmFzZSA9IHJlZ2lzdGVyRGF0YWJhc2U7XG5yZWdpc3RlckRhdGFiYXNlKGFwcF8xLmRlZmF1bHQpO1xudmFyIERhdGFTbmFwc2hvdF8xID0gcmVxdWlyZShcIi4vc3JjL2FwaS9EYXRhU25hcHNob3RcIik7XG5leHBvcnRzLkRhdGFTbmFwc2hvdCA9IERhdGFTbmFwc2hvdF8xLkRhdGFTbmFwc2hvdDtcbnZhciBvbkRpc2Nvbm5lY3RfMSA9IHJlcXVpcmUoXCIuL3NyYy9hcGkvb25EaXNjb25uZWN0XCIpO1xuZXhwb3J0cy5PbkRpc2Nvbm5lY3QgPSBvbkRpc2Nvbm5lY3RfMS5PbkRpc2Nvbm5lY3Q7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBXcmFwcyBhIERPTSBTdG9yYWdlIG9iamVjdCBhbmQ6XG4gKiAtIGF1dG9tYXRpY2FsbHkgZW5jb2RlIG9iamVjdHMgYXMgSlNPTiBzdHJpbmdzIGJlZm9yZSBzdG9yaW5nIHRoZW0gdG8gYWxsb3cgdXMgdG8gc3RvcmUgYXJiaXRyYXJ5IHR5cGVzLlxuICogLSBwcmVmaXhlcyBuYW1lcyB3aXRoIFwiZmlyZWJhc2U6XCIgdG8gYXZvaWQgY29sbGlzaW9ucyB3aXRoIGFwcCBkYXRhLlxuICpcbiAqIFdlIGF1dG9tYXRpY2FsbHkgKHNlZSBzdG9yYWdlLmpzKSBjcmVhdGUgdHdvIHN1Y2ggd3JhcHBlcnMsIG9uZSBmb3Igc2Vzc2lvblN0b3JhZ2UsXG4gKiBhbmQgb25lIGZvciBsb2NhbFN0b3JhZ2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBET01TdG9yYWdlV3JhcHBlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0b3JhZ2V9IGRvbVN0b3JhZ2VfIFRoZSB1bmRlcmx5aW5nIHN0b3JhZ2Ugb2JqZWN0IChlLmcuIGxvY2FsU3RvcmFnZSBvciBzZXNzaW9uU3RvcmFnZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBET01TdG9yYWdlV3JhcHBlcihkb21TdG9yYWdlXykge1xuICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfID0gZG9tU3RvcmFnZV87XG4gICAgICAgIC8vIFVzZSBhIHByZWZpeCB0byBhdm9pZCBjb2xsaXNpb25zIHdpdGggb3RoZXIgc3R1ZmYgc2F2ZWQgYnkgdGhlIGFwcC5cbiAgICAgICAgdGhpcy5wcmVmaXhfID0gJ2ZpcmViYXNlOic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byBzYXZlIHRoZSB2YWx1ZSB1bmRlclxuICAgICAqIEBwYXJhbSB7P09iamVjdH0gdmFsdWUgVGhlIHZhbHVlIGJlaW5nIHN0b3JlZCwgb3IgbnVsbCB0byByZW1vdmUgdGhlIGtleS5cbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRvbVN0b3JhZ2VfLnNldEl0ZW0odGhpcy5wcmVmaXhlZE5hbWVfKGtleSksIHV0aWxfMS5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm4geyp9IFRoZSB2YWx1ZSB0aGF0IHdhcyBzdG9yZWQgdW5kZXIgdGhpcyBrZXksIG9yIG51bGxcbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RvcmVkVmFsID0gdGhpcy5kb21TdG9yYWdlXy5nZXRJdGVtKHRoaXMucHJlZml4ZWROYW1lXyhrZXkpKTtcbiAgICAgICAgaWYgKHN0b3JlZFZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuanNvbkV2YWwoc3RvcmVkVmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuICAgIERPTVN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHRoaXMuZG9tU3RvcmFnZV8ucmVtb3ZlSXRlbSh0aGlzLnByZWZpeGVkTmFtZV8oa2V5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBET01TdG9yYWdlV3JhcHBlci5wcm90b3R5cGUucHJlZml4ZWROYW1lXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpeF8gKyBuYW1lO1xuICAgIH07XG4gICAgRE9NU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb21TdG9yYWdlXy50b1N0cmluZygpO1xuICAgIH07XG4gICAgcmV0dXJuIERPTVN0b3JhZ2VXcmFwcGVyO1xufSgpKTtcbmV4cG9ydHMuRE9NU3RvcmFnZVdyYXBwZXIgPSBET01TdG9yYWdlV3JhcHBlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RE9NU3RvcmFnZVdyYXBwZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvc3RvcmFnZS9ET01TdG9yYWdlV3JhcHBlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogQW4gaW4tbWVtb3J5IHN0b3JhZ2UgaW1wbGVtZW50YXRpb24gdGhhdCBtYXRjaGVzIHRoZSBBUEkgb2YgRE9NU3RvcmFnZVdyYXBwZXJcbiAqIChUT0RPOiBjcmVhdGUgaW50ZXJmYWNlIGZvciBib3RoIHRvIGltcGxlbWVudCkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNZW1vcnlTdG9yYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbW9yeVN0b3JhZ2UoKSB7XG4gICAgICAgIHRoaXMuY2FjaGVfID0ge307XG4gICAgICAgIHRoaXMuaXNJbk1lbW9yeVN0b3JhZ2UgPSB0cnVlO1xuICAgIH1cbiAgICBNZW1vcnlTdG9yYWdlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVfW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlX1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lbW9yeVN0b3JhZ2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHV0aWxfMS5jb250YWlucyh0aGlzLmNhY2hlXywga2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVfW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBNZW1vcnlTdG9yYWdlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlX1trZXldO1xuICAgIH07XG4gICAgcmV0dXJuIE1lbW9yeVN0b3JhZ2U7XG59KCkpO1xuZXhwb3J0cy5NZW1vcnlTdG9yYWdlID0gTWVtb3J5U3RvcmFnZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVtb3J5U3RvcmFnZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdG9yYWdlL01lbW9yeVN0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgVHJhbnNhY3Rpb25SZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQSB0eXBlIGZvciB0aGUgcmVzb2x2ZSB2YWx1ZSBvZiBGaXJlYmFzZS50cmFuc2FjdGlvbi5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZGljdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tbWl0dGVkXG4gICAgICogQHBhcmFtIHtEYXRhU25hcHNob3R9IHNuYXBzaG90XG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25SZXN1bHQoY29tbWl0dGVkLCBzbmFwc2hvdCkge1xuICAgICAgICB0aGlzLmNvbW1pdHRlZCA9IGNvbW1pdHRlZDtcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgIH1cbiAgICAvLyBEbyBub3QgY3JlYXRlIHB1YmxpYyBkb2N1bWVudGF0aW9uLiBUaGlzIGlzIGludGVuZGVkIHRvIG1ha2UgSlNPTiBzZXJpYWxpemF0aW9uIHdvcmsgYnV0IGlzIG90aGVyd2lzZSB1bm5lY2Vzc2FyeVxuICAgIC8vIGZvciBlbmQtdXNlcnNcbiAgICBUcmFuc2FjdGlvblJlc3VsdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEudmFsaWRhdGVBcmdDb3VudCgnVHJhbnNhY3Rpb25SZXN1bHQudG9KU09OJywgMCwgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7IGNvbW1pdHRlZDogdGhpcy5jb21taXR0ZWQsIHNuYXBzaG90OiB0aGlzLnNuYXBzaG90LnRvSlNPTigpIH07XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNhY3Rpb25SZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2FjdGlvblJlc3VsdCA9IFRyYW5zYWN0aW9uUmVzdWx0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvblJlc3VsdC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvYXBpL1RyYW5zYWN0aW9uUmVzdWx0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBGYW5jeSBJRCBnZW5lcmF0b3IgdGhhdCBjcmVhdGVzIDIwLWNoYXJhY3RlciBzdHJpbmcgaWRlbnRpZmllcnMgd2l0aCB0aGVcbiAqIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIDEuIFRoZXkncmUgYmFzZWQgb24gdGltZXN0YW1wIHNvIHRoYXQgdGhleSBzb3J0ICphZnRlciogYW55IGV4aXN0aW5nIGlkcy5cbiAqIDIuIFRoZXkgY29udGFpbiA3Mi1iaXRzIG9mIHJhbmRvbSBkYXRhIGFmdGVyIHRoZSB0aW1lc3RhbXAgc28gdGhhdCBJRHMgd29uJ3RcbiAqICAgIGNvbGxpZGUgd2l0aCBvdGhlciBjbGllbnRzJyBJRHMuXG4gKiAzLiBUaGV5IHNvcnQgKmxleGljb2dyYXBoaWNhbGx5KiAoc28gdGhlIHRpbWVzdGFtcCBpcyBjb252ZXJ0ZWQgdG8gY2hhcmFjdGVyc1xuICogICAgdGhhdCB3aWxsIHNvcnQgcHJvcGVybHkpLlxuICogNC4gVGhleSdyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuIEV2ZW4gaWYgeW91IGdlbmVyYXRlIG1vcmUgdGhhbiBvbmUgaW5cbiAqICAgIHRoZSBzYW1lIHRpbWVzdGFtcCwgdGhlIGxhdHRlciBvbmVzIHdpbGwgc29ydCBhZnRlciB0aGUgZm9ybWVyIG9uZXMuIFdlIGRvXG4gKiAgICB0aGlzIGJ5IHVzaW5nIHRoZSBwcmV2aW91cyByYW5kb20gYml0cyBidXQgXCJpbmNyZW1lbnRpbmdcIiB0aGVtIGJ5IDEgKG9ubHlcbiAqICAgIGluIHRoZSBjYXNlIG9mIGEgdGltZXN0YW1wIGNvbGxpc2lvbikuXG4gKi9cbmV4cG9ydHMubmV4dFB1c2hJZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgLy8gTW9kZWxlZCBhZnRlciBiYXNlNjQgd2ViLXNhZmUgY2hhcnMsIGJ1dCBvcmRlcmVkIGJ5IEFTQ0lJLlxuICAgIHZhciBQVVNIX0NIQVJTID0gJy0wMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpfYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonO1xuICAgIC8vIFRpbWVzdGFtcCBvZiBsYXN0IHB1c2gsIHVzZWQgdG8gcHJldmVudCBsb2NhbCBjb2xsaXNpb25zIGlmIHlvdSBwdXNoIHR3aWNlXG4gICAgLy8gaW4gb25lIG1zLlxuICAgIHZhciBsYXN0UHVzaFRpbWUgPSAwO1xuICAgIC8vIFdlIGdlbmVyYXRlIDcyLWJpdHMgb2YgcmFuZG9tbmVzcyB3aGljaCBnZXQgdHVybmVkIGludG8gMTIgY2hhcmFjdGVycyBhbmRcbiAgICAvLyBhcHBlbmRlZCB0byB0aGUgdGltZXN0YW1wIHRvIHByZXZlbnQgY29sbGlzaW9ucyB3aXRoIG90aGVyIGNsaWVudHMuIFdlXG4gICAgLy8gc3RvcmUgdGhlIGxhc3QgY2hhcmFjdGVycyB3ZSBnZW5lcmF0ZWQgYmVjYXVzZSBpbiB0aGUgZXZlbnQgb2YgYSBjb2xsaXNpb24sXG4gICAgLy8gd2UnbGwgdXNlIHRob3NlIHNhbWUgY2hhcmFjdGVycyBleGNlcHQgXCJpbmNyZW1lbnRlZFwiIGJ5IG9uZS5cbiAgICB2YXIgbGFzdFJhbmRDaGFycyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobm93KSB7XG4gICAgICAgIHZhciBkdXBsaWNhdGVUaW1lID0gbm93ID09PSBsYXN0UHVzaFRpbWU7XG4gICAgICAgIGxhc3RQdXNoVGltZSA9IG5vdztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciB0aW1lU3RhbXBDaGFycyA9IG5ldyBBcnJheSg4KTtcbiAgICAgICAgZm9yIChpID0gNzsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRpbWVTdGFtcENoYXJzW2ldID0gUFVTSF9DSEFSUy5jaGFyQXQobm93ICUgNjQpO1xuICAgICAgICAgICAgLy8gTk9URTogQ2FuJ3QgdXNlIDw8IGhlcmUgYmVjYXVzZSBqYXZhc2NyaXB0IHdpbGwgY29udmVydCB0byBpbnQgYW5kIGxvc2VcbiAgICAgICAgICAgIC8vIHRoZSB1cHBlciBiaXRzLlxuICAgICAgICAgICAgbm93ID0gTWF0aC5mbG9vcihub3cgLyA2NCk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmFzc2VydChub3cgPT09IDAsICdDYW5ub3QgcHVzaCBhdCB0aW1lID09IDAnKTtcbiAgICAgICAgdmFyIGlkID0gdGltZVN0YW1wQ2hhcnMuam9pbignJyk7XG4gICAgICAgIGlmICghZHVwbGljYXRlVGltZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogNjQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHRpbWVzdGFtcCBoYXNuJ3QgY2hhbmdlZCBzaW5jZSBsYXN0IHB1c2gsIHVzZSB0aGUgc2FtZSByYW5kb21cbiAgICAgICAgICAgIC8vIG51bWJlciwgZXhjZXB0IGluY3JlbWVudGVkIGJ5IDEuXG4gICAgICAgICAgICBmb3IgKGkgPSAxMTsgaSA+PSAwICYmIGxhc3RSYW5kQ2hhcnNbaV0gPT09IDYzOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsYXN0UmFuZENoYXJzW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RSYW5kQ2hhcnNbaV0rKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgaWQgKz0gUFVTSF9DSEFSUy5jaGFyQXQobGFzdFJhbmRDaGFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbF8xLmFzc2VydChpZC5sZW5ndGggPT09IDIwLCAnbmV4dFB1c2hJZDogTGVuZ3RoIHNob3VsZCBiZSAyMC4nKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH07XG59KSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OZXh0UHVzaElkLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvTmV4dFB1c2hJZC5qc1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERhdGFTbmFwc2hvdF8xID0gcmVxdWlyZShcIi4uLy4uL2FwaS9EYXRhU25hcHNob3RcIik7XG52YXIgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIFJlcHJlc2VudHMgcmVnaXN0cmF0aW9uIGZvciAndmFsdWUnIGV2ZW50cy5cbiAqL1xudmFyIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oIURhdGFTbmFwc2hvdCl9IGNhbGxiYWNrX1xuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKEVycm9yKX0gY2FuY2VsQ2FsbGJhY2tfXG4gICAgICogQHBhcmFtIHs/T2JqZWN0fSBjb250ZXh0X1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24oY2FsbGJhY2tfLCBjYW5jZWxDYWxsYmFja18sIGNvbnRleHRfKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tfID0gY2FsbGJhY2tfO1xuICAgICAgICB0aGlzLmNhbmNlbENhbGxiYWNrXyA9IGNhbmNlbENhbGxiYWNrXztcbiAgICAgICAgdGhpcy5jb250ZXh0XyA9IGNvbnRleHRfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLnJlc3BvbmRzVG8gPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBldmVudFR5cGUgPT09ICd2YWx1ZSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmNyZWF0ZUV2ZW50ID0gZnVuY3Rpb24gKGNoYW5nZSwgcXVlcnkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuRGF0YUV2ZW50KCd2YWx1ZScsIHRoaXMsIG5ldyBEYXRhU25hcHNob3RfMS5EYXRhU25hcHNob3QoY2hhbmdlLnNuYXBzaG90Tm9kZSwgcXVlcnkuZ2V0UmVmKCksIGluZGV4KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFZhbHVlRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmdldEV2ZW50UnVubmVyID0gZnVuY3Rpb24gKGV2ZW50RGF0YSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0XztcbiAgICAgICAgaWYgKGV2ZW50RGF0YS5nZXRFdmVudFR5cGUoKSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIHV0aWxfMi5hc3NlcnQodGhpcy5jYW5jZWxDYWxsYmFja18sICdSYWlzaW5nIGEgY2FuY2VsIGV2ZW50IG9uIGEgbGlzdGVuZXIgd2l0aCBubyBjYW5jZWwgY2FsbGJhY2snKTtcbiAgICAgICAgICAgIHZhciBjYW5jZWxDQl8xID0gdGhpcy5jYW5jZWxDYWxsYmFja187XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCBlcnJvciBleGlzdHMsIHdlIGNoZWNrZWQgYWJvdmUgdGhhdCB0aGlzIGlzIGEgY2FuY2VsIGV2ZW50XG4gICAgICAgICAgICAgICAgY2FuY2VsQ0JfMS5jYWxsKGN0eCwgZXZlbnREYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2JfMSA9IHRoaXMuY2FsbGJhY2tfO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYl8xLmNhbGwoY3R4LCBldmVudERhdGEuc25hcHNob3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5jcmVhdGVDYW5jZWxFdmVudCA9IGZ1bmN0aW9uIChlcnJvciwgcGF0aCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxDYWxsYmFja18pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRfMS5DYW5jZWxFdmVudCh0aGlzLCBlcnJvciwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghb3RoZXIuY2FsbGJhY2tfIHx8ICF0aGlzLmNhbGxiYWNrXykge1xuICAgICAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgc3BlY2lmaWVkLCB3ZSBjb25zaWRlciBpdCB0byBtYXRjaCBhbnkgY2FsbGJhY2suXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXIuY2FsbGJhY2tfID09PSB0aGlzLmNhbGxiYWNrXyAmJiBvdGhlci5jb250ZXh0XyA9PT0gdGhpcy5jb250ZXh0Xyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgVmFsdWVFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuaGFzQW55Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxiYWNrXyAhPT0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBWYWx1ZUV2ZW50UmVnaXN0cmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuVmFsdWVFdmVudFJlZ2lzdHJhdGlvbiA9IFZhbHVlRXZlbnRSZWdpc3RyYXRpb247XG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHJlZ2lzdHJhdGlvbiBvZiAxIG9yIG1vcmUgY2hpbGRfeHh4IGV2ZW50cy5cbiAqXG4gKiBDdXJyZW50bHksIGl0IGlzIGFsd2F5cyBleGFjdGx5IDEgY2hpbGRfeHh4IGV2ZW50LCBidXQgdGhlIGlkZWEgaXMgd2UgbWlnaHQgbGV0IHlvdVxuICogcmVnaXN0ZXIgYSBncm91cCBvZiBjYWxsYmFja3MgdG9nZXRoZXIgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtFdmVudFJlZ2lzdHJhdGlvbn1cbiAqL1xudmFyIENoaWxkRXZlbnRSZWdpc3RyYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/T2JqZWN0LjxzdHJpbmcsIGZ1bmN0aW9uKCFEYXRhU25hcHNob3QsID9zdHJpbmc9KT59IGNhbGxiYWNrc19cbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbihFcnJvcil9IGNhbmNlbENhbGxiYWNrX1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dF9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKGNhbGxiYWNrc18sIGNhbmNlbENhbGxiYWNrXywgY29udGV4dF8pIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3NfID0gY2FsbGJhY2tzXztcbiAgICAgICAgdGhpcy5jYW5jZWxDYWxsYmFja18gPSBjYW5jZWxDYWxsYmFja187XG4gICAgICAgIHRoaXMuY29udGV4dF8gPSBjb250ZXh0XztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5yZXNwb25kc1RvID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgZXZlbnRUb0NoZWNrID0gZXZlbnRUeXBlID09PSAnY2hpbGRyZW5fYWRkZWQnID8gJ2NoaWxkX2FkZGVkJyA6IGV2ZW50VHlwZTtcbiAgICAgICAgZXZlbnRUb0NoZWNrID1cbiAgICAgICAgICAgIGV2ZW50VG9DaGVjayA9PT0gJ2NoaWxkcmVuX3JlbW92ZWQnID8gJ2NoaWxkX3JlbW92ZWQnIDogZXZlbnRUb0NoZWNrO1xuICAgICAgICByZXR1cm4gdXRpbF8xLmNvbnRhaW5zKHRoaXMuY2FsbGJhY2tzXywgZXZlbnRUb0NoZWNrKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuY3JlYXRlQ2FuY2VsRXZlbnQgPSBmdW5jdGlvbiAoZXJyb3IsIHBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsQ2FsbGJhY2tfKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuQ2FuY2VsRXZlbnQodGhpcywgZXJyb3IsIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuY3JlYXRlRXZlbnQgPSBmdW5jdGlvbiAoY2hhbmdlLCBxdWVyeSkge1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KGNoYW5nZS5jaGlsZE5hbWUgIT0gbnVsbCwgJ0NoaWxkIGV2ZW50cyBzaG91bGQgaGF2ZSBhIGNoaWxkTmFtZS4nKTtcbiAgICAgICAgdmFyIHJlZiA9IHF1ZXJ5LmdldFJlZigpLmNoaWxkKC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gKGNoYW5nZS5jaGlsZE5hbWUpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5nZXRJbmRleCgpO1xuICAgICAgICByZXR1cm4gbmV3IEV2ZW50XzEuRGF0YUV2ZW50KGNoYW5nZS50eXBlLCB0aGlzLCBuZXcgRGF0YVNuYXBzaG90XzEuRGF0YVNuYXBzaG90KGNoYW5nZS5zbmFwc2hvdE5vZGUsIHJlZiwgaW5kZXgpLCBjaGFuZ2UucHJldk5hbWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uLnByb3RvdHlwZS5nZXRFdmVudFJ1bm5lciA9IGZ1bmN0aW9uIChldmVudERhdGEpIHtcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dF87XG4gICAgICAgIGlmIChldmVudERhdGEuZ2V0RXZlbnRUeXBlKCkgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICB1dGlsXzIuYXNzZXJ0KHRoaXMuY2FuY2VsQ2FsbGJhY2tfLCAnUmFpc2luZyBhIGNhbmNlbCBldmVudCBvbiBhIGxpc3RlbmVyIHdpdGggbm8gY2FuY2VsIGNhbGxiYWNrJyk7XG4gICAgICAgICAgICB2YXIgY2FuY2VsQ0JfMiA9IHRoaXMuY2FuY2VsQ2FsbGJhY2tfO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgZXJyb3IgZXhpc3RzLCB3ZSBjaGVja2VkIGFib3ZlIHRoYXQgdGhpcyBpcyBhIGNhbmNlbCBldmVudFxuICAgICAgICAgICAgICAgIGNhbmNlbENCXzIuY2FsbChjdHgsIGV2ZW50RGF0YS5lcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNiXzIgPSB0aGlzLmNhbGxiYWNrc19bZXZlbnREYXRhLmV2ZW50VHlwZV07XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiXzIuY2FsbChjdHgsIGV2ZW50RGF0YS5zbmFwc2hvdCwgZXZlbnREYXRhLnByZXZOYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDaGlsZEV2ZW50UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzXyB8fCAhb3RoZXIuY2FsbGJhY2tzXykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZXh0XyA9PT0gb3RoZXIuY29udGV4dF8pIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb3VudCA9IHV0aWxfMS5nZXRDb3VudChvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICB2YXIgdGhpc0NvdW50ID0gdXRpbF8xLmdldENvdW50KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQ291bnQgPT09IHRoaXNDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjb3VudCBpcyAxLCBkbyBhbiBleGFjdCBtYXRjaCBvbiBldmVudFR5cGUsIGlmIGVpdGhlciBpcyBkZWZpbmVkIGJ1dCBudWxsLCBpdCdzIGEgbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIC8vICBJZiBldmVudCB0eXBlcyBkb24ndCBtYXRjaCwgbm90IGEgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgY291bnQgaXMgbm90IDEsIGV4YWN0IG1hdGNoIGFjcm9zcyBhbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ291bnQgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlcktleSAvKiogQHR5cGUgeyFzdHJpbmd9ICovID0gdXRpbF8xLmdldEFueUtleShvdGhlci5jYWxsYmFja3NfKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzS2V5IC8qKiBAdHlwZSB7IXN0cmluZ30gKi8gPSB1dGlsXzEuZ2V0QW55S2V5KHRoaXMuY2FsbGJhY2tzXyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNLZXkgPT09IG90aGVyS2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKCFvdGhlci5jYWxsYmFja3NfW290aGVyS2V5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5jYWxsYmFja3NfW3RoaXNLZXldIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmNhbGxiYWNrc19bb3RoZXJLZXldID09PSB0aGlzLmNhbGxiYWNrc19bdGhpc0tleV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4YWN0IG1hdGNoIG9uIGVhY2gga2V5LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5ldmVyeSh0aGlzLmNhbGxiYWNrc18sIGZ1bmN0aW9uIChldmVudFR5cGUsIGNiKSB7IHJldHVybiBvdGhlci5jYWxsYmFja3NfW2V2ZW50VHlwZV0gPT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIENoaWxkRXZlbnRSZWdpc3RyYXRpb24ucHJvdG90eXBlLmhhc0FueUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsYmFja3NfICE9PSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIENoaWxkRXZlbnRSZWdpc3RyYXRpb247XG59KCkpO1xuZXhwb3J0cy5DaGlsZEV2ZW50UmVnaXN0cmF0aW9uID0gQ2hpbGRFdmVudFJlZ2lzdHJhdGlvbjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRSZWdpc3RyYXRpb24uanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9FdmVudFJlZ2lzdHJhdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogRW5jYXBzdWxhdGVzIHRoZSBkYXRhIG5lZWRlZCB0byByYWlzZSBhbiBldmVudFxuICogQGltcGxlbWVudHMge0V2ZW50fVxuICovXG52YXIgRGF0YUV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlIE9uZSBvZjogdmFsdWUsIGNoaWxkX2FkZGVkLCBjaGlsZF9jaGFuZ2VkLCBjaGlsZF9tb3ZlZCwgY2hpbGRfcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7IUV2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB0byB3aXRoIHRoZSBldmVudCBkYXRhLiBVc2VyIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHshRGF0YVNuYXBzaG90fSBzbmFwc2hvdCBUaGUgZGF0YSBiYWNraW5nIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IHByZXZOYW1lIE9wdGlvbmFsLCB0aGUgbmFtZSBvZiB0aGUgcHJldmlvdXMgY2hpbGQgZm9yIGNoaWxkXyogZXZlbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIERhdGFFdmVudChldmVudFR5cGUsIGV2ZW50UmVnaXN0cmF0aW9uLCBzbmFwc2hvdCwgcHJldk5hbWUpIHtcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24gPSBldmVudFJlZ2lzdHJhdGlvbjtcbiAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICB0aGlzLnByZXZOYW1lID0gcHJldk5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgRGF0YUV2ZW50LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5zbmFwc2hvdC5nZXRSZWYoKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRUeXBlID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmLmdldFBhcmVudCgpLnBhdGg7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgRGF0YUV2ZW50LnByb3RvdHlwZS5nZXRFdmVudFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50VHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgRGF0YUV2ZW50LnByb3RvdHlwZS5nZXRFdmVudFJ1bm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb24uZ2V0RXZlbnRSdW5uZXIodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIERhdGFFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5nZXRQYXRoKCkudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgdGhpcy5ldmVudFR5cGUgK1xuICAgICAgICAgICAgJzonICtcbiAgICAgICAgICAgIHV0aWxfMS5zdHJpbmdpZnkodGhpcy5zbmFwc2hvdC5leHBvcnRWYWwoKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFFdmVudDtcbn0oKSk7XG5leHBvcnRzLkRhdGFFdmVudCA9IERhdGFFdmVudDtcbnZhciBDYW5jZWxFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0V2ZW50UmVnaXN0cmF0aW9ufSBldmVudFJlZ2lzdHJhdGlvblxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENhbmNlbEV2ZW50KGV2ZW50UmVnaXN0cmF0aW9uLCBlcnJvciwgcGF0aCkge1xuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uID0gZXZlbnRSZWdpc3RyYXRpb247XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDYW5jZWxFdmVudC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgQ2FuY2VsRXZlbnQucHJvdG90eXBlLmdldEV2ZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDYW5jZWxFdmVudC5wcm90b3R5cGUuZ2V0RXZlbnRSdW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uLmdldEV2ZW50UnVubmVyKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBDYW5jZWxFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhdGgudG9TdHJpbmcoKSArICc6Y2FuY2VsJztcbiAgICB9O1xuICAgIHJldHVybiBDYW5jZWxFdmVudDtcbn0oKSk7XG5leHBvcnRzLkNhbmNlbEV2ZW50ID0gQ2FuY2VsRXZlbnQ7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnQuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIEFja1VzZXJXcml0ZV8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL0Fja1VzZXJXcml0ZVwiKTtcbnZhciBDaGlsZHJlbk5vZGVfMSA9IHJlcXVpcmUoXCIuL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBJbW11dGFibGVUcmVlXzEgPSByZXF1aXJlKFwiLi91dGlsL0ltbXV0YWJsZVRyZWVcIik7XG52YXIgTGlzdGVuQ29tcGxldGVfMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbi9MaXN0ZW5Db21wbGV0ZVwiKTtcbnZhciBNZXJnZV8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL01lcmdlXCIpO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uL09wZXJhdGlvblwiKTtcbnZhciBPdmVyd3JpdGVfMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvbi9PdmVyd3JpdGVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vdXRpbC9QYXRoXCIpO1xudmFyIFN5bmNQb2ludF8xID0gcmVxdWlyZShcIi4vU3luY1BvaW50XCIpO1xudmFyIFdyaXRlVHJlZV8xID0gcmVxdWlyZShcIi4vV3JpdGVUcmVlXCIpO1xuLyoqXG4gKiBTeW5jVHJlZSBpcyB0aGUgY2VudHJhbCBjbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnQgY2FsbGJhY2sgcmVnaXN0cmF0aW9uLCBkYXRhIGNhY2hpbmcsIHZpZXdzXG4gKiAocXVlcnkgcHJvY2Vzc2luZyksIGFuZCBldmVudCBnZW5lcmF0aW9uLiAgVGhlcmUgYXJlIHR5cGljYWxseSB0d28gU3luY1RyZWUgaW5zdGFuY2VzIGZvclxuICogZWFjaCBSZXBvLCBvbmUgZm9yIHRoZSBub3JtYWwgRmlyZWJhc2UgZGF0YSwgYW5kIG9uZSBmb3IgdGhlIC5pbmZvIGRhdGEuXG4gKlxuICogSXQgaGFzIGEgbnVtYmVyIG9mIHJlc3BvbnNpYmlsaXRpZXMsIGluY2x1ZGluZzpcbiAqICAtIFRyYWNraW5nIGFsbCB1c2VyIGV2ZW50IGNhbGxiYWNrcyAocmVnaXN0ZXJlZCB2aWEgYWRkRXZlbnRSZWdpc3RyYXRpb24oKSBhbmQgcmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24oKSkuXG4gKiAgLSBBcHBseWluZyBhbmQgY2FjaGluZyBkYXRhIGNoYW5nZXMgZm9yIHVzZXIgc2V0KCksIHRyYW5zYWN0aW9uKCksIGFuZCB1cGRhdGUoKSBjYWxsc1xuICogICAgKGFwcGx5VXNlck92ZXJ3cml0ZSgpLCBhcHBseVVzZXJNZXJnZSgpKS5cbiAqICAtIEFwcGx5aW5nIGFuZCBjYWNoaW5nIGRhdGEgY2hhbmdlcyBmb3Igc2VydmVyIGRhdGEgY2hhbmdlcyAoYXBwbHlTZXJ2ZXJPdmVyd3JpdGUoKSxcbiAqICAgIGFwcGx5U2VydmVyTWVyZ2UoKSkuXG4gKiAgLSBHZW5lcmF0aW5nIHVzZXItZmFjaW5nIGV2ZW50cyBmb3Igc2VydmVyIGFuZCB1c2VyIGNoYW5nZXMgKGFsbCBvZiB0aGUgYXBwbHkqIG1ldGhvZHNcbiAqICAgIHJldHVybiB0aGUgc2V0IG9mIGV2ZW50cyB0aGF0IG5lZWQgdG8gYmUgcmFpc2VkIGFzIGEgcmVzdWx0KS5cbiAqICAtIE1haW50YWluaW5nIHRoZSBhcHByb3ByaWF0ZSBzZXQgb2Ygc2VydmVyIGxpc3RlbnMgdG8gZW5zdXJlIHdlIGFyZSBhbHdheXMgc3Vic2NyaWJlZFxuICogICAgdG8gdGhlIGNvcnJlY3Qgc2V0IG9mIHBhdGhzIGFuZCBxdWVyaWVzIHRvIHNhdGlzZnkgdGhlIGN1cnJlbnQgc2V0IG9mIHVzZXIgZXZlbnRcbiAqICAgIGNhbGxiYWNrcyAobGlzdGVucyBhcmUgc3RhcnRlZC9zdG9wcGVkIHVzaW5nIHRoZSBwcm92aWRlZCBsaXN0ZW5Qcm92aWRlcikuXG4gKlxuICogTk9URTogQWx0aG91Z2ggU3luY1RyZWUgdHJhY2tzIGV2ZW50IGNhbGxiYWNrcyBhbmQgY2FsY3VsYXRlcyBldmVudHMgdG8gcmFpc2UsIHRoZSBhY3R1YWxcbiAqIGV2ZW50cyBhcmUgcmV0dXJuZWQgdG8gdGhlIGNhbGxlciByYXRoZXIgdGhhbiByYWlzZWQgc3luY2hyb25vdXNseS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN5bmNUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUxpc3RlblByb3ZpZGVyfSBsaXN0ZW5Qcm92aWRlcl8gVXNlZCBieSBTeW5jVHJlZSB0byBzdGFydCAvIHN0b3AgbGlzdGVuaW5nXG4gICAgICogICB0byBzZXJ2ZXIgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTeW5jVHJlZShsaXN0ZW5Qcm92aWRlcl8pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8gPSBsaXN0ZW5Qcm92aWRlcl87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmVlIG9mIFN5bmNQb2ludHMuICBUaGVyZSdzIGEgU3luY1BvaW50IGF0IGFueSBsb2NhdGlvbiB0aGF0IGhhcyAxIG9yIG1vcmUgdmlld3MuXG4gICAgICAgICAqIEB0eXBlIHshSW1tdXRhYmxlVHJlZS48IVN5bmNQb2ludD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN5bmNQb2ludFRyZWVfID0gSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUuRW1wdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRyZWUgb2YgYWxsIHBlbmRpbmcgdXNlciB3cml0ZXMgKHVzZXItaW5pdGlhdGVkIHNldCgpJ3MsIHRyYW5zYWN0aW9uKCkncywgdXBkYXRlKCkncywgZXRjLikuXG4gICAgICAgICAqIEB0eXBlIHshV3JpdGVUcmVlfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXyA9IG5ldyBXcml0ZVRyZWVfMS5Xcml0ZVRyZWUoKTtcbiAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwXyA9IHt9O1xuICAgICAgICB0aGlzLnF1ZXJ5VG9UYWdNYXBfID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGNoYW5nZXMgZm9yIGEgdXNlci1nZW5lcmF0ZWQgc2V0KCkgb3IgdHJhbnNhY3Rpb24oKSBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5ld0RhdGFcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd3JpdGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZpc2libGVcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlVc2VyT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpIHtcbiAgICAgICAgLy8gUmVjb3JkIHBlbmRpbmcgd3JpdGUuXG4gICAgICAgIHRoaXMucGVuZGluZ1dyaXRlVHJlZV8uYWRkT3ZlcndyaXRlKHBhdGgsIG5ld0RhdGEsIHdyaXRlSWQsIHZpc2libGUpO1xuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgT3ZlcndyaXRlXzEuT3ZlcndyaXRlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBuZXdEYXRhKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBkYXRhIGZyb20gYSB1c2VyLWdlbmVyYXRlZCB1cGRhdGUoKSBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5VXNlck1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVJZCkge1xuICAgICAgICAvLyBSZWNvcmQgcGVuZGluZyBtZXJnZS5cbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5hZGRNZXJnZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlSWQpO1xuICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBNZXJnZV8xLk1lcmdlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5Vc2VyLCBwYXRoLCBjaGFuZ2VUcmVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBY2tub3dsZWRnZSBhIHBlbmRpbmcgdXNlciB3cml0ZSB0aGF0IHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCBhcHBseVVzZXJPdmVyd3JpdGUoKSBvciBhcHBseVVzZXJNZXJnZSgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB3cml0ZUlkXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmV2ZXJ0IFRydWUgaWYgdGhlIGdpdmVuIHdyaXRlIGZhaWxlZCBhbmQgbmVlZHMgdG8gYmUgcmV2ZXJ0ZWRcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYWNrVXNlcldyaXRlID0gZnVuY3Rpb24gKHdyaXRlSWQsIHJldmVydCkge1xuICAgICAgICBpZiAocmV2ZXJ0ID09PSB2b2lkIDApIHsgcmV2ZXJ0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHdyaXRlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5nZXRXcml0ZSh3cml0ZUlkKTtcbiAgICAgICAgdmFyIG5lZWRUb1JlZXZhbHVhdGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLnJlbW92ZVdyaXRlKHdyaXRlSWQpO1xuICAgICAgICBpZiAoIW5lZWRUb1JlZXZhbHVhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZFRyZWVfMSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZVxuICAgICAgICAgICAgICAgIGFmZmVjdGVkVHJlZV8xID0gYWZmZWN0ZWRUcmVlXzEuc2V0KFBhdGhfMS5QYXRoLkVtcHR5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMy5mb3JFYWNoKHdyaXRlLmNoaWxkcmVuLCBmdW5jdGlvbiAocGF0aFN0cmluZywgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZFRyZWVfMSA9IGFmZmVjdGVkVHJlZV8xLnNldChuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZyksIG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBBY2tVc2VyV3JpdGVfMS5BY2tVc2VyV3JpdGUod3JpdGUucGF0aCwgYWZmZWN0ZWRUcmVlXzEsIHJldmVydCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBuZXcgc2VydmVyIGRhdGEgZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gbmV3RGF0YVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseVNlcnZlck92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBuZXdEYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5T3BlcmF0aW9uVG9TeW5jUG9pbnRzXyhuZXcgT3ZlcndyaXRlXzEuT3ZlcndyaXRlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5TZXJ2ZXIsIHBhdGgsIG5ld0RhdGEpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IG5ldyBzZXJ2ZXIgZGF0YSB0byBiZSBtZXJnZWQgaW4gYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gRXZlbnRzIHRvIHJhaXNlLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseVNlcnZlck1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbikge1xuICAgICAgICB2YXIgY2hhbmdlVHJlZSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLmZyb21PYmplY3QoY2hhbmdlZENoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfKG5ldyBNZXJnZV8xLk1lcmdlKE9wZXJhdGlvbl8xLk9wZXJhdGlvblNvdXJjZS5TZXJ2ZXIsIHBhdGgsIGNoYW5nZVRyZWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IGEgbGlzdGVuIGNvbXBsZXRlIGZvciBhIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFwcGx5TGlzdGVuQ29tcGxldGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvblRvU3luY1BvaW50c18obmV3IExpc3RlbkNvbXBsZXRlXzEuTGlzdGVuQ29tcGxldGUoT3BlcmF0aW9uXzEuT3BlcmF0aW9uU291cmNlLlNlcnZlciwgcGF0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgbmV3IHNlcnZlciBkYXRhIGZvciB0aGUgc3BlY2lmaWVkIHRhZ2dlZCBxdWVyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRRdWVyeU92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBzbmFwLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByID0gU3luY1RyZWUucGFyc2VRdWVyeUtleV8ocXVlcnlLZXkpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5UGF0aCA9IHIucGF0aCwgcXVlcnlJZCA9IHIucXVlcnlJZDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocXVlcnlQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBvcCA9IG5ldyBPdmVyd3JpdGVfMS5PdmVyd3JpdGUoT3BlcmF0aW9uXzEuT3BlcmF0aW9uU291cmNlLmZvclNlcnZlclRhZ2dlZFF1ZXJ5KHF1ZXJ5SWQpLCByZWxhdGl2ZVBhdGgsIHNuYXApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlUYWdnZWRPcGVyYXRpb25fKHF1ZXJ5UGF0aCwgb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUXVlcnkgbXVzdCBoYXZlIGJlZW4gcmVtb3ZlZCBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHNlcnZlciBkYXRhIHRvIGJlIG1lcmdlZCBpbiBmb3IgdGhlIHNwZWNpZmllZCB0YWdnZWQgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRRdWVyeU1lcmdlID0gZnVuY3Rpb24gKHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgdGFnKSB7XG4gICAgICAgIHZhciBxdWVyeUtleSA9IHRoaXMucXVlcnlLZXlGb3JUYWdfKHRhZyk7XG4gICAgICAgIGlmIChxdWVyeUtleSkge1xuICAgICAgICAgICAgdmFyIHIgPSBTeW5jVHJlZS5wYXJzZVF1ZXJ5S2V5XyhxdWVyeUtleSk7XG4gICAgICAgICAgICB2YXIgcXVlcnlQYXRoID0gci5wYXRoLCBxdWVyeUlkID0gci5xdWVyeUlkO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aChxdWVyeVBhdGgsIHBhdGgpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZVRyZWUgPSBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZS5mcm9tT2JqZWN0KGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTWVyZ2VfMS5NZXJnZShPcGVyYXRpb25fMS5PcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCwgY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBsaXN0ZW4gY29tcGxldGUgZm9yIGEgdGFnZ2VkIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IEV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRMaXN0ZW5Db21wbGV0ZSA9IGZ1bmN0aW9uIChwYXRoLCB0YWcpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gdGhpcy5xdWVyeUtleUZvclRhZ18odGFnKTtcbiAgICAgICAgaWYgKHF1ZXJ5S2V5KSB7XG4gICAgICAgICAgICB2YXIgciA9IFN5bmNUcmVlLnBhcnNlUXVlcnlLZXlfKHF1ZXJ5S2V5KTtcbiAgICAgICAgICAgIHZhciBxdWVyeVBhdGggPSByLnBhdGgsIHF1ZXJ5SWQgPSByLnF1ZXJ5SWQ7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHF1ZXJ5UGF0aCwgcGF0aCk7XG4gICAgICAgICAgICB2YXIgb3AgPSBuZXcgTGlzdGVuQ29tcGxldGVfMS5MaXN0ZW5Db21wbGV0ZShPcGVyYXRpb25fMS5PcGVyYXRpb25Tb3VyY2UuZm9yU2VydmVyVGFnZ2VkUXVlcnkocXVlcnlJZCksIHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRhZ2dlZE9wZXJhdGlvbl8ocXVlcnlQYXRoLCBvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IHJlbW92ZWQgdGhlIHF1ZXJ5LiBObyBiaWcgZGVhbCwgaWdub3JlIHRoZSB1cGRhdGVcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGNhbGxiYWNrIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHBhcmFtIHshRXZlbnRSZWdpc3RyYXRpb259IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBFdmVudHMgdG8gcmFpc2UuXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmFkZEV2ZW50UmVnaXN0cmF0aW9uID0gZnVuY3Rpb24gKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IG51bGw7XG4gICAgICAgIHZhciBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPSBmYWxzZTtcbiAgICAgICAgLy8gQW55IGNvdmVyaW5nIHdyaXRlcyB3aWxsIG5lY2Vzc2FyaWx5IGJlIGF0IHRoZSByb290LCBzbyByZWFsbHkgYWxsIHdlIG5lZWQgdG8gZmluZCBpcyB0aGUgc2VydmVyIGNhY2hlLlxuICAgICAgICAvLyBDb25zaWRlciBvcHRpbWl6aW5nIHRoaXMgb25jZSB0aGVyZSdzIGEgYmV0dGVyIHVuZGVyc3RhbmRpbmcgb2Ygd2hhdCBhY3R1YWwgYmVoYXZpb3Igd2lsbCBiZS5cbiAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXy5mb3JlYWNoT25QYXRoKHBhdGgsIGZ1bmN0aW9uIChwYXRoVG9TeW5jUG9pbnQsIHNwKSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHBhdGhUb1N5bmNQb2ludCwgcGF0aCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHNwLmdldENvbXBsZXRlU2VydmVyQ2FjaGUocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyA9XG4gICAgICAgICAgICAgICAgZm91bmRBbmNlc3RvckRlZmF1bHRWaWV3IHx8IHNwLmhhc0NvbXBsZXRlVmlldygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoIXN5bmNQb2ludCkge1xuICAgICAgICAgICAgc3luY1BvaW50ID0gbmV3IFN5bmNQb2ludF8xLlN5bmNQb2ludCgpO1xuICAgICAgICAgICAgdGhpcy5zeW5jUG9pbnRUcmVlXyA9IHRoaXMuc3luY1BvaW50VHJlZV8uc2V0KHBhdGgsIHN5bmNQb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3VuZEFuY2VzdG9yRGVmYXVsdFZpZXcgPVxuICAgICAgICAgICAgICAgIGZvdW5kQW5jZXN0b3JEZWZhdWx0VmlldyB8fCBzeW5jUG9pbnQuaGFzQ29tcGxldGVWaWV3KCk7XG4gICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlIHx8IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VydmVyQ2FjaGVDb21wbGV0ZTtcbiAgICAgICAgaWYgKHNlcnZlckNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VydmVyQ2FjaGVDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VydmVyQ2FjaGUgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xuICAgICAgICAgICAgc3VidHJlZS5mb3JlYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGRTeW5jUG9pbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxldGVDYWNoZSA9IGNoaWxkU3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc2VydmVyQ2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lLCBjb21wbGV0ZUNhY2hlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmlld0FscmVhZHlFeGlzdHMgPSBzeW5jUG9pbnQudmlld0V4aXN0c0ZvclF1ZXJ5KHF1ZXJ5KTtcbiAgICAgICAgaWYgKCF2aWV3QWxyZWFkeUV4aXN0cyAmJiAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayBhIHRhZyBmb3IgdGhpcyBxdWVyeVxuICAgICAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KCEocXVlcnlLZXkgaW4gdGhpcy5xdWVyeVRvVGFnTWFwXyksICdWaWV3IGRvZXMgbm90IGV4aXN0LCBidXQgd2UgaGF2ZSBhIHRhZycpO1xuICAgICAgICAgICAgdmFyIHRhZyA9IFN5bmNUcmVlLmdldE5leHRRdWVyeVRhZ18oKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlUb1RhZ01hcF9bcXVlcnlLZXldID0gdGFnO1xuICAgICAgICAgICAgLy8gQ29lcmNlIHRvIHN0cmluZyB0byBhdm9pZCBzcGFyc2UgYXJyYXlzLlxuICAgICAgICAgICAgdGhpcy50YWdUb1F1ZXJ5TWFwX1snXycgKyB0YWddID0gcXVlcnlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdyaXRlc0NhY2hlID0gdGhpcy5wZW5kaW5nV3JpdGVUcmVlXy5jaGlsZFdyaXRlcyhwYXRoKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHN5bmNQb2ludC5hZGRFdmVudFJlZ2lzdHJhdGlvbihxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgc2VydmVyQ2FjaGVDb21wbGV0ZSk7XG4gICAgICAgIGlmICghdmlld0FscmVhZHlFeGlzdHMgJiYgIWZvdW5kQW5jZXN0b3JEZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIHZpZXcgLyoqIEB0eXBlICFWaWV3ICovID0gc3luY1BvaW50LnZpZXdGb3JRdWVyeShxdWVyeSk7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2V0dXBMaXN0ZW5lcl8ocXVlcnksIHZpZXcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGV2ZW50IGNhbGxiYWNrKHMpLlxuICAgICAqXG4gICAgICogSWYgcXVlcnkgaXMgdGhlIGRlZmF1bHQgcXVlcnksIHdlJ2xsIGNoZWNrIGFsbCBxdWVyaWVzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50UmVnaXN0cmF0aW9uLlxuICAgICAqIElmIGV2ZW50UmVnaXN0cmF0aW9uIGlzIG51bGwsIHdlJ2xsIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgc3BlY2lmaWVkIHF1ZXJ5L3F1ZXJpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgYWxsIGNhbGxiYWNrcyBhcmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge0Vycm9yPX0gY2FuY2VsRXJyb3IgSWYgYSBjYW5jZWxFcnJvciBpcyBwcm92aWRlZCwgYXBwcm9wcmlhdGUgY2FuY2VsIGV2ZW50cyB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn0gQ2FuY2VsIGV2ZW50cywgaWYgY2FuY2VsRXJyb3Igd2FzIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChxdWVyeSwgZXZlbnRSZWdpc3RyYXRpb24sIGNhbmNlbEVycm9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEZpbmQgdGhlIHN5bmNQb2ludCBmaXJzdC4gVGhlbiBkZWFsIHdpdGggd2hldGhlciBvciBub3QgaXQgaGFzIG1hdGNoaW5nIGxpc3RlbmVyc1xuICAgICAgICB2YXIgcGF0aCA9IHF1ZXJ5LnBhdGg7XG4gICAgICAgIHZhciBtYXliZVN5bmNQb2ludCA9IHRoaXMuc3luY1BvaW50VHJlZV8uZ2V0KHBhdGgpO1xuICAgICAgICB2YXIgY2FuY2VsRXZlbnRzID0gW107XG4gICAgICAgIC8vIEEgcmVtb3ZhbCBvbiBhIGRlZmF1bHQgcXVlcnkgYWZmZWN0cyBhbGwgcXVlcmllcyBhdCB0aGF0IGxvY2F0aW9uLiBBIHJlbW92YWwgb24gYW4gaW5kZXhlZCBxdWVyeSwgZXZlbiBvbmUgd2l0aG91dFxuICAgICAgICAvLyBvdGhlciBxdWVyeSBjb25zdHJhaW50cywgZG9lcyAqbm90KiBhZmZlY3QgYWxsIHF1ZXJpZXMgYXQgdGhhdCBsb2NhdGlvbi4gU28gdGhpcyBjaGVjayBtdXN0IGJlIGZvciAnZGVmYXVsdCcsIGFuZFxuICAgICAgICAvLyBub3QgbG9hZHNBbGxEYXRhKCkuXG4gICAgICAgIGlmIChtYXliZVN5bmNQb2ludCAmJlxuICAgICAgICAgICAgKHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpID09PSAnZGVmYXVsdCcgfHxcbiAgICAgICAgICAgICAgICBtYXliZVN5bmNQb2ludC52aWV3RXhpc3RzRm9yUXVlcnkocXVlcnkpKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7e3JlbW92ZWQ6ICFBcnJheS48IVF1ZXJ5PiwgZXZlbnRzOiAhQXJyYXkuPCFFdmVudD59fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFuZEV2ZW50cyA9IG1heWJlU3luY1BvaW50LnJlbW92ZUV2ZW50UmVnaXN0cmF0aW9uKHF1ZXJ5LCBldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpO1xuICAgICAgICAgICAgaWYgKG1heWJlU3luY1BvaW50LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3luY1BvaW50VHJlZV8gPSB0aGlzLnN5bmNQb2ludFRyZWVfLnJlbW92ZShwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gcmVtb3ZlZEFuZEV2ZW50cy5yZW1vdmVkO1xuICAgICAgICAgICAgY2FuY2VsRXZlbnRzID0gcmVtb3ZlZEFuZEV2ZW50cy5ldmVudHM7XG4gICAgICAgICAgICAvLyBXZSBtYXkgaGF2ZSBqdXN0IHJlbW92ZWQgb25lIG9mIG1hbnkgbGlzdGVuZXJzIGFuZCBjYW4gc2hvcnQtY2lyY3VpdCB0aGlzIHdob2xlIHByb2Nlc3NcbiAgICAgICAgICAgIC8vIFdlIG1heSBhbHNvIG5vdCBoYXZlIHJlbW92ZWQgYSBkZWZhdWx0IGxpc3RlbmVyLCBpbiB3aGljaCBjYXNlIGFsbCBvZiB0aGUgZGVzY2VuZGFudCBsaXN0ZW5lcnMgc2hvdWxkIGFscmVhZHkgYmVcbiAgICAgICAgICAgIC8vIHByb3Blcmx5IHNldCB1cC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBTaW5jZSBpbmRleGVkIHF1ZXJpZXMgY2FuIHNoYWRvdyBpZiB0aGV5IGRvbid0IGhhdmUgb3RoZXIgcXVlcnkgY29uc3RyYWludHMsIGNoZWNrIGZvciBsb2Fkc0FsbERhdGEoKSwgaW5zdGVhZCBvZlxuICAgICAgICAgICAgLy8gcXVlcnlJZCA9PT0gJ2RlZmF1bHQnXG4gICAgICAgICAgICB2YXIgcmVtb3ZpbmdEZWZhdWx0ID0gLTEgIT09XG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5maW5kSW5kZXgoZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNvdmVyZWQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmZpbmRPblBhdGgocGF0aCwgZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgcGFyZW50U3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFN5bmNQb2ludC5oYXNDb21wbGV0ZVZpZXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlbW92aW5nRGVmYXVsdCAmJiAhY292ZXJlZCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJ0cmVlID0gdGhpcy5zeW5jUG9pbnRUcmVlXy5zdWJ0cmVlKHBhdGgpO1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBwb3RlbnRpYWxseSBjaGlsZCBsaXN0ZW5lcnMuIERldGVybWluZSB3aGF0IGlmIGFueSBsaXN0ZW5zIHdlIG5lZWQgdG8gc2VuZCBiZWZvcmUgZXhlY3V0aW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIHJlbW92YWxcbiAgICAgICAgICAgICAgICBpZiAoIXN1YnRyZWUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZm9sZCBvdmVyIG91ciBzdWJ0cmVlIGFuZCBjb2xsZWN0IHRoZSBsaXN0ZW5lcnMgdG8gc2VuZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Vmlld3MgPSB0aGlzLmNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8oc3VidHJlZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9rLCB3ZSd2ZSBjb2xsZWN0ZWQgYWxsIHRoZSBsaXN0ZW5zIHdlIG5lZWQuIFNldCB0aGVtIHVwLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1ZpZXdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlldyA9IG5ld1ZpZXdzW2ldLCBuZXdRdWVyeSA9IHZpZXcuZ2V0UXVlcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuY3JlYXRlTGlzdGVuZXJGb3JWaWV3Xyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0YXJ0TGlzdGVuaW5nKFN5bmNUcmVlLnF1ZXJ5Rm9yTGlzdGVuaW5nXyhuZXdRdWVyeSksIHRoaXMudGFnRm9yUXVlcnlfKG5ld1F1ZXJ5KSwgbGlzdGVuZXIuaGFzaEZuLCBsaXN0ZW5lci5vbkNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIGJlbG93IHVzLCBzbyBub3RoaW5nIHdlIG5lZWQgdG8gc3RhcnQgbGlzdGVuaW5nIG9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhbnl0aGluZyBhbmQgd2UncmUgbm90IGNvdmVyZWQgYnkgYSBoaWdoZXIgdXAgbGlzdGVuLCB3ZSBuZWVkIHRvIHN0b3AgbGlzdGVuaW5nIG9uIHRoaXMgcXVlcnlcbiAgICAgICAgICAgIC8vIFRoZSBhYm92ZSBibG9jayBoYXMgdXMgY292ZXJlZCBpbiB0ZXJtcyBvZiBtYWtpbmcgc3VyZSB3ZSdyZSBzZXQgdXAgb24gbGlzdGVucyBsb3dlciBpbiB0aGUgdHJlZS5cbiAgICAgICAgICAgIC8vIEFsc28sIG5vdGUgdGhhdCBpZiB3ZSBoYXZlIGEgY2FuY2VsRXJyb3IsIGl0J3MgYWxyZWFkeSBiZWVuIHJlbW92ZWQgYXQgdGhlIHByb3ZpZGVyIGxldmVsLlxuICAgICAgICAgICAgaWYgKCFjb3ZlcmVkICYmIHJlbW92ZWQubGVuZ3RoID4gMCAmJiAhY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGEgZGVmYXVsdCwgdGhlbiB3ZSB3ZXJlbid0IGxpc3RlbmluZyBvbiBhbnkgb2YgdGhlIG90aGVyIHF1ZXJpZXMgaGVyZS4gSnVzdCBjYW5jZWwgdGhlIG9uZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQuIE90aGVyd2lzZSwgd2UgbmVlZCB0byBpdGVyYXRlIHRocm91Z2ggYW5kIGNhbmNlbCBlYWNoIGluZGl2aWR1YWwgcXVlcnlcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZpbmdEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHRhZyBkZWZhdWx0IGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFRhZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgZGVmYXVsdFRhZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHF1ZXJ5VG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWdUb1JlbW92ZSA9IF90aGlzLnF1ZXJ5VG9UYWdNYXBfW1N5bmNUcmVlLm1ha2VRdWVyeUtleV8ocXVlcnlUb1JlbW92ZSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubGlzdGVuUHJvdmlkZXJfLnN0b3BMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5VG9SZW1vdmUpLCB0YWdUb1JlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdywgY2xlYXIgYWxsIG9mIHRoZSB0YWdzIHdlJ3JlIHRyYWNraW5nIGZvciB0aGUgcmVtb3ZlZCBsaXN0ZW5zXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ3NfKHJlbW92ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8tb3AsIHRoaXMgbGlzdGVuZXIgbXVzdCd2ZSBiZWVuIGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5jZWxFdmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2FjaGUsIGlmIHdlIGhhdmUgb25lLCBvZiB0aGUgZGF0YSBhdCBhIHBhcnRpY3VsYXIgcGF0aC4gVGhlIGxvY2F0aW9uIG11c3QgaGF2ZSBhIGxpc3RlbmVyIGFib3ZlXG4gICAgICogaXQsIGJ1dCBhcyB0aGlzIGlzIG9ubHkgdXNlZCBieSB0cmFuc2FjdGlvbiBjb2RlLCB0aGF0IHNob3VsZCBhbHdheXMgYmUgdGhlIGNhc2UgYW55d2F5cy5cbiAgICAgKlxuICAgICAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgKmluY2x1ZGUqIGhpZGRlbiB3cml0ZXMgZnJvbSB0cmFuc2FjdGlvbiB3aXRoIGFwcGx5TG9jYWxseSBzZXQgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgcGF0aCB0byB0aGUgZGF0YSB3ZSB3YW50XG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIEEgc3BlY2lmaWMgc2V0IHRvIGJlIGV4Y2x1ZGVkXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUgPSBmdW5jdGlvbiAocGF0aCwgd3JpdGVJZHNUb0V4Y2x1ZGUpIHtcbiAgICAgICAgdmFyIGluY2x1ZGVIaWRkZW5TZXRzID0gdHJ1ZTtcbiAgICAgICAgdmFyIHdyaXRlVHJlZSA9IHRoaXMucGVuZGluZ1dyaXRlVHJlZV87XG4gICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uZmluZE9uUGF0aChwYXRoLCBmdW5jdGlvbiAocGF0aFNvRmFyLCBzeW5jUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocGF0aFNvRmFyLCBwYXRoKTtcbiAgICAgICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VydmVyQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd3JpdGVUcmVlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUocGF0aCwgc2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuU2V0cyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbGxhcHNlcyBtdWx0aXBsZSB1bmZpbHRlcmVkIHZpZXdzIGludG8gYSBzaW5nbGUgdmlldywgc2luY2Ugd2Ugb25seSBuZWVkIGEgc2luZ2xlXG4gICAgICogbGlzdGVuZXIgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFJbW11dGFibGVUcmVlLjwhU3luY1BvaW50Pn0gc3VidHJlZVxuICAgICAqIEByZXR1cm4geyFBcnJheS48IVZpZXc+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLmNvbGxlY3REaXN0aW5jdFZpZXdzRm9yU3ViVHJlZV8gPSBmdW5jdGlvbiAoc3VidHJlZSkge1xuICAgICAgICByZXR1cm4gc3VidHJlZS5mb2xkKGZ1bmN0aW9uIChyZWxhdGl2ZVBhdGgsIG1heWJlQ2hpbGRTeW5jUG9pbnQsIGNoaWxkTWFwKSB7XG4gICAgICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCAmJiBtYXliZUNoaWxkU3luY1BvaW50Lmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlVmlldyA9IG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0Q29tcGxldGVWaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb21wbGV0ZVZpZXddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gY29tcGxldGUgdmlldyBoZXJlLCBmbGF0dGVuIGFueSBkZWVwZXIgbGlzdGVucyBpbnRvIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdzXzEgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVDaGlsZFN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3c18xID0gbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRRdWVyeVZpZXdzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHV0aWxfMy5mb3JFYWNoKGNoaWxkTWFwLCBmdW5jdGlvbiAoa2V5LCBjaGlsZFZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdzXzEgPSB2aWV3c18xLmNvbmNhdChjaGlsZFZpZXdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlld3NfMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IVF1ZXJ5Pn0gcXVlcmllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnJlbW92ZVRhZ3NfID0gZnVuY3Rpb24gKHF1ZXJpZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBxdWVyaWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZFF1ZXJ5ID0gcXVlcmllc1tqXTtcbiAgICAgICAgICAgIGlmICghcmVtb3ZlZFF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkubG9hZHNBbGxEYXRhKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgaGF2ZSBhIHRhZyBmb3IgdGhpc1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkUXVlcnlLZXkgPSBTeW5jVHJlZS5tYWtlUXVlcnlLZXlfKHJlbW92ZWRRdWVyeSk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRRdWVyeVRhZyA9IHRoaXMucXVlcnlUb1RhZ01hcF9bcmVtb3ZlZFF1ZXJ5S2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWVyeVRvVGFnTWFwX1tyZW1vdmVkUXVlcnlLZXldO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnRhZ1RvUXVlcnlNYXBfWydfJyArIHJlbW92ZWRRdWVyeVRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYSBxdWVyeSB0byBhIHF1ZXJ5IHdlIHNlbmQgdGhlIHNlcnZlciBmb3IgbGlzdGVuaW5nXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7IVF1ZXJ5fSBUaGUgbm9ybWFsaXplZCBxdWVyeVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChxdWVyeS5nZXRRdWVyeVBhcmFtcygpLmxvYWRzQWxsRGF0YSgpICYmXG4gICAgICAgICAgICAhcXVlcnkuZ2V0UXVlcnlQYXJhbXMoKS5pc0RlZmF1bHQoKSkge1xuICAgICAgICAgICAgLy8gV2UgdHJlYXQgcXVlcmllcyB0aGF0IGxvYWQgYWxsIGRhdGEgYXMgZGVmYXVsdCBxdWVyaWVzXG4gICAgICAgICAgICAvLyBDYXN0IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHJlZigpIHRlY2huaWNhbGx5IHJldHVybnMgRmlyZWJhc2Ugd2hpY2ggaXMgYWN0dWFsbHkgZmIuYXBpLkZpcmViYXNlIHdoaWNoIGluaGVyaXRzXG4gICAgICAgICAgICAvLyBmcm9tIFF1ZXJ5XG4gICAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHshUXVlcnl9ICovIHF1ZXJ5LmdldFJlZigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiBuZXcgbGlzdGVuLCBtYW5hZ2UgdGhlIGRlLWR1cGxpY2F0aW9uIG9mIG91dHN0YW5kaW5nIHN1YnNjcmlwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFRdWVyeX0gcXVlcnlcbiAgICAgKiBAcGFyYW0geyFWaWV3fSB2aWV3XG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fSBUaGlzIG1ldGhvZCBjYW4gcmV0dXJuIGV2ZW50cyB0byBzdXBwb3J0IHN5bmNocm9ub3VzIGRhdGEgc291cmNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnNldHVwTGlzdGVuZXJfID0gZnVuY3Rpb24gKHF1ZXJ5LCB2aWV3KSB7XG4gICAgICAgIHZhciBwYXRoID0gcXVlcnkucGF0aDtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5KTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5jcmVhdGVMaXN0ZW5lckZvclZpZXdfKHZpZXcpO1xuICAgICAgICB2YXIgZXZlbnRzID0gdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RhcnRMaXN0ZW5pbmcoU3luY1RyZWUucXVlcnlGb3JMaXN0ZW5pbmdfKHF1ZXJ5KSwgdGFnLCBsaXN0ZW5lci5oYXNoRm4sIGxpc3RlbmVyLm9uQ29tcGxldGUpO1xuICAgICAgICB2YXIgc3VidHJlZSA9IHRoaXMuc3luY1BvaW50VHJlZV8uc3VidHJlZShwYXRoKTtcbiAgICAgICAgLy8gVGhlIHJvb3Qgb2YgdGhpcyBzdWJ0cmVlIGhhcyBvdXIgcXVlcnkuIFdlJ3JlIGhlcmUgYmVjYXVzZSB3ZSBkZWZpbml0ZWx5IG5lZWQgdG8gc2VuZCBhIGxpc3RlbiBmb3IgdGhhdCwgYnV0IHdlXG4gICAgICAgIC8vIG1heSBuZWVkIHRvIHNoYWRvdyBvdGhlciBsaXN0ZW5zIGFzIHdlbGwuXG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoIXN1YnRyZWUudmFsdWUuaGFzQ29tcGxldGVWaWV3KCksIFwiSWYgd2UncmUgYWRkaW5nIGEgcXVlcnksIGl0IHNob3VsZG4ndCBiZSBzaGFkb3dlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNoYWRvdyBldmVyeXRoaW5nIGF0IG9yIGJlbG93IHRoaXMgbG9jYXRpb24sIHRoaXMgaXMgYSBkZWZhdWx0IGxpc3RlbmVyLlxuICAgICAgICAgICAgdmFyIHF1ZXJpZXNUb1N0b3AgPSBzdWJ0cmVlLmZvbGQoZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgbWF5YmVDaGlsZFN5bmNQb2ludCwgY2hpbGRNYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbGF0aXZlUGF0aC5pc0VtcHR5KCkgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF5YmVDaGlsZFN5bmNQb2ludCAmJlxuICAgICAgICAgICAgICAgICAgICBtYXliZUNoaWxkU3luY1BvaW50Lmhhc0NvbXBsZXRlVmlldygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWF5YmVDaGlsZFN5bmNQb2ludC5nZXRDb21wbGV0ZVZpZXcoKS5nZXRRdWVyeSgpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGRlZmF1bHQgbGlzdGVuZXIgaGVyZSwgZmxhdHRlbiBhbnkgZGVlcGVyIHF1ZXJpZXMgaW50byBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVlcmllc18xID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUNoaWxkU3luY1BvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVzXzEgPSBxdWVyaWVzXzEuY29uY2F0KG1heWJlQ2hpbGRTeW5jUG9pbnQuZ2V0UXVlcnlWaWV3cygpLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gdmlldy5nZXRRdWVyeSgpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdXRpbF8zLmZvckVhY2goY2hpbGRNYXAsIGZ1bmN0aW9uIChrZXksIGNoaWxkUXVlcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcmllc18xID0gcXVlcmllc18xLmNvbmNhdChjaGlsZFF1ZXJpZXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1ZXJpZXNfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcmllc1RvU3RvcC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBxdWVyeVRvU3RvcCA9IHF1ZXJpZXNUb1N0b3BbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5Qcm92aWRlcl8uc3RvcExpc3RlbmluZyhTeW5jVHJlZS5xdWVyeUZvckxpc3RlbmluZ18ocXVlcnlUb1N0b3ApLCB0aGlzLnRhZ0ZvclF1ZXJ5XyhxdWVyeVRvU3RvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVZpZXd9IHZpZXdcbiAgICAgKiBAcmV0dXJuIHt7aGFzaEZuOiBmdW5jdGlvbigpLCBvbkNvbXBsZXRlOiBmdW5jdGlvbighc3RyaW5nLCAqKX19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuY3JlYXRlTGlzdGVuZXJGb3JWaWV3XyA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBxdWVyeSA9IHZpZXcuZ2V0UXVlcnkoKTtcbiAgICAgICAgdmFyIHRhZyA9IHRoaXMudGFnRm9yUXVlcnlfKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhhc2hGbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IHZpZXcuZ2V0U2VydmVyQ2FjaGUoKSB8fCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGUuaGFzaCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnb2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hcHBseVRhZ2dlZExpc3RlbkNvbXBsZXRlKHF1ZXJ5LnBhdGgsIHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXBwbHlMaXN0ZW5Db21wbGV0ZShxdWVyeS5wYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBsaXN0ZW4gZmFpbGVkLCBraWxsIGFsbCBvZiB0aGUgbGlzdGVuZXJzIGhlcmUsIG5vdCBqdXN0IHRoZSBvbmUgdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgbmVlZCB0byBiZSBzY29wZWQgdG8ganVzdCB0aGlzIGxpc3RlbmVyIGlmIHdlIGNoYW5nZSBwZXJtaXNzaW9ucyBvbiBmaWx0ZXJlZCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSB1dGlsXzIuZXJyb3JGb3JTZXJ2ZXJDb2RlKHN0YXR1cywgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlRXZlbnRSZWdpc3RyYXRpb24ocXVlcnksIFxuICAgICAgICAgICAgICAgICAgICAvKmV2ZW50UmVnaXN0cmF0aW9uKi8gbnVsbCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgcXVlcnksIGNvbXB1dGVzIGEgXCJxdWVyeUtleVwiIHN1aXRhYmxlIGZvciB1c2UgaW4gb3VyIHF1ZXJ5VG9UYWdNYXBfLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIFN5bmNUcmVlLm1ha2VRdWVyeUtleV8gPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5LnBhdGgudG9TdHJpbmcoKSArICckJyArIHF1ZXJ5LnF1ZXJ5SWRlbnRpZmllcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBxdWVyeUtleSAoY3JlYXRlZCBieSBtYWtlUXVlcnlLZXkpLCBwYXJzZSBpdCBiYWNrIGludG8gYSBwYXRoIGFuZCBxdWVyeUlkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBxdWVyeUtleVxuICAgICAqIEByZXR1cm4ge3txdWVyeUlkOiAhc3RyaW5nLCBwYXRoOiAhUGF0aH19XG4gICAgICovXG4gICAgU3luY1RyZWUucGFyc2VRdWVyeUtleV8gPSBmdW5jdGlvbiAocXVlcnlLZXkpIHtcbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBxdWVyeUtleS5pbmRleE9mKCckJyk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQoc3BsaXRJbmRleCAhPT0gLTEgJiYgc3BsaXRJbmRleCA8IHF1ZXJ5S2V5Lmxlbmd0aCAtIDEsICdCYWQgcXVlcnlLZXkuJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWVyeUlkOiBxdWVyeUtleS5zdWJzdHIoc3BsaXRJbmRleCArIDEpLFxuICAgICAgICAgICAgcGF0aDogbmV3IFBhdGhfMS5QYXRoKHF1ZXJ5S2V5LnN1YnN0cigwLCBzcGxpdEluZGV4KSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcXVlcnkgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiB0YWcsIGlmIHdlIGhhdmUgb25lXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSB0YWdcbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUucHJvdG90eXBlLnF1ZXJ5S2V5Rm9yVGFnXyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnVG9RdWVyeU1hcF9bJ18nICsgdGFnXTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdGFnIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gcXVlcnkuXG4gICAgICogQHBhcmFtIHshUXVlcnl9IHF1ZXJ5XG4gICAgICogQHJldHVybiB7P251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS50YWdGb3JRdWVyeV8gPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIHF1ZXJ5S2V5ID0gU3luY1RyZWUubWFrZVF1ZXJ5S2V5XyhxdWVyeSk7XG4gICAgICAgIHJldHVybiB1dGlsXzMuc2FmZUdldCh0aGlzLnF1ZXJ5VG9UYWdNYXBfLCBxdWVyeUtleSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgYWNjZXNzb3IgZm9yIHF1ZXJ5IHRhZ3MuXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgU3luY1RyZWUuZ2V0TmV4dFF1ZXJ5VGFnXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFN5bmNUcmVlLm5leHRRdWVyeVRhZ18rKztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIG1ldGhvZCB0byBhcHBseSB0YWdnZWQgb3BlcmF0aW9uc1xuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcXVlcnlQYXRoXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlUYWdnZWRPcGVyYXRpb25fID0gZnVuY3Rpb24gKHF1ZXJ5UGF0aCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBzeW5jUG9pbnQgPSB0aGlzLnN5bmNQb2ludFRyZWVfLmdldChxdWVyeVBhdGgpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHN5bmNQb2ludCwgXCJNaXNzaW5nIHN5bmMgcG9pbnQgZm9yIHF1ZXJ5IHRhZyB0aGF0IHdlJ3JlIHRyYWNraW5nXCIpO1xuICAgICAgICB2YXIgd3JpdGVzQ2FjaGUgPSB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKHF1ZXJ5UGF0aCk7XG4gICAgICAgIHJldHVybiBzeW5jUG9pbnQuYXBwbHlPcGVyYXRpb24ob3BlcmF0aW9uLCB3cml0ZXNDYWNoZSwgXG4gICAgICAgIC8qc2VydmVyQ2FjaGU9Ki8gbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBtZXRob2QgdGhhdCB2aXNpdHMgYWxsIGRlc2NlbmRhbnQgYW5kIGFuY2VzdG9yIFN5bmNQb2ludHMsIGFwcGx5aW5nIHRoZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBOT1RFUzpcbiAgICAgKiAtIERlc2NlbmRhbnQgU3luY1BvaW50cyB3aWxsIGJlIHZpc2l0ZWQgZmlyc3QgKHNpbmNlIHdlIHJhaXNlIGV2ZW50cyBkZXB0aC1maXJzdCkuXG4gIFxuICAgICAqIC0gV2UgY2FsbCBhcHBseU9wZXJhdGlvbigpIG9uIGVhY2ggU3luY1BvaW50IHBhc3NpbmcgdGhyZWUgdGhpbmdzOlxuICAgICAqICAgMS4gQSB2ZXJzaW9uIG9mIHRoZSBPcGVyYXRpb24gdGhhdCBoYXMgYmVlbiBtYWRlIHJlbGF0aXZlIHRvIHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAyLiBBIFdyaXRlVHJlZVJlZiBvZiBhbnkgd3JpdGVzIHdlIGhhdmUgY2FjaGVkIGF0IHRoZSBTeW5jUG9pbnQgbG9jYXRpb24uXG4gICAgICogICAzLiBBIHNuYXBzaG90IE5vZGUgd2l0aCBjYWNoZWQgc2VydmVyIGRhdGEsIGlmIHdlIGhhdmUgaXQuXG4gIFxuICAgICAqIC0gV2UgY29uY2F0ZW5hdGUgYWxsIG9mIHRoZSBldmVudHMgcmV0dXJuZWQgYnkgZWFjaCBTeW5jUG9pbnQgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTeW5jVHJlZS5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb25Ub1N5bmNQb2ludHNfID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8ob3BlcmF0aW9uLCB0aGlzLnN5bmNQb2ludFRyZWVfLCBcbiAgICAgICAgLypzZXJ2ZXJDYWNoZT0qLyBudWxsLCB0aGlzLnBlbmRpbmdXcml0ZVRyZWVfLmNoaWxkV3JpdGVzKFBhdGhfMS5QYXRoLkVtcHR5KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbkhlbHBlcl8gPSBmdW5jdGlvbiAob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5wYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlPcGVyYXRpb25EZXNjZW5kYW50c0hlbHBlcl8ob3BlcmF0aW9uLCBzeW5jUG9pbnRUcmVlLCBzZXJ2ZXJDYWNoZSwgd3JpdGVzQ2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN5bmNQb2ludCA9IHN5bmNQb2ludFRyZWUuZ2V0KFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgY2FjaGVkIHNlcnZlciBkYXRhLCBzZWUgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHRoaXMgU3luY1BvaW50LlxuICAgICAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXJDYWNoZSA9IHN5bmNQb2ludC5nZXRDb21wbGV0ZVNlcnZlckNhY2hlKFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5hbWUgPSBvcGVyYXRpb24ucGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgdmFyIGNoaWxkT3BlcmF0aW9uID0gb3BlcmF0aW9uLm9wZXJhdGlvbkZvckNoaWxkKGNoaWxkTmFtZSk7XG4gICAgICAgICAgICB2YXIgY2hpbGRUcmVlID0gc3luY1BvaW50VHJlZS5jaGlsZHJlbi5nZXQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIGlmIChjaGlsZFRyZWUgJiYgY2hpbGRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRTZXJ2ZXJDYWNoZSA9IHNlcnZlckNhY2hlXG4gICAgICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkV3JpdGVzQ2FjaGUgPSB3cml0ZXNDYWNoZS5jaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5hcHBseU9wZXJhdGlvbkhlbHBlcl8oY2hpbGRPcGVyYXRpb24sIGNoaWxkVHJlZSwgY2hpbGRTZXJ2ZXJDYWNoZSwgY2hpbGRXcml0ZXNDYWNoZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN5bmNQb2ludCkge1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQoc3luY1BvaW50LmFwcGx5T3BlcmF0aW9uKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmUgaGVscGVyIGZvciBhcHBseU9wZXJhdGlvblRvU3luY1BvaW50c19cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFTeW5jUG9pbnQ+fSBzeW5jUG9pbnRUcmVlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gc2VydmVyQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFN5bmNUcmVlLnByb3RvdHlwZS5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyA9IGZ1bmN0aW9uIChvcGVyYXRpb24sIHN5bmNQb2ludFRyZWUsIHNlcnZlckNhY2hlLCB3cml0ZXNDYWNoZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3luY1BvaW50ID0gc3luY1BvaW50VHJlZS5nZXQoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGNhY2hlZCBzZXJ2ZXIgZGF0YSwgc2VlIGlmIHdlIGNhbiBnZXQgaXQgZnJvbSB0aGlzIFN5bmNQb2ludC5cbiAgICAgICAgaWYgKHNlcnZlckNhY2hlID09IG51bGwgJiYgc3luY1BvaW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZlckNhY2hlID0gc3luY1BvaW50LmdldENvbXBsZXRlU2VydmVyQ2FjaGUoUGF0aF8xLlBhdGguRW1wdHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgc3luY1BvaW50VHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkU2VydmVyQ2FjaGUgPSBzZXJ2ZXJDYWNoZVxuICAgICAgICAgICAgICAgID8gc2VydmVyQ2FjaGUuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGROYW1lKVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBjaGlsZFdyaXRlc0NhY2hlID0gd3JpdGVzQ2FjaGUuY2hpbGQoY2hpbGROYW1lKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE9wZXJhdGlvbiA9IG9wZXJhdGlvbi5vcGVyYXRpb25Gb3JDaGlsZChjaGlsZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGNoaWxkT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChfdGhpcy5hcHBseU9wZXJhdGlvbkRlc2NlbmRhbnRzSGVscGVyXyhjaGlsZE9wZXJhdGlvbiwgY2hpbGRUcmVlLCBjaGlsZFNlcnZlckNhY2hlLCBjaGlsZFdyaXRlc0NhY2hlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3luY1BvaW50KSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHN5bmNQb2ludC5hcHBseU9wZXJhdGlvbihvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGF0aWMgdHJhY2tlciBmb3IgbmV4dCBxdWVyeSB0YWcuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFN5bmNUcmVlLm5leHRRdWVyeVRhZ18gPSAxO1xuICAgIHJldHVybiBTeW5jVHJlZTtcbn0oKSk7XG5leHBvcnRzLlN5bmNUcmVlID0gU3luY1RyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bmNUcmVlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1N5bmNUcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1BhdGhcIik7XG52YXIgT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9PcGVyYXRpb25cIik7XG52YXIgQWNrVXNlcldyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWU8IWJvb2xlYW4+fSBhZmZlY3RlZFRyZWUgQSB0cmVlIGNvbnRhaW5pbmcgdHJ1ZSBmb3IgZWFjaCBhZmZlY3RlZCBwYXRoLiBBZmZlY3RlZCBwYXRocyBjYW4ndCBvdmVybGFwLlxuICAgICAqIEBwYXJhbSB7IWJvb2xlYW59IHJldmVydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEFja1VzZXJXcml0ZShcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gcGF0aCwgXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIGFmZmVjdGVkVHJlZSwgXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIHJldmVydCkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmFmZmVjdGVkVHJlZSA9IGFmZmVjdGVkVHJlZTtcbiAgICAgICAgdGhpcy5yZXZlcnQgPSByZXZlcnQ7XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLkFDS19VU0VSX1dSSVRFO1xuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25Tb3VyY2UuVXNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBBY2tVc2VyV3JpdGUucHJvdG90eXBlLm9wZXJhdGlvbkZvckNoaWxkID0gZnVuY3Rpb24gKGNoaWxkTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy5wYXRoLmdldEZyb250KCkgPT09IGNoaWxkTmFtZSwgJ29wZXJhdGlvbkZvckNoaWxkIGNhbGxlZCBmb3IgdW5yZWxhdGVkIGNoaWxkLicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY2tVc2VyV3JpdGUodGhpcy5wYXRoLnBvcEZyb250KCksIHRoaXMuYWZmZWN0ZWRUcmVlLCB0aGlzLnJldmVydCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hZmZlY3RlZFRyZWUudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydCh0aGlzLmFmZmVjdGVkVHJlZS5jaGlsZHJlbi5pc0VtcHR5KCksICdhZmZlY3RlZFRyZWUgc2hvdWxkIG5vdCBoYXZlIG92ZXJsYXBwaW5nIGFmZmVjdGVkIHBhdGhzLicpO1xuICAgICAgICAgICAgLy8gQWxsIGNoaWxkIGxvY2F0aW9ucyBhcmUgYWZmZWN0ZWQgYXMgd2VsbDsganVzdCByZXR1cm4gc2FtZSBvcGVyYXRpb24uXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSB0aGlzLmFmZmVjdGVkVHJlZS5zdWJ0cmVlKG5ldyBQYXRoXzEuUGF0aChjaGlsZE5hbWUpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWNrVXNlcldyaXRlKFBhdGhfMS5QYXRoLkVtcHR5LCBjaGlsZFRyZWUsIHRoaXMucmV2ZXJ0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFja1VzZXJXcml0ZTtcbn0oKSk7XG5leHBvcnRzLkFja1VzZXJXcml0ZSA9IEFja1VzZXJXcml0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWNrVXNlcldyaXRlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL29wZXJhdGlvbi9BY2tVc2VyV3JpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQYXRoXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9QYXRoXCIpO1xudmFyIE9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vT3BlcmF0aW9uXCIpO1xuLyoqXG4gKiBAcGFyYW0geyFPcGVyYXRpb25Tb3VyY2V9IHNvdXJjZVxuICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7T3BlcmF0aW9ufVxuICovXG52YXIgTGlzdGVuQ29tcGxldGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGlzdGVuQ29tcGxldGUoc291cmNlLCBwYXRoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICAgICAgdGhpcy50eXBlID0gT3BlcmF0aW9uXzEuT3BlcmF0aW9uVHlwZS5MSVNURU5fQ09NUExFVEU7XG4gICAgfVxuICAgIExpc3RlbkNvbXBsZXRlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdGVuQ29tcGxldGUodGhpcy5zb3VyY2UsIHRoaXMucGF0aC5wb3BGcm9udCgpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIExpc3RlbkNvbXBsZXRlO1xufSgpKTtcbmV4cG9ydHMuTGlzdGVuQ29tcGxldGUgPSBMaXN0ZW5Db21wbGV0ZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdGVuQ29tcGxldGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvb3BlcmF0aW9uL0xpc3RlbkNvbXBsZXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9PcGVyYXRpb25cIik7XG52YXIgT3ZlcndyaXRlXzEgPSByZXF1aXJlKFwiLi9PdmVyd3JpdGVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL3V0aWwvUGF0aFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIEBwYXJhbSB7IU9wZXJhdGlvblNvdXJjZX0gc291cmNlXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAcGFyYW0geyFJbW11dGFibGVUcmVlLjwhTm9kZT59IGNoaWxkcmVuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtPcGVyYXRpb259XG4gKi9cbnZhciBNZXJnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZShcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gc291cmNlLCBcbiAgICAgICAgLyoqQGluaGVyaXREb2MgKi8gcGF0aCwgXG4gICAgICAgIC8qKkBpbmhlcml0RG9jICovIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk1FUkdFO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIE1lcmdlLnByb3RvdHlwZS5vcGVyYXRpb25Gb3JDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZFRyZWUgPSB0aGlzLmNoaWxkcmVuLnN1YnRyZWUobmV3IFBhdGhfMS5QYXRoKGNoaWxkTmFtZSkpO1xuICAgICAgICAgICAgaWYgKGNoaWxkVHJlZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIHVuYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkVHJlZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzbmFwc2hvdCBmb3IgdGhlIGNoaWxkIGluIHF1ZXN0aW9uLiAgVGhpcyBiZWNvbWVzIGFuIG92ZXJ3cml0ZSBvZiB0aGUgY2hpbGQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPdmVyd3JpdGVfMS5PdmVyd3JpdGUodGhpcy5zb3VyY2UsIFBhdGhfMS5QYXRoLkVtcHR5LCBjaGlsZFRyZWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG1lcmdlIGF0IGEgZGVlcGVyIGxldmVsXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNZXJnZSh0aGlzLnNvdXJjZSwgUGF0aF8xLlBhdGguRW1wdHksIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMucGF0aC5nZXRGcm9udCgpID09PSBjaGlsZE5hbWUsIFwiQ2FuJ3QgZ2V0IGEgbWVyZ2UgZm9yIGEgY2hpbGQgbm90IG9uIHRoZSBwYXRoIG9mIHRoZSBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1lcmdlKHRoaXMuc291cmNlLCB0aGlzLnBhdGgucG9wRnJvbnQoKSwgdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTWVyZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKCdPcGVyYXRpb24oJyArXG4gICAgICAgICAgICB0aGlzLnBhdGggK1xuICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS50b1N0cmluZygpICtcbiAgICAgICAgICAgICcgbWVyZ2U6ICcgK1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi50b1N0cmluZygpICtcbiAgICAgICAgICAgICcpJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2U7XG59KCkpO1xuZXhwb3J0cy5NZXJnZSA9IE1lcmdlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9vcGVyYXRpb24vTWVyZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbmRleGVkRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXIvSW5kZXhlZEZpbHRlclwiKTtcbnZhciBWaWV3UHJvY2Vzc29yXzEgPSByZXF1aXJlKFwiLi9WaWV3UHJvY2Vzc29yXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIENhY2hlTm9kZV8xID0gcmVxdWlyZShcIi4vQ2FjaGVOb2RlXCIpO1xudmFyIFZpZXdDYWNoZV8xID0gcmVxdWlyZShcIi4vVmlld0NhY2hlXCIpO1xudmFyIEV2ZW50R2VuZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9FdmVudEdlbmVyYXRvclwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgT3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vb3BlcmF0aW9uL09wZXJhdGlvblwiKTtcbnZhciBDaGFuZ2VfMSA9IHJlcXVpcmUoXCIuL0NoYW5nZVwiKTtcbnZhciBQcmlvcml0eUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG4vKipcbiAqIEEgdmlldyByZXByZXNlbnRzIGEgc3BlY2lmaWMgbG9jYXRpb24gYW5kIHF1ZXJ5IHRoYXQgaGFzIDEgb3IgbW9yZSBldmVudCByZWdpc3RyYXRpb25zLlxuICpcbiAqIEl0IGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4gKiAgLSBNYWludGFpbnMgdGhlIGxpc3Qgb2YgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBsb2NhdGlvbi9xdWVyeS5cbiAqICAtIE1haW50YWlucyBhIGNhY2hlIG9mIHRoZSBkYXRhIHZpc2libGUgZm9yIHRoaXMgbG9jYXRpb24vcXVlcnkuXG4gKiAgLSBBcHBsaWVzIG5ldyBvcGVyYXRpb25zICh2aWEgYXBwbHlPcGVyYXRpb24pLCB1cGRhdGVzIHRoZSBjYWNoZSwgYW5kIGJhc2VkIG9uIHRoZSBldmVudFxuICogICAgcmVnaXN0cmF0aW9ucyByZXR1cm5zIHRoZSBzZXQgb2YgZXZlbnRzIHRvIGJlIHJhaXNlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeV9cbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IGluaXRpYWxWaWV3Q2FjaGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBWaWV3KHF1ZXJ5XywgaW5pdGlhbFZpZXdDYWNoZSkge1xuICAgICAgICB0aGlzLnF1ZXJ5XyA9IHF1ZXJ5XztcbiAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpO1xuICAgICAgICB2YXIgaW5kZXhGaWx0ZXIgPSBuZXcgSW5kZXhlZEZpbHRlcl8xLkluZGV4ZWRGaWx0ZXIocGFyYW1zLmdldEluZGV4KCkpO1xuICAgICAgICB2YXIgZmlsdGVyID0gcGFyYW1zLmdldE5vZGVGaWx0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtWaWV3UHJvY2Vzc29yfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfID0gbmV3IFZpZXdQcm9jZXNzb3JfMS5WaWV3UHJvY2Vzc29yKGZpbHRlcik7XG4gICAgICAgIHZhciBpbml0aWFsU2VydmVyQ2FjaGUgPSBpbml0aWFsVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCk7XG4gICAgICAgIHZhciBpbml0aWFsRXZlbnRDYWNoZSA9IGluaXRpYWxWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICAvLyBEb24ndCBmaWx0ZXIgc2VydmVyIG5vZGUgd2l0aCBvdGhlciBmaWx0ZXIgdGhhbiBpbmRleCwgd2FpdCBmb3IgdGFnZ2VkIGxpc3RlblxuICAgICAgICB2YXIgc2VydmVyU25hcCA9IGluZGV4RmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLCBpbml0aWFsU2VydmVyQ2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcbiAgICAgICAgdmFyIGV2ZW50U25hcCA9IGZpbHRlci51cGRhdGVGdWxsTm9kZShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSwgaW5pdGlhbEV2ZW50Q2FjaGUuZ2V0Tm9kZSgpLCBudWxsKTtcbiAgICAgICAgdmFyIG5ld1NlcnZlckNhY2hlID0gbmV3IENhY2hlTm9kZV8xLkNhY2hlTm9kZShzZXJ2ZXJTbmFwLCBpbml0aWFsU2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGluZGV4RmlsdGVyLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgdmFyIG5ld0V2ZW50Q2FjaGUgPSBuZXcgQ2FjaGVOb2RlXzEuQ2FjaGVOb2RlKGV2ZW50U25hcCwgaW5pdGlhbEV2ZW50Q2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCksIGZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVZpZXdDYWNoZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IG5ldyBWaWV3Q2FjaGVfMS5WaWV3Q2FjaGUobmV3RXZlbnRDYWNoZSwgbmV3U2VydmVyQ2FjaGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFFdmVudEdlbmVyYXRvcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRHZW5lcmF0b3JfID0gbmV3IEV2ZW50R2VuZXJhdG9yXzEuRXZlbnRHZW5lcmF0b3IodGhpcy5xdWVyeV8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshUXVlcnl9XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2V0UXVlcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldFNlcnZlckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3Q2FjaGVfLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldENvbXBsZXRlU2VydmVyQ2FjaGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0Q29tcGxldGVTZXJ2ZXJTbmFwKCk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpc24ndCBhIFwibG9hZHNBbGxEYXRhXCIgdmlldywgdGhlbiBjYWNoZSBpc24ndCBhY3R1YWxseSBhIGNvbXBsZXRlIGNhY2hlIGFuZFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBzZWUgaWYgaXQgY29udGFpbnMgdGhlIGNoaWxkIHdlJ3JlIGludGVyZXN0ZWQgaW4uXG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeV8uZ2V0UXVlcnlQYXJhbXMoKS5sb2Fkc0FsbERhdGEoKSB8fFxuICAgICAgICAgICAgICAgICghcGF0aC5pc0VtcHR5KCkgJiYgIWNhY2hlLmdldEltbWVkaWF0ZUNoaWxkKHBhdGguZ2V0RnJvbnQoKSkuaXNFbXB0eSgpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5hZGRFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18ucHVzaChldmVudFJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9FdmVudFJlZ2lzdHJhdGlvbn0gZXZlbnRSZWdpc3RyYXRpb24gSWYgbnVsbCwgcmVtb3ZlIGFsbCBjYWxsYmFja3MuXG4gICAgICogQHBhcmFtIHtFcnJvcj19IGNhbmNlbEVycm9yIElmIGEgY2FuY2VsRXJyb3IgaXMgcHJvdmlkZWQsIGFwcHJvcHJpYXRlIGNhbmNlbCBldmVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59IENhbmNlbCBldmVudHMsIGlmIGNhbmNlbEVycm9yIHdhcyBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBWaWV3LnByb3RvdHlwZS5yZW1vdmVFdmVudFJlZ2lzdHJhdGlvbiA9IGZ1bmN0aW9uIChldmVudFJlZ2lzdHJhdGlvbiwgY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgdmFyIGNhbmNlbEV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoY2FuY2VsRXJyb3IpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoZXZlbnRSZWdpc3RyYXRpb24gPT0gbnVsbCwgJ0EgY2FuY2VsIHNob3VsZCBjYW5jZWwgYWxsIGV2ZW50IHJlZ2lzdHJhdGlvbnMuJyk7XG4gICAgICAgICAgICB2YXIgcGF0aF8xID0gdGhpcy5xdWVyeV8ucGF0aDtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZWdpc3RyYXRpb25zXy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxFcnJvciAvKiogQHR5cGUgeyFFcnJvcn0gKi8gPSBjYW5jZWxFcnJvcjtcbiAgICAgICAgICAgICAgICB2YXIgbWF5YmVFdmVudCA9IHJlZ2lzdHJhdGlvbi5jcmVhdGVDYW5jZWxFdmVudChjYW5jZWxFcnJvciwgcGF0aF8xKTtcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxFdmVudHMucHVzaChtYXliZUV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRSZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmcgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfW2ldO1xuICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmcubWF0Y2hlcyhldmVudFJlZ2lzdHJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nLnB1c2goZXhpc3RpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFJlZ2lzdHJhdGlvbi5oYXNBbnlDYWxsYmFjaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHJlbW92aW5nIGp1c3QgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLmNvbmNhdCh0aGlzLmV2ZW50UmVnaXN0cmF0aW9uc18uc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gcmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGdpdmVuIE9wZXJhdGlvbiwgdXBkYXRlcyBvdXIgY2FjaGUsIGFuZCByZXR1cm5zIHRoZSBhcHByb3ByaWF0ZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPcGVyYXRpb259IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5T3BlcmF0aW9uID0gZnVuY3Rpb24gKG9wZXJhdGlvbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlU2VydmVyQ2FjaGUpIHtcbiAgICAgICAgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk1FUkdFICYmXG4gICAgICAgICAgICBvcGVyYXRpb24uc291cmNlLnF1ZXJ5SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodGhpcy52aWV3Q2FjaGVfLmdldENvbXBsZXRlU2VydmVyU25hcCgpLCAnV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgZnVsbCBjYWNoZSBiZWZvcmUgaGFuZGxpbmcgbWVyZ2VzJyk7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZUV2ZW50U25hcCgpLCAnTWlzc2luZyBldmVudCBjYWNoZSwgZXZlbiB0aG91Z2ggd2UgaGF2ZSBhIHNlcnZlciBjYWNoZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvbGRWaWV3Q2FjaGUgPSB0aGlzLnZpZXdDYWNoZV87XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb2Nlc3Nvcl8uYXBwbHlPcGVyYXRpb24ob2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzb3JfLmFzc2VydEluZGV4ZWQocmVzdWx0LnZpZXdDYWNoZSk7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQocmVzdWx0LnZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8XG4gICAgICAgICAgICAhb2xkVmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCksICdPbmNlIGEgc2VydmVyIHNuYXAgaXMgY29tcGxldGUsIGl0IHNob3VsZCBuZXZlciBnbyBiYWNrJyk7XG4gICAgICAgIHRoaXMudmlld0NhY2hlXyA9IHJlc3VsdC52aWV3Q2FjaGU7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18ocmVzdWx0LmNoYW5nZXMsIHJlc3VsdC52aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgbnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFFdmVudFJlZ2lzdHJhdGlvbn0gcmVnaXN0cmF0aW9uXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhRXZlbnQ+fVxuICAgICAqL1xuICAgIFZpZXcucHJvdG90eXBlLmdldEluaXRpYWxFdmVudHMgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBldmVudFNuYXAgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICB2YXIgaW5pdGlhbENoYW5nZXMgPSBbXTtcbiAgICAgICAgaWYgKCFldmVudFNuYXAuZ2V0Tm9kZSgpLmlzTGVhZk5vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50Tm9kZSA9IGV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICBldmVudE5vZGUuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGtleSwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRBZGRlZENoYW5nZShrZXksIGNoaWxkTm9kZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSkge1xuICAgICAgICAgICAgaW5pdGlhbENoYW5nZXMucHVzaChDaGFuZ2VfMS5DaGFuZ2UudmFsdWVDaGFuZ2UoZXZlbnRTbmFwLmdldE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRzRm9yQ2hhbmdlc18oaW5pdGlhbENoYW5nZXMsIGV2ZW50U25hcC5nZXROb2RlKCksIHJlZ2lzdHJhdGlvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IGV2ZW50Q2FjaGVcbiAgICAgKiBAcGFyYW0ge0V2ZW50UmVnaXN0cmF0aW9uPX0gZXZlbnRSZWdpc3RyYXRpb25cbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFFdmVudD59XG4gICAgICovXG4gICAgVmlldy5wcm90b3R5cGUuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzXyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBldmVudENhY2hlLCBldmVudFJlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgcmVnaXN0cmF0aW9ucyA9IGV2ZW50UmVnaXN0cmF0aW9uXG4gICAgICAgICAgICA/IFtldmVudFJlZ2lzdHJhdGlvbl1cbiAgICAgICAgICAgIDogdGhpcy5ldmVudFJlZ2lzdHJhdGlvbnNfO1xuICAgICAgICByZXR1cm4gdGhpcy5ldmVudEdlbmVyYXRvcl8uZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzKGNoYW5nZXMsIGV2ZW50Q2FjaGUsIHJlZ2lzdHJhdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFZpZXc7XG59KCkpO1xuZXhwb3J0cy5WaWV3ID0gVmlldztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vmlldy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L1ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDExM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBPcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi9vcGVyYXRpb24vT3BlcmF0aW9uXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXzEgPSByZXF1aXJlKFwiLi9DaGlsZENoYW5nZUFjY3VtdWxhdG9yXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4vQ2hhbmdlXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIEtleUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL0tleUluZGV4XCIpO1xudmFyIEltbXV0YWJsZVRyZWVfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0ltbXV0YWJsZVRyZWVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4uL3V0aWwvUGF0aFwiKTtcbnZhciBDb21wbGV0ZUNoaWxkU291cmNlXzEgPSByZXF1aXJlKFwiLi9Db21wbGV0ZUNoaWxkU291cmNlXCIpO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFByb2Nlc3NvclJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IHZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NvclJlc3VsdCh2aWV3Q2FjaGUsIGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy52aWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiBQcm9jZXNzb3JSZXN1bHQ7XG59KCkpO1xuZXhwb3J0cy5Qcm9jZXNzb3JSZXN1bHQgPSBQcm9jZXNzb3JSZXN1bHQ7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVmlld1Byb2Nlc3NvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlRmlsdGVyfSBmaWx0ZXJfXG4gICAgICovXG4gICAgZnVuY3Rpb24gVmlld1Byb2Nlc3NvcihmaWx0ZXJfKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyXyA9IGZpbHRlcl87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXNzZXJ0SW5kZXhlZCA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh2aWV3Q2FjaGVcbiAgICAgICAgICAgIC5nZXRFdmVudENhY2hlKClcbiAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgIC5pc0luZGV4ZWQodGhpcy5maWx0ZXJfLmdldEluZGV4KCkpLCAnRXZlbnQgc25hcCBub3QgaW5kZXhlZCcpO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHZpZXdDYWNoZVxuICAgICAgICAgICAgLmdldFNlcnZlckNhY2hlKClcbiAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgIC5pc0luZGV4ZWQodGhpcy5maWx0ZXJfLmdldEluZGV4KCkpLCAnU2VydmVyIHNuYXAgbm90IGluZGV4ZWQnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshT3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVDYWNoZVxuICAgICAqIEByZXR1cm4geyFQcm9jZXNzb3JSZXN1bHR9XG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlPcGVyYXRpb24gPSBmdW5jdGlvbiAob2xkVmlld0NhY2hlLCBvcGVyYXRpb24sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlKSB7XG4gICAgICAgIHZhciBhY2N1bXVsYXRvciA9IG5ldyBDaGlsZENoYW5nZUFjY3VtdWxhdG9yXzEuQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcigpO1xuICAgICAgICB2YXIgbmV3Vmlld0NhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlO1xuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvbl8xLk9wZXJhdGlvblR5cGUuT1ZFUldSSVRFKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcndyaXRlID0gb3BlcmF0aW9uO1xuICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVVzZXIpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5VXNlck92ZXJ3cml0ZV8ob2xkVmlld0NhY2hlLCBvdmVyd3JpdGUucGF0aCwgb3ZlcndyaXRlLnNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KG92ZXJ3cml0ZS5zb3VyY2UuZnJvbVNlcnZlciwgJ1Vua25vd24gc291cmNlLicpO1xuICAgICAgICAgICAgICAgIC8vIFdlIGZpbHRlciB0aGUgbm9kZSBpZiBpdCdzIGEgdGFnZ2VkIHVwZGF0ZSBvciB0aGUgbm9kZSBoYXMgYmVlbiBwcmV2aW91c2x5IGZpbHRlcmVkICBhbmQgdGhlXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGlzIG5vdCBhdCB0aGUgcm9vdCBpbiB3aGljaCBjYXNlIGl0IGlzIG9rIChhbmQgbmVjZXNzYXJ5KSB0byBtYXJrIHRoZSBub2RlIHVuZmlsdGVyZWRcbiAgICAgICAgICAgICAgICAvLyBhZ2FpblxuICAgICAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxuICAgICAgICAgICAgICAgICAgICBvdmVyd3JpdGUuc291cmNlLnRhZ2dlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFvdmVyd3JpdGUucGF0aC5pc0VtcHR5KCkpO1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfKG9sZFZpZXdDYWNoZSwgb3ZlcndyaXRlLnBhdGgsIG92ZXJ3cml0ZS5zbmFwLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLk1FUkdFKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSBvcGVyYXRpb247XG4gICAgICAgICAgICBpZiAobWVyZ2Uuc291cmNlLmZyb21Vc2VyKSB7XG4gICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5hcHBseVVzZXJNZXJnZV8ob2xkVmlld0NhY2hlLCBtZXJnZS5wYXRoLCBtZXJnZS5jaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQobWVyZ2Uuc291cmNlLmZyb21TZXJ2ZXIsICdVbmtub3duIHNvdXJjZS4nKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBmaWx0ZXIgdGhlIG5vZGUgaWYgaXQncyBhIHRhZ2dlZCB1cGRhdGUgb3IgdGhlIG5vZGUgaGFzIGJlZW4gcHJldmlvdXNseSBmaWx0ZXJlZFxuICAgICAgICAgICAgICAgIGZpbHRlclNlcnZlck5vZGUgPVxuICAgICAgICAgICAgICAgICAgICBtZXJnZS5zb3VyY2UudGFnZ2VkIHx8IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKTtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFwcGx5U2VydmVyTWVyZ2VfKG9sZFZpZXdDYWNoZSwgbWVyZ2UucGF0aCwgbWVyZ2UuY2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09IE9wZXJhdGlvbl8xLk9wZXJhdGlvblR5cGUuQUNLX1VTRVJfV1JJVEUpIHtcbiAgICAgICAgICAgIHZhciBhY2tVc2VyV3JpdGUgPSBvcGVyYXRpb247XG4gICAgICAgICAgICBpZiAoIWFja1VzZXJXcml0ZS5yZXZlcnQpIHtcbiAgICAgICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSB0aGlzLmFja1VzZXJXcml0ZV8ob2xkVmlld0NhY2hlLCBhY2tVc2VyV3JpdGUucGF0aCwgYWNrVXNlcldyaXRlLmFmZmVjdGVkVHJlZSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IHRoaXMucmV2ZXJ0VXNlcldyaXRlXyhvbGRWaWV3Q2FjaGUsIGFja1VzZXJXcml0ZS5wYXRoLCB3cml0ZXNDYWNoZSwgY29tcGxldGVDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbi50eXBlID09PSBPcGVyYXRpb25fMS5PcGVyYXRpb25UeXBlLkxJU1RFTl9DT01QTEVURSkge1xuICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gdGhpcy5saXN0ZW5Db21wbGV0ZV8ob2xkVmlld0NhY2hlLCBvcGVyYXRpb24ucGF0aCwgd3JpdGVzQ2FjaGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHV0aWxfMS5hc3NlcnRpb25FcnJvcignVW5rbm93biBvcGVyYXRpb24gdHlwZTogJyArIG9wZXJhdGlvbi50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbmdlcyA9IGFjY3VtdWxhdG9yLmdldENoYW5nZXMoKTtcbiAgICAgICAgVmlld1Byb2Nlc3Nvci5tYXliZUFkZFZhbHVlRXZlbnRfKG9sZFZpZXdDYWNoZSwgbmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9jZXNzb3JSZXN1bHQobmV3Vmlld0NhY2hlLCBjaGFuZ2VzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gb2xkVmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSBuZXdWaWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUNoYW5nZT59IGFjY3VtdWxhdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLm1heWJlQWRkVmFsdWVFdmVudF8gPSBmdW5jdGlvbiAob2xkVmlld0NhY2hlLCBuZXdWaWV3Q2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBldmVudFNuYXAgPSBuZXdWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICBpZiAoZXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICB2YXIgaXNMZWFmT3JFbXB0eSA9IGV2ZW50U25hcC5nZXROb2RlKCkuaXNMZWFmTm9kZSgpIHx8IGV2ZW50U25hcC5nZXROb2RlKCkuaXNFbXB0eSgpO1xuICAgICAgICAgICAgdmFyIG9sZENvbXBsZXRlU25hcCA9IG9sZFZpZXdDYWNoZS5nZXRDb21wbGV0ZUV2ZW50U25hcCgpO1xuICAgICAgICAgICAgaWYgKGFjY3VtdWxhdG9yLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgICAgICAgICAhb2xkVmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxuICAgICAgICAgICAgICAgIChpc0xlYWZPckVtcHR5ICYmXG4gICAgICAgICAgICAgICAgICAgICFldmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5lcXVhbHMoLyoqIEB0eXBlIHshTm9kZX0gKi8gKG9sZENvbXBsZXRlU25hcCkpKSB8fFxuICAgICAgICAgICAgICAgICFldmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0UHJpb3JpdHkoKVxuICAgICAgICAgICAgICAgICAgICAuZXF1YWxzKG9sZENvbXBsZXRlU25hcC5nZXRQcmlvcml0eSgpKSkge1xuICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yLnB1c2goQ2hhbmdlXzEuQ2hhbmdlLnZhbHVlQ2hhbmdlKFxuICAgICAgICAgICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovIG5ld1ZpZXdDYWNoZS5nZXRDb21wbGV0ZUV2ZW50U25hcCgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gY2hhbmdlUGF0aFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFDb21wbGV0ZUNoaWxkU291cmNlfSBzb3VyY2VcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5nZW5lcmF0ZUV2ZW50Q2FjaGVBZnRlclNlcnZlckV2ZW50XyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIGNoYW5nZVBhdGgsIHdyaXRlc0NhY2hlLCBzb3VyY2UsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBvbGRFdmVudFNuYXAgPSB2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICBpZiAod3JpdGVzQ2FjaGUuc2hhZG93aW5nV3JpdGUoY2hhbmdlUGF0aCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhIHNoYWRvd2luZyB3cml0ZSwgaWdub3JlIGNoYW5nZXNcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRDYWNoZSA9IHZvaWQgMCwgc2VydmVyTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRoaXMgcGxheXMgd2l0aCBcInNsaWRpbmcgYWNrIHdpbmRvd3NcIlxuICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQodmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNGdWxseUluaXRpYWxpemVkKCksICdJZiBjaGFuZ2UgcGF0aCBpcyBlbXB0eSwgd2UgbXVzdCBoYXZlIGNvbXBsZXRlIHNlcnZlciBkYXRhJyk7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRmlsdGVyZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHNwZWNpYWwgY2FzZSB0aGlzLCBiZWNhdXNlIHdlIG5lZWQgdG8gb25seSBhcHBseSB3cml0ZXMgdG8gY29tcGxldGUgY2hpbGRyZW4sIG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGVuZCB1cCByYWlzaW5nIGV2ZW50cyBmb3IgaW5jb21wbGV0ZSBjaGlsZHJlbi4gSWYgdGhlIHNlcnZlciBkYXRhIGlzIGZpbHRlcmVkIGRlZXBcbiAgICAgICAgICAgICAgICAgICAgLy8gd3JpdGVzIGNhbm5vdCBiZSBndWFyYW50ZWVkIHRvIGJlIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDYWNoZSA9IHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlQ2hpbGRyZW4gPSBzZXJ2ZXJDYWNoZSBpbnN0YW5jZW9mIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJ2ZXJDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlRXZlbnRDaGlsZHJlbiA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oY29tcGxldGVDaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUodmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksIGNvbXBsZXRlRXZlbnRDaGlsZHJlbiwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlTm9kZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2FjaGUodmlld0NhY2hlLmdldENvbXBsZXRlU2VydmVyU25hcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVGdWxsTm9kZSh2aWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgY29tcGxldGVOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkS2V5ID0gY2hhbmdlUGF0aC5nZXRGcm9udCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PSAnLnByaW9yaXR5Jykge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KGNoYW5nZVBhdGguZ2V0TGVuZ3RoKCkgPT0gMSwgXCJDYW4ndCBoYXZlIGEgcHJpb3JpdHkgd2l0aCBhZGRpdGlvbmFsIHBhdGggY29tcG9uZW50c1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZEV2ZW50Tm9kZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG1pZ2h0IGhhdmUgb3ZlcndyaXRlcyBmb3IgdGhpcyBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZFByaW9yaXR5ID0gd3JpdGVzQ2FjaGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZShjaGFuZ2VQYXRoLCBvbGRFdmVudE5vZGUsIHNlcnZlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFByaW9yaXR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlUHJpb3JpdHkob2xkRXZlbnROb2RlLCB1cGRhdGVkUHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJpb3JpdHkgZGlkbid0IGNoYW5nZSwga2VlcCBvbGQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50U25hcC5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZENoYW5nZVBhdGggPSBjaGFuZ2VQYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjaGlsZFxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRDaGlsZCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZEV2ZW50U25hcC5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50Q2hpbGRVcGRhdGUgPSB3cml0ZXNDYWNoZS5jYWxjRXZlbnRDYWNoZUFmdGVyU2VydmVyT3ZlcndyaXRlKGNoYW5nZVBhdGgsIG9sZEV2ZW50U25hcC5nZXROb2RlKCksIHNlcnZlck5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Q2hpbGRVcGRhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGV2ZW50Q2hpbGRVcGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aGluZyBjaGFuZ2VkLCBqdXN0IGtlZXAgdGhlIG9sZCBjaGlsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2hpbGQgPSBvbGRFdmVudFNuYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDaGlsZCA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUNoaWxkKGNoaWxkS2V5LCB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2hpbGQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpLCBjaGlsZEtleSwgbmV3RXZlbnRDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIGNvbXBsZXRlIGNoaWxkIGF2YWlsYWJsZSBvciBubyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSBvbGRFdmVudFNuYXAuZ2V0Tm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IGNoYW5nZVBhdGguaXNFbXB0eSgpLCB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFWaWV3Q2FjaGV9IG9sZFZpZXdDYWNoZVxuICAgICAqIEBwYXJhbSB7IVBhdGh9IGNoYW5nZVBhdGhcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBjaGFuZ2VkU25hcFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZUNhY2hlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfID0gZnVuY3Rpb24gKG9sZFZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgY2hhbmdlZFNuYXAsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgb2xkU2VydmVyU25hcCA9IG9sZFZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpO1xuICAgICAgICB2YXIgbmV3U2VydmVyQ2FjaGU7XG4gICAgICAgIHZhciBzZXJ2ZXJGaWx0ZXIgPSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICAgICAgICA/IHRoaXMuZmlsdGVyX1xuICAgICAgICAgICAgOiB0aGlzLmZpbHRlcl8uZ2V0SW5kZXhlZEZpbHRlcigpO1xuICAgICAgICBpZiAoY2hhbmdlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBjaGFuZ2VkU25hcCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VydmVyRmlsdGVyLmZpbHRlcnNOb2RlcygpICYmICFvbGRTZXJ2ZXJTbmFwLmlzRmlsdGVyZWQoKSkge1xuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBmaWx0ZXIgdGhlIHNlcnZlciBub2RlLCBidXQgd2UgZGlkbid0IGZpbHRlciB0aGUgc2VydmVyIG5vZGUgeWV0LCBzbyBzaW11bGF0ZSBhIGZ1bGwgdXBkYXRlXG4gICAgICAgICAgICB2YXIgbmV3U2VydmVyTm9kZSA9IG9sZFNlcnZlclNuYXBcbiAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKGNoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcbiAgICAgICAgICAgIG5ld1NlcnZlckNhY2hlID0gc2VydmVyRmlsdGVyLnVwZGF0ZUZ1bGxOb2RlKG9sZFNlcnZlclNuYXAuZ2V0Tm9kZSgpLCBuZXdTZXJ2ZXJOb2RlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IGNoYW5nZVBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgIGlmICghb2xkU2VydmVyU25hcC5pc0NvbXBsZXRlRm9yUGF0aChjaGFuZ2VQYXRoKSAmJlxuICAgICAgICAgICAgICAgIGNoYW5nZVBhdGguZ2V0TGVuZ3RoKCkgPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXBkYXRlIGluY29tcGxldGUgbm9kZXMgd2l0aCB1cGRhdGVzIGludGVuZGVkIGZvciBvdGhlciBsaXN0ZW5lcnNcbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkVmlld0NhY2hlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNoaWxkQ2hhbmdlUGF0aCA9IGNoYW5nZVBhdGgucG9wRnJvbnQoKTtcbiAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICB2YXIgbmV3Q2hpbGROb2RlID0gY2hpbGROb2RlLnVwZGF0ZUNoaWxkKGNoaWxkQ2hhbmdlUGF0aCwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgaWYgKGNoaWxkS2V5ID09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgbmV3U2VydmVyQ2FjaGUgPSBzZXJ2ZXJGaWx0ZXIudXBkYXRlUHJpb3JpdHkob2xkU2VydmVyU25hcC5nZXROb2RlKCksIG5ld0NoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTZXJ2ZXJDYWNoZSA9IHNlcnZlckZpbHRlci51cGRhdGVDaGlsZChvbGRTZXJ2ZXJTbmFwLmdldE5vZGUoKSwgY2hpbGRLZXksIG5ld0NoaWxkTm9kZSwgY2hpbGRDaGFuZ2VQYXRoLCBDb21wbGV0ZUNoaWxkU291cmNlXzEuTk9fQ09NUExFVEVfQ0hJTERfU09VUkNFLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZVNlcnZlclNuYXAobmV3U2VydmVyQ2FjaGUsIG9sZFNlcnZlclNuYXAuaXNGdWxseUluaXRpYWxpemVkKCkgfHwgY2hhbmdlUGF0aC5pc0VtcHR5KCksIHNlcnZlckZpbHRlci5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIHZhciBzb3VyY2UgPSBuZXcgQ29tcGxldGVDaGlsZFNvdXJjZV8xLldyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2Uod3JpdGVzQ2FjaGUsIG5ld1ZpZXdDYWNoZSwgY29tcGxldGVDYWNoZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnRfKG5ld1ZpZXdDYWNoZSwgY2hhbmdlUGF0aCwgd3JpdGVzQ2FjaGUsIHNvdXJjZSwgYWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSBvbGRWaWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGFuZ2VQYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gY2hhbmdlZFNuYXBcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFwcGx5VXNlck92ZXJ3cml0ZV8gPSBmdW5jdGlvbiAob2xkVmlld0NhY2hlLCBjaGFuZ2VQYXRoLCBjaGFuZ2VkU25hcCwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBvbGRFdmVudFNuYXAgPSBvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICB2YXIgbmV3Vmlld0NhY2hlLCBuZXdFdmVudENhY2hlO1xuICAgICAgICB2YXIgc291cmNlID0gbmV3IENvbXBsZXRlQ2hpbGRTb3VyY2VfMS5Xcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlKHdyaXRlc0NhY2hlLCBvbGRWaWV3Q2FjaGUsIGNvbXBsZXRlQ2FjaGUpO1xuICAgICAgICBpZiAoY2hhbmdlUGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUob2xkVmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCksIGNoYW5nZWRTbmFwLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICBuZXdWaWV3Q2FjaGUgPSBvbGRWaWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKG5ld0V2ZW50Q2FjaGUsIHRydWUsIHRoaXMuZmlsdGVyXy5maWx0ZXJzTm9kZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRLZXkgPSBjaGFuZ2VQYXRoLmdldEZyb250KCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRLZXkgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVQcmlvcml0eShvbGRWaWV3Q2FjaGUuZ2V0RXZlbnRDYWNoZSgpLmdldE5vZGUoKSwgY2hhbmdlZFNuYXApO1xuICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IG9sZFZpZXdDYWNoZS51cGRhdGVFdmVudFNuYXAobmV3RXZlbnRDYWNoZSwgb2xkRXZlbnRTbmFwLmlzRnVsbHlJbml0aWFsaXplZCgpLCBvbGRFdmVudFNuYXAuaXNGaWx0ZXJlZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZENoYW5nZVBhdGggPSBjaGFuZ2VQYXRoLnBvcEZyb250KCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENoaWxkID0gb2xkRXZlbnRTbmFwLmdldE5vZGUoKS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZENoYW5nZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoaWxkIG92ZXJ3cml0ZSwgd2UgY2FuIHJlcGxhY2UgdGhlIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkID0gY2hhbmdlZFNuYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gc291cmNlLmdldENvbXBsZXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGROb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZENoYW5nZVBhdGguZ2V0QmFjaygpID09PSAnLnByaW9yaXR5JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZS5nZXRDaGlsZChjaGlsZENoYW5nZVBhdGgucGFyZW50KCkpLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwcmlvcml0eSB1cGRhdGUgb24gYW4gZW1wdHkgbm9kZS4gSWYgdGhpcyBub2RlIGV4aXN0cyBvbiB0aGUgc2VydmVyLCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXJ2ZXIgd2lsbCBzZW5kIGRvd24gdGhlIHByaW9yaXR5IGluIHRoZSB1cGRhdGUsIHNvIGlnbm9yZSBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBjaGlsZE5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IGNoaWxkTm9kZS51cGRhdGVDaGlsZChjaGlsZENoYW5nZVBhdGgsIGNoYW5nZWRTbmFwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGNvbXBsZXRlIGNoaWxkIG5vZGUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZCA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb2xkQ2hpbGQuZXF1YWxzKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRTbmFwID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUNoaWxkKG9sZEV2ZW50U25hcC5nZXROb2RlKCksIGNoaWxkS2V5LCBuZXdDaGlsZCwgY2hpbGRDaGFuZ2VQYXRoLCBzb3VyY2UsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Vmlld0NhY2hlID0gb2xkVmlld0NhY2hlLnVwZGF0ZUV2ZW50U25hcChuZXdFdmVudFNuYXAsIG9sZEV2ZW50U25hcC5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSwgdGhpcy5maWx0ZXJfLmZpbHRlcnNOb2RlcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZpZXdDYWNoZSA9IG9sZFZpZXdDYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IuY2FjaGVIYXNDaGlsZF8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBjaGlsZEtleSkge1xuICAgICAgICByZXR1cm4gdmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshVmlld0NhY2hlfSB2aWV3Q2FjaGVcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHtJbW11dGFibGVUcmVlLjwhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBzZXJ2ZXJDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFwcGx5VXNlck1lcmdlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIGNoYW5nZWRDaGlsZHJlbiwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBIQUNLOiBJbiB0aGUgY2FzZSBvZiBhIGxpbWl0IHF1ZXJ5LCB0aGVyZSBtYXkgYmUgc29tZSBjaGFuZ2VzIHRoYXQgYnVtcCB0aGluZ3Mgb3V0IG9mIHRoZVxuICAgICAgICAvLyB3aW5kb3cgbGVhdmluZyByb29tIGZvciBuZXcgaXRlbXMuICBJdCdzIGltcG9ydGFudCB3ZSBwcm9jZXNzIHRoZXNlIGNoYW5nZXMgZmlyc3QsIHNvIHdlXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhlIGNoYW5nZXMgdHdpY2UsIGZpcnN0IHByb2Nlc3NpbmcgYW55IHRoYXQgYWZmZWN0IGl0ZW1zIGN1cnJlbnRseSBpbiB2aWV3LlxuICAgICAgICAvLyBUT0RPOiBJIGNvbnNpZGVyIGFuIGl0ZW0gXCJpbiB2aWV3XCIgaWYgY2FjaGVIYXNDaGlsZCBpcyB0cnVlLCB3aGljaCBjaGVja3MgYm90aCB0aGUgc2VydmVyXG4gICAgICAgIC8vIGFuZCBldmVudCBzbmFwLiAgSSdtIG5vdCBzdXJlIGlmIHRoaXMgd2lsbCByZXN1bHQgaW4gZWRnZSBjYXNlcyB3aGVuIGEgY2hpbGQgaXMgaW4gb25lIGJ1dFxuICAgICAgICAvLyBub3QgdGhlIG90aGVyLlxuICAgICAgICB2YXIgY3VyVmlld0NhY2hlID0gdmlld0NhY2hlO1xuICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZVBhdGggPSBwYXRoLmNoaWxkKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoVmlld1Byb2Nlc3Nvci5jYWNoZUhhc0NoaWxkXyh2aWV3Q2FjaGUsIHdyaXRlUGF0aC5nZXRGcm9udCgpKSkge1xuICAgICAgICAgICAgICAgIGN1clZpZXdDYWNoZSA9IF90aGlzLmFwcGx5VXNlck92ZXJ3cml0ZV8oY3VyVmlld0NhY2hlLCB3cml0ZVBhdGgsIGNoaWxkTm9kZSwgd3JpdGVzQ2FjaGUsIHNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFuZ2VkQ2hpbGRyZW4uZm9yZWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciB3cml0ZVBhdGggPSBwYXRoLmNoaWxkKHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIVZpZXdQcm9jZXNzb3IuY2FjaGVIYXNDaGlsZF8odmlld0NhY2hlLCB3cml0ZVBhdGguZ2V0RnJvbnQoKSkpIHtcbiAgICAgICAgICAgICAgICBjdXJWaWV3Q2FjaGUgPSBfdGhpcy5hcHBseVVzZXJPdmVyd3JpdGVfKGN1clZpZXdDYWNoZSwgd3JpdGVQYXRoLCBjaGlsZE5vZGUsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge0ltbXV0YWJsZVRyZWUuPCFOb2RlPn0gbWVyZ2VcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFwcGx5TWVyZ2VfID0gZnVuY3Rpb24gKG5vZGUsIG1lcmdlKSB7XG4gICAgICAgIG1lcmdlLmZvcmVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGgsIGNoaWxkTm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gY2hhbmdlZENoaWxkcmVuXG4gICAgICogQHBhcmFtIHshV3JpdGVUcmVlUmVmfSB3cml0ZXNDYWNoZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTZXJ2ZXJOb2RlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUuYXBwbHlTZXJ2ZXJNZXJnZV8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4sIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNhY2hlIHlldCwgdGhpcyBtZXJnZSB3YXMgaW50ZW5kZWQgZm9yIGEgcHJldmlvdXNseSBsaXN0ZW4gaW4gdGhlIHNhbWUgbG9jYXRpb24uIElnbm9yZSBpdCBhbmRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNvbXBsZXRlIGRhdGEgdXBkYXRlIGNvbWluZyBzb29uLlxuICAgICAgICBpZiAodmlld0NhY2hlXG4gICAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgLmlzRW1wdHkoKSAmJlxuICAgICAgICAgICAgIXZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhBQ0s6IEluIHRoZSBjYXNlIG9mIGEgbGltaXQgcXVlcnksIHRoZXJlIG1heSBiZSBzb21lIGNoYW5nZXMgdGhhdCBidW1wIHRoaW5ncyBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHdpbmRvdyBsZWF2aW5nIHJvb20gZm9yIG5ldyBpdGVtcy4gIEl0J3MgaW1wb3J0YW50IHdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBmaXJzdCwgc28gd2VcbiAgICAgICAgLy8gaXRlcmF0ZSB0aGUgY2hhbmdlcyB0d2ljZSwgZmlyc3QgcHJvY2Vzc2luZyBhbnkgdGhhdCBhZmZlY3QgaXRlbXMgY3VycmVudGx5IGluIHZpZXcuXG4gICAgICAgIC8vIFRPRE86IEkgY29uc2lkZXIgYW4gaXRlbSBcImluIHZpZXdcIiBpZiBjYWNoZUhhc0NoaWxkIGlzIHRydWUsIHdoaWNoIGNoZWNrcyBib3RoIHRoZSBzZXJ2ZXJcbiAgICAgICAgLy8gYW5kIGV2ZW50IHNuYXAuICBJJ20gbm90IHN1cmUgaWYgdGhpcyB3aWxsIHJlc3VsdCBpbiBlZGdlIGNhc2VzIHdoZW4gYSBjaGlsZCBpcyBpbiBvbmUgYnV0XG4gICAgICAgIC8vIG5vdCB0aGUgb3RoZXIuXG4gICAgICAgIHZhciBjdXJWaWV3Q2FjaGUgPSB2aWV3Q2FjaGU7XG4gICAgICAgIHZhciB2aWV3TWVyZ2VUcmVlO1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHZpZXdNZXJnZVRyZWUgPSBjaGFuZ2VkQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3TWVyZ2VUcmVlID0gSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUuRW1wdHkuc2V0VHJlZShwYXRoLCBjaGFuZ2VkQ2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXJ2ZXJOb2RlID0gdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuZ2V0Tm9kZSgpO1xuICAgICAgICB2aWV3TWVyZ2VUcmVlLmNoaWxkcmVuLmlub3JkZXJUcmF2ZXJzYWwoZnVuY3Rpb24gKGNoaWxkS2V5LCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJOb2RlLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJDaGlsZCA9IHZpZXdDYWNoZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U2VydmVyQ2FjaGUoKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0Tm9kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0gX3RoaXMuYXBwbHlNZXJnZV8oc2VydmVyQ2hpbGQsIGNoaWxkVHJlZSk7XG4gICAgICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gX3RoaXMuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfKGN1clZpZXdDYWNoZSwgbmV3IFBhdGhfMS5QYXRoKGNoaWxkS2V5KSwgbmV3Q2hpbGQsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmlld01lcmdlVHJlZS5jaGlsZHJlbi5pbm9yZGVyVHJhdmVyc2FsKGZ1bmN0aW9uIChjaGlsZEtleSwgY2hpbGRNZXJnZVRyZWUpIHtcbiAgICAgICAgICAgIHZhciBpc1Vua25vd25EZWVwTWVyZ2UgPSAhdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkuaXNDb21wbGV0ZUZvckNoaWxkKGNoaWxkS2V5KSAmJlxuICAgICAgICAgICAgICAgIGNoaWxkTWVyZ2VUcmVlLnZhbHVlID09IG51bGw7XG4gICAgICAgICAgICBpZiAoIXNlcnZlck5vZGUuaGFzQ2hpbGQoY2hpbGRLZXkpICYmICFpc1Vua25vd25EZWVwTWVyZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VydmVyQ2hpbGQgPSB2aWV3Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLmdldFNlcnZlckNhY2hlKClcbiAgICAgICAgICAgICAgICAgICAgLmdldE5vZGUoKVxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IF90aGlzLmFwcGx5TWVyZ2VfKHNlcnZlckNoaWxkLCBjaGlsZE1lcmdlVHJlZSk7XG4gICAgICAgICAgICAgICAgY3VyVmlld0NhY2hlID0gX3RoaXMuYXBwbHlTZXJ2ZXJPdmVyd3JpdGVfKGN1clZpZXdDYWNoZSwgbmV3IFBhdGhfMS5QYXRoKGNoaWxkS2V5KSwgbmV3Q2hpbGQsIHdyaXRlc0NhY2hlLCBzZXJ2ZXJDYWNoZSwgZmlsdGVyU2VydmVyTm9kZSwgYWNjdW11bGF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1clZpZXdDYWNoZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gYWNrUGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWU8IWJvb2xlYW4+fSBhZmZlY3RlZFRyZWVcbiAgICAgKiBAcGFyYW0geyFXcml0ZVRyZWVSZWZ9IHdyaXRlc0NhY2hlXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gY29tcGxldGVDYWNoZVxuICAgICAqIEBwYXJhbSB7IUNoaWxkQ2hhbmdlQWNjdW11bGF0b3J9IGFjY3VtdWxhdG9yXG4gICAgICogQHJldHVybiB7IVZpZXdDYWNoZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFZpZXdQcm9jZXNzb3IucHJvdG90eXBlLmFja1VzZXJXcml0ZV8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBhY2tQYXRoLCBhZmZlY3RlZFRyZWUsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAod3JpdGVzQ2FjaGUuc2hhZG93aW5nV3JpdGUoYWNrUGF0aCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGZpbHRlciBzZXJ2ZXIgbm9kZSBpZiBpdCBpcyBjdXJyZW50bHkgZmlsdGVyZWRcbiAgICAgICAgdmFyIGZpbHRlclNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0ZpbHRlcmVkKCk7XG4gICAgICAgIC8vIEVzc2VudGlhbGx5IHdlJ2xsIGp1c3QgZ2V0IG91ciBleGlzdGluZyBzZXJ2ZXIgY2FjaGUgZm9yIHRoZSBhZmZlY3RlZCBwYXRocyBhbmQgcmUtYXBwbHkgaXQgYXMgYSBzZXJ2ZXIgdXBkYXRlXG4gICAgICAgIC8vIG5vdyB0aGF0IGl0IHdvbid0IGJlIHNoYWRvd2VkLlxuICAgICAgICB2YXIgc2VydmVyQ2FjaGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICAgICAgaWYgKGFmZmVjdGVkVHJlZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG92ZXJ3cml0ZS5cbiAgICAgICAgICAgIGlmICgoYWNrUGF0aC5pc0VtcHR5KCkgJiYgc2VydmVyQ2FjaGUuaXNGdWxseUluaXRpYWxpemVkKCkpIHx8XG4gICAgICAgICAgICAgICAgc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoYWNrUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVNlcnZlck92ZXJ3cml0ZV8odmlld0NhY2hlLCBhY2tQYXRoLCBzZXJ2ZXJDYWNoZS5nZXROb2RlKCkuZ2V0Q2hpbGQoYWNrUGF0aCksIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2tQYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBnb29meSBlZGdlIGNhc2Ugd2hlcmUgd2UgYXJlIGFja2luZyBkYXRhIGF0IHRoaXMgbG9jYXRpb24gYnV0IGRvbid0IGhhdmUgZnVsbCBkYXRhLiAgV2VcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQganVzdCByZS1hcHBseSB3aGF0ZXZlciB3ZSBoYXZlIGluIG91ciBjYWNoZSBhcyBhIG1lcmdlLlxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hpbGRyZW5fMSA9IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlLkVtcHR5O1xuICAgICAgICAgICAgICAgIHNlcnZlckNhY2hlLmdldE5vZGUoKS5mb3JFYWNoQ2hpbGQoS2V5SW5kZXhfMS5LRVlfSU5ERVgsIGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDaGlsZHJlbl8xID0gY2hhbmdlZENoaWxkcmVuXzEuc2V0KG5ldyBQYXRoXzEuUGF0aChuYW1lKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHlTZXJ2ZXJNZXJnZV8odmlld0NhY2hlLCBhY2tQYXRoLCBjaGFuZ2VkQ2hpbGRyZW5fMSwgd3JpdGVzQ2FjaGUsIGNvbXBsZXRlQ2FjaGUsIGZpbHRlclNlcnZlck5vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWVyZ2UuXG4gICAgICAgICAgICB2YXIgY2hhbmdlZENoaWxkcmVuXzIgPSBJbW11dGFibGVUcmVlXzEuSW1tdXRhYmxlVHJlZS5FbXB0eTtcbiAgICAgICAgICAgIGFmZmVjdGVkVHJlZS5mb3JlYWNoKGZ1bmN0aW9uIChtZXJnZVBhdGgsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcnZlckNhY2hlUGF0aCA9IGFja1BhdGguY2hpbGQobWVyZ2VQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyQ2FjaGUuaXNDb21wbGV0ZUZvclBhdGgoc2VydmVyQ2FjaGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQ2hpbGRyZW5fMiA9IGNoYW5nZWRDaGlsZHJlbl8yLnNldChtZXJnZVBhdGgsIHNlcnZlckNhY2hlLmdldE5vZGUoKS5nZXRDaGlsZChzZXJ2ZXJDYWNoZVBhdGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwcGx5U2VydmVyTWVyZ2VfKHZpZXdDYWNoZSwgYWNrUGF0aCwgY2hhbmdlZENoaWxkcmVuXzIsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZUNhY2hlLCBmaWx0ZXJTZXJ2ZXJOb2RlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0geyFDaGlsZENoYW5nZUFjY3VtdWxhdG9yfSBhY2N1bXVsYXRvclxuICAgICAqIEByZXR1cm4geyFWaWV3Q2FjaGV9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBWaWV3UHJvY2Vzc29yLnByb3RvdHlwZS5saXN0ZW5Db21wbGV0ZV8gPSBmdW5jdGlvbiAodmlld0NhY2hlLCBwYXRoLCB3cml0ZXNDYWNoZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIG9sZFNlcnZlck5vZGUgPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICAgICAgdmFyIG5ld1ZpZXdDYWNoZSA9IHZpZXdDYWNoZS51cGRhdGVTZXJ2ZXJTbmFwKG9sZFNlcnZlck5vZGUuZ2V0Tm9kZSgpLCBvbGRTZXJ2ZXJOb2RlLmlzRnVsbHlJbml0aWFsaXplZCgpIHx8IHBhdGguaXNFbXB0eSgpLCBvbGRTZXJ2ZXJOb2RlLmlzRmlsdGVyZWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlRXZlbnRDYWNoZUFmdGVyU2VydmVyRXZlbnRfKG5ld1ZpZXdDYWNoZSwgcGF0aCwgd3JpdGVzQ2FjaGUsIENvbXBsZXRlQ2hpbGRTb3VyY2VfMS5OT19DT01QTEVURV9DSElMRF9TT1VSQ0UsIGFjY3VtdWxhdG9yKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzQ2FjaGVcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHshQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gYWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshVmlld0NhY2hlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVmlld1Byb2Nlc3Nvci5wcm90b3R5cGUucmV2ZXJ0VXNlcldyaXRlXyA9IGZ1bmN0aW9uICh2aWV3Q2FjaGUsIHBhdGgsIHdyaXRlc0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlLCBhY2N1bXVsYXRvcikge1xuICAgICAgICB2YXIgY29tcGxldGU7XG4gICAgICAgIGlmICh3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShwYXRoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG5ldyBDb21wbGV0ZUNoaWxkU291cmNlXzEuV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNDYWNoZSwgdmlld0NhY2hlLCBjb21wbGV0ZVNlcnZlckNhY2hlKTtcbiAgICAgICAgICAgIHZhciBvbGRFdmVudENhY2hlID0gdmlld0NhY2hlLmdldEV2ZW50Q2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgICB2YXIgbmV3RXZlbnRDYWNoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSB8fCBwYXRoLmdldEZyb250KCkgPT09ICcucHJpb3JpdHknKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld05vZGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENhY2hlKHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyQ2hpbGRyZW4gPSB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hc3NlcnQoc2VydmVyQ2hpbGRyZW4gaW5zdGFuY2VvZiBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUsICdzZXJ2ZXJDaGlsZHJlbiB3b3VsZCBiZSBjb21wbGV0ZSBpZiBsZWFmIG5vZGUnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZSA9IHdyaXRlc0NhY2hlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4oc2VydmVyQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdOb2RlID0gbmV3Tm9kZTtcbiAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gdGhpcy5maWx0ZXJfLnVwZGF0ZUZ1bGxOb2RlKG9sZEV2ZW50Q2FjaGUsIG5ld05vZGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZEtleSA9IHBhdGguZ2V0RnJvbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2hpbGQgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVDaGlsZChjaGlsZEtleSwgdmlld0NhY2hlLmdldFNlcnZlckNhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdDaGlsZCA9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQgPSBvbGRFdmVudENhY2hlLmdldEltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgbmV3Q2hpbGQsIHBhdGgucG9wRnJvbnQoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZpZXdDYWNoZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0RXZlbnRDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAgIC5nZXROb2RlKClcbiAgICAgICAgICAgICAgICAgICAgLmhhc0NoaWxkKGNoaWxkS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBjb21wbGV0ZSBjaGlsZCBhdmFpbGFibGUsIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lLCBpZiBhbnlcbiAgICAgICAgICAgICAgICAgICAgbmV3RXZlbnRDYWNoZSA9IHRoaXMuZmlsdGVyXy51cGRhdGVDaGlsZChvbGRFdmVudENhY2hlLCBjaGlsZEtleSwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUsIHBhdGgucG9wRnJvbnQoKSwgc291cmNlLCBhY2N1bXVsYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudENhY2hlID0gb2xkRXZlbnRDYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld0V2ZW50Q2FjaGUuaXNFbXB0eSgpICYmXG4gICAgICAgICAgICAgICAgICAgIHZpZXdDYWNoZS5nZXRTZXJ2ZXJDYWNoZSgpLmlzRnVsbHlJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGhhdmUgcmV2ZXJ0ZWQgYWxsIGNoaWxkIHdyaXRlcy4gTWF5YmUgdGhlIG9sZCBldmVudCB3YXMgYSBsZWFmIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGUgPSB3cml0ZXNDYWNoZS5jYWxjQ29tcGxldGVFdmVudENhY2hlKHZpZXdDYWNoZS5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wbGV0ZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50Q2FjaGUgPSB0aGlzLmZpbHRlcl8udXBkYXRlRnVsbE5vZGUobmV3RXZlbnRDYWNoZSwgY29tcGxldGUsIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBsZXRlID1cbiAgICAgICAgICAgICAgICB2aWV3Q2FjaGUuZ2V0U2VydmVyQ2FjaGUoKS5pc0Z1bGx5SW5pdGlhbGl6ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICB3cml0ZXNDYWNoZS5zaGFkb3dpbmdXcml0ZShQYXRoXzEuUGF0aC5FbXB0eSkgIT0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB2aWV3Q2FjaGUudXBkYXRlRXZlbnRTbmFwKG5ld0V2ZW50Q2FjaGUsIGNvbXBsZXRlLCB0aGlzLmZpbHRlcl8uZmlsdGVyc05vZGVzKCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVmlld1Byb2Nlc3Nvcjtcbn0oKSk7XG5leHBvcnRzLlZpZXdQcm9jZXNzb3IgPSBWaWV3UHJvY2Vzc29yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaWV3UHJvY2Vzc29yLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvVmlld1Byb2Nlc3Nvci5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBDaGFuZ2VfMSA9IHJlcXVpcmUoXCIuL0NoYW5nZVwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGlsZENoYW5nZUFjY3VtdWxhdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5nZU1hcF8gPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQ2hhbmdlfSBjaGFuZ2VcbiAgICAgKi9cbiAgICBDaGlsZENoYW5nZUFjY3VtdWxhdG9yLnByb3RvdHlwZS50cmFja0NoaWxkQ2hhbmdlID0gZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGNoYW5nZS50eXBlO1xuICAgICAgICB2YXIgY2hpbGRLZXkgLyoqIEB0eXBlIHshc3RyaW5nfSAqLyA9IGNoYW5nZS5jaGlsZE5hbWU7XG4gICAgICAgIHV0aWxfMi5hc3NlcnQodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQURERUQgfHxcbiAgICAgICAgICAgIHR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQgfHxcbiAgICAgICAgICAgIHR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX1JFTU9WRUQsICdPbmx5IGNoaWxkIGNoYW5nZXMgc3VwcG9ydGVkIGZvciB0cmFja2luZycpO1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KGNoaWxkS2V5ICE9PSAnLnByaW9yaXR5JywgJ09ubHkgbm9uLXByaW9yaXR5IGNoaWxkIGNoYW5nZXMgY2FuIGJlIHRyYWNrZWQuJyk7XG4gICAgICAgIHZhciBvbGRDaGFuZ2UgPSB1dGlsXzEuc2FmZUdldCh0aGlzLmNoYW5nZU1hcF8sIGNoaWxkS2V5KTtcbiAgICAgICAgaWYgKG9sZENoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG9sZFR5cGUgPSBvbGRDaGFuZ2UudHlwZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9BRERFRCAmJiBvbGRUeXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9SRU1PVkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IENoYW5nZV8xLkNoYW5nZS5jaGlsZENoYW5nZWRDaGFuZ2UoY2hpbGRLZXksIGNoYW5nZS5zbmFwc2hvdE5vZGUsIG9sZENoYW5nZS5zbmFwc2hvdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfUkVNT1ZFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0FEREVEKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9SRU1PVkVEICYmXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQ0hBTkdFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlTWFwX1tjaGlsZEtleV0gPSBDaGFuZ2VfMS5DaGFuZ2UuY2hpbGRSZW1vdmVkQ2hhbmdlKGNoaWxkS2V5LCBvbGRDaGFuZ2Uub2xkU25hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09IENoYW5nZV8xLkNoYW5nZS5DSElMRF9DSEFOR0VEICYmXG4gICAgICAgICAgICAgICAgb2xkVHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQURERUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UoY2hpbGRLZXksIGNoYW5nZS5zbmFwc2hvdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICAgICAgICAgIG9sZFR5cGUgPT0gQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZU1hcF9bY2hpbGRLZXldID0gQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShjaGlsZEtleSwgY2hhbmdlLnNuYXBzaG90Tm9kZSwgb2xkQ2hhbmdlLm9sZFNuYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdXRpbF8yLmFzc2VydGlvbkVycm9yKCdJbGxlZ2FsIGNvbWJpbmF0aW9uIG9mIGNoYW5nZXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgK1xuICAgICAgICAgICAgICAgICAgICAnIG9jY3VycmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICBvbGRDaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VNYXBfW2NoaWxkS2V5XSA9IGNoYW5nZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7IUFycmF5LjwhQ2hhbmdlPn1cbiAgICAgKi9cbiAgICBDaGlsZENoYW5nZUFjY3VtdWxhdG9yLnByb3RvdHlwZS5nZXRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmdldFZhbHVlcyh0aGlzLmNoYW5nZU1hcF8pO1xuICAgIH07XG4gICAgcmV0dXJuIENoaWxkQ2hhbmdlQWNjdW11bGF0b3I7XG59KCkpO1xuZXhwb3J0cy5DaGlsZENoYW5nZUFjY3VtdWxhdG9yID0gQ2hpbGRDaGFuZ2VBY2N1bXVsYXRvcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hpbGRDaGFuZ2VBY2N1bXVsYXRvci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NoaWxkQ2hhbmdlQWNjdW11bGF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDYWNoZU5vZGVfMSA9IHJlcXVpcmUoXCIuL0NhY2hlTm9kZVwiKTtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgQ29tcGxldGVDaGlsZFNvdXJjZSB0aGF0IG5ldmVyIHJldHVybnMgYW55IGFkZGl0aW9uYWwgY2hpbGRyZW5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyBDb21wbGV0ZUNoaWxkU291cmNlXG4gKi9cbnZhciBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vQ29tcGxldGVDaGlsZFNvdXJjZV8oKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTm9Db21wbGV0ZUNoaWxkU291cmNlXy5wcm90b3R5cGUuZ2V0Q29tcGxldGVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZEtleSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTm9Db21wbGV0ZUNoaWxkU291cmNlXy5wcm90b3R5cGUuZ2V0Q2hpbGRBZnRlckNoaWxkID0gZnVuY3Rpb24gKGluZGV4LCBjaGlsZCwgcmV2ZXJzZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfO1xufSgpKTtcbmV4cG9ydHMuTm9Db21wbGV0ZUNoaWxkU291cmNlXyA9IE5vQ29tcGxldGVDaGlsZFNvdXJjZV87XG4vKipcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZS5cbiAqIEBjb25zdFxuICogQHR5cGUgeyFDb21wbGV0ZUNoaWxkU291cmNlfVxuICovXG5leHBvcnRzLk5PX0NPTVBMRVRFX0NISUxEX1NPVVJDRSA9IG5ldyBOb0NvbXBsZXRlQ2hpbGRTb3VyY2VfKCk7XG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIENvbXBsZXRlQ2hpbGRTb3VyY2UgdGhhdCB1c2VzIGEgV3JpdGVUcmVlIGluIGFkZGl0aW9uIHRvIGFueSBvdGhlciBzZXJ2ZXIgZGF0YSBvclxuICogb2xkIGV2ZW50IGNhY2hlcyBhdmFpbGFibGUgdG8gY2FsY3VsYXRlIGNvbXBsZXRlIGNoaWxkcmVuLlxuICpcbiAqXG4gKiBAaW1wbGVtZW50cyBDb21wbGV0ZUNoaWxkU291cmNlXG4gKi9cbnZhciBXcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZVJlZn0gd3JpdGVzX1xuICAgICAqIEBwYXJhbSB7IVZpZXdDYWNoZX0gdmlld0NhY2hlX1xuICAgICAqIEBwYXJhbSB7P05vZGV9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZSh3cml0ZXNfLCB2aWV3Q2FjaGVfLCBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXykge1xuICAgICAgICBpZiAob3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gPT09IHZvaWQgMCkgeyBvcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG51bGw7IH1cbiAgICAgICAgdGhpcy53cml0ZXNfID0gd3JpdGVzXztcbiAgICAgICAgdGhpcy52aWV3Q2FjaGVfID0gdmlld0NhY2hlXztcbiAgICAgICAgdGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXyA9IG9wdENvbXBsZXRlU2VydmVyQ2FjaGVfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UucHJvdG90eXBlLmdldENvbXBsZXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRLZXkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnZpZXdDYWNoZV8uZ2V0RXZlbnRDYWNoZSgpO1xuICAgICAgICBpZiAobm9kZS5pc0NvbXBsZXRlRm9yQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNlcnZlck5vZGUgPSB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfICE9IG51bGxcbiAgICAgICAgICAgICAgICA/IG5ldyBDYWNoZU5vZGVfMS5DYWNoZU5vZGUodGhpcy5vcHRDb21wbGV0ZVNlcnZlckNhY2hlXywgdHJ1ZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgOiB0aGlzLnZpZXdDYWNoZV8uZ2V0U2VydmVyQ2FjaGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlc18uY2FsY0NvbXBsZXRlQ2hpbGQoY2hpbGRLZXksIHNlcnZlck5vZGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2UucHJvdG90eXBlLmdldENoaWxkQWZ0ZXJDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCwgY2hpbGQsIHJldmVyc2UpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlU2VydmVyRGF0YSA9IHRoaXMub3B0Q29tcGxldGVTZXJ2ZXJDYWNoZV8gIT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLm9wdENvbXBsZXRlU2VydmVyQ2FjaGVfXG4gICAgICAgICAgICA6IHRoaXMudmlld0NhY2hlXy5nZXRDb21wbGV0ZVNlcnZlclNuYXAoKTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy53cml0ZXNfLmNhbGNJbmRleGVkU2xpY2UoY29tcGxldGVTZXJ2ZXJEYXRhLCBjaGlsZCwgMSwgcmV2ZXJzZSwgaW5kZXgpO1xuICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFdyaXRlVHJlZUNvbXBsZXRlQ2hpbGRTb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5Xcml0ZVRyZWVDb21wbGV0ZUNoaWxkU291cmNlID0gV3JpdGVUcmVlQ29tcGxldGVDaGlsZFNvdXJjZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcGxldGVDaGlsZFNvdXJjZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS92aWV3L0NvbXBsZXRlQ2hpbGRTb3VyY2UuanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi4vc25hcC9Ob2RlXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4vQ2hhbmdlXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbi8qKlxuICogQW4gRXZlbnRHZW5lcmF0b3IgaXMgdXNlZCB0byBjb252ZXJ0IFwicmF3XCIgY2hhbmdlcyAoQ2hhbmdlKSBhcyBjb21wdXRlZCBieSB0aGVcbiAqIENhY2hlRGlmZmVyIGludG8gYWN0dWFsIGV2ZW50cyAoRXZlbnQpIHRoYXQgY2FuIGJlIHJhaXNlZC4gIFNlZSBnZW5lcmF0ZUV2ZW50c0ZvckNoYW5nZXMoKVxuICogZm9yIGRldGFpbHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFdmVudEdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeV9cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBFdmVudEdlbmVyYXRvcihxdWVyeV8pIHtcbiAgICAgICAgdGhpcy5xdWVyeV8gPSBxdWVyeV87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7IUluZGV4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleF8gPSB0aGlzLnF1ZXJ5Xy5nZXRRdWVyeVBhcmFtcygpLmdldEluZGV4KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgc2V0IG9mIHJhdyBjaGFuZ2VzIChubyBtb3ZlZCBldmVudHMgYW5kIHByZXZOYW1lIG5vdCBzcGVjaWZpZWQgeWV0KSwgYW5kIGEgc2V0IG9mXG4gICAgICogRXZlbnRSZWdpc3RyYXRpb25zIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHRoZXNlIGNoYW5nZXMsIGdlbmVyYXRlIHRoZSBhY3R1YWwgZXZlbnRzIHRvIGJlIHJhaXNlZC5cbiAgICAgKlxuICAgICAqIE5vdGVzOlxuICAgICAqICAtIGNoaWxkX21vdmVkIGV2ZW50cyB3aWxsIGJlIHN5bnRoZXNpemVkIGF0IHRoaXMgdGltZSBmb3IgYW55IGNoaWxkX2NoYW5nZWQgZXZlbnRzIHRoYXQgYWZmZWN0XG4gICAgICogICAgb3VyIGluZGV4LlxuICAgICAqICAtIHByZXZOYW1lIHdpbGwgYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgaW5kZXggb3JkZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IUNoYW5nZT59IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBldmVudENhY2hlXG4gICAgICogQHBhcmFtIHshQXJyYXkuPCFFdmVudFJlZ2lzdHJhdGlvbj59IGV2ZW50UmVnaXN0cmF0aW9uc1xuICAgICAqIEByZXR1cm4geyFBcnJheS48IUV2ZW50Pn1cbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUuZ2VuZXJhdGVFdmVudHNGb3JDaGFuZ2VzID0gZnVuY3Rpb24gKGNoYW5nZXMsIGV2ZW50Q2FjaGUsIGV2ZW50UmVnaXN0cmF0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHZhciBtb3ZlcyA9IFtdO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSBDaGFuZ2VfMS5DaGFuZ2UuQ0hJTERfQ0hBTkdFRCAmJlxuICAgICAgICAgICAgICAgIF90aGlzLmluZGV4Xy5pbmRleGVkVmFsdWVDaGFuZ2VkKGNoYW5nZS5vbGRTbmFwLCBjaGFuZ2Uuc25hcHNob3ROb2RlKSkge1xuICAgICAgICAgICAgICAgIG1vdmVzLnB1c2goQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkTW92ZWRDaGFuZ2UoY2hhbmdlLmNoaWxkTmFtZSwgY2hhbmdlLnNuYXBzaG90Tm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX1JFTU9WRUQsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZV8xLkNoYW5nZS5DSElMRF9BRERFRCwgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX01PVkVELCBtb3ZlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUV2ZW50c0ZvclR5cGVfKGV2ZW50cywgQ2hhbmdlXzEuQ2hhbmdlLkNISUxEX0NIQU5HRUQsIGNoYW5nZXMsIGV2ZW50UmVnaXN0cmF0aW9ucywgZXZlbnRDYWNoZSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVFdmVudHNGb3JUeXBlXyhldmVudHMsIENoYW5nZV8xLkNoYW5nZS5WQUxVRSwgY2hhbmdlcywgZXZlbnRSZWdpc3RyYXRpb25zLCBldmVudENhY2hlKTtcbiAgICAgICAgcmV0dXJuIGV2ZW50cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGNoYW5nZXMgb2YgYSBzaW5nbGUgY2hhbmdlIHR5cGUsIGdlbmVyYXRlIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnQ+fSBldmVudHNcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhQ2hhbmdlPn0gY2hhbmdlc1xuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnRSZWdpc3RyYXRpb24+fSByZWdpc3RyYXRpb25zXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRDYWNoZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRXZlbnRHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlRXZlbnRzRm9yVHlwZV8gPSBmdW5jdGlvbiAoZXZlbnRzLCBldmVudFR5cGUsIGNoYW5nZXMsIHJlZ2lzdHJhdGlvbnMsIGV2ZW50Q2FjaGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlcmVkQ2hhbmdlcyA9IGNoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGFuZ2UpIHsgcmV0dXJuIGNoYW5nZS50eXBlID09PSBldmVudFR5cGU7IH0pO1xuICAgICAgICBmaWx0ZXJlZENoYW5nZXMuc29ydCh0aGlzLmNvbXBhcmVDaGFuZ2VzXy5iaW5kKHRoaXMpKTtcbiAgICAgICAgZmlsdGVyZWRDaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIG1hdGVyaWFsaXplZENoYW5nZSA9IF90aGlzLm1hdGVyaWFsaXplU2luZ2xlQ2hhbmdlXyhjaGFuZ2UsIGV2ZW50Q2FjaGUpO1xuICAgICAgICAgICAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cmF0aW9uLnJlc3BvbmRzVG8oY2hhbmdlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKHJlZ2lzdHJhdGlvbi5jcmVhdGVFdmVudChtYXRlcmlhbGl6ZWRDaGFuZ2UsIF90aGlzLnF1ZXJ5XykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUNoYW5nZX0gY2hhbmdlXG4gICAgICogQHBhcmFtIHshTm9kZX0gZXZlbnRDYWNoZVxuICAgICAqIEByZXR1cm4geyFDaGFuZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUubWF0ZXJpYWxpemVTaW5nbGVDaGFuZ2VfID0gZnVuY3Rpb24gKGNoYW5nZSwgZXZlbnRDYWNoZSkge1xuICAgICAgICBpZiAoY2hhbmdlLnR5cGUgPT09ICd2YWx1ZScgfHwgY2hhbmdlLnR5cGUgPT09ICdjaGlsZF9yZW1vdmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZS5wcmV2TmFtZSA9IGV2ZW50Q2FjaGUuZ2V0UHJlZGVjZXNzb3JDaGlsZE5hbWUoXG4gICAgICAgICAgICAvKiogQHR5cGUgeyFzdHJpbmd9ICovXG4gICAgICAgICAgICBjaGFuZ2UuY2hpbGROYW1lLCBjaGFuZ2Uuc25hcHNob3ROb2RlLCB0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFDaGFuZ2V9IGFcbiAgICAgKiBAcGFyYW0geyFDaGFuZ2V9IGJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudEdlbmVyYXRvci5wcm90b3R5cGUuY29tcGFyZUNoYW5nZXNfID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuY2hpbGROYW1lID09IG51bGwgfHwgYi5jaGlsZE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgdXRpbF8xLmFzc2VydGlvbkVycm9yKCdTaG91bGQgb25seSBjb21wYXJlIGNoaWxkXyBldmVudHMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFXcmFwcGVkID0gbmV3IE5vZGVfMS5OYW1lZE5vZGUoYS5jaGlsZE5hbWUsIGEuc25hcHNob3ROb2RlKTtcbiAgICAgICAgdmFyIGJXcmFwcGVkID0gbmV3IE5vZGVfMS5OYW1lZE5vZGUoYi5jaGlsZE5hbWUsIGIuc25hcHNob3ROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhfLmNvbXBhcmUoYVdyYXBwZWQsIGJXcmFwcGVkKTtcbiAgICB9O1xuICAgIHJldHVybiBFdmVudEdlbmVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLkV2ZW50R2VuZXJhdG9yID0gRXZlbnRHZW5lcmF0b3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50R2VuZXJhdG9yLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnRHZW5lcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL3V0aWwvUGF0aFwiKTtcbnZhciBDb21wb3VuZFdyaXRlXzEgPSByZXF1aXJlKFwiLi9Db21wb3VuZFdyaXRlXCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuL3NuYXAvaW5kZXhlcy9Qcmlvcml0eUluZGV4XCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4vc25hcC9DaGlsZHJlbk5vZGVcIik7XG4vKipcbiAqIFdyaXRlVHJlZSB0cmFja3MgYWxsIHBlbmRpbmcgdXNlci1pbml0aWF0ZWQgd3JpdGVzIGFuZCBoYXMgbWV0aG9kcyB0byBjYWxjdWxhdGUgdGhlIHJlc3VsdCBvZiBtZXJnaW5nIHRoZW1cbiAqIHdpdGggdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSAodG8gY3JlYXRlIFwiZXZlbnQgY2FjaGVcIiBkYXRhKS4gIFBlbmRpbmcgd3JpdGVzIGFyZSBhZGRlZCB3aXRoIGFkZE92ZXJ3cml0ZSgpXG4gKiBhbmQgYWRkTWVyZ2UoKSwgYW5kIHJlbW92ZWQgd2l0aCByZW1vdmVXcml0ZSgpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV3JpdGVUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdyaXRlVHJlZSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdHJlZSB0cmFja2luZyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGFsbCB2aXNpYmxlIHdyaXRlcy4gIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0cmFuc2FjdGlvbnMgd2l0aFxuICAgICAgICAgKiBhcHBseUxvY2FsbHk9ZmFsc2Ugb3Igd3JpdGVzIHRoYXQgYXJlIGNvbXBsZXRlbHkgc2hhZG93ZWQgYnkgb3RoZXIgd3JpdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7IUNvbXBvdW5kV3JpdGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGVXcml0ZXNfID0gQ29tcG91bmRXcml0ZV8xLkNvbXBvdW5kV3JpdGUuRW1wdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgYWxsIHBlbmRpbmcgd3JpdGVzLCByZWdhcmRsZXNzIG9mIHZpc2liaWxpdHkgYW5kIHNoYWRvd2VkLW5lc3MuICBVc2VkIHRvIGNhbGN1bGF0ZSBhcmJpdHJhcnlcbiAgICAgICAgICogc2V0cyBvZiB0aGUgY2hhbmdlZCBkYXRhLCBzdWNoIGFzIGhpZGRlbiB3cml0ZXMgKGZyb20gdHJhbnNhY3Rpb25zKSBvciBjaGFuZ2VzIHdpdGggY2VydGFpbiB3cml0ZXMgZXhjbHVkZWQgKGFsc29cbiAgICAgICAgICogdXNlZCBieSB0cmFuc2FjdGlvbnMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjwhV3JpdGVSZWNvcmQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbGxXcml0ZXNfID0gW107XG4gICAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBXcml0ZVRyZWVSZWYgZm9yIHRoZSBnaXZlbiBwYXRoLiBGb3IgdXNlIHdpdGggYSBuZXcgc3luYyBwb2ludCBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshV3JpdGVUcmVlUmVmfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2hpbGRXcml0ZXMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRlVHJlZVJlZihwYXRoLCB0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlY29yZCBhIG5ldyBvdmVyd3JpdGUgZnJvbSB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gc25hcFxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHZpc2libGUgVGhpcyBpcyBzZXQgdG8gZmFsc2UgYnkgc29tZSB0cmFuc2FjdGlvbnMuIEl0IHNob3VsZCBiZSBleGNsdWRlZCBmcm9tIGV2ZW50IGNhY2hlc1xuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuYWRkT3ZlcndyaXRlID0gZnVuY3Rpb24gKHBhdGgsIHNuYXAsIHdyaXRlSWQsIHZpc2libGUpIHtcbiAgICAgICAgdXRpbF8yLmFzc2VydCh3cml0ZUlkID4gdGhpcy5sYXN0V3JpdGVJZF8sICdTdGFja2luZyBhbiBvbGRlciB3cml0ZSBvbiB0b3Agb2YgbmV3ZXIgb25lcycpO1xuICAgICAgICBpZiAodmlzaWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbFdyaXRlc18ucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgc25hcDogc25hcCxcbiAgICAgICAgICAgIHdyaXRlSWQ6IHdyaXRlSWQsXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18uYWRkV3JpdGUocGF0aCwgc25hcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0V3JpdGVJZF8gPSB3cml0ZUlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVjb3JkIGEgbmV3IG1lcmdlIGZyb20gdXNlciBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhTm9kZT59IGNoYW5nZWRDaGlsZHJlblxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuYWRkTWVyZ2UgPSBmdW5jdGlvbiAocGF0aCwgY2hhbmdlZENoaWxkcmVuLCB3cml0ZUlkKSB7XG4gICAgICAgIHV0aWxfMi5hc3NlcnQod3JpdGVJZCA+IHRoaXMubGFzdFdyaXRlSWRfLCAnU3RhY2tpbmcgYW4gb2xkZXIgbWVyZ2Ugb24gdG9wIG9mIG5ld2VyIG9uZXMnKTtcbiAgICAgICAgdGhpcy5hbGxXcml0ZXNfLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGFuZ2VkQ2hpbGRyZW4sXG4gICAgICAgICAgICB3cml0ZUlkOiB3cml0ZUlkLFxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18uYWRkV3JpdGVzKHBhdGgsIGNoYW5nZWRDaGlsZHJlbik7XG4gICAgICAgIHRoaXMubGFzdFdyaXRlSWRfID0gd3JpdGVJZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gd3JpdGVJZFxuICAgICAqIEByZXR1cm4gez9Xcml0ZVJlY29yZH1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmdldFdyaXRlID0gZnVuY3Rpb24gKHdyaXRlSWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByZWNvcmQgPSB0aGlzLmFsbFdyaXRlc19baV07XG4gICAgICAgICAgICBpZiAocmVjb3JkLndyaXRlSWQgPT09IHdyaXRlSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgd3JpdGUgKGVpdGhlciBhbiBvdmVyd3JpdGUgb3IgbWVyZ2UpIHRoYXQgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGFja25vd2xlZGdlIGJ5IHRoZSBzZXJ2ZXIuIFJlY2FsY3VsYXRlc1xuICAgICAqIHRoZSB0cmVlIGlmIG5lY2Vzc2FyeS4gIFdlIHJldHVybiB0cnVlIGlmIGl0IG1heSBoYXZlIGJlZW4gdmlzaWJsZSwgbWVhbmluZyB2aWV3cyBuZWVkIHRvIHJlZXZhbHVhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IHdyaXRlSWRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSB3cml0ZSBtYXkgaGF2ZSBiZWVuIHZpc2libGUgKG1lYW5pbmcgd2UnbGwgbmVlZCB0byByZWV2YWx1YXRlIC8gcmFpc2VcbiAgICAgKiBldmVudHMgYXMgYSByZXN1bHQpLlxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUucmVtb3ZlV3JpdGUgPSBmdW5jdGlvbiAod3JpdGVJZCkge1xuICAgICAgICAvLyBOb3RlOiBkaXNhYmxpbmcgdGhpcyBjaGVjay4gSXQgY291bGQgYmUgYSB0cmFuc2FjdGlvbiB0aGF0IHByZWVtcHRlZCBhbm90aGVyIHRyYW5zYWN0aW9uLCBhbmQgdGh1cyB3YXMgYXBwbGllZFxuICAgICAgICAvLyBvdXQgb2Ygb3JkZXIuXG4gICAgICAgIC8vY29uc3QgdmFsaWRDbGVhciA9IHJldmVydCB8fCB0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID09PSAwIHx8IHdyaXRlSWQgPD0gdGhpcy5hbGxXcml0ZXNfWzBdLndyaXRlSWQ7XG4gICAgICAgIC8vYXNzZXJ0KHZhbGlkQ2xlYXIsIFwiRWl0aGVyIHdlIGRvbid0IGhhdmUgdGhpcyB3cml0ZSwgb3IgaXQncyB0aGUgZmlyc3Qgb25lIGluIHRoZSBxdWV1ZVwiKTtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuYWxsV3JpdGVzXy5maW5kSW5kZXgoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLndyaXRlSWQgPT09IHdyaXRlSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB1dGlsXzIuYXNzZXJ0KGlkeCA+PSAwLCAncmVtb3ZlV3JpdGUgY2FsbGVkIHdpdGggbm9uZXhpc3RlbnQgd3JpdGVJZC4nKTtcbiAgICAgICAgdmFyIHdyaXRlVG9SZW1vdmUgPSB0aGlzLmFsbFdyaXRlc19baWR4XTtcbiAgICAgICAgdGhpcy5hbGxXcml0ZXNfLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB2YXIgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IHdyaXRlVG9SZW1vdmUudmlzaWJsZTtcbiAgICAgICAgdmFyIHJlbW92ZWRXcml0ZU92ZXJsYXBzV2l0aE90aGVyV3JpdGVzID0gZmFsc2U7XG4gICAgICAgIHZhciBpID0gdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChyZW1vdmVkV3JpdGVXYXNWaXNpYmxlICYmIGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRXcml0ZSA9IHRoaXMuYWxsV3JpdGVzX1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50V3JpdGUudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID49IGlkeCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29yZENvbnRhaW5zUGF0aF8oY3VycmVudFdyaXRlLCB3cml0ZVRvUmVtb3ZlLnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1vdmVkIHdyaXRlIHdhcyBjb21wbGV0ZWx5IHNoYWRvd2VkIGJ5IGEgc3Vic2VxdWVudCB3cml0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlV2FzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cml0ZVRvUmVtb3ZlLnBhdGguY29udGFpbnMoY3VycmVudFdyaXRlLnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciB3ZSdyZSBjb3ZlcmluZyBzb21lIHdyaXRlcyBvciB0aGV5J3JlIGNvdmVyaW5nIHBhcnQgb2YgdXMgKGRlcGVuZGluZyBvbiB3aGljaCBjYW1lIGZpcnN0KS5cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFdyaXRlT3ZlcmxhcHNXaXRoT3RoZXJXcml0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbW92ZWRXcml0ZVdhc1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZW1vdmVkV3JpdGVPdmVybGFwc1dpdGhPdGhlcldyaXRlcykge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBzb21lIHNoYWRvd2luZyBnb2luZyBvbi4gSnVzdCByZWJ1aWxkIHRoZSB2aXNpYmxlIHdyaXRlcyBmcm9tIHNjcmF0Y2guXG4gICAgICAgICAgICB0aGlzLnJlc2V0VHJlZV8oKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBubyBzaGFkb3dpbmcuICBXZSBjYW4gc2FmZWx5IGp1c3QgcmVtb3ZlIHRoZSB3cml0ZShzKSBmcm9tIHZpc2libGVXcml0ZXMuXG4gICAgICAgICAgICBpZiAod3JpdGVUb1JlbW92ZS5zbmFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IHRoaXMudmlzaWJsZVdyaXRlc18ucmVtb3ZlV3JpdGUod3JpdGVUb1JlbW92ZS5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHdyaXRlVG9SZW1vdmUuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdXRpbF8xLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudmlzaWJsZVdyaXRlc18gPSBfdGhpcy52aXNpYmxlV3JpdGVzXy5yZW1vdmVXcml0ZSh3cml0ZVRvUmVtb3ZlLnBhdGguY2hpbGQoY2hpbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY29tcGxldGUgc25hcHNob3QgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlJ3MgdmlzaWJsZSB3cml0ZSBkYXRhIGF0IHRoYXQgcGF0aCwgZWxzZSBudWxsLlxuICAgICAqIE5vIHNlcnZlciBkYXRhIGlzIGNvbnNpZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5nZXRDb21wbGV0ZVdyaXRlRGF0YSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVXcml0ZXNfLmdldENvbXBsZXRlTm9kZShwYXRoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIG9wdGlvbmFsLCB1bmRlcmx5aW5nIHNlcnZlciBkYXRhLCBhbmQgYW4gb3B0aW9uYWwgc2V0IG9mIGNvbnN0cmFpbnRzIChleGNsdWRlIHNvbWUgc2V0cywgaW5jbHVkZSBoaWRkZW5cbiAgICAgKiB3cml0ZXMpLCBhdHRlbXB0IHRvIGNhbGN1bGF0ZSBhIGNvbXBsZXRlIHNuYXBzaG90IGZvciB0aGUgZ2l2ZW4gcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIEFuIG9wdGlvbmFsIHNldCB0byBiZSBleGNsdWRlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVIaWRkZW5Xcml0ZXMgRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jYWxjQ29tcGxldGVFdmVudENhY2hlID0gZnVuY3Rpb24gKHRyZWVQYXRoLCBjb21wbGV0ZVNlcnZlckNhY2hlLCB3cml0ZUlkc1RvRXhjbHVkZSwgaW5jbHVkZUhpZGRlbldyaXRlcykge1xuICAgICAgICBpZiAoIXdyaXRlSWRzVG9FeGNsdWRlICYmICFpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XG4gICAgICAgICAgICB2YXIgc2hhZG93aW5nTm9kZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhZG93aW5nTm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWJNZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViTWVyZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVNlcnZlckNhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckNhY2hlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIXN1Yk1lcmdlLmhhc0NvbXBsZXRlV3JpdGUoUGF0aF8xLlBhdGguRW1wdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdvdWxkbid0IGhhdmUgYSBjb21wbGV0ZSBzbmFwc2hvdCwgc2luY2UgdGhlcmUncyBubyB1bmRlcmx5aW5nIGRhdGEgYW5kIG5vIGNvbXBsZXRlIHNoYWRvd1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXllcmVkQ2FjaGUgPSBjb21wbGV0ZVNlcnZlckNhY2hlIHx8IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViTWVyZ2UuYXBwbHkobGF5ZXJlZENhY2hlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZSh0cmVlUGF0aCk7XG4gICAgICAgICAgICBpZiAoIWluY2x1ZGVIaWRkZW5Xcml0ZXMgJiYgbWVyZ2UuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlU2VydmVyQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGNhY2hlIGlzIG51bGwsIGFuZCB3ZSBkb24ndCBoYXZlIGEgY29tcGxldGUgY2FjaGUsIHdlIG5lZWQgdG8gcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVIaWRkZW5Xcml0ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTZXJ2ZXJDYWNoZSA9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICFtZXJnZS5oYXNDb21wbGV0ZVdyaXRlKFBhdGhfMS5QYXRoLkVtcHR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHdyaXRlLnZpc2libGUgfHwgaW5jbHVkZUhpZGRlbldyaXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIXdyaXRlSWRzVG9FeGNsdWRlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICF+d3JpdGVJZHNUb0V4Y2x1ZGUuaW5kZXhPZih3cml0ZS53cml0ZUlkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAod3JpdGUucGF0aC5jb250YWlucyh0cmVlUGF0aCkgfHwgdHJlZVBhdGguY29udGFpbnMod3JpdGUucGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lcmdlQXRQYXRoID0gV3JpdGVUcmVlLmxheWVyVHJlZV8odGhpcy5hbGxXcml0ZXNfLCBmaWx0ZXIsIHRyZWVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyZWRDYWNoZSA9IGNvbXBsZXRlU2VydmVyQ2FjaGUgfHwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZUF0UGF0aC5hcHBseShsYXllcmVkQ2FjaGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV2l0aCBvcHRpb25hbCwgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSwgYXR0ZW1wdCB0byByZXR1cm4gYSBjaGlsZHJlbiBub2RlIG9mIGNoaWxkcmVuIHRoYXQgd2UgaGF2ZSBjb21wbGV0ZSBkYXRhIGZvci5cbiAgICAgKiBVc2VkIHdoZW4gY3JlYXRpbmcgbmV3IHZpZXdzLCB0byBwcmUtZmlsbCB0aGVpciBjb21wbGV0ZSBldmVudCBjaGlsZHJlbiBzbmFwc2hvdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVQYXRoXG4gICAgICogQHBhcmFtIHs/Q2hpbGRyZW5Ob2RlfSBjb21wbGV0ZVNlcnZlckNoaWxkcmVuXG4gICAgICogQHJldHVybiB7IUNoaWxkcmVuTm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLmNhbGNDb21wbGV0ZUV2ZW50Q2hpbGRyZW4gPSBmdW5jdGlvbiAodHJlZVBhdGgsIGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlQ2hpbGRyZW4gPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgdmFyIHRvcExldmVsU2V0ID0gdGhpcy52aXNpYmxlV3JpdGVzXy5nZXRDb21wbGV0ZU5vZGUodHJlZVBhdGgpO1xuICAgICAgICBpZiAodG9wTGV2ZWxTZXQpIHtcbiAgICAgICAgICAgIGlmICghdG9wTGV2ZWxTZXQuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UncmUgc2hhZG93aW5nIGV2ZXJ5dGhpbmcuIFJldHVybiB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxTZXQuZm9yRWFjaENoaWxkKFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWCwgZnVuY3Rpb24gKGNoaWxkTmFtZSwgY2hpbGRTbmFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2hpbGRyZW4gPSBjb21wbGV0ZUNoaWxkcmVuLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkTmFtZSwgY2hpbGRTbmFwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZUNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgIC8vIExheWVyIGFueSBjaGlsZHJlbiB3ZSBoYXZlIG9uIHRvcCBvZiB0aGlzXG4gICAgICAgICAgICAvLyBXZSBrbm93IHdlIGRvbid0IGhhdmUgYSB0b3AtbGV2ZWwgc2V0LCBzbyBqdXN0IGVudW1lcmF0ZSBleGlzdGluZyBjaGlsZHJlblxuICAgICAgICAgICAgdmFyIG1lcmdlXzEgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZSh0cmVlUGF0aCk7XG4gICAgICAgICAgICBjb21wbGV0ZVNlcnZlckNoaWxkcmVuLmZvckVhY2hDaGlsZChQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gbWVyZ2VfMVxuICAgICAgICAgICAgICAgICAgICAuY2hpbGRDb21wb3VuZFdyaXRlKG5ldyBQYXRoXzEuUGF0aChjaGlsZE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwbHkoY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChjaGlsZE5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBBZGQgYW55IGNvbXBsZXRlIGNoaWxkcmVuIHdlIGhhdmUgZnJvbSB0aGUgc2V0XG4gICAgICAgICAgICBtZXJnZV8xLmdldENvbXBsZXRlQ2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gbGF5ZXIgb24gdG9wIG9mLiBMYXllciBvbiBhbnkgY2hpbGRyZW4gd2UgaGF2ZVxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGNhbiByZXR1cm4gYW4gZW1wdHkgc25hcCBpZiB3ZSBoYXZlIGEgZGVmaW5lZCBkZWxldGVcbiAgICAgICAgICAgIHZhciBtZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHRyZWVQYXRoKTtcbiAgICAgICAgICAgIG1lcmdlLmdldENvbXBsZXRlQ2hpbGRyZW4oKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lZE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZUNoaWxkcmVuID0gY29tcGxldGVDaGlsZHJlbi51cGRhdGVJbW1lZGlhdGVDaGlsZChuYW1lZE5vZGUubmFtZSwgbmFtZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29tcGxldGVDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhhdCB0aGUgdW5kZXJseWluZyBzZXJ2ZXIgZGF0YSBoYXMgdXBkYXRlZCwgZGV0ZXJtaW5lIHdoYXQsIGlmIGFueXRoaW5nLCBuZWVkcyB0byBiZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGNhY2hlLlxuICAgICAqXG4gICAgICogUG9zc2liaWxpdGllczpcbiAgICAgKlxuICAgICAqIDEuIE5vIHdyaXRlcyBhcmUgc2hhZG93aW5nLiBFdmVudHMgc2hvdWxkIGJlIHJhaXNlZCwgdGhlIHNuYXAgdG8gYmUgYXBwbGllZCBjb21lcyBmcm9tIHRoZSBzZXJ2ZXIgZGF0YVxuICAgICAqXG4gICAgICogMi4gU29tZSB3cml0ZSBpcyBjb21wbGV0ZWx5IHNoYWRvd2luZy4gTm8gZXZlbnRzIHRvIGJlIHJhaXNlZFxuICAgICAqXG4gICAgICogMy4gSXMgcGFydGlhbGx5IHNoYWRvd2VkLiBFdmVudHNcbiAgICAgKlxuICAgICAqIEVpdGhlciBleGlzdGluZ0V2ZW50U25hcCBvciBleGlzdGluZ1NlcnZlclNuYXAgbXVzdCBleGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGlsZFBhdGhcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ0V2ZW50U25hcFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nU2VydmVyU25hcFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSA9IGZ1bmN0aW9uICh0cmVlUGF0aCwgY2hpbGRQYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XG4gICAgICAgIHV0aWxfMi5hc3NlcnQoZXhpc3RpbmdFdmVudFNuYXAgfHwgZXhpc3RpbmdTZXJ2ZXJTbmFwLCAnRWl0aGVyIGV4aXN0aW5nRXZlbnRTbmFwIG9yIGV4aXN0aW5nU2VydmVyU25hcCBtdXN0IGV4aXN0Jyk7XG4gICAgICAgIHZhciBwYXRoID0gdHJlZVBhdGguY2hpbGQoY2hpbGRQYXRoKTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZVdyaXRlc18uaGFzQ29tcGxldGVXcml0ZShwYXRoKSkge1xuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBjYW4gcHJvYmFibHkgZ3VhcmFudGVlIHRoYXQgd2UncmUgaW4gY2FzZSAyLCBtZWFuaW5nIG5vIGV2ZW50c1xuICAgICAgICAgICAgLy8gTWF5IG5lZWQgdG8gY2hlY2sgdmlzaWJpbGl0eSB3aGlsZSBkb2luZyB0aGUgZmluZFJvb3RNb3N0VmFsdWVBbmRQYXRoIGNhbGxcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gY29tcGxldGUgc2hhZG93aW5nLiBXZSdyZSBlaXRoZXIgcGFydGlhbGx5IHNoYWRvd2luZyBvciBub3Qgc2hhZG93aW5nIGF0IGFsbC5cbiAgICAgICAgICAgIHZhciBjaGlsZE1lcmdlID0gdGhpcy52aXNpYmxlV3JpdGVzXy5jaGlsZENvbXBvdW5kV3JpdGUocGF0aCk7XG4gICAgICAgICAgICBpZiAoY2hpbGRNZXJnZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBub3Qgc2hhZG93aW5nIGF0IGFsbC4gQ2FzZSAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nU2VydmVyU25hcC5nZXRDaGlsZChjaGlsZFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBpZiB0aGUgc2VydmVyTm9kZSArIHVwZGF0ZXMgZG9lc24ndCBjaGFuZ2UgdGhlIGV2ZW50U25hcFxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhpcyBpcyB0cmlja3kgdG8gZmluZCBvdXQsIHNpbmNlIHVzZXIgdXBkYXRlcyBkb24ndCBuZWNlc3NhcnkgY2hhbmdlIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBzbmFwLCBlLmcuIHByaW9yaXR5IHVwZGF0ZXMgb24gZW1wdHkgbm9kZXMsIG9yIGRlZXAgZGVsZXRlcy4gQW5vdGhlciBzcGVjaWFsIGNhc2UgaXMgaWYgdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIGFkZHMgbm9kZXMsIGJ1dCBkb2Vzbid0IGNoYW5nZSBhbnkgZXhpc3Rpbmcgd3JpdGVzLiBJdCBpcyB0aGVyZWZvcmUgbm90IGVub3VnaCB0b1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgY2hlY2sgaWYgdGhlIHVwZGF0ZXMgY2hhbmdlIHRoZSBzZXJ2ZXJOb2RlLlxuICAgICAgICAgICAgICAgIC8vIE1heWJlIGNoZWNrIGlmIHRoZSBtZXJnZSB0cmVlIGNvbnRhaW5zIHRoZXNlIHNwZWNpYWwgY2FzZXMgYW5kIG9ubHkgZG8gYSBmdWxsIG92ZXJ3cml0ZSBpbiB0aGF0IGNhc2U/XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTWVyZ2UuYXBwbHkoZXhpc3RpbmdTZXJ2ZXJTbmFwLmdldENoaWxkKGNoaWxkUGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGxldGUgY2hpbGQgZm9yIGEgZ2l2ZW4gc2VydmVyIHNuYXAgYWZ0ZXIgYXBwbHlpbmcgYWxsIHVzZXIgd3JpdGVzIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9cbiAgICAgKiBjb21wbGV0ZSBjaGlsZCBmb3IgdGhpcyBDaGlsZEtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHRyZWVQYXRoXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IUNhY2hlTm9kZX0gZXhpc3RpbmdTZXJ2ZXJTbmFwXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlLnByb3RvdHlwZS5jYWxjQ29tcGxldGVDaGlsZCA9IGZ1bmN0aW9uICh0cmVlUGF0aCwgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyU25hcCkge1xuICAgICAgICB2YXIgcGF0aCA9IHRyZWVQYXRoLmNoaWxkKGNoaWxkS2V5KTtcbiAgICAgICAgdmFyIHNoYWRvd2luZ05vZGUgPSB0aGlzLnZpc2libGVXcml0ZXNfLmdldENvbXBsZXRlTm9kZShwYXRoKTtcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRvd2luZ05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdTZXJ2ZXJTbmFwLmlzQ29tcGxldGVGb3JDaGlsZChjaGlsZEtleSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRNZXJnZSA9IHRoaXMudmlzaWJsZVdyaXRlc18uY2hpbGRDb21wb3VuZFdyaXRlKHBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE1lcmdlLmFwcGx5KGV4aXN0aW5nU2VydmVyU25hcC5nZXROb2RlKCkuZ2V0SW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxuICAgICAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLnNoYWRvd2luZ1dyaXRlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZVdyaXRlc18uZ2V0Q29tcGxldGVOb2RlKHBhdGgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB3aGVuIHByb2Nlc3NpbmcgY2hpbGQgcmVtb3ZlIGV2ZW50cyBvbiBhIHF1ZXJ5LiBJZiB3ZSBjYW4sIHdlIHB1bGwgaW4gY2hpbGRyZW4gdGhhdCB3ZXJlIG91dHNpZGVcbiAgICAgKiB0aGUgd2luZG93LCBidXQgbWF5IG5vdyBiZSBpbiB0aGUgd2luZG93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshUGF0aH0gdHJlZVBhdGhcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckRhdGFcbiAgICAgKiBAcGFyYW0geyFOYW1lZE5vZGV9IHN0YXJ0UG9zdFxuICAgICAqIEBwYXJhbSB7IW51bWJlcn0gY291bnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJldmVyc2VcbiAgICAgKiBAcGFyYW0geyFJbmRleH0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHshQXJyYXkuPCFOYW1lZE5vZGU+fVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUuY2FsY0luZGV4ZWRTbGljZSA9IGZ1bmN0aW9uICh0cmVlUGF0aCwgY29tcGxldGVTZXJ2ZXJEYXRhLCBzdGFydFBvc3QsIGNvdW50LCByZXZlcnNlLCBpbmRleCkge1xuICAgICAgICB2YXIgdG9JdGVyYXRlO1xuICAgICAgICB2YXIgbWVyZ2UgPSB0aGlzLnZpc2libGVXcml0ZXNfLmNoaWxkQ29tcG91bmRXcml0ZSh0cmVlUGF0aCk7XG4gICAgICAgIHZhciBzaGFkb3dpbmdOb2RlID0gbWVyZ2UuZ2V0Q29tcGxldGVOb2RlKFBhdGhfMS5QYXRoLkVtcHR5KTtcbiAgICAgICAgaWYgKHNoYWRvd2luZ05vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9JdGVyYXRlID0gc2hhZG93aW5nTm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wbGV0ZVNlcnZlckRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgdG9JdGVyYXRlID0gbWVyZ2UuYXBwbHkoY29tcGxldGVTZXJ2ZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG5vIGNoaWxkcmVuIHRvIGl0ZXJhdGUgb25cbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB0b0l0ZXJhdGUgPSB0b0l0ZXJhdGUud2l0aEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKCF0b0l0ZXJhdGUuaXNFbXB0eSgpICYmICF0b0l0ZXJhdGUuaXNMZWFmTm9kZSgpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjbXAgPSBpbmRleC5nZXRDb21wYXJlKCk7XG4gICAgICAgICAgICB2YXIgaXRlciA9IHJldmVyc2VcbiAgICAgICAgICAgICAgICA/IHRvSXRlcmF0ZS5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgOiB0b0l0ZXJhdGUuZ2V0SXRlcmF0b3JGcm9tKHN0YXJ0UG9zdCwgaW5kZXgpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICYmIG5vZGVzLmxlbmd0aCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNtcChuZXh0LCBzdGFydFBvc3QpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpdGVyLmdldE5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshV3JpdGVSZWNvcmR9IHdyaXRlUmVjb3JkXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXcml0ZVRyZWUucHJvdG90eXBlLnJlY29yZENvbnRhaW5zUGF0aF8gPSBmdW5jdGlvbiAod3JpdGVSZWNvcmQsIHBhdGgpIHtcbiAgICAgICAgaWYgKHdyaXRlUmVjb3JkLnNuYXApIHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVJlY29yZC5wYXRoLmNvbnRhaW5zKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmluZEtleSBjYW4gcmV0dXJuIHVuZGVmaW5lZCwgc28gdXNlICEhIHRvIGNvZXJjZSB0byBib29sZWFuXG4gICAgICAgICAgICByZXR1cm4gISF1dGlsXzEuZmluZEtleSh3cml0ZVJlY29yZC5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkU25hcCwgY2hpbGROYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyaXRlUmVjb3JkLnBhdGguY2hpbGQoY2hpbGROYW1lKS5jb250YWlucyhwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZS1sYXllciB0aGUgd3JpdGVzIGFuZCBtZXJnZXMgaW50byBhIHRyZWUgc28gd2UgY2FuIGVmZmljaWVudGx5IGNhbGN1bGF0ZSBldmVudCBzbmFwc2hvdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5wcm90b3R5cGUucmVzZXRUcmVlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlV3JpdGVzXyA9IFdyaXRlVHJlZS5sYXllclRyZWVfKHRoaXMuYWxsV3JpdGVzXywgV3JpdGVUcmVlLkRlZmF1bHRGaWx0ZXJfLCBQYXRoXzEuUGF0aC5FbXB0eSk7XG4gICAgICAgIGlmICh0aGlzLmFsbFdyaXRlc18ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0V3JpdGVJZF8gPSB0aGlzLmFsbFdyaXRlc19bdGhpcy5hbGxXcml0ZXNfLmxlbmd0aCAtIDFdLndyaXRlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RXcml0ZUlkXyA9IC0xO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBmaWx0ZXIgdXNlZCB3aGVuIGNvbnN0cnVjdGluZyB0aGUgdHJlZS4gS2VlcCBldmVyeXRoaW5nIHRoYXQncyB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshV3JpdGVSZWNvcmR9IHdyaXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFdyaXRlVHJlZS5EZWZhdWx0RmlsdGVyXyA9IGZ1bmN0aW9uICh3cml0ZSkge1xuICAgICAgICByZXR1cm4gd3JpdGUudmlzaWJsZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXRpYyBtZXRob2QuIEdpdmVuIGFuIGFycmF5IG9mIFdyaXRlUmVjb3JkcywgYSBmaWx0ZXIgZm9yIHdoaWNoIG9uZXMgdG8gaW5jbHVkZSwgYW5kIGEgcGF0aCwgY29uc3RydWN0IHRoZSB0cmVlIG9mXG4gICAgICogZXZlbnQgZGF0YSBhdCB0aGF0IHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFBcnJheS48IVdyaXRlUmVjb3JkPn0gd3JpdGVzXG4gICAgICogQHBhcmFtIHshZnVuY3Rpb24oIVdyaXRlUmVjb3JkKTpib29sZWFufSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0geyFQYXRofSB0cmVlUm9vdFxuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgV3JpdGVUcmVlLmxheWVyVHJlZV8gPSBmdW5jdGlvbiAod3JpdGVzLCBmaWx0ZXIsIHRyZWVSb290KSB7XG4gICAgICAgIHZhciBjb21wb3VuZFdyaXRlID0gQ29tcG91bmRXcml0ZV8xLkNvbXBvdW5kV3JpdGUuRW1wdHk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd3JpdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgd3JpdGUgPSB3cml0ZXNbaV07XG4gICAgICAgICAgICAvLyBUaGVvcnksIGEgbGF0ZXIgc2V0IHdpbGwgZWl0aGVyOlxuICAgICAgICAgICAgLy8gYSkgYWJvcnQgYSByZWxldmFudCB0cmFuc2FjdGlvbiwgc28gbm8gbmVlZCB0byB3b3JyeSBhYm91dCBleGNsdWRpbmcgaXQgZnJvbSBjYWxjdWxhdGluZyB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBiKSBub3QgYmUgcmVsZXZhbnQgdG8gYSB0cmFuc2FjdGlvbiAoc2VwYXJhdGUgYnJhbmNoKSwgc28gYWdhaW4gd2lsbCBub3QgYWZmZWN0IHRoZSBkYXRhIGZvciB0aGF0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBpZiAoZmlsdGVyKHdyaXRlKSkge1xuICAgICAgICAgICAgICAgIHZhciB3cml0ZVBhdGggPSB3cml0ZS5wYXRoO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHdyaXRlLnNuYXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyZWVSb290LmNvbnRhaW5zKHdyaXRlUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aCh0cmVlUm9vdCwgd3JpdGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvdW5kV3JpdGUgPSBjb21wb3VuZFdyaXRlLmFkZFdyaXRlKHJlbGF0aXZlUGF0aCwgd3JpdGUuc25hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVQYXRoLmNvbnRhaW5zKHRyZWVSb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHdyaXRlUGF0aCwgdHJlZVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGUoUGF0aF8xLlBhdGguRW1wdHksIHdyaXRlLnNuYXAuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBvdmVybGFwIGJldHdlZW4gcm9vdCBwYXRoIGFuZCB3cml0ZSBwYXRoLCBpZ25vcmUgd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh3cml0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJlZVJvb3QuY29udGFpbnMod3JpdGVQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoID0gUGF0aF8xLlBhdGgucmVsYXRpdmVQYXRoKHRyZWVSb290LCB3cml0ZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGVzKHJlbGF0aXZlUGF0aCwgd3JpdGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyaXRlUGF0aC5jb250YWlucyh0cmVlUm9vdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aCh3cml0ZVBhdGgsIHRyZWVSb290KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG91bmRXcml0ZSA9IGNvbXBvdW5kV3JpdGUuYWRkV3JpdGVzKFBhdGhfMS5QYXRoLkVtcHR5LCB3cml0ZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB1dGlsXzEuc2FmZUdldCh3cml0ZS5jaGlsZHJlbiwgcmVsYXRpdmVQYXRoLmdldEZyb250KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBleGlzdHMgYSBjaGlsZCBpbiB0aGlzIG5vZGUgdGhhdCBtYXRjaGVzIHRoZSByb290IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlZXBOb2RlID0gY2hpbGQuZ2V0Q2hpbGQocmVsYXRpdmVQYXRoLnBvcEZyb250KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb3VuZFdyaXRlID0gY29tcG91bmRXcml0ZS5hZGRXcml0ZShQYXRoXzEuUGF0aC5FbXB0eSwgZGVlcE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiByb290IHBhdGggYW5kIHdyaXRlIHBhdGgsIGlnbm9yZSB3cml0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB1dGlsXzIuYXNzZXJ0aW9uRXJyb3IoJ1dyaXRlUmVjb3JkIHNob3VsZCBoYXZlIC5zbmFwIG9yIC5jaGlsZHJlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG91bmRXcml0ZTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVRyZWU7XG59KCkpO1xuZXhwb3J0cy5Xcml0ZVRyZWUgPSBXcml0ZVRyZWU7XG4vKipcbiAqIEEgV3JpdGVUcmVlUmVmIHdyYXBzIGEgV3JpdGVUcmVlIGFuZCBhIHBhdGgsIGZvciBjb252ZW5pZW50IGFjY2VzcyB0byBhIHBhcnRpY3VsYXIgc3VidHJlZS4gIEFsbCBvZiB0aGUgbWV0aG9kc1xuICoganVzdCBwcm94eSB0byB0aGUgdW5kZXJseWluZyBXcml0ZVRyZWUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBXcml0ZVRyZWVSZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshUGF0aH0gcGF0aFxuICAgICAqIEBwYXJhbSB7IVdyaXRlVHJlZX0gd3JpdGVUcmVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gV3JpdGVUcmVlUmVmKHBhdGgsIHdyaXRlVHJlZSkge1xuICAgICAgICB0aGlzLnRyZWVQYXRoXyA9IHBhdGg7XG4gICAgICAgIHRoaXMud3JpdGVUcmVlXyA9IHdyaXRlVHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHJldHVybnMgYSBjb21wbGV0ZSBldmVudCBjYWNoZSwgdXNpbmcgdGhlIHVuZGVybHlpbmcgc2VydmVyIGRhdGEgaWYgcG9zc2libGUuIEluIGFkZGl0aW9uLCBjYW4gYmUgdXNlZFxuICAgICAqIHRvIGdldCBhIGNhY2hlIHRoYXQgaW5jbHVkZXMgaGlkZGVuIHdyaXRlcywgYW5kIGV4Y2x1ZGVzIGFyYml0cmFyeSB3cml0ZXMuIE5vdGUgdGhhdCBjdXN0b21pemluZyB0aGUgcmV0dXJuZWQgbm9kZVxuICAgICAqIGNhbiBsZWFkIHRvIGEgbW9yZSBleHBlbnNpdmUgY2FsY3VsYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBjb21wbGV0ZVNlcnZlckNhY2hlXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPj19IHdyaXRlSWRzVG9FeGNsdWRlIE9wdGlvbmFsIHdyaXRlcyB0byBleGNsdWRlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVIaWRkZW5Xcml0ZXMgRGVmYXVsdHMgdG8gZmFsc2UsIHdoZXRoZXIgb3Igbm90IHRvIGxheWVyIG9uIHdyaXRlcyB3aXRoIHZpc2libGUgc2V0IHRvIGZhbHNlXG4gICAgICogQHJldHVybiB7P05vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jYWxjQ29tcGxldGVFdmVudENhY2hlID0gZnVuY3Rpb24gKGNvbXBsZXRlU2VydmVyQ2FjaGUsIHdyaXRlSWRzVG9FeGNsdWRlLCBpbmNsdWRlSGlkZGVuV3JpdGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDYWNoZSh0aGlzLnRyZWVQYXRoXywgY29tcGxldGVTZXJ2ZXJDYWNoZSwgd3JpdGVJZHNUb0V4Y2x1ZGUsIGluY2x1ZGVIaWRkZW5Xcml0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWYgcG9zc2libGUsIHJldHVybnMgYSBjaGlsZHJlbiBub2RlIGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjb21wbGV0ZSBjaGlsZHJlbiB3ZSBoYXZlIGRhdGEgZm9yLiBUaGUgcmV0dXJuZWQgZGF0YSBpcyBhXG4gICAgICogbWl4IG9mIHRoZSBnaXZlbiBzZXJ2ZXIgZGF0YSBhbmQgd3JpdGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P0NoaWxkcmVuTm9kZX0gY29tcGxldGVTZXJ2ZXJDaGlsZHJlblxuICAgICAqIEByZXR1cm4geyFDaGlsZHJlbk5vZGV9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuID0gZnVuY3Rpb24gKGNvbXBsZXRlU2VydmVyQ2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjQ29tcGxldGVFdmVudENoaWxkcmVuKHRoaXMudHJlZVBhdGhfLCBjb21wbGV0ZVNlcnZlckNoaWxkcmVuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHRoYXQgZWl0aGVyIHRoZSB1bmRlcmx5aW5nIHNlcnZlciBkYXRhIGhhcyB1cGRhdGVkIG9yIHRoZSBvdXRzdGFuZGluZyB3cml0ZXMgaGF2ZSB1cGRhdGVkLCBkZXRlcm1pbmUgd2hhdCxcbiAgICAgKiBpZiBhbnl0aGluZywgbmVlZHMgdG8gYmUgYXBwbGllZCB0byB0aGUgZXZlbnQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBQb3NzaWJpbGl0aWVzOlxuICAgICAqXG4gICAgICogMS4gTm8gd3JpdGVzIGFyZSBzaGFkb3dpbmcuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkLCB0aGUgc25hcCB0byBiZSBhcHBsaWVkIGNvbWVzIGZyb20gdGhlIHNlcnZlciBkYXRhXG4gICAgICpcbiAgICAgKiAyLiBTb21lIHdyaXRlIGlzIGNvbXBsZXRlbHkgc2hhZG93aW5nLiBObyBldmVudHMgdG8gYmUgcmFpc2VkXG4gICAgICpcbiAgICAgKiAzLiBJcyBwYXJ0aWFsbHkgc2hhZG93ZWQuIEV2ZW50cyBzaG91bGQgYmUgcmFpc2VkXG4gICAgICpcbiAgICAgKiBFaXRoZXIgZXhpc3RpbmdFdmVudFNuYXAgb3IgZXhpc3RpbmdTZXJ2ZXJTbmFwIG11c3QgZXhpc3QsIHRoaXMgaXMgdmFsaWRhdGVkIHZpYSBhbiBhc3NlcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBleGlzdGluZ0V2ZW50U25hcFxuICAgICAqIEBwYXJhbSB7P05vZGV9IGV4aXN0aW5nU2VydmVyU25hcFxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSA9IGZ1bmN0aW9uIChwYXRoLCBleGlzdGluZ0V2ZW50U25hcCwgZXhpc3RpbmdTZXJ2ZXJTbmFwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV8uY2FsY0V2ZW50Q2FjaGVBZnRlclNlcnZlck92ZXJ3cml0ZSh0aGlzLnRyZWVQYXRoXywgcGF0aCwgZXhpc3RpbmdFdmVudFNuYXAsIGV4aXN0aW5nU2VydmVyU25hcCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbm9kZSBpZiB0aGVyZSBpcyBhIGNvbXBsZXRlIG92ZXJ3cml0ZSBmb3IgdGhpcyBwYXRoLiBNb3JlIHNwZWNpZmljYWxseSwgaWYgdGhlcmUgaXMgYSB3cml0ZSBhdFxuICAgICAqIGEgaGlnaGVyIHBhdGgsIHRoaXMgd2lsbCByZXR1cm4gdGhlIGNoaWxkIG9mIHRoYXQgd3JpdGUgcmVsYXRpdmUgdG8gdGhlIHdyaXRlIGFuZCB0aGlzIHBhdGguXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZXJlIGlzIG5vIHdyaXRlIGF0IHRoaXMgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBXcml0ZVRyZWVSZWYucHJvdG90eXBlLnNoYWRvd2luZ1dyaXRlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5zaGFkb3dpbmdXcml0ZSh0aGlzLnRyZWVQYXRoXy5jaGlsZChwYXRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHdoZW4gcHJvY2Vzc2luZyBjaGlsZCByZW1vdmUgZXZlbnRzIG9uIGEgcXVlcnkuIElmIHdlIGNhbiwgd2UgcHVsbCBpbiBjaGlsZHJlbiB0aGF0IHdlcmUgb3V0c2lkZVxuICAgICAqIHRoZSB3aW5kb3csIGJ1dCBtYXkgbm93IGJlIGluIHRoZSB3aW5kb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P05vZGV9IGNvbXBsZXRlU2VydmVyRGF0YVxuICAgICAqIEBwYXJhbSB7IU5hbWVkTm9kZX0gc3RhcnRQb3N0XG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBjb3VudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV2ZXJzZVxuICAgICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICAgICAqIEByZXR1cm4geyFBcnJheS48IU5hbWVkTm9kZT59XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jYWxjSW5kZXhlZFNsaWNlID0gZnVuY3Rpb24gKGNvbXBsZXRlU2VydmVyRGF0YSwgc3RhcnRQb3N0LCBjb3VudCwgcmV2ZXJzZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjSW5kZXhlZFNsaWNlKHRoaXMudHJlZVBhdGhfLCBjb21wbGV0ZVNlcnZlckRhdGEsIHN0YXJ0UG9zdCwgY291bnQsIHJldmVyc2UsIGluZGV4KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wbGV0ZSBjaGlsZCBmb3IgYSBnaXZlbiBzZXJ2ZXIgc25hcCBhZnRlciBhcHBseWluZyBhbGwgdXNlciB3cml0ZXMgb3IgbnVsbCBpZiB0aGVyZSBpcyBub1xuICAgICAqIGNvbXBsZXRlIGNoaWxkIGZvciB0aGlzIENoaWxkS2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBjaGlsZEtleVxuICAgICAqIEBwYXJhbSB7IUNhY2hlTm9kZX0gZXhpc3RpbmdTZXJ2ZXJDYWNoZVxuICAgICAqIEByZXR1cm4gez9Ob2RlfVxuICAgICAqL1xuICAgIFdyaXRlVHJlZVJlZi5wcm90b3R5cGUuY2FsY0NvbXBsZXRlQ2hpbGQgPSBmdW5jdGlvbiAoY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5jYWxjQ29tcGxldGVDaGlsZCh0aGlzLnRyZWVQYXRoXywgY2hpbGRLZXksIGV4aXN0aW5nU2VydmVyQ2FjaGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgV3JpdGVUcmVlUmVmIGZvciBhIGNoaWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkTmFtZVxuICAgICAqIEByZXR1cm4geyFXcml0ZVRyZWVSZWZ9XG4gICAgICovXG4gICAgV3JpdGVUcmVlUmVmLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZVRyZWVSZWYodGhpcy50cmVlUGF0aF8uY2hpbGQoY2hpbGROYW1lKSwgdGhpcy53cml0ZVRyZWVfKTtcbiAgICB9O1xuICAgIHJldHVybiBXcml0ZVRyZWVSZWY7XG59KCkpO1xuZXhwb3J0cy5Xcml0ZVRyZWVSZWYgPSBXcml0ZVRyZWVSZWY7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyaXRlVHJlZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9Xcml0ZVRyZWUuanNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBJbW11dGFibGVUcmVlXzEgPSByZXF1aXJlKFwiLi91dGlsL0ltbXV0YWJsZVRyZWVcIik7XG52YXIgUGF0aF8xID0gcmVxdWlyZShcIi4vdXRpbC9QYXRoXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBOb2RlXzEgPSByZXF1aXJlKFwiLi9zbmFwL05vZGVcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGhvbGRzIGEgY29sbGVjdGlvbiBvZiB3cml0ZXMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBub2RlcyBpbiB1bmlzb24uIEl0IGFic3RyYWN0cyBhd2F5IHRoZSBsb2dpYyB3aXRoXG4gKiBkZWFsaW5nIHdpdGggcHJpb3JpdHkgd3JpdGVzIGFuZCBtdWx0aXBsZSBuZXN0ZWQgd3JpdGVzLiBBdCBhbnkgZ2l2ZW4gcGF0aCB0aGVyZSBpcyBvbmx5IGFsbG93ZWQgdG8gYmUgb25lIHdyaXRlXG4gKiBtb2RpZnlpbmcgdGhhdCBwYXRoLiBBbnkgd3JpdGUgdG8gYW4gZXhpc3RpbmcgcGF0aCBvciBzaGFkb3dpbmcgYW4gZXhpc3RpbmcgcGF0aCB3aWxsIG1vZGlmeSB0aGF0IGV4aXN0aW5nIHdyaXRlXG4gKiB0byByZWZsZWN0IHRoZSB3cml0ZSBhZGRlZC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gd3JpdGVUcmVlXG4gKi9cbnZhciBDb21wb3VuZFdyaXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBvdW5kV3JpdGUod3JpdGVUcmVlXykge1xuICAgICAgICB0aGlzLndyaXRlVHJlZV8gPSB3cml0ZVRyZWVfO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmFkZFdyaXRlID0gZnVuY3Rpb24gKHBhdGgsIG5vZGUpIHtcbiAgICAgICAgaWYgKHBhdGguaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlKG5vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByb290bW9zdCA9IHRoaXMud3JpdGVUcmVlXy5maW5kUm9vdE1vc3RWYWx1ZUFuZFBhdGgocGF0aCk7XG4gICAgICAgICAgICBpZiAocm9vdG1vc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciByb290TW9zdFBhdGggPSByb290bW9zdC5wYXRoO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHJvb3Rtb3N0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocm9vdE1vc3RQYXRoLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKHRoaXMud3JpdGVUcmVlXy5zZXQocm9vdE1vc3RQYXRoLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnRyZWUgPSBuZXcgSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1dyaXRlVHJlZSA9IHRoaXMud3JpdGVUcmVlXy5zZXRUcmVlKHBhdGgsIHN1YnRyZWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZShuZXdXcml0ZVRyZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICFOb2RlPn0gdXBkYXRlc1xuICAgICAqIEByZXR1cm4geyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmFkZFdyaXRlcyA9IGZ1bmN0aW9uIChwYXRoLCB1cGRhdGVzKSB7XG4gICAgICAgIHZhciBuZXdXcml0ZSA9IHRoaXM7XG4gICAgICAgIHV0aWxfMS5mb3JFYWNoKHVwZGF0ZXMsIGZ1bmN0aW9uIChjaGlsZEtleSwgbm9kZSkge1xuICAgICAgICAgICAgbmV3V3JpdGUgPSBuZXdXcml0ZS5hZGRXcml0ZShwYXRoLmNoaWxkKGNoaWxkS2V5KSwgbm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3V3JpdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXaWxsIHJlbW92ZSBhIHdyaXRlIGF0IHRoZSBnaXZlbiBwYXRoIGFuZCBkZWVwZXIgcGF0aHMuIFRoaXMgd2lsbCA8ZW0+bm90PC9lbT4gbW9kaWZ5IGEgd3JpdGUgYXQgYSBoaWdoZXJcbiAgICAgKiBsb2NhdGlvbiwgd2hpY2ggbXVzdCBiZSByZW1vdmVkIGJ5IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCB0aGF0IHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIGF0IHdoaWNoIGEgd3JpdGUgYW5kIGFsbCBkZWVwZXIgd3JpdGVzIHNob3VsZCBiZSByZW1vdmVkXG4gICAgICogQHJldHVybiB7IUNvbXBvdW5kV3JpdGV9IFRoZSBuZXcgQ29tcG91bmRXcml0ZSB3aXRoIHRoZSByZW1vdmVkIHBhdGhcbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5yZW1vdmVXcml0ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIENvbXBvdW5kV3JpdGUuRW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3V3JpdGVUcmVlID0gdGhpcy53cml0ZVRyZWVfLnNldFRyZWUocGF0aCwgSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUuRW1wdHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZFdyaXRlKG5ld1dyaXRlVHJlZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGlzIENvbXBvdW5kV3JpdGUgd2lsbCBmdWxseSBvdmVyd3JpdGUgYSBub2RlIGF0IGEgZ2l2ZW4gbG9jYXRpb24gYW5kIGNhbiB0aGVyZWZvcmUgYmVcbiAgICAgKiBjb25zaWRlcmVkIFwiY29tcGxldGVcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGggVGhlIHBhdGggdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGVyZSBpcyBhIGNvbXBsZXRlIHdyaXRlIGF0IHRoYXQgcGF0aFxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmhhc0NvbXBsZXRlV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wbGV0ZU5vZGUocGF0aCkgIT0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBub2RlIGZvciBhIHBhdGggaWYgYW5kIG9ubHkgaWYgdGhlIG5vZGUgaXMgYSBcImNvbXBsZXRlXCIgb3ZlcndyaXRlIGF0IHRoYXQgcGF0aC4gVGhpcyB3aWxsIG5vdCBhZ2dyZWdhdGVcbiAgICAgKiB3cml0ZXMgZnJvbSBkZWVwZXIgcGF0aHMsIGJ1dCB3aWxsIHJldHVybiBjaGlsZCBub2RlcyBmcm9tIGEgbW9yZSBzaGFsbG93IHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRvIGdldCBhIGNvbXBsZXRlIHdyaXRlXG4gICAgICogQHJldHVybiB7P05vZGV9IFRoZSBub2RlIGlmIGNvbXBsZXRlIGF0IHRoYXQgcGF0aCwgb3IgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuZ2V0Q29tcGxldGVOb2RlID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgdmFyIHJvb3Rtb3N0ID0gdGhpcy53cml0ZVRyZWVfLmZpbmRSb290TW9zdFZhbHVlQW5kUGF0aChwYXRoKTtcbiAgICAgICAgaWYgKHJvb3Rtb3N0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndyaXRlVHJlZV9cbiAgICAgICAgICAgICAgICAuZ2V0KHJvb3Rtb3N0LnBhdGgpXG4gICAgICAgICAgICAgICAgLmdldENoaWxkKFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aChyb290bW9zdC5wYXRoLCBwYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY2hpbGRyZW4gdGhhdCBhcmUgZ3VhcmFudGVlZCB0byBiZSBhIGNvbXBsZXRlIG92ZXJ3cml0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyFBcnJheS48TmFtZWROb2RlPn0gQSBsaXN0IG9mIGFsbCBjb21wbGV0ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5nZXRDb21wbGV0ZUNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLndyaXRlVHJlZV8udmFsdWU7XG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGl0J3MgYSBsZWFmIG5vZGUsIGl0IGhhcyBubyBjaGlsZHJlbjsgc28gbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIGlmICghbm9kZS5pc0xlYWZOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLmZvckVhY2hDaGlsZChQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgsIGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkTmFtZSwgY2hpbGROb2RlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlVHJlZV8uY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGROYW1lLCBjaGlsZFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRUcmVlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTm9kZV8xLk5hbWVkTm9kZShjaGlsZE5hbWUsIGNoaWxkVHJlZS52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAgICAgKiBAcmV0dXJuIHshQ29tcG91bmRXcml0ZX1cbiAgICAgKi9cbiAgICBDb21wb3VuZFdyaXRlLnByb3RvdHlwZS5jaGlsZENvbXBvdW5kV3JpdGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHNoYWRvd2luZ05vZGUgPSB0aGlzLmdldENvbXBsZXRlTm9kZShwYXRoKTtcbiAgICAgICAgICAgIGlmIChzaGFkb3dpbmdOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvdW5kV3JpdGUobmV3IEltbXV0YWJsZVRyZWVfMS5JbW11dGFibGVUcmVlKHNoYWRvd2luZ05vZGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRXcml0ZSh0aGlzLndyaXRlVHJlZV8uc3VidHJlZShwYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIENvbXBvdW5kV3JpdGUgaXMgZW1wdHkgYW5kIHRoZXJlZm9yZSBkb2VzIG5vdCBtb2RpZnkgYW55IG5vZGVzLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBDb21wb3VuZFdyaXRlIGlzIGVtcHR5XG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVUcmVlXy5pc0VtcHR5KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoaXMgQ29tcG91bmRXcml0ZSB0byBhIG5vZGUuIFRoZSBub2RlIGlzIHJldHVybmVkIHdpdGggYWxsIHdyaXRlcyBmcm9tIHRoaXMgQ29tcG91bmRXcml0ZSBhcHBsaWVkIHRvIHRoZVxuICAgICAqIG5vZGVcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIGFwcGx5IHRoaXMgQ29tcG91bmRXcml0ZSB0b1xuICAgICAqIEByZXR1cm4geyFOb2RlfSBUaGUgbm9kZSB3aXRoIGFsbCB3cml0ZXMgYXBwbGllZFxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIENvbXBvdW5kV3JpdGUuYXBwbHlTdWJ0cmVlV3JpdGVfKFBhdGhfMS5QYXRoLkVtcHR5LCB0aGlzLndyaXRlVHJlZV8sIG5vZGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFDb21wb3VuZFdyaXRlfVxuICAgICAqL1xuICAgIENvbXBvdW5kV3JpdGUuRW1wdHkgPSBuZXcgQ29tcG91bmRXcml0ZShuZXcgSW1tdXRhYmxlVHJlZV8xLkltbXV0YWJsZVRyZWUobnVsbCkpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVBhdGh9IHJlbGF0aXZlUGF0aFxuICAgICAqIEBwYXJhbSB7IUltbXV0YWJsZVRyZWUuPCFOb2RlPn0gd3JpdGVUcmVlXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29tcG91bmRXcml0ZS5hcHBseVN1YnRyZWVXcml0ZV8gPSBmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUsIG5vZGUpIHtcbiAgICAgICAgaWYgKHdyaXRlVHJlZS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGVyZSBhIHdyaXRlIGlzIGFsd2F5cyBhIGxlYWYsIHdlJ3JlIGRvbmUgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIG5vZGUudXBkYXRlQ2hpbGQocmVsYXRpdmVQYXRoLCB3cml0ZVRyZWUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByaW9yaXR5V3JpdGVfMSA9IG51bGw7XG4gICAgICAgICAgICB3cml0ZVRyZWUuY2hpbGRyZW4uaW5vcmRlclRyYXZlcnNhbChmdW5jdGlvbiAoY2hpbGRLZXksIGNoaWxkVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZEtleSA9PT0gJy5wcmlvcml0eScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgcHJpb3JpdGllcyBhdCB0aGUgZW5kIHNvIHdlIGRvbid0IHVwZGF0ZSBwcmlvcml0aWVzIGZvciBlaXRoZXIgZW1wdHkgbm9kZXMgb3IgZm9yZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFwcGx5IHByaW9yaXRpZXMgdG8gZW1wdHkgbm9kZXMgdGhhdCBhcmUgbGF0ZXIgZmlsbGVkXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMi5hc3NlcnQoY2hpbGRUcmVlLnZhbHVlICE9PSBudWxsLCAnUHJpb3JpdHkgd3JpdGVzIG11c3QgYWx3YXlzIGJlIGxlYWYgbm9kZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlXcml0ZV8xID0gY2hpbGRUcmVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IENvbXBvdW5kV3JpdGUuYXBwbHlTdWJ0cmVlV3JpdGVfKHJlbGF0aXZlUGF0aC5jaGlsZChjaGlsZEtleSksIGNoaWxkVHJlZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYSBwcmlvcml0eSB3cml0ZSwgd2Ugb25seSBhcHBseSBpdCBpZiB0aGUgbm9kZSBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGlmICghbm9kZS5nZXRDaGlsZChyZWxhdGl2ZVBhdGgpLmlzRW1wdHkoKSAmJiBwcmlvcml0eVdyaXRlXzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS51cGRhdGVDaGlsZChyZWxhdGl2ZVBhdGguY2hpbGQoJy5wcmlvcml0eScpLCBwcmlvcml0eVdyaXRlXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21wb3VuZFdyaXRlO1xufSgpKTtcbmV4cG9ydHMuQ29tcG91bmRXcml0ZSA9IENvbXBvdW5kV3JpdGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvdW5kV3JpdGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvQ29tcG91bmRXcml0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4vc25hcC9DaGlsZHJlbk5vZGVcIik7XG4vKipcbiAqIE11dGFibGUgb2JqZWN0IHdoaWNoIGJhc2ljYWxseSBqdXN0IHN0b3JlcyBhIHJlZmVyZW5jZSB0byB0aGUgXCJsYXRlc3RcIiBpbW11dGFibGUgc25hcHNob3QuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTbmFwc2hvdEhvbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbmFwc2hvdEhvbGRlcigpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZV8gPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICB9XG4gICAgU25hcHNob3RIb2xkZXIucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Tm9kZV8uZ2V0Q2hpbGQocGF0aCk7XG4gICAgfTtcbiAgICBTbmFwc2hvdEhvbGRlci5wcm90b3R5cGUudXBkYXRlU25hcHNob3QgPSBmdW5jdGlvbiAocGF0aCwgbmV3U25hcHNob3ROb2RlKSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGVfID0gdGhpcy5yb290Tm9kZV8udXBkYXRlQ2hpbGQocGF0aCwgbmV3U25hcHNob3ROb2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBTbmFwc2hvdEhvbGRlcjtcbn0oKSk7XG5leHBvcnRzLlNuYXBzaG90SG9sZGVyID0gU25hcHNob3RIb2xkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNuYXBzaG90SG9sZGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1NuYXBzaG90SG9sZGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xuLyoqXG4gKiBBYnN0cmFjdGlvbiBhcm91bmQgRmlyZWJhc2VBcHAncyB0b2tlbiBmZXRjaGluZyBjYXBhYmlsaXRpZXMuXG4gKi9cbnZhciBBdXRoVG9rZW5Qcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFGaXJlYmFzZUFwcH0gYXBwX1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1dGhUb2tlblByb3ZpZGVyKGFwcF8pIHtcbiAgICAgICAgdGhpcy5hcHBfID0gYXBwXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVJlZnJlc2hcbiAgICAgKiBAcmV0dXJuIHshUHJvbWlzZTxGaXJlYmFzZUF1dGhUb2tlbkRhdGE+fVxuICAgICAqL1xuICAgIEF1dGhUb2tlblByb3ZpZGVyLnByb3RvdHlwZS5nZXRUb2tlbiA9IGZ1bmN0aW9uIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwX1snSU5URVJOQUwnXVsnZ2V0VG9rZW4nXShmb3JjZVJlZnJlc2gpLnRoZW4obnVsbCwgXG4gICAgICAgIC8vIC5jYXRjaFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgdG8gZmlndXJlIG91dCBhbGwgdGhlIGNhc2VzIHRoaXMgaXMgcmFpc2VkIGFuZCB3aGV0aGVyXG4gICAgICAgICAgICAvLyB0aGlzIG1ha2VzIHNlbnNlLlxuICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmNvZGUgPT09ICdhdXRoL3Rva2VuLW5vdC1pbml0aWFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB1dGlsXzEubG9nKCdHb3QgYXV0aC90b2tlbi1ub3QtaW5pdGlhbGl6ZWQgZXJyb3IuICBUcmVhdGluZyBhcyBudWxsIHRva2VuLicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdXRoVG9rZW5Qcm92aWRlci5wcm90b3R5cGUuYWRkVG9rZW5DaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAvLyBUT0RPOiBXZSBtaWdodCB3YW50IHRvIHdyYXAgdGhlIGxpc3RlbmVyIGFuZCBjYWxsIGl0IHdpdGggbm8gYXJncyB0b1xuICAgICAgICAvLyBhdm9pZCBhIGxlYWt5IGFic3RyYWN0aW9uLCBidXQgdGhhdCBtYWtlcyByZW1vdmluZyB0aGUgbGlzdGVuZXIgaGFyZGVyLlxuICAgICAgICB0aGlzLmFwcF9bJ0lOVEVSTkFMJ11bJ2FkZEF1dGhUb2tlbkxpc3RlbmVyJ10obGlzdGVuZXIpO1xuICAgIH07XG4gICAgQXV0aFRva2VuUHJvdmlkZXIucHJvdG90eXBlLnJlbW92ZVRva2VuQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5hcHBfWydJTlRFUk5BTCddWydyZW1vdmVBdXRoVG9rZW5MaXN0ZW5lciddKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIEF1dGhUb2tlblByb3ZpZGVyLnByb3RvdHlwZS5ub3RpZnlGb3JJbnZhbGlkVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnUHJvdmlkZWQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMgZm9yIHRoZSBhcHAgbmFtZWQgXCInICtcbiAgICAgICAgICAgIHRoaXMuYXBwXy5uYW1lICtcbiAgICAgICAgICAgICdcIiBhcmUgaW52YWxpZC4gVGhpcyB1c3VhbGx5IGluZGljYXRlcyB5b3VyIGFwcCB3YXMgbm90ICcgK1xuICAgICAgICAgICAgJ2luaXRpYWxpemVkIGNvcnJlY3RseS4gJztcbiAgICAgICAgaWYgKCdjcmVkZW50aWFsJyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJjcmVkZW50aWFsXCIgcHJvcGVydHkgcHJvdmlkZWQgdG8gaW5pdGlhbGl6ZUFwcCgpICcgK1xuICAgICAgICAgICAgICAgICAgICAnaXMgYXV0aG9yaXplZCB0byBhY2Nlc3MgdGhlIHNwZWNpZmllZCBcImRhdGFiYXNlVVJMXCIgYW5kIGlzIGZyb20gdGhlIGNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdwcm9qZWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ3NlcnZpY2VBY2NvdW50JyBpbiB0aGlzLmFwcF8ub3B0aW9ucykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJzZXJ2aWNlQWNjb3VudFwiIHByb3BlcnR5IHByb3ZpZGVkIHRvIGluaXRpYWxpemVBcHAoKSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lzIGF1dGhvcml6ZWQgdG8gYWNjZXNzIHRoZSBzcGVjaWZpZWQgXCJkYXRhYmFzZVVSTFwiIGFuZCBpcyBmcm9tIHRoZSBjb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICAgICAncHJvamVjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9XG4gICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0aGUgXCJhcGlLZXlcIiBhbmQgXCJkYXRhYmFzZVVSTFwiIHByb3BlcnRpZXMgcHJvdmlkZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICdpbml0aWFsaXplQXBwKCkgbWF0Y2ggdGhlIHZhbHVlcyBwcm92aWRlZCBmb3IgeW91ciBhcHAgYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2NvbnNvbGUuZmlyZWJhc2UuZ29vZ2xlLmNvbS8uJztcbiAgICAgICAgfVxuICAgICAgICB1dGlsXzEud2FybihlcnJvck1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhUb2tlblByb3ZpZGVyO1xufSgpKTtcbmV4cG9ydHMuQXV0aFRva2VuUHJvdmlkZXIgPSBBdXRoVG9rZW5Qcm92aWRlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXV0aFRva2VuUHJvdmlkZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvQXV0aFRva2VuUHJvdmlkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBUcmFja3MgYSBjb2xsZWN0aW9uIG9mIHN0YXRzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3RhdHNDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRzQ29sbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb3VudGVyc18gPSB7fTtcbiAgICB9XG4gICAgU3RhdHNDb2xsZWN0aW9uLnByb3RvdHlwZS5pbmNyZW1lbnRDb3VudGVyID0gZnVuY3Rpb24gKG5hbWUsIGFtb3VudCkge1xuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHsgYW1vdW50ID0gMTsgfVxuICAgICAgICBpZiAoIXV0aWxfMi5jb250YWlucyh0aGlzLmNvdW50ZXJzXywgbmFtZSkpXG4gICAgICAgICAgICB0aGlzLmNvdW50ZXJzX1tuYW1lXSA9IDA7XG4gICAgICAgIHRoaXMuY291bnRlcnNfW25hbWVdICs9IGFtb3VudDtcbiAgICB9O1xuICAgIFN0YXRzQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdXRpbF8xLmRlZXBDb3B5KHRoaXMuY291bnRlcnNfKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0c0NvbGxlY3Rpb247XG59KCkpO1xuZXhwb3J0cy5TdGF0c0NvbGxlY3Rpb24gPSBTdGF0c0NvbGxlY3Rpb247XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRzQ29sbGVjdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9zdGF0cy9TdGF0c0NvbGxlY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4uL3V0aWwvdXRpbFwiKTtcbnZhciBTdGF0c0xpc3RlbmVyXzEgPSByZXF1aXJlKFwiLi9TdGF0c0xpc3RlbmVyXCIpO1xuLy8gQXNzdW1pbmcgc29tZSBhcHBzIG1heSBoYXZlIGEgc2hvcnQgYW1vdW50IG9mIHRpbWUgb24gcGFnZSwgYW5kIGEgYnVsayBvZiBmaXJlYmFzZSBvcGVyYXRpb25zIHByb2JhYmx5XG4vLyBoYXBwZW4gb24gcGFnZSBsb2FkLCB3ZSB0cnkgdG8gcmVwb3J0IG91ciBmaXJzdCBzZXQgb2Ygc3RhdHMgcHJldHR5IHF1aWNrbHksIGJ1dCB3ZSB3YWl0IGF0IGxlYXN0IDEwXG4vLyBzZWNvbmRzIHRvIHRyeSB0byBlbnN1cmUgdGhlIEZpcmViYXNlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgLyBzZXR0bGVkLlxudmFyIEZJUlNUX1NUQVRTX01JTl9USU1FID0gMTAgKiAxMDAwO1xudmFyIEZJUlNUX1NUQVRTX01BWF9USU1FID0gMzAgKiAxMDAwO1xuLy8gV2UnbGwgY29udGludWUgdG8gcmVwb3J0IHN0YXRzIG9uIGF2ZXJhZ2UgZXZlcnkgNSBtaW51dGVzLlxudmFyIFJFUE9SVF9TVEFUU19JTlRFUlZBTCA9IDUgKiA2MCAqIDEwMDA7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU3RhdHNSZXBvcnRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBzZXJ2ZXJfXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhdHNSZXBvcnRlcihjb2xsZWN0aW9uLCBzZXJ2ZXJfKSB7XG4gICAgICAgIHRoaXMuc2VydmVyXyA9IHNlcnZlcl87XG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF8gPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0c0xpc3RlbmVyXyA9IG5ldyBTdGF0c0xpc3RlbmVyXzEuU3RhdHNMaXN0ZW5lcihjb2xsZWN0aW9uKTtcbiAgICAgICAgdmFyIHRpbWVvdXQgPSBGSVJTVF9TVEFUU19NSU5fVElNRSArXG4gICAgICAgICAgICAoRklSU1RfU1RBVFNfTUFYX1RJTUUgLSBGSVJTVF9TVEFUU19NSU5fVElNRSkgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB1dGlsXzIuc2V0VGltZW91dE5vbkJsb2NraW5nKHRoaXMucmVwb3J0U3RhdHNfLmJpbmQodGhpcyksIE1hdGguZmxvb3IodGltZW91dCkpO1xuICAgIH1cbiAgICBTdGF0c1JlcG9ydGVyLnByb3RvdHlwZS5pbmNsdWRlU3RhdCA9IGZ1bmN0aW9uIChzdGF0KSB7XG4gICAgICAgIHRoaXMuc3RhdHNUb1JlcG9ydF9bc3RhdF0gPSB0cnVlO1xuICAgIH07XG4gICAgU3RhdHNSZXBvcnRlci5wcm90b3R5cGUucmVwb3J0U3RhdHNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzTGlzdGVuZXJfLmdldCgpO1xuICAgICAgICB2YXIgcmVwb3J0ZWRTdGF0cyA9IHt9O1xuICAgICAgICB2YXIgaGF2ZVN0YXRzVG9SZXBvcnQgPSBmYWxzZTtcbiAgICAgICAgdXRpbF8xLmZvckVhY2goc3RhdHMsIGZ1bmN0aW9uIChzdGF0LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gMCAmJiB1dGlsXzEuY29udGFpbnMoX3RoaXMuc3RhdHNUb1JlcG9ydF8sIHN0YXQpKSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0ZWRTdGF0c1tzdGF0XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGhhdmVTdGF0c1RvUmVwb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXZlU3RhdHNUb1JlcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJfLnJlcG9ydFN0YXRzKHJlcG9ydGVkU3RhdHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHF1ZXVlIG91ciBuZXh0IHJ1bi5cbiAgICAgICAgdXRpbF8yLnNldFRpbWVvdXROb25CbG9ja2luZyh0aGlzLnJlcG9ydFN0YXRzXy5iaW5kKHRoaXMpLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICogUkVQT1JUX1NUQVRTX0lOVEVSVkFMKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdHNSZXBvcnRlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRzUmVwb3J0ZXIgPSBTdGF0c1JlcG9ydGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0c1JlcG9ydGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3N0YXRzL1N0YXRzUmVwb3J0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xuLyoqXG4gKiBUaGUgZXZlbnQgcXVldWUgc2VydmVzIGEgZmV3IHB1cnBvc2VzOlxuICogMS4gSXQgZW5zdXJlcyB3ZSBtYWludGFpbiBldmVudCBvcmRlciBpbiB0aGUgZmFjZSBvZiBldmVudCBjYWxsYmFja3MgZG9pbmcgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBtb3JlXG4gKiAgICBldmVudHMgYmVpbmcgcXVldWVkLlxuICogMi4gcmFpc2VRdWV1ZWRFdmVudHMoKSBoYW5kbGVzIGJlaW5nIGNhbGxlZCByZWVudHJhbnRseSBuaWNlbHkuICBUaGF0IGlzLCBpZiBpbiB0aGUgY291cnNlIG9mIHJhaXNpbmcgZXZlbnRzLFxuICogICAgcmFpc2VRdWV1ZWRFdmVudHMoKSBpcyBjYWxsZWQgYWdhaW4sIHRoZSBcImlubmVyXCIgY2FsbCB3aWxsIHBpY2sgdXAgcmFpc2luZyBldmVudHMgd2hlcmUgdGhlIFwib3V0ZXJcIiBjYWxsXG4gKiAgICBsZWZ0IG9mZiwgZW5zdXJpbmcgdGhhdCB0aGUgZXZlbnRzIGFyZSBzdGlsbCByYWlzZWQgc3luY2hyb25vdXNseSBhbmQgaW4gb3JkZXIuXG4gKiAzLiBZb3UgY2FuIHVzZSByYWlzZUV2ZW50c0F0UGF0aCBhbmQgcmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aCB0byBlbnN1cmUgb25seSByZWxldmFudCBwcmV2aW91c2x5LXF1ZXVlZFxuICogICAgZXZlbnRzIGFyZSByYWlzZWQgc3luY2hyb25vdXNseS5cbiAqXG4gKiBOT1RFOiBUaGlzIGNhbiBhbGwgZ28gYXdheSBpZi93aGVuIHdlIG1vdmUgdG8gYXN5bmMgZXZlbnRzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRXZlbnRRdWV1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudFF1ZXVlKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48RXZlbnRMaXN0Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRMaXN0c18gPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyByZWN1cnNpb24gZGVwdGggb2YgcmFpc2VRdWV1ZWRFdmVudHNfLCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7IW51bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshQXJyYXkuPEV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgbmV3IGV2ZW50cyB0byBxdWV1ZS5cbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5xdWV1ZUV2ZW50cyA9IGZ1bmN0aW9uIChldmVudERhdGFMaXN0KSB7XG4gICAgICAgIC8vIFdlIGdyb3VwIGV2ZW50cyBieSBwYXRoLCBzdG9yaW5nIHRoZW0gaW4gYSBzaW5nbGUgRXZlbnRMaXN0LCB0byBtYWtlIGl0IGVhc2llciB0byBza2lwIG92ZXIgdGhlbSBxdWlja2x5LlxuICAgICAgICB2YXIgY3Vyckxpc3QgPSBudWxsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSBldmVudERhdGFMaXN0W2ldO1xuICAgICAgICAgICAgdmFyIGV2ZW50UGF0aCA9IGV2ZW50RGF0YS5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY3Vyckxpc3QgIT09IG51bGwgJiYgIWV2ZW50UGF0aC5lcXVhbHMoY3Vyckxpc3QuZ2V0UGF0aCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XG4gICAgICAgICAgICAgICAgY3Vyckxpc3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3Vyckxpc3QgPSBuZXcgRXZlbnRMaXN0KGV2ZW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyTGlzdC5hZGQoZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3Vyckxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c18ucHVzaChjdXJyTGlzdCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFF1ZXVlcyB0aGUgc3BlY2lmaWVkIGV2ZW50cyBhbmQgc3luY2hyb25vdXNseSByYWlzZXMgYWxsIGV2ZW50cyAoaW5jbHVkaW5nIHByZXZpb3VzbHkgcXVldWVkIG9uZXMpXG4gICAgICogZm9yIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgbmV3IGV2ZW50cyBhcmUgYWxsIGZvciB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRvIHJhaXNlIGV2ZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHshQXJyYXkuPEV2ZW50Pn0gZXZlbnREYXRhTGlzdCBUaGUgbmV3IGV2ZW50cyB0byByYWlzZS5cbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZUV2ZW50c0F0UGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBldmVudERhdGFMaXN0KSB7XG4gICAgICAgIHRoaXMucXVldWVFdmVudHMoZXZlbnREYXRhTGlzdCk7XG4gICAgICAgIHRoaXMucmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8oZnVuY3Rpb24gKGV2ZW50UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UGF0aC5lcXVhbHMocGF0aCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUXVldWVzIHRoZSBzcGVjaWZpZWQgZXZlbnRzIGFuZCBzeW5jaHJvbm91c2x5IHJhaXNlcyBhbGwgZXZlbnRzIChpbmNsdWRpbmcgcHJldmlvdXNseSBxdWV1ZWQgb25lcykgZm9yXG4gICAgICogbG9jYXRpb25zIHJlbGF0ZWQgdG8gdGhlIHNwZWNpZmllZCBjaGFuZ2UgcGF0aCAoaS5lLiBhbGwgYW5jZXN0b3JzIGFuZCBkZXNjZW5kYW50cykuXG4gICAgICpcbiAgICAgKiBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG5ldyBldmVudHMgYXJlIGFsbCByZWxhdGVkIChhbmNlc3RvciBvciBkZXNjZW5kYW50KSB0byB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFQYXRofSBjaGFuZ2VkUGF0aCBUaGUgcGF0aCB0byByYWlzZSBldmVudHMgZm9yLlxuICAgICAqIEBwYXJhbSB7IUFycmF5LjwhRXZlbnQ+fSBldmVudERhdGFMaXN0IFRoZSBldmVudHMgdG8gcmFpc2VcbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoID0gZnVuY3Rpb24gKGNoYW5nZWRQYXRoLCBldmVudERhdGFMaXN0KSB7XG4gICAgICAgIHRoaXMucXVldWVFdmVudHMoZXZlbnREYXRhTGlzdCk7XG4gICAgICAgIHRoaXMucmFpc2VRdWV1ZWRFdmVudHNNYXRjaGluZ1ByZWRpY2F0ZV8oZnVuY3Rpb24gKGV2ZW50UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50UGF0aC5jb250YWlucyhjaGFuZ2VkUGF0aCkgfHwgY2hhbmdlZFBhdGguY29udGFpbnMoZXZlbnRQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFmdW5jdGlvbighUGF0aCk6Ym9vbGVhbn0gcHJlZGljYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBFdmVudFF1ZXVlLnByb3RvdHlwZS5yYWlzZVF1ZXVlZEV2ZW50c01hdGNoaW5nUHJlZGljYXRlXyA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgdGhpcy5yZWN1cnNpb25EZXB0aF8rKztcbiAgICAgICAgdmFyIHNlbnRBbGwgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRMaXN0c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudExpc3QgPSB0aGlzLmV2ZW50TGlzdHNfW2ldO1xuICAgICAgICAgICAgaWYgKGV2ZW50TGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciBldmVudFBhdGggPSBldmVudExpc3QuZ2V0UGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZXZlbnRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50TGlzdHNfW2ldLnJhaXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0c19baV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VudEFsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VudEFsbCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RzXyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVjdXJzaW9uRGVwdGhfLS07XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRRdWV1ZTtcbn0oKSk7XG5leHBvcnRzLkV2ZW50UXVldWUgPSBFdmVudFF1ZXVlO1xuLyoqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50TGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudExpc3QocGF0aF8pIHtcbiAgICAgICAgdGhpcy5wYXRoXyA9IHBhdGhfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFBcnJheS48RXZlbnQ+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHNfID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudERhdGFcbiAgICAgKi9cbiAgICBFdmVudExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChldmVudERhdGEpIHtcbiAgICAgICAgdGhpcy5ldmVudHNfLnB1c2goZXZlbnREYXRhKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGxpc3QgYW5kIHJhaXNlcyBlYWNoIGV2ZW50XG4gICAgICovXG4gICAgRXZlbnRMaXN0LnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50c18ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBldmVudERhdGEgPSB0aGlzLmV2ZW50c19baV07XG4gICAgICAgICAgICBpZiAoZXZlbnREYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNfW2ldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRGbiA9IGV2ZW50RGF0YS5nZXRFdmVudFJ1bm5lcigpO1xuICAgICAgICAgICAgICAgIGlmICh1dGlsXzEubG9nZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5sb2coJ2V2ZW50OiAnICsgZXZlbnREYXRhLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1dGlsXzEuZXhjZXB0aW9uR3VhcmQoZXZlbnRGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFQYXRofVxuICAgICAqL1xuICAgIEV2ZW50TGlzdC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aF87XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRMaXN0O1xufSgpKTtcbmV4cG9ydHMuRXZlbnRMaXN0ID0gRXZlbnRMaXN0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFF1ZXVlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvRXZlbnRRdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudEVtaXR0ZXJcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG52YXIgVmlzaWJpbGl0eU1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFZpc2liaWxpdHlNb25pdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpc2liaWxpdHlNb25pdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbJ3Zpc2libGUnXSkgfHwgdGhpcztcbiAgICAgICAgdmFyIGhpZGRlbjtcbiAgICAgICAgdmFyIHZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRbJ2hpZGRlbiddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbW96SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtb3p2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnbW96SGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnbXNIaWRkZW4nXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ21zdmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudFsnd2Via2l0SGlkZGVuJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICAgICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsbHksIHdlIGFsd2F5cyBhc3N1bWUgd2UgYXJlIHZpc2libGUuIFRoaXMgZW5zdXJlcyB0aGF0IGluIGJyb3dzZXJzXG4gICAgICAgIC8vIHdpdGhvdXQgcGFnZSB2aXNpYmlsaXR5IHN1cHBvcnQgb3IgaW4gY2FzZXMgd2hlcmUgd2UgYXJlIG5ldmVyIHZpc2libGVcbiAgICAgICAgLy8gKGUuZy4gY2hyb21lIGV4dGVuc2lvbiksIHdlIGFjdCBhcyBpZiB3ZSBhcmUgdmlzaWJsZSwgaS5lLiBkb24ndCBkZWxheVxuICAgICAgICAvLyByZWNvbm5lY3RzXG4gICAgICAgIF90aGlzLnZpc2libGVfID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZpc2liaWxpdHlDaGFuZ2UpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodmlzaWJpbGl0eUNoYW5nZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2aXNpYmxlID0gIWRvY3VtZW50W2hpZGRlbl07XG4gICAgICAgICAgICAgICAgaWYgKHZpc2libGUgIT09IF90aGlzLnZpc2libGVfKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnZpc2libGVfID0gdmlzaWJsZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJpZ2dlcigndmlzaWJsZScsIHZpc2libGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFZpc2liaWxpdHlNb25pdG9yLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFZpc2liaWxpdHlNb25pdG9yKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGV2ZW50VHlwZVxuICAgICAqIEByZXR1cm4ge0FycmF5Ljxib29sZWFuPn1cbiAgICAgKi9cbiAgICBWaXNpYmlsaXR5TW9uaXRvci5wcm90b3R5cGUuZ2V0SW5pdGlhbEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50VHlwZSkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KGV2ZW50VHlwZSA9PT0gJ3Zpc2libGUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnZpc2libGVfXTtcbiAgICB9O1xuICAgIHJldHVybiBWaXNpYmlsaXR5TW9uaXRvcjtcbn0oRXZlbnRFbWl0dGVyXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLlZpc2liaWxpdHlNb25pdG9yID0gVmlzaWJpbGl0eU1vbml0b3I7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZpc2liaWxpdHlNb25pdG9yLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvVmlzaWJpbGl0eU1vbml0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RW1pdHRlclwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG4vKipcbiAqIE1vbml0b3JzIG9ubGluZSBzdGF0ZSAoYXMgcmVwb3J0ZWQgYnkgd2luZG93Lm9ubGluZS9vZmZsaW5lIGV2ZW50cykuXG4gKlxuICogVGhlIGV4cGVjdGF0aW9uIGlzIHRoYXQgdGhpcyBjb3VsZCBoYXZlIG1hbnkgZmFsc2UgcG9zaXRpdmVzICh0aGlua3Mgd2UgYXJlIG9ubGluZVxuICogd2hlbiB3ZSdyZSBub3QpLCBidXQgbm8gZmFsc2UgbmVnYXRpdmVzLiAgU28gd2UgY2FuIHNhZmVseSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZW5cbiAqIHdlIGRlZmluaXRlbHkgY2Fubm90IHJlYWNoIHRoZSBpbnRlcm5ldC5cbiAqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG52YXIgT25saW5lTW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT25saW5lTW9uaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPbmxpbmVNb25pdG9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBbJ29ubGluZSddKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5vbmxpbmVfID0gdHJ1ZTtcbiAgICAgICAgLy8gV2UndmUgaGFkIHJlcGVhdGVkIGNvbXBsYWludHMgdGhhdCBDb3Jkb3ZhIGFwcHMgY2FuIGdldCBzdHVjayBcIm9mZmxpbmVcIiwgZS5nLlxuICAgICAgICAvLyBodHRwczovL2ZvcnVtLmlvbmljZnJhbWV3b3JrLmNvbS90L2ZpcmViYXNlLWNvbm5lY3Rpb24taXMtbG9zdC1hbmQtbmV2ZXItY29tZS1iYWNrLzQzODEwXG4gICAgICAgIC8vIEl0IHdvdWxkIHNlZW0gdGhhdCB0aGUgJ29ubGluZScgZXZlbnQgZG9lcyBub3QgYWx3YXlzIGZpcmUgY29uc2lzdGVudGx5LiBTbyB3ZSBkaXNhYmxlIGl0XG4gICAgICAgIC8vIGZvciBDb3Jkb3ZhLlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICF1dGlsXzIuaXNNb2JpbGVDb3Jkb3ZhKCkpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vbmxpbmVfKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9ubGluZV8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub25saW5lXykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbmxpbmVfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ29ubGluZScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPbmxpbmVNb25pdG9yLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE9ubGluZU1vbml0b3IoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30gZXZlbnRUeXBlXG4gICAgICogQHJldHVybiB7QXJyYXkuPGJvb2xlYW4+fVxuICAgICAqL1xuICAgIE9ubGluZU1vbml0b3IucHJvdG90eXBlLmdldEluaXRpYWxFdmVudCA9IGZ1bmN0aW9uIChldmVudFR5cGUpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydChldmVudFR5cGUgPT09ICdvbmxpbmUnLCAnVW5rbm93biBldmVudCB0eXBlOiAnICsgZXZlbnRUeXBlKTtcbiAgICAgICAgcmV0dXJuIFt0aGlzLm9ubGluZV9dO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBPbmxpbmVNb25pdG9yLnByb3RvdHlwZS5jdXJyZW50bHlPbmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ubGluZV87XG4gICAgfTtcbiAgICByZXR1cm4gT25saW5lTW9uaXRvcjtcbn0oRXZlbnRFbWl0dGVyXzEuRXZlbnRFbWl0dGVyKSk7XG5leHBvcnRzLk9ubGluZU1vbml0b3IgPSBPbmxpbmVNb25pdG9yO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PbmxpbmVNb25pdG9yLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3V0aWwvT25saW5lTW9uaXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEJyb3dzZXJQb2xsQ29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4vQnJvd3NlclBvbGxDb25uZWN0aW9uXCIpO1xudmFyIFdlYlNvY2tldENvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuL1dlYlNvY2tldENvbm5lY3Rpb25cIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbC91dGlsXCIpO1xuLyoqXG4gKiBDdXJyZW50bHkgc2ltcGxpc3RpYywgdGhpcyBjbGFzcyBtYW5hZ2VzIHdoYXQgdHJhbnNwb3J0IGEgQ29ubmVjdGlvbiBzaG91bGQgdXNlIGF0IHZhcmlvdXMgc3RhZ2VzIG9mIGl0c1xuICogbGlmZWN5Y2xlLlxuICpcbiAqIEl0IHN0YXJ0cyB3aXRoIGxvbmdwb2xsaW5nIGluIGEgYnJvd3NlciwgYW5kIGh0dHBwb2xsaW5nIG9uIG5vZGUuIEl0IHRoZW4gdXBncmFkZXMgdG8gd2Vic29ja2V0cyBpZlxuICogdGhleSBhcmUgYXZhaWxhYmxlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUcmFuc3BvcnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mbyBNZXRhZGF0YSBhcm91bmQgdGhlIG5hbWVzcGFjZSB3ZSdyZSBjb25uZWN0aW5nIHRvXG4gICAgICovXG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0TWFuYWdlcihyZXBvSW5mbykge1xuICAgICAgICB0aGlzLmluaXRUcmFuc3BvcnRzXyhyZXBvSW5mbyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc3BvcnRNYW5hZ2VyLCBcIkFMTF9UUkFOU1BPUlRTXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBjb25zdFxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5LjxmdW5jdGlvbihuZXc6VHJhbnNwb3J0LCBzdHJpbmcsIFJlcG9JbmZvLCBzdHJpbmc9KT59XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbQnJvd3NlclBvbGxDb25uZWN0aW9uXzEuQnJvd3NlclBvbGxDb25uZWN0aW9uLCBXZWJTb2NrZXRDb25uZWN0aW9uXzEuV2ViU29ja2V0Q29ubmVjdGlvbl07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgVHJhbnNwb3J0TWFuYWdlci5wcm90b3R5cGUuaW5pdFRyYW5zcG9ydHNfID0gZnVuY3Rpb24gKHJlcG9JbmZvKSB7XG4gICAgICAgIHZhciBpc1dlYlNvY2tldHNBdmFpbGFibGUgPSBXZWJTb2NrZXRDb25uZWN0aW9uXzEuV2ViU29ja2V0Q29ubmVjdGlvbiAmJiBXZWJTb2NrZXRDb25uZWN0aW9uXzEuV2ViU29ja2V0Q29ubmVjdGlvblsnaXNBdmFpbGFibGUnXSgpO1xuICAgICAgICB2YXIgaXNTa2lwUG9sbENvbm5lY3Rpb24gPSBpc1dlYlNvY2tldHNBdmFpbGFibGUgJiYgIVdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uLnByZXZpb3VzbHlGYWlsZWQoKTtcbiAgICAgICAgaWYgKHJlcG9JbmZvLndlYlNvY2tldE9ubHkpIHtcbiAgICAgICAgICAgIGlmICghaXNXZWJTb2NrZXRzQXZhaWxhYmxlKVxuICAgICAgICAgICAgICAgIHV0aWxfMS53YXJuKFwid3NzOi8vIFVSTCB1c2VkLCBidXQgYnJvd3NlciBpc24ndCBrbm93biB0byBzdXBwb3J0IHdlYnNvY2tldHMuICBUcnlpbmcgYW55d2F5LlwiKTtcbiAgICAgICAgICAgIGlzU2tpcFBvbGxDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTa2lwUG9sbENvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0c18gPSBbV2ViU29ja2V0Q29ubmVjdGlvbl8xLldlYlNvY2tldENvbm5lY3Rpb25dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydHNfMSA9ICh0aGlzLnRyYW5zcG9ydHNfID0gW10pO1xuICAgICAgICAgICAgdXRpbF8xLmVhY2goVHJhbnNwb3J0TWFuYWdlci5BTExfVFJBTlNQT1JUUywgZnVuY3Rpb24gKGksIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdHJhbnNwb3J0Wydpc0F2YWlsYWJsZSddKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0c18xLnB1c2godHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRyYW5zcG9ydCwgIXN0cmluZywgIVJlcG9JbmZvLCBzdHJpbmc9LCBzdHJpbmc9KX0gVGhlIGNvbnN0cnVjdG9yIGZvciB0aGVcbiAgICAgKiBpbml0aWFsIHRyYW5zcG9ydCB0byB1c2VcbiAgICAgKi9cbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS5pbml0aWFsVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P2Z1bmN0aW9uKG5ldzpUcmFuc3BvcnQsIGZ1bmN0aW9uKCksZnVuY3Rpb24oKSwgc3RyaW5nPSl9IFRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5leHRcbiAgICAgKiB0cmFuc3BvcnQsIG9yIG51bGxcbiAgICAgKi9cbiAgICBUcmFuc3BvcnRNYW5hZ2VyLnByb3RvdHlwZS51cGdyYWRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzXy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRzX1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNwb3J0TWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9ydE1hbmFnZXIgPSBUcmFuc3BvcnRNYW5hZ2VyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc3BvcnRNYW5hZ2VyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9yZWFsdGltZS9UcmFuc3BvcnRNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbC91dGlsXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGVuc3VyZXMgdGhlIHBhY2tldHMgZnJvbSB0aGUgc2VydmVyIGFycml2ZSBpbiBvcmRlclxuICogVGhpcyBjbGFzcyB0YWtlcyBkYXRhIGZyb20gdGhlIHNlcnZlciBhbmQgZW5zdXJlcyBpdCBnZXRzIHBhc3NlZCBpbnRvIHRoZSBjYWxsYmFja3MgaW4gb3JkZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBhY2tldFJlY2VpdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbk1lc3NhZ2VfXG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFja2V0UmVjZWl2ZXIob25NZXNzYWdlXykge1xuICAgICAgICB0aGlzLm9uTWVzc2FnZV8gPSBvbk1lc3NhZ2VfO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVzcG9uc2VOdW0gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA9IC0xO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSBudWxsO1xuICAgIH1cbiAgICBQYWNrZXRSZWNlaXZlci5wcm90b3R5cGUuY2xvc2VBZnRlciA9IGZ1bmN0aW9uIChyZXNwb25zZU51bSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jbG9zZUFmdGVyUmVzcG9uc2UgPSByZXNwb25zZU51bTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlQWZ0ZXJSZXNwb25zZSA8IHRoaXMuY3VycmVudFJlc3BvbnNlTnVtKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVhY2ggbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXIgY29tZXMgd2l0aCBhIHJlc3BvbnNlIG51bWJlciwgYW5kIGFuIGFycmF5IG9mIGRhdGEuIFRoZSByZXNwb25zZU51bWJlclxuICAgICAqIGFsbG93cyB1cyB0byBlbnN1cmUgdGhhdCB3ZSBwcm9jZXNzIHRoZW0gaW4gdGhlIHJpZ2h0IG9yZGVyLCBzaW5jZSB3ZSBjYW4ndCBiZSBndWFyYW50ZWVkIHRoYXQgYWxsXG4gICAgICogYnJvd3NlcnMgd2lsbCByZXNwb25kIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSByZXF1ZXN0cyB3ZSBzZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlcXVlc3ROdW1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkYXRhXG4gICAgICovXG4gICAgUGFja2V0UmVjZWl2ZXIucHJvdG90eXBlLmhhbmRsZVJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcXVlc3ROdW0sIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wZW5kaW5nUmVzcG9uc2VzW3JlcXVlc3ROdW1dID0gZGF0YTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9Qcm9jZXNzID0gdGhpc18xLnBlbmRpbmdSZXNwb25zZXNbdGhpc18xLmN1cnJlbnRSZXNwb25zZU51bV07XG4gICAgICAgICAgICBkZWxldGUgdGhpc18xLnBlbmRpbmdSZXNwb25zZXNbdGhpc18xLmN1cnJlbnRSZXNwb25zZU51bV07XG4gICAgICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvUHJvY2Vzc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZXhjZXB0aW9uR3VhcmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25NZXNzYWdlXyh0b1Byb2Nlc3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1Byb2Nlc3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBfbG9vcF8yKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNfMS5jdXJyZW50UmVzcG9uc2VOdW0gPT09IHRoaXNfMS5jbG9zZUFmdGVyUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc18xLm9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc18xLm9uQ2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc18xLmN1cnJlbnRSZXNwb25zZU51bSsrO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ1Jlc3BvbnNlc1t0aGlzLmN1cnJlbnRSZXNwb25zZU51bV0pIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICAgICAgaWYgKHN0YXRlXzEgPT09IFwiYnJlYWtcIilcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhY2tldFJlY2VpdmVyO1xufSgpKTtcbmV4cG9ydHMuUGFja2V0UmVjZWl2ZXIgPSBQYWNrZXRSZWNlaXZlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFja2V0UmVjZWl2ZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL3JlYWx0aW1lL3BvbGxpbmcvUGFja2V0UmVjZWl2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi91dGlsL3V0aWxcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIHV0aWxfNCA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzUgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgU2VydmVyQWN0aW9uc18xID0gcmVxdWlyZShcIi4vU2VydmVyQWN0aW9uc1wiKTtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgU2VydmVyQWN0aW9ucyB0aGF0IGNvbW11bmljYXRlcyB3aXRoIHRoZSBzZXJ2ZXIgdmlhIFJFU1QgcmVxdWVzdHMuXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBjcmF3bGVycywgd2hlcmUgd2UgZG9uJ3Qgd2FudCB0byBzcGluIHVwIGEgZnVsbFxuICogcGVyc2lzdGVudCBjb25uZWN0aW9uICh1c2luZyBXZWJTb2NrZXRzIG9yIGxvbmctcG9sbGluZylcbiAqL1xudmFyIFJlYWRvbmx5UmVzdENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVhZG9ubHlSZXN0Q2xpZW50LCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVJlcG9JbmZvfSByZXBvSW5mb18gRGF0YSBhYm91dCB0aGUgbmFtZXNwYWNlIHdlIGFyZSBjb25uZWN0aW5nIHRvXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsICosIGJvb2xlYW4sID9udW1iZXIpfSBvbkRhdGFVcGRhdGVfIEEgY2FsbGJhY2sgZm9yIG5ldyBkYXRhIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwYXJhbSB7QXV0aFRva2VuUHJvdmlkZXJ9IGF1dGhUb2tlblByb3ZpZGVyX1xuICAgICAqIEBpbXBsZW1lbnRzIHtTZXJ2ZXJBY3Rpb25zfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlYWRvbmx5UmVzdENsaWVudChyZXBvSW5mb18sIG9uRGF0YVVwZGF0ZV8sIGF1dGhUb2tlblByb3ZpZGVyXykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXBvSW5mb18gPSByZXBvSW5mb187XG4gICAgICAgIF90aGlzLm9uRGF0YVVwZGF0ZV8gPSBvbkRhdGFVcGRhdGVfO1xuICAgICAgICBfdGhpcy5hdXRoVG9rZW5Qcm92aWRlcl8gPSBhdXRoVG9rZW5Qcm92aWRlcl87XG4gICAgICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oLi4uWypdKX0gKi9cbiAgICAgICAgX3RoaXMubG9nXyA9IHV0aWxfMi5sb2dXcmFwcGVyKCdwOnJlc3Q6Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBkb24ndCBhY3R1YWxseSBuZWVkIHRvIHRyYWNrIGxpc3RlbnMsIGV4Y2VwdCB0byBwcmV2ZW50IHVzIGNhbGxpbmcgYW4gb25Db21wbGV0ZSBmb3IgYSBsaXN0ZW5cbiAgICAgICAgICogdGhhdCdzIGJlZW4gcmVtb3ZlZC4gOi0vXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlIHshT2JqZWN0LjxzdHJpbmcsICFPYmplY3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGlzdGVuc18gPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWFkb25seVJlc3RDbGllbnQucHJvdG90eXBlLnJlcG9ydFN0YXRzID0gZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICAgICAqIEBwYXJhbSB7P251bWJlcj19IHRhZ1xuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8gPSBmdW5jdGlvbiAocXVlcnksIHRhZykge1xuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAndGFnJCcgKyB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1dGlsXzEuYXNzZXJ0KHF1ZXJ5LmdldFF1ZXJ5UGFyYW1zKCkuaXNEZWZhdWx0KCksIFwic2hvdWxkIGhhdmUgYSB0YWcgaWYgaXQncyBub3QgYSBkZWZhdWx0IHF1ZXJ5LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKHF1ZXJ5LCBjdXJyZW50SGFzaEZuLCB0YWcsIG9uQ29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBxdWVyeS5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMubG9nXygnTGlzdGVuIGNhbGxlZCBmb3IgJyArIHBhdGhTdHJpbmcgKyAnICcgKyBxdWVyeS5xdWVyeUlkZW50aWZpZXIoKSk7XG4gICAgICAgIC8vIE1hcmsgdGhpcyBsaXN0ZW5lciBzbyB3ZSBjYW4gdGVsbCBpZiBpdCdzIHJlbW92ZWQuXG4gICAgICAgIHZhciBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XG4gICAgICAgIHZhciB0aGlzTGlzdGVuID0ge307XG4gICAgICAgIHRoaXMubGlzdGVuc19bbGlzdGVuSWRdID0gdGhpc0xpc3RlbjtcbiAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nUGFyYW1hdGVycyA9IHF1ZXJ5XG4gICAgICAgICAgICAuZ2V0UXVlcnlQYXJhbXMoKVxuICAgICAgICAgICAgLnRvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycygpO1xuICAgICAgICB0aGlzLnJlc3RSZXF1ZXN0XyhwYXRoU3RyaW5nICsgJy5qc29uJywgcXVlcnlTdHJpbmdQYXJhbWF0ZXJzLCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YVVwZGF0ZV8ocGF0aFN0cmluZywgZGF0YSwgLyppc01lcmdlPSovIGZhbHNlLCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHV0aWxfNC5zYWZlR2V0KF90aGlzLmxpc3RlbnNfLCBsaXN0ZW5JZCkgPT09IHRoaXNMaXN0ZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzXzE7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9ICdvayc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9ICdwZXJtaXNzaW9uX2RlbmllZCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9ICdyZXN0X2Vycm9yOicgKyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZShzdGF0dXNfMSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gICAgUmVhZG9ubHlSZXN0Q2xpZW50LnByb3RvdHlwZS51bmxpc3RlbiA9IGZ1bmN0aW9uIChxdWVyeSwgdGFnKSB7XG4gICAgICAgIHZhciBsaXN0ZW5JZCA9IFJlYWRvbmx5UmVzdENsaWVudC5nZXRMaXN0ZW5JZF8ocXVlcnksIHRhZyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbnNfW2xpc3RlbklkXTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIFJlYWRvbmx5UmVzdENsaWVudC5wcm90b3R5cGUucmVmcmVzaEF1dGhUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAvLyBuby1vcCBzaW5jZSB3ZSBqdXN0IGFsd2F5cyBjYWxsIGdldFRva2VuLlxuICAgIH07XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBSRVNUIHJlcXVlc3QgdG8gdGhlIGdpdmVuIHBhdGgsIHdpdGggdGhlIHByb3ZpZGVkIHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzLFxuICAgICAqIGFuZCBhbnkgYXV0aCBjcmVkZW50aWFscyB3ZSBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshc3RyaW5nfSBwYXRoU3RyaW5nXG4gICAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsICo+fSBxdWVyeVN0cmluZ1BhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbig/bnVtYmVyLCAqPSl9IGNhbGxiYWNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBSZWFkb25seVJlc3RDbGllbnQucHJvdG90eXBlLnJlc3RSZXF1ZXN0XyA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBxdWVyeVN0cmluZ1BhcmFtZXRlcnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPT09IHZvaWQgMCkgeyBxdWVyeVN0cmluZ1BhcmFtZXRlcnMgPSB7fTsgfVxuICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2Zvcm1hdCddID0gJ2V4cG9ydCc7XG4gICAgICAgIHRoaXMuYXV0aFRva2VuUHJvdmlkZXJfXG4gICAgICAgICAgICAuZ2V0VG9rZW4oLypmb3JjZVJlZnJlc2g9Ki8gZmFsc2UpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoYXV0aFRva2VuRGF0YSkge1xuICAgICAgICAgICAgdmFyIGF1dGhUb2tlbiA9IGF1dGhUb2tlbkRhdGEgJiYgYXV0aFRva2VuRGF0YS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIGlmIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBxdWVyeVN0cmluZ1BhcmFtZXRlcnNbJ2F1dGgnXSA9IGF1dGhUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB1cmwgPSAoX3RoaXMucmVwb0luZm9fLnNlY3VyZSA/ICdodHRwczovLycgOiAnaHR0cDovLycpICtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBvSW5mb18uaG9zdCArXG4gICAgICAgICAgICAgICAgcGF0aFN0cmluZyArXG4gICAgICAgICAgICAgICAgJz8nICtcbiAgICAgICAgICAgICAgICB1dGlsXzUucXVlcnlzdHJpbmcocXVlcnlTdHJpbmdQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIF90aGlzLmxvZ18oJ1NlbmRpbmcgUkVTVCByZXF1ZXN0IGZvciAnICsgdXJsKTtcbiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxvZ18oJ1JFU1QgUmVzcG9uc2UgZm9yICcgKyB1cmwgKyAnIHJlY2VpdmVkLiBzdGF0dXM6JywgeGhyLnN0YXR1cywgJ3Jlc3BvbnNlOicsIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdXRpbF8zLmpzb25FdmFsKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzIud2FybignRmFpbGVkIHRvIHBhcnNlIEpTT04gcmVzcG9uc2UgZm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDAxIGFuZCA0MDQgYXJlIGV4cGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgIT09IDQwMSAmJiB4aHIuc3RhdHVzICE9PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGlsXzIud2FybignR290IHVuc3VjY2Vzc2Z1bCBSRVNUIHJlc3BvbnNlIGZvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBTdGF0dXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHhoci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgLyphc3luY2hyb25vdXM9Ki8gdHJ1ZSk7XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFkb25seVJlc3RDbGllbnQ7XG59KFNlcnZlckFjdGlvbnNfMS5TZXJ2ZXJBY3Rpb25zKSk7XG5leHBvcnRzLlJlYWRvbmx5UmVzdENsaWVudCA9IFJlYWRvbmx5UmVzdENsaWVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhZG9ubHlSZXN0Q2xpZW50LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL1JlYWRvbmx5UmVzdENsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciB1dGlsXzIgPSByZXF1aXJlKFwiLi4vdXRpbC91dGlsXCIpO1xudmFyIEtleUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL0tleUluZGV4XCIpO1xudmFyIFByaW9yaXR5SW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9zbmFwL2luZGV4ZXMvUHJpb3JpdHlJbmRleFwiKTtcbnZhciBWYWx1ZUluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1ZhbHVlSW5kZXhcIik7XG52YXIgUGF0aEluZGV4XzEgPSByZXF1aXJlKFwiLi4vc25hcC9pbmRleGVzL1BhdGhJbmRleFwiKTtcbnZhciBJbmRleGVkRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXIvSW5kZXhlZEZpbHRlclwiKTtcbnZhciBMaW1pdGVkRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXIvTGltaXRlZEZpbHRlclwiKTtcbnZhciBSYW5nZWRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlci9SYW5nZWRGaWx0ZXJcIik7XG52YXIgdXRpbF8zID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGFuIGltbXV0YWJsZS1mcm9tLXRoZS1wdWJsaWMtYXBpIHN0cnVjdCBjb250YWluaW5nIGEgc2V0IG9mIHF1ZXJ5IHBhcmFtZXRlcnMgZGVmaW5pbmcgYVxuICogcmFuZ2UgdG8gYmUgcmV0dXJuZWQgZm9yIGEgcGFydGljdWxhciBsb2NhdGlvbi4gSXQgaXMgYXNzdW1lZCB0aGF0IHZhbGlkYXRpb24gb2YgcGFyYW1ldGVycyBpcyBkb25lIGF0IHRoZVxuICogdXNlci1mYWNpbmcgQVBJIGxldmVsLCBzbyBpdCBpcyBub3QgZG9uZSBoZXJlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBRdWVyeVBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWVyeVBhcmFtcygpIHtcbiAgICAgICAgdGhpcy5saW1pdFNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydFNldF8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFydE5hbWVTZXRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kU2V0XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuZE5hbWVTZXRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGltaXRfID0gMDtcbiAgICAgICAgdGhpcy52aWV3RnJvbV8gPSAnJztcbiAgICAgICAgdGhpcy5pbmRleFN0YXJ0VmFsdWVfID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcbiAgICAgICAgdGhpcy5pbmRleEVuZFZhbHVlXyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhFbmROYW1lXyA9ICcnO1xuICAgICAgICB0aGlzLmluZGV4XyA9IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuaGFzU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0U2V0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaXQgd291bGQgcmV0dXJuIGZyb20gbGVmdC5cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuaXNWaWV3RnJvbUxlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdGcm9tXyA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIGxpbWl0KCksIHJhdGhlciB0aGFuIGxpbWl0VG9GaXJzdCBvciBsaW1pdFRvTGFzdCB3YXMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IG9ubHkgb25lIG9mIHN0YXJ0U2V0XyBhbmQgZW5kU2V0XyBpcyB0cnVlLiBVc2UgdGhlbVxuICAgICAgICAgICAgLy8gdG8gY2FsY3VsYXRlIHdoaWNoIHNpZGUgb2YgdGhlIHZpZXcgdG8gYW5jaG9yIHRvLiBJZiBuZWl0aGVyIGlzIHNldCxcbiAgICAgICAgICAgIC8vIGFuY2hvciB0byB0aGUgZW5kLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRTZXRfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZpZXdGcm9tXyA9PT0gUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfLlZJRVdfRlJPTV9MRUZUKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc1N0YXJ0KCkgcmV0dXJucyB0cnVlXG4gICAgICogQHJldHVybiB7Kn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXhTdGFydFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydFZhbHVlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNTdGFydCgpIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBzdGFydGluZyBrZXkgbmFtZSBmb3IgdGhlIHJhbmdlIGRlZmluZWQgYnkgdGhlc2UgcXVlcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4geyFzdHJpbmd9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldEluZGV4U3RhcnROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuc3RhcnRTZXRfLCAnT25seSB2YWxpZCBpZiBzdGFydCBoYXMgYmVlbiBzZXQnKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhTdGFydE5hbWVfO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMi5NSU5fTkFNRTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuaGFzRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRTZXRfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT25seSB2YWxpZCB0byBjYWxsIGlmIGhhc0VuZCgpIHJldHVybnMgdHJ1ZS5cbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXRJbmRleEVuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEVuZFZhbHVlXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE9ubHkgdmFsaWQgdG8gY2FsbCBpZiBoYXNFbmQoKSByZXR1cm5zIHRydWUuXG4gICAgICogUmV0dXJucyB0aGUgZW5kIGtleSBuYW1lIGZvciB0aGUgcmFuZ2UgZGVmaW5lZCBieSB0aGVzZSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybiB7IXN0cmluZ31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXhFbmROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHRoaXMuZW5kU2V0XywgJ09ubHkgdmFsaWQgaWYgZW5kIGhhcyBiZWVuIHNldCcpO1xuICAgICAgICBpZiAodGhpcy5lbmROYW1lU2V0Xykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhFbmROYW1lXztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzIuTUFYX05BTUU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmhhc0xpbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW1pdFNldF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgbGltaXQgaGFzIGJlZW4gc2V0IGFuZCBpdCBoYXMgYmVlbiBleHBsaWNpdGx5IGFuY2hvcmVkXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmhhc0FuY2hvcmVkTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0U2V0XyAmJiB0aGlzLnZpZXdGcm9tXyAhPT0gJyc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPbmx5IHZhbGlkIHRvIGNhbGwgaWYgaGFzTGltaXQoKSByZXR1cm5zIHRydWVcbiAgICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXRMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbF8xLmFzc2VydCh0aGlzLmxpbWl0U2V0XywgJ09ubHkgdmFsaWQgaWYgbGltaXQgaGFzIGJlZW4gc2V0Jyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbWl0XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFJbmRleH1cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5jb3B5XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBuZXcgUXVlcnlQYXJhbXMoKTtcbiAgICAgICAgY29weS5saW1pdFNldF8gPSB0aGlzLmxpbWl0U2V0XztcbiAgICAgICAgY29weS5saW1pdF8gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgY29weS5zdGFydFNldF8gPSB0aGlzLnN0YXJ0U2V0XztcbiAgICAgICAgY29weS5pbmRleFN0YXJ0VmFsdWVfID0gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICAgICAgICBjb3B5LnN0YXJ0TmFtZVNldF8gPSB0aGlzLnN0YXJ0TmFtZVNldF87XG4gICAgICAgIGNvcHkuaW5kZXhTdGFydE5hbWVfID0gdGhpcy5pbmRleFN0YXJ0TmFtZV87XG4gICAgICAgIGNvcHkuZW5kU2V0XyA9IHRoaXMuZW5kU2V0XztcbiAgICAgICAgY29weS5pbmRleEVuZFZhbHVlXyA9IHRoaXMuaW5kZXhFbmRWYWx1ZV87XG4gICAgICAgIGNvcHkuZW5kTmFtZVNldF8gPSB0aGlzLmVuZE5hbWVTZXRfO1xuICAgICAgICBjb3B5LmluZGV4RW5kTmFtZV8gPSB0aGlzLmluZGV4RW5kTmFtZV87XG4gICAgICAgIGNvcHkuaW5kZXhfID0gdGhpcy5pbmRleF87XG4gICAgICAgIGNvcHkudmlld0Zyb21fID0gdGhpcy52aWV3RnJvbV87XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUubGltaXQgPSBmdW5jdGlvbiAobmV3TGltaXQpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0U2V0XyA9IHRydWU7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdF8gPSBuZXdMaW1pdDtcbiAgICAgICAgbmV3UGFyYW1zLnZpZXdGcm9tXyA9ICcnO1xuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshbnVtYmVyfSBuZXdMaW1pdFxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUubGltaXRUb0ZpcnN0ID0gZnVuY3Rpb24gKG5ld0xpbWl0KSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgICAgIG5ld1BhcmFtcy5saW1pdFNldF8gPSB0cnVlO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRfID0gbmV3TGltaXQ7XG4gICAgICAgIG5ld1BhcmFtcy52aWV3RnJvbV8gPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU18uVklFV19GUk9NX0xFRlQ7XG4gICAgICAgIHJldHVybiBuZXdQYXJhbXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFudW1iZXJ9IG5ld0xpbWl0XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5saW1pdFRvTGFzdCA9IGZ1bmN0aW9uIChuZXdMaW1pdCkge1xuICAgICAgICB2YXIgbmV3UGFyYW1zID0gdGhpcy5jb3B5XygpO1xuICAgICAgICBuZXdQYXJhbXMubGltaXRTZXRfID0gdHJ1ZTtcbiAgICAgICAgbmV3UGFyYW1zLmxpbWl0XyA9IG5ld0xpbWl0O1xuICAgICAgICBuZXdQYXJhbXMudmlld0Zyb21fID0gUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfLlZJRVdfRlJPTV9SSUdIVDtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Kn0gaW5kZXhWYWx1ZVxuICAgICAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICAgICAqIEByZXR1cm4geyFRdWVyeVBhcmFtc31cbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5wcm90b3R5cGUuc3RhcnRBdCA9IGZ1bmN0aW9uIChpbmRleFZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLnN0YXJ0U2V0XyA9IHRydWU7XG4gICAgICAgIGlmICghKGluZGV4VmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIGluZGV4VmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0VmFsdWVfID0gaW5kZXhWYWx1ZTtcbiAgICAgICAgaWYgKGtleSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZXdQYXJhbXMuc3RhcnROYW1lU2V0XyA9IHRydWU7XG4gICAgICAgICAgICBuZXdQYXJhbXMuaW5kZXhTdGFydE5hbWVfID0ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGFyYW1zLnN0YXJ0TmFtZVNldF8gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5pbmRleFN0YXJ0TmFtZV8gPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHsqfSBpbmRleFZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5lbmRBdCA9IGZ1bmN0aW9uIChpbmRleFZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld1BhcmFtcyA9IHRoaXMuY29weV8oKTtcbiAgICAgICAgbmV3UGFyYW1zLmVuZFNldF8gPSB0cnVlO1xuICAgICAgICBpZiAoIShpbmRleFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBpbmRleFZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmRWYWx1ZV8gPSBpbmRleFZhbHVlO1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IHRydWU7XG4gICAgICAgICAgICBuZXdQYXJhbXMuaW5kZXhFbmROYW1lXyA9IGtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1BhcmFtcy5lbmROYW1lU2V0XyA9IGZhbHNlO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmluZGV4RW5kTmFtZV8gPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSW5kZXh9IGluZGV4XG4gICAgICogQHJldHVybiB7IVF1ZXJ5UGFyYW1zfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSB0aGlzLmNvcHlfKCk7XG4gICAgICAgIG5ld1BhcmFtcy5pbmRleF8gPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLmdldFF1ZXJ5T2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMgPSBRdWVyeVBhcmFtcy5XSVJFX1BST1RPQ09MX0NPTlNUQU5UU187XG4gICAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRTZXRfKSB7XG4gICAgICAgICAgICBvYmpbV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuSU5ERVhfU1RBUlRfVkFMVUVdID0gdGhpcy5pbmRleFN0YXJ0VmFsdWVfO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhcnROYW1lU2V0Xykge1xuICAgICAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9TVEFSVF9OQU1FXSA9IHRoaXMuaW5kZXhTdGFydE5hbWVfO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZFNldF8pIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF9FTkRfVkFMVUVdID0gdGhpcy5pbmRleEVuZFZhbHVlXztcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZE5hbWVTZXRfKSB7XG4gICAgICAgICAgICAgICAgb2JqW1dJUkVfUFJPVE9DT0xfQ09OU1RBTlRTLklOREVYX0VORF9OQU1FXSA9IHRoaXMuaW5kZXhFbmROYW1lXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW1pdFNldF8pIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5MSU1JVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgICAgIHZhciB2aWV3RnJvbSA9IHRoaXMudmlld0Zyb21fO1xuICAgICAgICAgICAgaWYgKHZpZXdGcm9tID09PSAnJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld0Zyb21MZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld0Zyb20gPSBXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01fTEVGVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdGcm9tID0gV0lSRV9QUk9UT0NPTF9DT05TVEFOVFMuVklFV19GUk9NX1JJR0hUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5WSUVXX0ZST01dID0gdmlld0Zyb207XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG5vdywgcHJpb3JpdHkgaW5kZXggaXMgdGhlIGRlZmF1bHQsIHNvIHdlIG9ubHkgc3BlY2lmeSBpZiBpdCdzIHNvbWUgb3RoZXIgaW5kZXhcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhfICE9PSBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpIHtcbiAgICAgICAgICAgIG9ialtXSVJFX1BST1RPQ09MX0NPTlNUQU5UUy5JTkRFWF0gPSB0aGlzLmluZGV4Xy50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5sb2Fkc0FsbERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhKHRoaXMuc3RhcnRTZXRfIHx8IHRoaXMuZW5kU2V0XyB8fCB0aGlzLmxpbWl0U2V0Xyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5pc0RlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRzQWxsRGF0YSgpICYmIHRoaXMuaW5kZXhfID09IFByaW9yaXR5SW5kZXhfMS5QUklPUklUWV9JTkRFWDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4geyFOb2RlRmlsdGVyfVxuICAgICAqL1xuICAgIFF1ZXJ5UGFyYW1zLnByb3RvdHlwZS5nZXROb2RlRmlsdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5sb2Fkc0FsbERhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmRleGVkRmlsdGVyXzEuSW5kZXhlZEZpbHRlcih0aGlzLmdldEluZGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaGFzTGltaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW1pdGVkRmlsdGVyXzEuTGltaXRlZEZpbHRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VkRmlsdGVyXzEuUmFuZ2VkRmlsdGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2V0IG9mIFJFU1QgcXVlcnkgc3RyaW5nIHBhcmFtZXRlcnMgcmVwcmVzZW50aW5nIHRoaXMgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0LjxzdHJpbmcsKj59IHF1ZXJ5IHN0cmluZyBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMucHJvdG90eXBlLnRvUmVzdFF1ZXJ5U3RyaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFJFU1RfQ09OU1RBTlRTID0gUXVlcnlQYXJhbXMuUkVTVF9RVUVSWV9DT05TVEFOVFNfO1xuICAgICAgICB2YXIgcXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaXNEZWZhdWx0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JkZXJCeTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhfID09PSBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpIHtcbiAgICAgICAgICAgIG9yZGVyQnkgPSBSRVNUX0NPTlNUQU5UUy5QUklPUklUWV9JTkRFWDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmluZGV4XyA9PT0gVmFsdWVJbmRleF8xLlZBTFVFX0lOREVYKSB7XG4gICAgICAgICAgICBvcmRlckJ5ID0gUkVTVF9DT05TVEFOVFMuVkFMVUVfSU5ERVg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pbmRleF8gPT09IEtleUluZGV4XzEuS0VZX0lOREVYKSB7XG4gICAgICAgICAgICBvcmRlckJ5ID0gUkVTVF9DT05TVEFOVFMuS0VZX0lOREVYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydCh0aGlzLmluZGV4XyBpbnN0YW5jZW9mIFBhdGhJbmRleF8xLlBhdGhJbmRleCwgJ1VucmVjb2duaXplZCBpbmRleCB0eXBlIScpO1xuICAgICAgICAgICAgb3JkZXJCeSA9IHRoaXMuaW5kZXhfLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuT1JERVJfQlldID0gdXRpbF8zLnN0cmluZ2lmeShvcmRlckJ5KTtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRTZXRfKSB7XG4gICAgICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5TVEFSVF9BVF0gPSB1dGlsXzMuc3RyaW5naWZ5KHRoaXMuaW5kZXhTdGFydFZhbHVlXyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydE5hbWVTZXRfKSB7XG4gICAgICAgICAgICAgICAgcXNbUkVTVF9DT05TVEFOVFMuU1RBUlRfQVRdICs9ICcsJyArIHV0aWxfMy5zdHJpbmdpZnkodGhpcy5pbmRleFN0YXJ0TmFtZV8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVuZFNldF8pIHtcbiAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkVORF9BVF0gPSB1dGlsXzMuc3RyaW5naWZ5KHRoaXMuaW5kZXhFbmRWYWx1ZV8pO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5kTmFtZVNldF8pIHtcbiAgICAgICAgICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5FTkRfQVRdICs9ICcsJyArIHV0aWxfMy5zdHJpbmdpZnkodGhpcy5pbmRleEVuZE5hbWVfKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saW1pdFNldF8pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld0Zyb21MZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBxc1tSRVNUX0NPTlNUQU5UUy5MSU1JVF9UT19GSVJTVF0gPSB0aGlzLmxpbWl0XztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHFzW1JFU1RfQ09OU1RBTlRTLkxJTUlUX1RPX0xBU1RdID0gdGhpcy5saW1pdF87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHFzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV2lyZSBQcm90b2NvbCBDb25zdGFudHNcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMuV0lSRV9QUk9UT0NPTF9DT05TVEFOVFNfID0ge1xuICAgICAgICBJTkRFWF9TVEFSVF9WQUxVRTogJ3NwJyxcbiAgICAgICAgSU5ERVhfU1RBUlRfTkFNRTogJ3NuJyxcbiAgICAgICAgSU5ERVhfRU5EX1ZBTFVFOiAnZXAnLFxuICAgICAgICBJTkRFWF9FTkRfTkFNRTogJ2VuJyxcbiAgICAgICAgTElNSVQ6ICdsJyxcbiAgICAgICAgVklFV19GUk9NOiAndmYnLFxuICAgICAgICBWSUVXX0ZST01fTEVGVDogJ2wnLFxuICAgICAgICBWSUVXX0ZST01fUklHSFQ6ICdyJyxcbiAgICAgICAgSU5ERVg6ICdpJ1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUkVTVCBRdWVyeSBDb25zdGFudHNcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUXVlcnlQYXJhbXMuUkVTVF9RVUVSWV9DT05TVEFOVFNfID0ge1xuICAgICAgICBPUkRFUl9CWTogJ29yZGVyQnknLFxuICAgICAgICBQUklPUklUWV9JTkRFWDogJyRwcmlvcml0eScsXG4gICAgICAgIFZBTFVFX0lOREVYOiAnJHZhbHVlJyxcbiAgICAgICAgS0VZX0lOREVYOiAnJGtleScsXG4gICAgICAgIFNUQVJUX0FUOiAnc3RhcnRBdCcsXG4gICAgICAgIEVORF9BVDogJ2VuZEF0JyxcbiAgICAgICAgTElNSVRfVE9fRklSU1Q6ICdsaW1pdFRvRmlyc3QnLFxuICAgICAgICBMSU1JVF9UT19MQVNUOiAnbGltaXRUb0xhc3QnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0LCBlbXB0eSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgICogQHR5cGUgeyFRdWVyeVBhcmFtc31cbiAgICAgKiBAY29uc3RcbiAgICAgKi9cbiAgICBRdWVyeVBhcmFtcy5ERUZBVUxUID0gbmV3IFF1ZXJ5UGFyYW1zKCk7XG4gICAgcmV0dXJuIFF1ZXJ5UGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuUXVlcnlQYXJhbXMgPSBRdWVyeVBhcmFtcztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UXVlcnlQYXJhbXMuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdmlldy9RdWVyeVBhcmFtcy5qc1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJhbmdlZEZpbHRlcl8xID0gcmVxdWlyZShcIi4vUmFuZ2VkRmlsdGVyXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4uLy4uL3NuYXAvQ2hpbGRyZW5Ob2RlXCIpO1xudmFyIE5vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9zbmFwL05vZGVcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIENoYW5nZV8xID0gcmVxdWlyZShcIi4uL0NoYW5nZVwiKTtcbi8qKlxuICogQXBwbGllcyBhIGxpbWl0IGFuZCBhIHJhbmdlIHRvIGEgbm9kZSBhbmQgdXNlcyBSYW5nZWRGaWx0ZXIgdG8gZG8gdGhlIGhlYXZ5IGxpZnRpbmcgd2hlcmUgcG9zc2libGVcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtOb2RlRmlsdGVyfVxuICovXG52YXIgTGltaXRlZEZpbHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFRdWVyeVBhcmFtc30gcGFyYW1zXG4gICAgICovXG4gICAgZnVuY3Rpb24gTGltaXRlZEZpbHRlcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5yYW5nZWRGaWx0ZXJfID0gbmV3IFJhbmdlZEZpbHRlcl8xLlJhbmdlZEZpbHRlcihwYXJhbXMpO1xuICAgICAgICB0aGlzLmluZGV4XyA9IHBhcmFtcy5nZXRJbmRleCgpO1xuICAgICAgICB0aGlzLmxpbWl0XyA9IHBhcmFtcy5nZXRMaW1pdCgpO1xuICAgICAgICB0aGlzLnJldmVyc2VfID0gIXBhcmFtcy5pc1ZpZXdGcm9tTGVmdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZUNoaWxkID0gZnVuY3Rpb24gKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcikge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ldyBOb2RlXzEuTmFtZWROb2RlKGtleSwgbmV3Q2hpbGQpKSkge1xuICAgICAgICAgICAgbmV3Q2hpbGQgPSBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc25hcC5nZXRJbW1lZGlhdGVDaGlsZChrZXkpLmVxdWFscyhuZXdDaGlsZCkpIHtcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZVxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc25hcC5udW1DaGlsZHJlbigpIDwgdGhpcy5saW1pdF8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cbiAgICAgICAgICAgICAgICAuZ2V0SW5kZXhlZEZpbHRlcigpXG4gICAgICAgICAgICAgICAgLnVwZGF0ZUNoaWxkKHNuYXAsIGtleSwgbmV3Q2hpbGQsIGFmZmVjdGVkUGF0aCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsTGltaXRVcGRhdGVDaGlsZF8oc25hcCwga2V5LCBuZXdDaGlsZCwgc291cmNlLCBvcHRDaGFuZ2VBY2N1bXVsYXRvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUudXBkYXRlRnVsbE5vZGUgPSBmdW5jdGlvbiAob2xkU25hcCwgbmV3U25hcCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkO1xuICAgICAgICBpZiAobmV3U25hcC5pc0xlYWZOb2RlKCkgfHwgbmV3U25hcC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2hpbGRyZW4gbm9kZSB3aXRoIHRoZSBjb3JyZWN0IGluZGV4LCBub3QgYSBsZWFmIG5vZGU7XG4gICAgICAgICAgICBmaWx0ZXJlZCA9IENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFLndpdGhJbmRleCh0aGlzLmluZGV4Xyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saW1pdF8gKiAyIDwgbmV3U25hcC5udW1DaGlsZHJlbigpICYmXG4gICAgICAgICAgICAgICAgbmV3U25hcC5pc0luZGV4ZWQodGhpcy5pbmRleF8pKSB7XG4gICAgICAgICAgICAgICAgLy8gRWFzaWVyIHRvIGJ1aWxkIHVwIGEgc25hcHNob3QsIHNpbmNlIHdoYXQgd2UncmUgZ2l2ZW4gaGFzIG1vcmUgdGhhbiB0d2ljZSB0aGUgZWxlbWVudHMgd2Ugd2FudFxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUud2l0aEluZGV4KHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICAgICAgICAvLyBhbmNob3IgdG8gdGhlIHN0YXJ0UG9zdCwgZW5kUG9zdCwgb3IgbGFzdCBlbGVtZW50IGFzIGFwcHJvcHJpYXRlXG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJldmVyc2VfKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRSZXZlcnNlSXRlcmF0b3JGcm9tKHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCksIHRoaXMuaW5kZXhfKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gbmV3U25hcC5nZXRJdGVyYXRvckZyb20odGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCB0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLmhhc05leHQoKSAmJiBjb3VudCA8IHRoaXMubGltaXRfKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5SYW5nZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUmFuZ2UgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhfLmNvbXBhcmUodGhpcy5yYW5nZWRGaWx0ZXJfLmdldFN0YXJ0UG9zdCgpLCBuZXh0KSA8PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5SYW5nZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleF8uY29tcGFyZShuZXh0LCB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0RW5kUG9zdCgpKSA8PSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgbmV4dC5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBwb3N0LCB3ZSBjYW5ub3Qga2VlcCBhZGRpbmcgZWxlbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzbmFwIGNvbnRhaW5zIGxlc3MgdGhhbiB0d2ljZSB0aGUgbGltaXQuIEZhc3RlciB0byBkZWxldGUgZnJvbSB0aGUgc25hcCB0aGFuIGJ1aWxkIHVwIGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgIGZpbHRlcmVkID0gbmV3U25hcC53aXRoSW5kZXgodGhpcy5pbmRleF8pO1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHN1cHBvcnQgcHJpb3JpdGllcyBvbiBxdWVyaWVzXG4gICAgICAgICAgICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC51cGRhdGVQcmlvcml0eShDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0UG9zdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUG9zdCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICB2YXIgY21wID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9IGZpbHRlcmVkLmdldFJldmVyc2VJdGVyYXRvcih0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZFBvc3QgPSB0aGlzLnJhbmdlZEZpbHRlcl8uZ2V0U3RhcnRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleENvbXBhcmVfMSA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGluZGV4Q29tcGFyZV8xKGIsIGEpOyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0b3IgPSBmaWx0ZXJlZC5nZXRJdGVyYXRvcih0aGlzLmluZGV4Xyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRTdGFydFBvc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9zdCA9IHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRFbmRQb3N0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZm91bmRTdGFydFBvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gaXRlcmF0b3IuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3RhcnRQb3N0ICYmIGNtcChzdGFydFBvc3QsIG5leHQpIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGFydFBvc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblJhbmdlID0gZm91bmRTdGFydFBvc3QgJiYgY291bnQgPCB0aGlzLmxpbWl0XyAmJiBjbXAobmV4dCwgZW5kUG9zdCkgPD0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJlZCA9IGZpbHRlcmVkLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKG5leHQubmFtZSwgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlZEZpbHRlcl9cbiAgICAgICAgICAgIC5nZXRJbmRleGVkRmlsdGVyKClcbiAgICAgICAgICAgIC51cGRhdGVGdWxsTm9kZShvbGRTbmFwLCBmaWx0ZXJlZCwgb3B0Q2hhbmdlQWNjdW11bGF0b3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGluaGVyaXREb2NcbiAgICAgKi9cbiAgICBMaW1pdGVkRmlsdGVyLnByb3RvdHlwZS51cGRhdGVQcmlvcml0eSA9IGZ1bmN0aW9uIChvbGRTbmFwLCBuZXdQcmlvcml0eSkge1xuICAgICAgICAvLyBEb24ndCBzdXBwb3J0IHByaW9yaXRpZXMgb24gcXVlcmllc1xuICAgICAgICByZXR1cm4gb2xkU25hcDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUuZmlsdGVyc05vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBpbmhlcml0RG9jXG4gICAgICovXG4gICAgTGltaXRlZEZpbHRlci5wcm90b3R5cGUuZ2V0SW5kZXhlZEZpbHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VkRmlsdGVyXy5nZXRJbmRleGVkRmlsdGVyKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdERvY1xuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleF87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBzbmFwXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoaWxkS2V5XG4gICAgICogQHBhcmFtIHshTm9kZX0gY2hpbGRTbmFwXG4gICAgICogQHBhcmFtIHshQ29tcGxldGVDaGlsZFNvdXJjZX0gc291cmNlXG4gICAgICogQHBhcmFtIHs/Q2hpbGRDaGFuZ2VBY2N1bXVsYXRvcn0gY2hhbmdlQWNjdW11bGF0b3JcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIExpbWl0ZWRGaWx0ZXIucHJvdG90eXBlLmZ1bGxMaW1pdFVwZGF0ZUNoaWxkXyA9IGZ1bmN0aW9uIChzbmFwLCBjaGlsZEtleSwgY2hpbGRTbmFwLCBzb3VyY2UsIGNoYW5nZUFjY3VtdWxhdG9yKSB7XG4gICAgICAgIC8vIFRPRE86IHJlbmFtZSBhbGwgY2FjaGUgc3R1ZmYgZXRjIHRvIGdlbmVyYWwgc25hcCB0ZXJtaW5vbG9neVxuICAgICAgICB2YXIgY21wO1xuICAgICAgICBpZiAodGhpcy5yZXZlcnNlXykge1xuICAgICAgICAgICAgdmFyIGluZGV4Q21wXzEgPSB0aGlzLmluZGV4Xy5nZXRDb21wYXJlKCk7XG4gICAgICAgICAgICBjbXAgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaW5kZXhDbXBfMShiLCBhKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNtcCA9IHRoaXMuaW5kZXhfLmdldENvbXBhcmUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb2xkRXZlbnRDYWNoZSA9IHNuYXA7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQob2xkRXZlbnRDYWNoZS5udW1DaGlsZHJlbigpID09IHRoaXMubGltaXRfLCAnJyk7XG4gICAgICAgIHZhciBuZXdDaGlsZE5hbWVkTm9kZSA9IG5ldyBOb2RlXzEuTmFtZWROb2RlKGNoaWxkS2V5LCBjaGlsZFNuYXApO1xuICAgICAgICB2YXIgd2luZG93Qm91bmRhcnkgPSB0aGlzLnJldmVyc2VfXG4gICAgICAgICAgICA/IG9sZEV2ZW50Q2FjaGUuZ2V0Rmlyc3RDaGlsZCh0aGlzLmluZGV4XylcbiAgICAgICAgICAgIDogb2xkRXZlbnRDYWNoZS5nZXRMYXN0Q2hpbGQodGhpcy5pbmRleF8pO1xuICAgICAgICB2YXIgaW5SYW5nZSA9IHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5ld0NoaWxkTmFtZWROb2RlKTtcbiAgICAgICAgaWYgKG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQoY2hpbGRLZXkpKSB7XG4gICAgICAgICAgICB2YXIgb2xkQ2hpbGRTbmFwID0gb2xkRXZlbnRDYWNoZS5nZXRJbW1lZGlhdGVDaGlsZChjaGlsZEtleSk7XG4gICAgICAgICAgICB2YXIgbmV4dENoaWxkID0gc291cmNlLmdldENoaWxkQWZ0ZXJDaGlsZCh0aGlzLmluZGV4Xywgd2luZG93Qm91bmRhcnksIHRoaXMucmV2ZXJzZV8pO1xuICAgICAgICAgICAgd2hpbGUgKG5leHRDaGlsZCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG5leHRDaGlsZC5uYW1lID09IGNoaWxkS2V5IHx8IG9sZEV2ZW50Q2FjaGUuaGFzQ2hpbGQobmV4dENoaWxkLm5hbWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgd2VpcmQgZWRnZSBjYXNlIHdoZXJlIGEgbm9kZSBpcyB1cGRhdGVkIGFzIHBhcnQgb2YgYSBtZXJnZSBpbiB0aGUgd3JpdGUgdHJlZSwgYnV0IGhhc24ndFxuICAgICAgICAgICAgICAgIC8vIGJlZW4gYXBwbGllZCB0byB0aGUgbGltaXRlZCBmaWx0ZXIgeWV0LiBJZ25vcmUgdGhpcyBuZXh0IGNoaWxkIHdoaWNoIHdpbGwgYmUgdXBkYXRlZCBsYXRlciBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsaW1pdGVkIGZpbHRlci4uLlxuICAgICAgICAgICAgICAgIG5leHRDaGlsZCA9IHNvdXJjZS5nZXRDaGlsZEFmdGVyQ2hpbGQodGhpcy5pbmRleF8sIG5leHRDaGlsZCwgdGhpcy5yZXZlcnNlXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29tcGFyZU5leHQgPSBuZXh0Q2hpbGQgPT0gbnVsbCA/IDEgOiBjbXAobmV4dENoaWxkLCBuZXdDaGlsZE5hbWVkTm9kZSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluc0luV2luZG93ID0gaW5SYW5nZSAmJiAhY2hpbGRTbmFwLmlzRW1wdHkoKSAmJiBjb21wYXJlTmV4dCA+PSAwO1xuICAgICAgICAgICAgaWYgKHJlbWFpbnNJbldpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VBY2N1bXVsYXRvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQ2hhbmdlZENoYW5nZShjaGlsZEtleSwgY2hpbGRTbmFwLCBvbGRDaGlsZFNuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIGNoaWxkU25hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2UoY2hpbGRLZXksIG9sZENoaWxkU25hcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRDYWNoZSA9IG9sZEV2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQoY2hpbGRLZXksIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoaWxkSW5SYW5nZSA9IG5leHRDaGlsZCAhPSBudWxsICYmIHRoaXMucmFuZ2VkRmlsdGVyXy5tYXRjaGVzKG5leHRDaGlsZCk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZUFjY3VtdWxhdG9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUFjY3VtdWxhdG9yLnRyYWNrQ2hpbGRDaGFuZ2UoQ2hhbmdlXzEuQ2hhbmdlLmNoaWxkQWRkZWRDaGFuZ2UobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50Q2FjaGUudXBkYXRlSW1tZWRpYXRlQ2hpbGQobmV4dENoaWxkLm5hbWUsIG5leHRDaGlsZC5ub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdFdmVudENhY2hlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaGlsZFNuYXAuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyB3ZSdyZSBkZWxldGluZyBhIG5vZGUsIGJ1dCBpdCB3YXMgbm90IGluIHRoZSB3aW5kb3csIHNvIGlnbm9yZSBpdFxuICAgICAgICAgICAgcmV0dXJuIHNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5SYW5nZSkge1xuICAgICAgICAgICAgaWYgKGNtcCh3aW5kb3dCb3VuZGFyeSwgbmV3Q2hpbGROYW1lZE5vZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlQWNjdW11bGF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZFJlbW92ZWRDaGFuZ2Uod2luZG93Qm91bmRhcnkubmFtZSwgd2luZG93Qm91bmRhcnkubm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VBY2N1bXVsYXRvci50cmFja0NoaWxkQ2hhbmdlKENoYW5nZV8xLkNoYW5nZS5jaGlsZEFkZGVkQ2hhbmdlKGNoaWxkS2V5LCBjaGlsZFNuYXApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZEV2ZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgLnVwZGF0ZUltbWVkaWF0ZUNoaWxkKGNoaWxkS2V5LCBjaGlsZFNuYXApXG4gICAgICAgICAgICAgICAgICAgIC51cGRhdGVJbW1lZGlhdGVDaGlsZCh3aW5kb3dCb3VuZGFyeS5uYW1lLCBDaGlsZHJlbk5vZGVfMS5DaGlsZHJlbk5vZGUuRU1QVFlfTk9ERSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzbmFwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTGltaXRlZEZpbHRlcjtcbn0oKSk7XG5leHBvcnRzLkxpbWl0ZWRGaWx0ZXIgPSBMaW1pdGVkRmlsdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW1pdGVkRmlsdGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9jb3JlL3ZpZXcvZmlsdGVyL0xpbWl0ZWRGaWx0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiQGZpcmViYXNlL3V0aWxcIik7XG52YXIgUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi4vYXBpL1JlZmVyZW5jZVwiKTtcbnZhciBEYXRhU25hcHNob3RfMSA9IHJlcXVpcmUoXCIuLi9hcGkvRGF0YVNuYXBzaG90XCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL3V0aWwvUGF0aFwiKTtcbnZhciBUcmVlXzEgPSByZXF1aXJlKFwiLi91dGlsL1RyZWVcIik7XG52YXIgUHJpb3JpdHlJbmRleF8xID0gcmVxdWlyZShcIi4vc25hcC9pbmRleGVzL1ByaW9yaXR5SW5kZXhcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIi4vdXRpbC91dGlsXCIpO1xudmFyIFNlcnZlclZhbHVlc18xID0gcmVxdWlyZShcIi4vdXRpbC9TZXJ2ZXJWYWx1ZXNcIik7XG52YXIgdmFsaWRhdGlvbl8xID0gcmVxdWlyZShcIi4vdXRpbC92YWxpZGF0aW9uXCIpO1xudmFyIHV0aWxfMyA9IHJlcXVpcmUoXCJAZmlyZWJhc2UvdXRpbFwiKTtcbnZhciBub2RlRnJvbUpTT05fMSA9IHJlcXVpcmUoXCIuL3NuYXAvbm9kZUZyb21KU09OXCIpO1xudmFyIENoaWxkcmVuTm9kZV8xID0gcmVxdWlyZShcIi4vc25hcC9DaGlsZHJlbk5vZGVcIik7XG52YXIgUmVwb18xID0gcmVxdWlyZShcIi4vUmVwb1wiKTtcbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IG1lc3N5LiAgSWRlYWxseSwgYSBsb3Qgb2YgdGhpcyB3b3VsZCBtb3ZlIGludG8gRmlyZWJhc2VEYXRhLCBvciBhIHRyYW5zYWN0aW9uLXNwZWNpZmljXG4vLyBjb21wb25lbnQgdXNlZCBieSBGaXJlYmFzZURhdGEsIGJ1dCBpdCBoYXMgdGllcyB0byB1c2VyIGNhbGxiYWNrcyAodHJhbnNhY3Rpb24gdXBkYXRlIGFuZCBvbkNvbXBsZXRlKSBhcyB3ZWxsXG4vLyBhcyB0aGUgcmVhbHRpbWUgY29ubmVjdGlvbiAodG8gc2VuZCB0cmFuc2FjdGlvbnMgdG8gdGhlIHNlcnZlcikuICBTbyB0aGF0IGFsbCBuZWVkcyB0byBiZSBkZWNvdXBsZWQgZmlyc3QuXG4vLyBGb3Igbm93IGl0J3MgcGFydCBvZiBSZXBvLCBidXQgaW4gaXRzIG93biBmaWxlLlxuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG52YXIgVHJhbnNhY3Rpb25TdGF0dXM7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gICAgLy8gV2UndmUgcnVuIHRoZSB0cmFuc2FjdGlvbiBhbmQgdXBkYXRlZCB0cmFuc2FjdGlvblJlc3VsdERhdGFfIHdpdGggdGhlIHJlc3VsdCwgYnV0IGl0IGlzbid0IGN1cnJlbnRseSBzZW50IHRvIHRoZVxuICAgIC8vIHNlcnZlci4gQSB0cmFuc2FjdGlvbiB3aWxsIGdvIGZyb20gUlVOIC0+IFNFTlQgLT4gUlVOIGlmIGl0IGNvbWVzIGJhY2sgZnJvbSB0aGUgc2VydmVyIGFzIHJlamVjdGVkIGR1ZSB0b1xuICAgIC8vIG1pc21hdGNoZWQgaGFzaC5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlJVTlwiXSA9IDBdID0gXCJSVU5cIjtcbiAgICAvLyBXZSd2ZSBydW4gdGhlIHRyYW5zYWN0aW9uIGFuZCBzZW50IGl0IHRvIHRoZSBzZXJ2ZXIgYW5kIGl0J3MgY3VycmVudGx5IG91dHN0YW5kaW5nIChoYXNuJ3QgY29tZSBiYWNrIGFzIGFjY2VwdGVkXG4gICAgLy8gb3IgcmVqZWN0ZWQgeWV0KS5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlNFTlRcIl0gPSAxXSA9IFwiU0VOVFwiO1xuICAgIC8vIFRlbXBvcmFyeSBzdGF0ZSB1c2VkIHRvIG1hcmsgY29tcGxldGVkIHRyYW5zYWN0aW9ucyAod2hldGhlciBzdWNjZXNzZnVsIG9yIGFib3J0ZWQpLiAgVGhlIHRyYW5zYWN0aW9uIHdpbGwgYmVcbiAgICAvLyByZW1vdmVkIHdoZW4gd2UgZ2V0IGEgY2hhbmNlIHRvIHBydW5lIGNvbXBsZXRlZCBvbmVzLlxuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiQ09NUExFVEVEXCJdID0gMl0gPSBcIkNPTVBMRVRFRFwiO1xuICAgIC8vIFVzZWQgd2hlbiBhbiBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb24gbmVlZHMgdG8gYmUgYWJvcnRlZCAoZS5nLiBkdWUgdG8gYSBjb25mbGljdGluZyBzZXQoKSBjYWxsIHRoYXQgd2FzIG1hZGUpLlxuICAgIC8vIElmIGl0IGNvbWVzIGJhY2sgYXMgdW5zdWNjZXNzZnVsLCB3ZSdsbCBhYm9ydCBpdC5cbiAgICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlNFTlRfTkVFRFNfQUJPUlRcIl0gPSAzXSA9IFwiU0VOVF9ORUVEU19BQk9SVFwiO1xuICAgIC8vIFRlbXBvcmFyeSBzdGF0ZSB1c2VkIHRvIG1hcmsgdHJhbnNhY3Rpb25zIHRoYXQgbmVlZCB0byBiZSBhYm9ydGVkLlxuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiTkVFRFNfQUJPUlRcIl0gPSA0XSA9IFwiTkVFRFNfQUJPUlRcIjtcbn0pKFRyYW5zYWN0aW9uU3RhdHVzID0gZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyB8fCAoZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIElmIGEgdHJhbnNhY3Rpb24gZG9lcyBub3Qgc3VjY2VlZCBhZnRlciAyNSByZXRyaWVzLCB3ZSBhYm9ydCBpdC4gIEFtb25nIG90aGVyIHRoaW5ncyB0aGlzIGVuc3VyZSB0aGF0IGlmIHRoZXJlJ3NcbiAqIGV2ZXIgYSBidWcgY2F1c2luZyBhIG1pc21hdGNoIGJldHdlZW4gY2xpZW50IC8gc2VydmVyIGhhc2hlcyBmb3Igc29tZSBkYXRhLCB3ZSB3b24ndCByZXRyeSBpbmRlZmluaXRlbHkuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGNvbnN0XG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5NQVhfVFJBTlNBQ1RJT05fUkVUUklFU18gPSAyNTtcbi8qKlxuICogU2V0dXAgdGhlIHRyYW5zYWN0aW9uIGRhdGEgc3RydWN0dXJlc1xuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnRyYW5zYWN0aW9uc19pbml0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgcXVldWVzIG9mIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9ucyBmb3IgRmlyZWJhc2UgbG9jYXRpb25zLlxuICAgICAqXG4gICAgICogQHR5cGUgeyFUcmVlLjxBcnJheS48IVRyYW5zYWN0aW9uPj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyA9IG5ldyBUcmVlXzEuVHJlZSgpO1xufTtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB0cmFuc2FjdGlvbiwgYWRkcyBpdCB0byB0aGUgdHJhbnNhY3Rpb25zIHdlJ3JlIHRyYWNraW5nLCBhbmQgc2VuZHMgaXQgdG8gdGhlIHNlcnZlciBpZiBwb3NzaWJsZS5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggYXQgd2hpY2ggdG8gZG8gdHJhbnNhY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOip9IHRyYW5zYWN0aW9uVXBkYXRlIFVwZGF0ZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKD9FcnJvciwgYm9vbGVhbiwgP0RhdGFTbmFwc2hvdCl9IG9uQ29tcGxldGUgQ29tcGxldGlvbiBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXBwbHlMb2NhbGx5IFdoZXRoZXIgb3Igbm90IHRvIG1ha2UgaW50ZXJtZWRpYXRlIHJlc3VsdHMgdmlzaWJsZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuc3RhcnRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChwYXRoLCB0cmFuc2FjdGlvblVwZGF0ZSwgb25Db21wbGV0ZSwgYXBwbHlMb2NhbGx5KSB7XG4gICAgdGhpcy5sb2dfKCd0cmFuc2FjdGlvbiBvbiAnICsgcGF0aCk7XG4gICAgLy8gQWRkIGEgd2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGdldCBzZXJ2ZXIgdXBkYXRlcy5cbiAgICB2YXIgdmFsdWVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICB2YXIgd2F0Y2hSZWYgPSBuZXcgUmVmZXJlbmNlXzEuUmVmZXJlbmNlKHRoaXMsIHBhdGgpO1xuICAgIHdhdGNoUmVmLm9uKCd2YWx1ZScsIHZhbHVlQ2FsbGJhY2spO1xuICAgIHZhciB1bndhdGNoZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhdGNoUmVmLm9mZigndmFsdWUnLCB2YWx1ZUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIEluaXRpYWxpemUgdHJhbnNhY3Rpb24uXG4gICAgdmFyIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB1cGRhdGU6IHRyYW5zYWN0aW9uVXBkYXRlLFxuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICAvLyBPbmUgb2YgVHJhbnNhY3Rpb25TdGF0dXMgZW51bXMuXG4gICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgLy8gVXNlZCB3aGVuIGNvbWJpbmluZyB0cmFuc2FjdGlvbnMgYXQgZGlmZmVyZW50IGxvY2F0aW9ucyB0byBmaWd1cmUgb3V0IHdoaWNoIG9uZSBnb2VzIGZpcnN0LlxuICAgICAgICBvcmRlcjogdXRpbF8yLkxVSURHZW5lcmF0b3IoKSxcbiAgICAgICAgLy8gV2hldGhlciB0byByYWlzZSBsb2NhbCBldmVudHMgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIGFwcGx5TG9jYWxseTogYXBwbHlMb2NhbGx5LFxuICAgICAgICAvLyBDb3VudCBvZiBob3cgbWFueSB0aW1lcyB3ZSd2ZSByZXRyaWVkIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgcmV0cnlDb3VudDogMCxcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gY2FsbCB0byBjbGVhbiB1cCBvdXIgLm9uKCkgbGlzdGVuZXIuXG4gICAgICAgIHVud2F0Y2hlcjogdW53YXRjaGVyLFxuICAgICAgICAvLyBTdG9yZXMgd2h5IGEgdHJhbnNhY3Rpb24gd2FzIGFib3J0ZWQuXG4gICAgICAgIGFib3J0UmVhc29uOiBudWxsLFxuICAgICAgICBjdXJyZW50V3JpdGVJZDogbnVsbCxcbiAgICAgICAgY3VycmVudElucHV0U25hcHNob3Q6IG51bGwsXG4gICAgICAgIGN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdzogbnVsbCxcbiAgICAgICAgY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQ6IG51bGxcbiAgICB9O1xuICAgIC8vIFJ1biB0cmFuc2FjdGlvbiBpbml0aWFsbHkuXG4gICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuZ2V0TGF0ZXN0U3RhdGVfKHBhdGgpO1xuICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRJbnB1dFNuYXBzaG90ID0gY3VycmVudFN0YXRlO1xuICAgIHZhciBuZXdWYWwgPSB0cmFuc2FjdGlvbi51cGRhdGUoY3VycmVudFN0YXRlLnZhbCgpKTtcbiAgICBpZiAobmV3VmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gQWJvcnQgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRyYW5zYWN0aW9uLnVud2F0Y2hlcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBudWxsO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG51bGw7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5vbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAvLyBXZSBqdXN0IHNldCB0aGUgaW5wdXQgc25hcHNob3QsIHNvIHRoaXMgY2FzdCBzaG91bGQgYmUgc2FmZVxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gbmV3IERhdGFTbmFwc2hvdF8xLkRhdGFTbmFwc2hvdCh0cmFuc2FjdGlvbi5jdXJyZW50SW5wdXRTbmFwc2hvdCwgbmV3IFJlZmVyZW5jZV8xLlJlZmVyZW5jZSh0aGlzLCB0cmFuc2FjdGlvbi5wYXRoKSwgUHJpb3JpdHlJbmRleF8xLlBSSU9SSVRZX0lOREVYKTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uQ29tcGxldGUobnVsbCwgZmFsc2UsIHNuYXBzaG90KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3VmFsLCB0cmFuc2FjdGlvbi5wYXRoKTtcbiAgICAgICAgLy8gTWFyayBhcyBydW4gYW5kIGFkZCB0byBvdXIgcXVldWUuXG4gICAgICAgIHRyYW5zYWN0aW9uLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlJVTjtcbiAgICAgICAgdmFyIHF1ZXVlTm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfLnN1YlRyZWUocGF0aCk7XG4gICAgICAgIHZhciBub2RlUXVldWUgPSBxdWV1ZU5vZGUuZ2V0VmFsdWUoKSB8fCBbXTtcbiAgICAgICAgbm9kZVF1ZXVlLnB1c2godHJhbnNhY3Rpb24pO1xuICAgICAgICBxdWV1ZU5vZGUuc2V0VmFsdWUobm9kZVF1ZXVlKTtcbiAgICAgICAgLy8gVXBkYXRlIHZpc2libGVEYXRhIGFuZCByYWlzZSBldmVudHNcbiAgICAgICAgLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSByYWlzZSBldmVudHMgYWZ0ZXIgdXBkYXRpbmcgYWxsIG9mIG91ciB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2UgdGhlIHVzZXIgY291bGRcbiAgICAgICAgLy8gc3RhcnQgbmV3IHRyYW5zYWN0aW9ucyBmcm9tIHRoZSBldmVudCBjYWxsYmFja3MuXG4gICAgICAgIHZhciBwcmlvcml0eUZvck5vZGUgPSB2b2lkIDA7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3VmFsID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgbmV3VmFsICE9PSBudWxsICYmXG4gICAgICAgICAgICB1dGlsXzMuY29udGFpbnMobmV3VmFsLCAnLnByaW9yaXR5JykpIHtcbiAgICAgICAgICAgIHByaW9yaXR5Rm9yTm9kZSA9IHV0aWxfMy5zYWZlR2V0KG5ld1ZhbCwgJy5wcmlvcml0eScpO1xuICAgICAgICAgICAgdXRpbF8xLmFzc2VydCh2YWxpZGF0aW9uXzEuaXNWYWxpZFByaW9yaXR5KHByaW9yaXR5Rm9yTm9kZSksICdJbnZhbGlkIHByaW9yaXR5IHJldHVybmVkIGJ5IHRyYW5zYWN0aW9uLiAnICtcbiAgICAgICAgICAgICAgICAnUHJpb3JpdHkgbXVzdCBiZSBhIHZhbGlkIHN0cmluZywgZmluaXRlIG51bWJlciwgc2VydmVyIHZhbHVlLCBvciBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShwYXRoKSB8fFxuICAgICAgICAgICAgICAgIENoaWxkcmVuTm9kZV8xLkNoaWxkcmVuTm9kZS5FTVBUWV9OT0RFO1xuICAgICAgICAgICAgcHJpb3JpdHlGb3JOb2RlID0gY3VycmVudE5vZGUuZ2V0UHJpb3JpdHkoKS52YWwoKTtcbiAgICAgICAgfVxuICAgICAgICBwcmlvcml0eUZvck5vZGUgLyoqIEB0eXBlIHtudWxsfG51bWJlcnxzdHJpbmd9ICovID0gcHJpb3JpdHlGb3JOb2RlO1xuICAgICAgICB2YXIgc2VydmVyVmFsdWVzID0gdGhpcy5nZW5lcmF0ZVNlcnZlclZhbHVlcygpO1xuICAgICAgICB2YXIgbmV3Tm9kZVVucmVzb2x2ZWQgPSBub2RlRnJvbUpTT05fMS5ub2RlRnJvbUpTT04obmV3VmFsLCBwcmlvcml0eUZvck5vZGUpO1xuICAgICAgICB2YXIgbmV3Tm9kZSA9IFNlcnZlclZhbHVlc18xLnJlc29sdmVEZWZlcnJlZFZhbHVlU25hcHNob3QobmV3Tm9kZVVucmVzb2x2ZWQsIHNlcnZlclZhbHVlcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJhdyA9IG5ld05vZGVVbnJlc29sdmVkO1xuICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSZXNvbHZlZCA9IG5ld05vZGU7XG4gICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuc2VydmVyU3luY1RyZWVfLmFwcGx5VXNlck92ZXJ3cml0ZShwYXRoLCBuZXdOb2RlLCB0cmFuc2FjdGlvbi5jdXJyZW50V3JpdGVJZCwgdHJhbnNhY3Rpb24uYXBwbHlMb2NhbGx5KTtcbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgICAgIHRoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXygpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7IVBhdGh9IHBhdGhcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj49fSBleGNsdWRlU2V0cyBBIHNwZWNpZmljIHNldCB0byBleGNsdWRlXG4gKiBAcmV0dXJuIHtOb2RlfVxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLmdldExhdGVzdFN0YXRlXyA9IGZ1bmN0aW9uIChwYXRoLCBleGNsdWRlU2V0cykge1xuICAgIHJldHVybiAodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uY2FsY0NvbXBsZXRlRXZlbnRDYWNoZShwYXRoLCBleGNsdWRlU2V0cykgfHxcbiAgICAgICAgQ2hpbGRyZW5Ob2RlXzEuQ2hpbGRyZW5Ob2RlLkVNUFRZX05PREUpO1xufTtcbi8qKlxuICogU2VuZHMgYW55IGFscmVhZHktcnVuIHRyYW5zYWN0aW9ucyB0aGF0IGFyZW4ndCB3YWl0aW5nIGZvciBvdXRzdGFuZGluZyB0cmFuc2FjdGlvbnMgdG9cbiAqIGNvbXBsZXRlLlxuICpcbiAqIEV4dGVybmFsbHkgaXQncyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMsIGJ1dCBpdCBjYWxscyBpdHNlbGYgcmVjdXJzaXZlbHkgd2l0aCBhIHBhcnRpY3VsYXJcbiAqIHRyYW5zYWN0aW9uUXVldWVUcmVlIG5vZGUgdG8gcmVjdXJzZSB0aHJvdWdoIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSB7VHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj49fSBub2RlICB0cmFuc2FjdGlvblF1ZXVlVHJlZSBub2RlIHRvIHN0YXJ0IGF0LlxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKG5vZGUgPT09IHZvaWQgMCkgeyBub2RlID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV87IH1cbiAgICAvLyBCZWZvcmUgcmVjdXJzaW5nLCBtYWtlIHN1cmUgYW55IGNvbXBsZXRlZCB0cmFuc2FjdGlvbnMgYXJlIHJlbW92ZWQuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5nZXRWYWx1ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMuYnVpbGRUcmFuc2FjdGlvblF1ZXVlXyhub2RlKTtcbiAgICAgICAgdXRpbF8xLmFzc2VydChxdWV1ZS5sZW5ndGggPiAwLCAnU2VuZGluZyB6ZXJvIGxlbmd0aCB0cmFuc2FjdGlvbiBxdWV1ZScpO1xuICAgICAgICB2YXIgYWxsUnVuID0gcXVldWUuZXZlcnkoZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7IHJldHVybiB0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTjsgfSk7XG4gICAgICAgIC8vIElmIHRoZXkncmUgYWxsIHJ1biAoYW5kIG5vdCBzZW50KSwgd2UgY2FuIHNlbmQgdGhlbS4gIEVsc2UsIHdlIG11c3Qgd2FpdC5cbiAgICAgICAgaWYgKGFsbFJ1bikge1xuICAgICAgICAgICAgdGhpcy5zZW5kVHJhbnNhY3Rpb25RdWV1ZV8obm9kZS5wYXRoKCksIHF1ZXVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgbm9kZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICAgICAgX3RoaXMuc2VuZFJlYWR5VHJhbnNhY3Rpb25zXyhjaGlsZE5vZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuLyoqXG4gKiBHaXZlbiBhIGxpc3Qgb2YgcnVuIHRyYW5zYWN0aW9ucywgc2VuZCB0aGVtIHRvIHRoZSBzZXJ2ZXIgYW5kIHRoZW4gaGFuZGxlIHRoZSByZXN1bHQgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSkuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgbG9jYXRpb24gb2YgdGhlIHF1ZXVlLlxuICogQHBhcmFtIHshQXJyYXkuPFRyYW5zYWN0aW9uPn0gcXVldWUgUXVldWUgb2YgdHJhbnNhY3Rpb25zIHVuZGVyIHRoZSBzcGVjaWZpZWQgbG9jYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uUXVldWVfID0gZnVuY3Rpb24gKHBhdGgsIHF1ZXVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBNYXJrIHRyYW5zYWN0aW9ucyBhcyBzZW50IGFuZCBpbmNyZW1lbnQgcmV0cnkgY291bnQhXG4gICAgdmFyIHNldHNUb0lnbm9yZSA9IHF1ZXVlLm1hcChmdW5jdGlvbiAodHhuKSB7XG4gICAgICAgIHJldHVybiB0eG4uY3VycmVudFdyaXRlSWQ7XG4gICAgfSk7XG4gICAgdmFyIGxhdGVzdFN0YXRlID0gdGhpcy5nZXRMYXRlc3RTdGF0ZV8ocGF0aCwgc2V0c1RvSWdub3JlKTtcbiAgICB2YXIgc25hcFRvU2VuZCA9IGxhdGVzdFN0YXRlO1xuICAgIHZhciBsYXRlc3RIYXNoID0gbGF0ZXN0U3RhdGUuaGFzaCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHR4biA9IHF1ZXVlW2ldO1xuICAgICAgICB1dGlsXzEuYXNzZXJ0KHR4bi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTiwgJ3RyeVRvU2VuZFRyYW5zYWN0aW9uUXVldWVfOiBpdGVtcyBpbiBxdWV1ZSBzaG91bGQgYWxsIGJlIHJ1bi4nKTtcbiAgICAgICAgdHhuLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlNFTlQ7XG4gICAgICAgIHR4bi5yZXRyeUNvdW50Kys7XG4gICAgICAgIHZhciByZWxhdGl2ZVBhdGggPSBQYXRoXzEuUGF0aC5yZWxhdGl2ZVBhdGgocGF0aCwgdHhuLnBhdGgpO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gdG8gdGhpcyBwb2ludCwgdGhlIG91dHB1dCBzbmFwc2hvdCBtdXN0IGJlIGRlZmluZWQuXG4gICAgICAgIHNuYXBUb1NlbmQgPSBzbmFwVG9TZW5kLnVwZGF0ZUNoaWxkKHJlbGF0aXZlUGF0aCAvKipAdHlwZSB7IU5vZGV9ICovLCB0eG4uY3VycmVudE91dHB1dFNuYXBzaG90UmF3KTtcbiAgICB9XG4gICAgdmFyIGRhdGFUb1NlbmQgPSBzbmFwVG9TZW5kLnZhbCh0cnVlKTtcbiAgICB2YXIgcGF0aFRvU2VuZCA9IHBhdGg7XG4gICAgLy8gU2VuZCB0aGUgcHV0LlxuICAgIHRoaXMuc2VydmVyXy5wdXQocGF0aFRvU2VuZC50b1N0cmluZygpLCBkYXRhVG9TZW5kLCBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgIF90aGlzLmxvZ18oJ3RyYW5zYWN0aW9uIHB1dCByZXNwb25zZScsIHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGhUb1NlbmQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICdvaycpIHtcbiAgICAgICAgICAgIC8vIFF1ZXVlIHVwIHRoZSBjYWxsYmFja3MgYW5kIGZpcmUgdGhlbSBhZnRlciBjbGVhbmluZyB1cCBhbGwgb2Ygb3VyIHRyYW5zYWN0aW9uIHN0YXRlLCBzaW5jZVxuICAgICAgICAgICAgLy8gdGhlIGNhbGxiYWNrIGNvdWxkIHRyaWdnZXIgbW9yZSB0cmFuc2FjdGlvbnMgb3Igc2V0cy5cbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdChfdGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkKSk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmV2ZXIgdW5zZXQgdGhlIG91dHB1dCBzbmFwc2hvdCwgYW5kIGdpdmVuIHRoYXQgdGhpcyB0cmFuc2FjdGlvbiBpcyBjb21wbGV0ZSwgaXQgc2hvdWxkIGJlIHNldFxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHF1ZXVlW2ldLmN1cnJlbnRPdXRwdXRTbmFwc2hvdFJlc29sdmVkO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVmID0gbmV3IFJlZmVyZW5jZV8xLlJlZmVyZW5jZShfdGhpcywgcXVldWVbaV0ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IG5ldyBEYXRhU25hcHNob3RfMS5EYXRhU25hcHNob3Qobm9kZSwgcmVmLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbnVsbCwgdHJ1ZSwgc25hcHNob3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcXVldWVbaV0udW53YXRjaGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3cgcmVtb3ZlIHRoZSBjb21wbGV0ZWQgdHJhbnNhY3Rpb25zLlxuICAgICAgICAgICAgX3RoaXMucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfKF90aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXy5zdWJUcmVlKHBhdGgpKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBwZW5kaW5nIHRyYW5zYWN0aW9ucyB0aGF0IHdlIGNhbiBub3cgc2VuZC5cbiAgICAgICAgICAgIF90aGlzLnNlbmRSZWFkeVRyYW5zYWN0aW9uc18oKTtcbiAgICAgICAgICAgIF90aGlzLmV2ZW50UXVldWVfLnJhaXNlRXZlbnRzRm9yQ2hhbmdlZFBhdGgocGF0aCwgZXZlbnRzKTtcbiAgICAgICAgICAgIC8vIEZpbmFsbHksIHRyaWdnZXIgb25Db21wbGV0ZSBjYWxsYmFja3MuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHV0aWxfMi5leGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdHJhbnNhY3Rpb25zIGFyZSBubyBsb25nZXIgc2VudC4gIFVwZGF0ZSB0aGVpciBzdGF0dXMgYXBwcm9wcmlhdGVseS5cbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdkYXRhc3RhbGUnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUKVxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuTkVFRFNfQUJPUlQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLlJVTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsXzIud2FybigndHJhbnNhY3Rpb24gYXQgJyArIHBhdGhUb1NlbmQudG9TdHJpbmcoKSArICcgZmFpbGVkOiAnICsgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLk5FRURTX0FCT1JUO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5yZXJ1blRyYW5zYWN0aW9uc18ocGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBsYXRlc3RIYXNoKTtcbn07XG4vKipcbiAqIEZpbmRzIGFsbCB0cmFuc2FjdGlvbnMgZGVwZW5kZW50IG9uIHRoZSBkYXRhIGF0IGNoYW5nZWRQYXRoIGFuZCByZXJ1bnMgdGhlbS5cbiAqXG4gKiBTaG91bGQgYmUgY2FsbGVkIGFueSB0aW1lIGNhY2hlZCBkYXRhIGNoYW5nZXMuXG4gKlxuICogUmV0dXJuIHRoZSBoaWdoZXN0IHBhdGggdGhhdCB3YXMgYWZmZWN0ZWQgYnkgcmVydW5uaW5nIHRyYW5zYWN0aW9ucy4gIFRoaXMgaXMgdGhlIHBhdGggYXQgd2hpY2ggZXZlbnRzIG5lZWQgdG9cbiAqIGJlIHJhaXNlZCBmb3IuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gY2hhbmdlZFBhdGggVGhlIHBhdGggaW4gbWVyZ2VkRGF0YSB0aGF0IGNoYW5nZWQuXG4gKiBAcmV0dXJuIHshUGF0aH0gVGhlIHJvb3Rtb3N0IHBhdGggdGhhdCB3YXMgYWZmZWN0ZWQgYnkgcmVydW5uaW5nIHRyYW5zYWN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5yZXJ1blRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbiAoY2hhbmdlZFBhdGgpIHtcbiAgICB2YXIgcm9vdE1vc3RUcmFuc2FjdGlvbk5vZGUgPSB0aGlzLmdldEFuY2VzdG9yVHJhbnNhY3Rpb25Ob2RlXyhjaGFuZ2VkUGF0aCk7XG4gICAgdmFyIHBhdGggPSByb290TW9zdFRyYW5zYWN0aW9uTm9kZS5wYXRoKCk7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5idWlsZFRyYW5zYWN0aW9uUXVldWVfKHJvb3RNb3N0VHJhbnNhY3Rpb25Ob2RlKTtcbiAgICB0aGlzLnJlcnVuVHJhbnNhY3Rpb25RdWV1ZV8ocXVldWUsIHBhdGgpO1xuICAgIHJldHVybiBwYXRoO1xufTtcbi8qKlxuICogRG9lcyBhbGwgdGhlIHdvcmsgb2YgcmVydW5uaW5nIHRyYW5zYWN0aW9ucyAoYXMgd2VsbCBhcyBjbGVhbnMgdXAgYWJvcnRlZCB0cmFuc2FjdGlvbnMgYW5kIHdoYXRub3QpLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPFRyYW5zYWN0aW9uPn0gcXVldWUgVGhlIHF1ZXVlIG9mIHRyYW5zYWN0aW9ucyB0byBydW4uXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFRoZSBwYXRoIHRoZSBxdWV1ZSBpcyBmb3IuXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUucmVydW5UcmFuc2FjdGlvblF1ZXVlXyA9IGZ1bmN0aW9uIChxdWV1ZSwgcGF0aCkge1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvIVxuICAgIH1cbiAgICAvLyBRdWV1ZSB1cCB0aGUgY2FsbGJhY2tzIGFuZCBmaXJlIHRoZW0gYWZ0ZXIgY2xlYW5pbmcgdXAgYWxsIG9mIG91ciB0cmFuc2FjdGlvbiBzdGF0ZSwgc2luY2VcbiAgICAvLyB0aGUgY2FsbGJhY2sgY291bGQgdHJpZ2dlciBtb3JlIHRyYW5zYWN0aW9ucyBvciBzZXRzLlxuICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICB2YXIgZXZlbnRzID0gW107XG4gICAgLy8gSWdub3JlIGFsbCBvZiB0aGUgc2V0cyB3ZSdyZSBnb2luZyB0byByZS1ydW4uXG4gICAgdmFyIHR4bnNUb1JlcnVuID0gcXVldWUuZmlsdGVyKGZ1bmN0aW9uIChxKSB7XG4gICAgICAgIHJldHVybiBxLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuUlVOO1xuICAgIH0pO1xuICAgIHZhciBzZXRzVG9JZ25vcmUgPSB0eG5zVG9SZXJ1bi5tYXAoZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgcmV0dXJuIHEuY3VycmVudFdyaXRlSWQ7XG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBxdWV1ZVtpXTtcbiAgICAgICAgdmFyIHJlbGF0aXZlUGF0aCA9IFBhdGhfMS5QYXRoLnJlbGF0aXZlUGF0aChwYXRoLCB0cmFuc2FjdGlvbi5wYXRoKTtcbiAgICAgICAgdmFyIGFib3J0VHJhbnNhY3Rpb24gPSBmYWxzZSwgYWJvcnRSZWFzb24gPSB2b2lkIDA7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQocmVsYXRpdmVQYXRoICE9PSBudWxsLCAncmVydW5UcmFuc2FjdGlvbnNVbmRlck5vZGVfOiByZWxhdGl2ZVBhdGggc2hvdWxkIG5vdCBiZSBudWxsLicpO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5ORUVEU19BQk9SVCkge1xuICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBhYm9ydFJlYXNvbiA9IHRyYW5zYWN0aW9uLmFib3J0UmVhc29uO1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFuc2FjdGlvbi5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTikge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnJldHJ5Q291bnQgPj0gUmVwb18xLlJlcG8uTUFYX1RSQU5TQUNUSU9OX1JFVFJJRVNfKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbWF4cmV0cnknO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgcmVydW5zIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLmdldExhdGVzdFN0YXRlXyh0cmFuc2FjdGlvbi5wYXRoLCBzZXRzVG9JZ25vcmUpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRJbnB1dFNuYXBzaG90ID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBxdWV1ZVtpXS51cGRhdGUoY3VycmVudE5vZGUudmFsKCkpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbl8xLnZhbGlkYXRlRmlyZWJhc2VEYXRhKCd0cmFuc2FjdGlvbiBmYWlsZWQ6IERhdGEgcmV0dXJuZWQgJywgbmV3RGF0YSwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdEYXRhTm9kZSA9IG5vZGVGcm9tSlNPTl8xLm5vZGVGcm9tSlNPTihuZXdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc0V4cGxpY2l0UHJpb3JpdHkgPSB0eXBlb2YgbmV3RGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RhdGEgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8zLmNvbnRhaW5zKG5ld0RhdGEsICcucHJpb3JpdHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNFeHBsaWNpdFByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBvbGQgcHJpb3JpdHkgaWYgdGhlcmUgd2Fzbid0IGEgcHJpb3JpdHkgZXhwbGljaXRseSBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdEYXRhTm9kZSA9IG5ld0RhdGFOb2RlLnVwZGF0ZVByaW9yaXR5KGN1cnJlbnROb2RlLmdldFByaW9yaXR5KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBvbGRXcml0ZUlkID0gdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXJWYWx1ZXMgPSB0aGlzLmdlbmVyYXRlU2VydmVyVmFsdWVzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlUmVzb2x2ZWQgPSBTZXJ2ZXJWYWx1ZXNfMS5yZXNvbHZlRGVmZXJyZWRWYWx1ZVNuYXBzaG90KG5ld0RhdGFOb2RlLCBzZXJ2ZXJWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5jdXJyZW50T3V0cHV0U25hcHNob3RSYXcgPSBuZXdEYXRhTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3VycmVudE91dHB1dFNuYXBzaG90UmVzb2x2ZWQgPSBuZXdOb2RlUmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmN1cnJlbnRXcml0ZUlkID0gdGhpcy5nZXROZXh0V3JpdGVJZF8oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTXV0YXRlcyBzZXRzVG9JZ25vcmUgaW4gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgc2V0c1RvSWdub3JlLnNwbGljZShzZXRzVG9JZ25vcmUuaW5kZXhPZihvbGRXcml0ZUlkKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYXBwbHlVc2VyT3ZlcndyaXRlKHRyYW5zYWN0aW9uLnBhdGgsIG5ld05vZGVSZXNvbHZlZCwgdHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRyYW5zYWN0aW9uLmFwcGx5TG9jYWxseSkpO1xuICAgICAgICAgICAgICAgICAgICBldmVudHMgPSBldmVudHMuY29uY2F0KHRoaXMuc2VydmVyU3luY1RyZWVfLmFja1VzZXJXcml0ZShvbGRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRSZWFzb24gPSAnbm9kYXRhJztcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzLmNvbmNhdCh0aGlzLnNlcnZlclN5bmNUcmVlXy5hY2tVc2VyV3JpdGUodHJhbnNhY3Rpb24uY3VycmVudFdyaXRlSWQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudFF1ZXVlXy5yYWlzZUV2ZW50c0ZvckNoYW5nZWRQYXRoKHBhdGgsIGV2ZW50cyk7XG4gICAgICAgIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoYWJvcnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgLy8gQWJvcnQuXG4gICAgICAgICAgICBxdWV1ZVtpXS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgICAgICAvLyBSZW1vdmluZyBhIGxpc3RlbmVyIGNhbiB0cmlnZ2VyIHBydW5pbmcgd2hpY2ggY2FuIG11Y2sgd2l0aCBtZXJnZWREYXRhL3Zpc2libGVEYXRhIChhcyBpdCBwcnVuZXMgZGF0YSkuXG4gICAgICAgICAgICAvLyBTbyBkZWZlciB0aGUgdW53YXRjaGVyIHVudGlsIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAoZnVuY3Rpb24gKHVud2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodW53YXRjaGVyLCBNYXRoLmZsb29yKDApKTtcbiAgICAgICAgICAgIH0pKHF1ZXVlW2ldLnVud2F0Y2hlcik7XG4gICAgICAgICAgICBpZiAocXVldWVbaV0ub25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhYm9ydFJlYXNvbiA9PT0gJ25vZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IG5ldyBSZWZlcmVuY2VfMS5SZWZlcmVuY2UodGhpcywgcXVldWVbaV0ucGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHNldCB0aGlzIGZpZWxkIGltbWVkaWF0ZWx5LCBzbyBpdCdzIHNhZmUgdG8gY2FzdCB0byBhbiBhY3R1YWwgc25hcHNob3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbnB1dCAvKiogQHR5cGUgeyFOb2RlfSAqLyA9IHF1ZXVlW2ldLmN1cnJlbnRJbnB1dFNuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHNob3QgPSBuZXcgRGF0YVNuYXBzaG90XzEuRGF0YVNuYXBzaG90KGxhc3RJbnB1dCwgcmVmLCBQcmlvcml0eUluZGV4XzEuUFJJT1JJVFlfSU5ERVgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbnVsbCwgZmFsc2UsIHNuYXBzaG90KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChxdWV1ZVtpXS5vbkNvbXBsZXRlLmJpbmQobnVsbCwgbmV3IEVycm9yKGFib3J0UmVhc29uKSwgZmFsc2UsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ2xlYW4gdXAgY29tcGxldGVkIHRyYW5zYWN0aW9ucy5cbiAgICB0aGlzLnBydW5lQ29tcGxldGVkVHJhbnNhY3Rpb25zQmVsb3dOb2RlXyh0aGlzLnRyYW5zYWN0aW9uUXVldWVUcmVlXyk7XG4gICAgLy8gTm93IGZpcmUgY2FsbGJhY2tzLCBub3cgdGhhdCB3ZSdyZSBpbiBhIGdvb2QsIGtub3duIHN0YXRlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHV0aWxfMi5leGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gcmVzdWx0IHRvIHRoZSBzZXJ2ZXIuXG4gICAgdGhpcy5zZW5kUmVhZHlUcmFuc2FjdGlvbnNfKCk7XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSByb290bW9zdCBhbmNlc3RvciBub2RlIG9mIHRoZSBzcGVjaWZpZWQgcGF0aCB0aGF0IGhhcyBhIHBlbmRpbmcgdHJhbnNhY3Rpb24gb24gaXQsIG9yIGp1c3QgcmV0dXJuc1xuICogdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBwYXRoIGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nIHRyYW5zYWN0aW9ucyBvbiBhbnkgYW5jZXN0b3IuXG4gKlxuICogQHBhcmFtIHshUGF0aH0gcGF0aCBUaGUgbG9jYXRpb24gdG8gc3RhcnQgYXQuXG4gKiBAcmV0dXJuIHshVHJlZS48QXJyYXkuPCFUcmFuc2FjdGlvbj4+fSBUaGUgcm9vdG1vc3Qgbm9kZSB3aXRoIGEgdHJhbnNhY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUuZ2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGVfID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgZnJvbnQ7XG4gICAgLy8gU3RhcnQgYXQgdGhlIHJvb3QgYW5kIHdhbGsgZGVlcGVyIGludG8gdGhlIHRyZWUgdG93YXJkcyBwYXRoIHVudGlsIHdlIGZpbmQgYSBub2RlIHdpdGggcGVuZGluZyB0cmFuc2FjdGlvbnMuXG4gICAgdmFyIHRyYW5zYWN0aW9uTm9kZSA9IHRoaXMudHJhbnNhY3Rpb25RdWV1ZVRyZWVfO1xuICAgIHdoaWxlICgoZnJvbnQgPSBwYXRoLmdldEZyb250KCkpICE9PSBudWxsICYmXG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZS5nZXRWYWx1ZSgpID09PSBudWxsKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uTm9kZSA9IHRyYW5zYWN0aW9uTm9kZS5zdWJUcmVlKGZyb250KTtcbiAgICAgICAgcGF0aCA9IHBhdGgucG9wRnJvbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uTm9kZTtcbn07XG4vKipcbiAqIEJ1aWxkcyB0aGUgcXVldWUgb2YgYWxsIHRyYW5zYWN0aW9ucyBhdCBvciBiZWxvdyB0aGUgc3BlY2lmaWVkIHRyYW5zYWN0aW9uTm9kZS5cbiAqXG4gKiBAcGFyYW0geyFUcmVlLjxBcnJheS48VHJhbnNhY3Rpb24+Pn0gdHJhbnNhY3Rpb25Ob2RlXG4gKiBAcmV0dXJuIHtBcnJheS48VHJhbnNhY3Rpb24+fSBUaGUgZ2VuZXJhdGVkIHF1ZXVlLlxuICogQHByaXZhdGVcbiAqL1xuUmVwb18xLlJlcG8ucHJvdG90eXBlLmJ1aWxkVHJhbnNhY3Rpb25RdWV1ZV8gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25Ob2RlKSB7XG4gICAgLy8gV2FsayBhbnkgY2hpbGQgdHJhbnNhY3Rpb24gcXVldWVzIGFuZCBhZ2dyZWdhdGUgdGhlbSBpbnRvIGEgc2luZ2xlIHF1ZXVlLlxuICAgIHZhciB0cmFuc2FjdGlvblF1ZXVlID0gW107XG4gICAgdGhpcy5hZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGVfKHRyYW5zYWN0aW9uTm9kZSwgdHJhbnNhY3Rpb25RdWV1ZSk7XG4gICAgLy8gU29ydCB0aGVtIGJ5IHRoZSBvcmRlciB0aGUgdHJhbnNhY3Rpb25zIHdlcmUgY3JlYXRlZC5cbiAgICB0cmFuc2FjdGlvblF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvblF1ZXVlO1xufTtcbi8qKlxuICogQHBhcmFtIHshVHJlZS48QXJyYXkuPFRyYW5zYWN0aW9uPj59IG5vZGVcbiAqIEBwYXJhbSB7QXJyYXkuPFRyYW5zYWN0aW9uPn0gcXVldWVcbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5hZ2dyZWdhdGVUcmFuc2FjdGlvblF1ZXVlc0Zvck5vZGVfID0gZnVuY3Rpb24gKG5vZGUsIHF1ZXVlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICB2YXIgbm9kZVF1ZXVlID0gbm9kZS5nZXRWYWx1ZSgpO1xuICAgIGlmIChub2RlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZVF1ZXVlW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBub2RlLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgX3RoaXMuYWdncmVnYXRlVHJhbnNhY3Rpb25RdWV1ZXNGb3JOb2RlXyhjaGlsZCwgcXVldWUpO1xuICAgIH0pO1xufTtcbi8qKlxuICogUmVtb3ZlIENPTVBMRVRFRCB0cmFuc2FjdGlvbnMgYXQgb3IgYmVsb3cgdGhpcyBub2RlIGluIHRoZSB0cmFuc2FjdGlvblF1ZXVlVHJlZV8uXG4gKlxuICogQHBhcmFtIHshVHJlZS48QXJyYXkuPCFUcmFuc2FjdGlvbj4+fSBub2RlXG4gKiBAcHJpdmF0ZVxuICovXG5SZXBvXzEuUmVwby5wcm90b3R5cGUucHJ1bmVDb21wbGV0ZWRUcmFuc2FjdGlvbnNCZWxvd05vZGVfID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAocXVldWUpIHtcbiAgICAgICAgdmFyIHRvID0gMDtcbiAgICAgICAgZm9yICh2YXIgZnJvbSA9IDA7IGZyb20gPCBxdWV1ZS5sZW5ndGg7IGZyb20rKykge1xuICAgICAgICAgICAgaWYgKHF1ZXVlW2Zyb21dLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEVEKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbdG9dID0gcXVldWVbZnJvbV07XG4gICAgICAgICAgICAgICAgdG8rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5sZW5ndGggPSB0bztcbiAgICAgICAgbm9kZS5zZXRWYWx1ZShxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUgOiBudWxsKTtcbiAgICB9XG4gICAgbm9kZS5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICBfdGhpcy5wcnVuZUNvbXBsZXRlZFRyYW5zYWN0aW9uc0JlbG93Tm9kZV8oY2hpbGROb2RlKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEFib3J0cyBhbGwgdHJhbnNhY3Rpb25zIG9uIGFuY2VzdG9ycyBvciBkZXNjZW5kYW50cyBvZiB0aGUgc3BlY2lmaWVkIHBhdGguICBDYWxsZWQgd2hlbiBkb2luZyBhIHNldCgpIG9yIHVwZGF0ZSgpXG4gKiBzaW5jZSB3ZSBjb25zaWRlciB0aGVtIGluY29tcGF0aWJsZSB3aXRoIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0geyFQYXRofSBwYXRoIFBhdGggZm9yIHdoaWNoIHdlIHdhbnQgdG8gYWJvcnQgcmVsYXRlZCB0cmFuc2FjdGlvbnMuXG4gKiBAcmV0dXJuIHshUGF0aH1cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5hYm9ydFRyYW5zYWN0aW9uc18gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGFmZmVjdGVkUGF0aCA9IHRoaXMuZ2V0QW5jZXN0b3JUcmFuc2FjdGlvbk5vZGVfKHBhdGgpLnBhdGgoKTtcbiAgICB2YXIgdHJhbnNhY3Rpb25Ob2RlID0gdGhpcy50cmFuc2FjdGlvblF1ZXVlVHJlZV8uc3ViVHJlZShwYXRoKTtcbiAgICB0cmFuc2FjdGlvbk5vZGUuZm9yRWFjaEFuY2VzdG9yKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIF90aGlzLmFib3J0VHJhbnNhY3Rpb25zT25Ob2RlXyhub2RlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFib3J0VHJhbnNhY3Rpb25zT25Ob2RlXyh0cmFuc2FjdGlvbk5vZGUpO1xuICAgIHRyYW5zYWN0aW9uTm9kZS5mb3JFYWNoRGVzY2VuZGFudChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBfdGhpcy5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8obm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFmZmVjdGVkUGF0aDtcbn07XG4vKipcbiAqIEFib3J0IHRyYW5zYWN0aW9ucyBzdG9yZWQgaW4gdGhpcyB0cmFuc2FjdGlvbiBxdWV1ZSBub2RlLlxuICpcbiAqIEBwYXJhbSB7IVRyZWUuPEFycmF5LjxUcmFuc2FjdGlvbj4+fSBub2RlIE5vZGUgdG8gYWJvcnQgdHJhbnNhY3Rpb25zIGZvci5cbiAqIEBwcml2YXRlXG4gKi9cblJlcG9fMS5SZXBvLnByb3RvdHlwZS5hYm9ydFRyYW5zYWN0aW9uc09uTm9kZV8gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBxdWV1ZSA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAocXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gUXVldWUgdXAgdGhlIGNhbGxiYWNrcyBhbmQgZmlyZSB0aGVtIGFmdGVyIGNsZWFuaW5nIHVwIGFsbCBvZiBvdXIgdHJhbnNhY3Rpb24gc3RhdGUsIHNpbmNlXG4gICAgICAgIC8vIHRoZSBjYWxsYmFjayBjb3VsZCB0cmlnZ2VyIG1vcmUgdHJhbnNhY3Rpb25zIG9yIHNldHMuXG4gICAgICAgIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgLy8gR28gdGhyb3VnaCBxdWV1ZS4gIEFueSBhbHJlYWR5LXNlbnQgdHJhbnNhY3Rpb25zIG11c3QgYmUgbWFya2VkIGZvciBhYm9ydCwgd2hpbGUgdGhlIHVuc2VudCBvbmVzXG4gICAgICAgIC8vIGNhbiBiZSBpbW1lZGlhdGVseSBhYm9ydGVkIGFuZCByZW1vdmVkLlxuICAgICAgICB2YXIgZXZlbnRzID0gW107XG4gICAgICAgIHZhciBsYXN0U2VudCA9IC0xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocXVldWVbaV0uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5TRU5UX05FRURTX0FCT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBtYXJrZWQuICBObyBhY3Rpb24gbmVlZGVkLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocXVldWVbaV0uc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5TRU5UKSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChsYXN0U2VudCA9PT0gaSAtIDEsICdBbGwgU0VOVCBpdGVtcyBzaG91bGQgYmUgYXQgYmVnaW5uaW5nIG9mIHF1ZXVlLicpO1xuICAgICAgICAgICAgICAgIGxhc3RTZW50ID0gaTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHRyYW5zYWN0aW9uIGZvciBhYm9ydCB3aGVuIGl0IGNvbWVzIGJhY2suXG4gICAgICAgICAgICAgICAgcXVldWVbaV0uc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuU0VOVF9ORUVEU19BQk9SVDtcbiAgICAgICAgICAgICAgICBxdWV1ZVtpXS5hYm9ydFJlYXNvbiA9ICdzZXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbF8xLmFzc2VydChxdWV1ZVtpXS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLlJVTiwgJ1VuZXhwZWN0ZWQgdHJhbnNhY3Rpb24gc3RhdHVzIGluIGFib3J0Jyk7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGFib3J0IGl0IGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLnVud2F0Y2hlcigpO1xuICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5jb25jYXQodGhpcy5zZXJ2ZXJTeW5jVHJlZV8uYWNrVXNlcldyaXRlKHF1ZXVlW2ldLmN1cnJlbnRXcml0ZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlW2ldLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2gocXVldWVbaV0ub25Db21wbGV0ZS5iaW5kKG51bGwsIG5ldyBFcnJvcignc2V0JyksIGZhbHNlLCBzbmFwc2hvdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdFNlbnQgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBub3Qgd2FpdGluZyBmb3IgYW55IHNlbnQgdHJhbnNhY3Rpb25zLiAgV2UgY2FuIGNsZWFyIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIG5vZGUuc2V0VmFsdWUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYW5zYWN0aW9ucyB3ZSBhYm9ydGVkLlxuICAgICAgICAgICAgcXVldWUubGVuZ3RoID0gbGFzdFNlbnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyBmaXJlIHRoZSBjYWxsYmFja3MuXG4gICAgICAgIHRoaXMuZXZlbnRRdWV1ZV8ucmFpc2VFdmVudHNGb3JDaGFuZ2VkUGF0aChub2RlLnBhdGgoKSwgZXZlbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHV0aWxfMi5leGNlcHRpb25HdWFyZChjYWxsYmFja3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVwb190cmFuc2FjdGlvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9kYXRhYmFzZS9kaXN0L2Nqcy9zcmMvY29yZS9SZXBvX3RyYW5zYWN0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xudmFyIFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG52YXIgdXRpbF8yID0gcmVxdWlyZShcIkBmaXJlYmFzZS91dGlsXCIpO1xuLyoqXG4gKiBOb2RlIGluIGEgVHJlZS5cbiAqL1xudmFyIFRyZWVOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRyZWVOb2RlKCkge1xuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtYWtpbmcgYWNjZXNzb3JzIHRoYXQgY3JlYXRlIGNoaWxkcmVuIGFuZCB2YWx1ZSBsYXppbHkgb3JcbiAgICAgICAgLy8gc2VwYXJhdGUgSW50ZXJuYWwgLyBMZWFmICd0eXBlcycuXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSB7fTtcbiAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBUcmVlTm9kZTtcbn0oKSk7XG5leHBvcnRzLlRyZWVOb2RlID0gVHJlZU5vZGU7XG4vKipcbiAqIEEgbGlnaHQtd2VpZ2h0IHRyZWUsIHRyYXZlcnNhYmxlIGJ5IHBhdGguICBOb2RlcyBjYW4gaGF2ZSBib3RoIHZhbHVlcyBhbmQgY2hpbGRyZW4uXG4gKiBOb2RlcyBhcmUgbm90IGVudW1lcmF0ZWQgKGJ5IGZvckVhY2hDaGlsZCkgdW5sZXNzIHRoZXkgaGF2ZSBhIHZhbHVlIG9yIG5vbi1lbXB0eVxuICogY2hpbGRyZW4uXG4gKi9cbnZhciBUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lXyBPcHRpb25hbCBuYW1lIG9mIHRoZSBub2RlLlxuICAgICAqIEBwYXJhbSB7VHJlZT19IHBhcmVudF8gT3B0aW9uYWwgcGFyZW50IG5vZGUuXG4gICAgICogQHBhcmFtIHtUcmVlTm9kZT19IG5vZGVfIE9wdGlvbmFsIG5vZGUgdG8gd3JhcC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmVlKG5hbWVfLCBwYXJlbnRfLCBub2RlXykge1xuICAgICAgICBpZiAobmFtZV8gPT09IHZvaWQgMCkgeyBuYW1lXyA9ICcnOyB9XG4gICAgICAgIGlmIChwYXJlbnRfID09PSB2b2lkIDApIHsgcGFyZW50XyA9IG51bGw7IH1cbiAgICAgICAgaWYgKG5vZGVfID09PSB2b2lkIDApIHsgbm9kZV8gPSBuZXcgVHJlZU5vZGUoKTsgfVxuICAgICAgICB0aGlzLm5hbWVfID0gbmFtZV87XG4gICAgICAgIHRoaXMucGFyZW50XyA9IHBhcmVudF87XG4gICAgICAgIHRoaXMubm9kZV8gPSBub2RlXztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN1Yi1UcmVlIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IShzdHJpbmd8UGF0aCl9IHBhdGhPYmogUGF0aCB0byBsb29rIHVwLlxuICAgICAqIEByZXR1cm4geyFUcmVlLjxUPn0gVHJlZSBmb3IgcGF0aC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5zdWJUcmVlID0gZnVuY3Rpb24gKHBhdGhPYmopIHtcbiAgICAgICAgLy8gVE9ETzogUmVxdWlyZSBwYXRoT2JqIHRvIGJlIFBhdGg/XG4gICAgICAgIHZhciBwYXRoID0gcGF0aE9iaiBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoID8gcGF0aE9iaiA6IG5ldyBQYXRoXzEuUGF0aChwYXRoT2JqKTtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcywgbmV4dDtcbiAgICAgICAgd2hpbGUgKChuZXh0ID0gcGF0aC5nZXRGcm9udCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHV0aWxfMi5zYWZlR2V0KGNoaWxkLm5vZGVfLmNoaWxkcmVuLCBuZXh0KSB8fCBuZXcgVHJlZU5vZGUoKTtcbiAgICAgICAgICAgIGNoaWxkID0gbmV3IFRyZWUobmV4dCwgY2hpbGQsIGNoaWxkTm9kZSk7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5wb3BGcm9udCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdHJlZSBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7P1R9IFRoZSBkYXRhIG9yIG51bGwgaWYgbm8gZGF0YSBleGlzdHMuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfLnZhbHVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyBkYXRhIHRvIHRoaXMgdHJlZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshVH0gdmFsdWUgVmFsdWUgdG8gc2V0LlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHV0aWxfMS5hc3NlcnQodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJywgJ0Nhbm5vdCBzZXQgdmFsdWUgdG8gdW5kZWZpbmVkJyk7XG4gICAgICAgIHRoaXMubm9kZV8udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRzXygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBjb250ZW50cyBvZiB0aGUgdHJlZSBub2RlIChpdHMgdmFsdWUgYW5kIGFsbCBjaGlsZHJlbikuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubm9kZV8udmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLm5vZGVfLmNoaWxkcmVuID0ge307XG4gICAgICAgIHRoaXMubm9kZV8uY2hpbGRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyZWUgaGFzIGFueSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZV8uY2hpbGRDb3VudCA+IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB0cmVlIGlzIGVtcHR5IChubyB2YWx1ZSBvciBjaGlsZHJlbikuXG4gICAgICovXG4gICAgVHJlZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiAhdGhpcy5oYXNDaGlsZHJlbigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYWN0aW9uIGZvciBlYWNoIGNoaWxkIG9mIHRoaXMgdHJlZSBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighVHJlZS48VD4pfSBhY3Rpb24gQWN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBjaGlsZC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoQ2hpbGQgPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWxfMi5mb3JFYWNoKHRoaXMubm9kZV8uY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCwgY2hpbGRUcmVlKSB7XG4gICAgICAgICAgICBhY3Rpb24obmV3IFRyZWUoY2hpbGQsIF90aGlzLCBjaGlsZFRyZWUpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2VzIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoaXMgbm9kZSdzIGRlc2NlbmRhbnRzLCBjYWxsaW5nIGFjdGlvbiBmb3IgZWFjaCBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFUcmVlLjxUPil9IGFjdGlvbiBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluY2x1ZGVTZWxmIFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gdGhpcyBub2RlIGFzIHdlbGwuIERlZmF1bHRzIHRvXG4gICAgICogICBmYWxzZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBjaGlsZHJlbkZpcnN0IFdoZXRoZXIgdG8gY2FsbCBhY3Rpb24gb24gY2hpbGRyZW4gYmVmb3JlIGNhbGxpbmcgaXQgb25cbiAgICAgKiAgIHBhcmVudC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoRGVzY2VuZGFudCA9IGZ1bmN0aW9uIChhY3Rpb24sIGluY2x1ZGVTZWxmLCBjaGlsZHJlbkZpcnN0KSB7XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiAhY2hpbGRyZW5GaXJzdClcbiAgICAgICAgICAgIGFjdGlvbih0aGlzKTtcbiAgICAgICAgdGhpcy5mb3JFYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5mb3JFYWNoRGVzY2VuZGFudChhY3Rpb24sIC8qaW5jbHVkZVNlbGY9Ki8gdHJ1ZSwgY2hpbGRyZW5GaXJzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5jbHVkZVNlbGYgJiYgY2hpbGRyZW5GaXJzdClcbiAgICAgICAgICAgIGFjdGlvbih0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxzIGFjdGlvbiBvbiBlYWNoIGFuY2VzdG9yIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFUcmVlLjxUPil9IGFjdGlvbiBBY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGVhY2ggcGFyZW50OyByZXR1cm5cbiAgICAgKiAgIHRydWUgdG8gYWJvcnQuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5jbHVkZVNlbGYgV2hldGhlciB0byBjYWxsIGFjdGlvbiBvbiB0aGlzIG5vZGUgYXMgd2VsbC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBhY3Rpb24gY2FsbGJhY2sgcmV0dXJuZWQgdHJ1ZS5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoQW5jZXN0b3IgPSBmdW5jdGlvbiAoYWN0aW9uLCBpbmNsdWRlU2VsZikge1xuICAgICAgICB2YXIgbm9kZSA9IGluY2x1ZGVTZWxmID8gdGhpcyA6IHRoaXMucGFyZW50KCk7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEb2VzIGEgZGVwdGgtZmlyc3QgdHJhdmVyc2FsIG9mIHRoaXMgbm9kZSdzIGRlc2NlbmRhbnRzLiAgV2hlbiBhIGRlc2NlbmRhbnQgd2l0aCBhIHZhbHVlXG4gICAgICogaXMgZm91bmQsIGFjdGlvbiBpcyBjYWxsZWQgb24gaXQgYW5kIHRyYXZlcnNhbCBkb2VzIG5vdCBjb250aW51ZSBpbnNpZGUgdGhlIG5vZGUuXG4gICAgICogQWN0aW9uIGlzICpub3QqIGNhbGxlZCBvbiB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFUcmVlLjxUPil9IGFjdGlvbiBBY3Rpb24gdG8gYmUgY2FsbGVkIGZvciBlYWNoIGNoaWxkLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLmZvckVhY2hJbW1lZGlhdGVEZXNjZW5kYW50V2l0aFZhbHVlID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmZvckVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5nZXRWYWx1ZSgpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIGFjdGlvbihjaGlsZCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hpbGQuZm9yRWFjaEltbWVkaWF0ZURlc2NlbmRhbnRXaXRoVmFsdWUoYWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHshUGF0aH0gVGhlIHBhdGggb2YgdGhpcyB0cmVlIG5vZGUsIGFzIGEgUGF0aC5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhfMS5QYXRoKHRoaXMucGFyZW50XyA9PT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLm5hbWVfXG4gICAgICAgICAgICA6IHRoaXMucGFyZW50Xy5wYXRoKCkgKyAnLycgKyB0aGlzLm5hbWVfKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb2YgdGhlIHRyZWUgbm9kZS5cbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lXztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez9UcmVlfSBUaGUgcGFyZW50IHRyZWUgbm9kZSwgb3IgbnVsbCBpZiB0aGlzIGlzIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50XztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgb3IgcmVtb3ZlcyB0aGlzIGNoaWxkIGZyb20gaXRzIHBhcmVudCBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgZW1wdHkgb3Igbm90LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBUcmVlLnByb3RvdHlwZS51cGRhdGVQYXJlbnRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50XyAhPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGFyZW50Xy51cGRhdGVDaGlsZF8odGhpcy5uYW1lXywgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIG9yIHJlbW92ZXMgdGhlIHBhc3NlZCBjaGlsZCB0byB0aGlzIHRyZWUgbm9kZSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQncyBlbXB0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlsZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGNoaWxkIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0geyFUcmVlLjxUPn0gY2hpbGQgVGhlIGNoaWxkIHRvIHVwZGF0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFRyZWUucHJvdG90eXBlLnVwZGF0ZUNoaWxkXyA9IGZ1bmN0aW9uIChjaGlsZE5hbWUsIGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZEVtcHR5ID0gY2hpbGQuaXNFbXB0eSgpO1xuICAgICAgICB2YXIgY2hpbGRFeGlzdHMgPSB1dGlsXzIuY29udGFpbnModGhpcy5ub2RlXy5jaGlsZHJlbiwgY2hpbGROYW1lKTtcbiAgICAgICAgaWYgKGNoaWxkRW1wdHkgJiYgY2hpbGRFeGlzdHMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVfLmNoaWxkcmVuW2NoaWxkTmFtZV07XG4gICAgICAgICAgICB0aGlzLm5vZGVfLmNoaWxkQ291bnQtLTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFyZW50c18oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghY2hpbGRFbXB0eSAmJiAhY2hpbGRFeGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZV8uY2hpbGRyZW5bY2hpbGROYW1lXSA9IGNoaWxkLm5vZGVfO1xuICAgICAgICAgICAgdGhpcy5ub2RlXy5jaGlsZENvdW50Kys7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudHNfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUcmVlO1xufSgpKTtcbmV4cG9ydHMuVHJlZSA9IFRyZWU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyZWUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvZGF0YWJhc2UvZGlzdC9janMvc3JjL2NvcmUvdXRpbC9UcmVlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgV2ViU29ja2V0Q29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4uL3JlYWx0aW1lL1dlYlNvY2tldENvbm5lY3Rpb25cIik7XG52YXIgQnJvd3NlclBvbGxDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvQnJvd3NlclBvbGxDb25uZWN0aW9uXCIpO1xuLyoqXG4gKiBJTlRFUk5BTCBtZXRob2RzIGZvciBpbnRlcm5hbC11c2Ugb25seSAodGVzdHMsIGV0Yy4pLlxuICpcbiAqIEN1c3RvbWVycyBzaG91bGRuJ3QgdXNlIHRoZXNlIG9yIGVsc2Ugc2hvdWxkIGJlIGF3YXJlIHRoYXQgdGhleSBjb3VsZCBicmVhayBhdCBhbnkgdGltZS5cbiAqXG4gKiBAY29uc3RcbiAqL1xuZXhwb3J0cy5mb3JjZUxvbmdQb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIFdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uLmZvcmNlRGlzYWxsb3coKTtcbiAgICBCcm93c2VyUG9sbENvbm5lY3Rpb25fMS5Ccm93c2VyUG9sbENvbm5lY3Rpb24uZm9yY2VBbGxvdygpO1xufTtcbmV4cG9ydHMuZm9yY2VXZWJTb2NrZXRzID0gZnVuY3Rpb24gKCkge1xuICAgIEJyb3dzZXJQb2xsQ29ubmVjdGlvbl8xLkJyb3dzZXJQb2xsQ29ubmVjdGlvbi5mb3JjZURpc2FsbG93KCk7XG59O1xuLyogVXNlZCBieSBBcHAgTWFuYWdlciAqL1xuZXhwb3J0cy5pc1dlYlNvY2tldHNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFdlYlNvY2tldENvbm5lY3Rpb25fMS5XZWJTb2NrZXRDb25uZWN0aW9uWydpc0F2YWlsYWJsZSddKCk7XG59O1xuZXhwb3J0cy5zZXRTZWN1cml0eURlYnVnQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVmLCBjYWxsYmFjaykge1xuICAgIHJlZi5yZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5zZWN1cml0eURlYnVnQ2FsbGJhY2tfID0gY2FsbGJhY2s7XG59O1xuZXhwb3J0cy5zdGF0cyA9IGZ1bmN0aW9uIChyZWYsIHNob3dEZWx0YSkge1xuICAgIHJlZi5yZXBvLnN0YXRzKHNob3dEZWx0YSk7XG59O1xuZXhwb3J0cy5zdGF0c0luY3JlbWVudENvdW50ZXIgPSBmdW5jdGlvbiAocmVmLCBtZXRyaWMpIHtcbiAgICByZWYucmVwby5zdGF0c0luY3JlbWVudENvdW50ZXIobWV0cmljKTtcbn07XG5leHBvcnRzLmRhdGFVcGRhdGVDb3VudCA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICByZXR1cm4gcmVmLnJlcG8uZGF0YVVwZGF0ZUNvdW50O1xufTtcbmV4cG9ydHMuaW50ZXJjZXB0U2VydmVyRGF0YSA9IGZ1bmN0aW9uIChyZWYsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlZi5yZXBvLmludGVyY2VwdFNlcnZlckRhdGFfKGNhbGxiYWNrKTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSZXBvSW5mb18xID0gcmVxdWlyZShcIi4uL2NvcmUvUmVwb0luZm9cIik7XG52YXIgUGVyc2lzdGVudENvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BlcnNpc3RlbnRDb25uZWN0aW9uXCIpO1xudmFyIFJlcG9NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9SZXBvTWFuYWdlclwiKTtcbnZhciBDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vcmVhbHRpbWUvQ29ubmVjdGlvblwiKTtcbmV4cG9ydHMuRGF0YUNvbm5lY3Rpb24gPSBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xLlBlcnNpc3RlbnRDb25uZWN0aW9uO1xuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IHBhdGhTdHJpbmdcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IG9uQ29tcGxldGVcbiAqL1xuUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuc2ltcGxlTGlzdGVuID0gZnVuY3Rpb24gKHBhdGhTdHJpbmcsIG9uQ29tcGxldGUpIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdxJywgeyBwOiBwYXRoU3RyaW5nIH0sIG9uQ29tcGxldGUpO1xufTtcbi8qKlxuICogQHBhcmFtIHsqfSBkYXRhXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopfSBvbkVjaG9cbiAqL1xuUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUuZWNobyA9IGZ1bmN0aW9uIChkYXRhLCBvbkVjaG8pIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KCdlY2hvJywgeyBkOiBkYXRhIH0sIG9uRWNobyk7XG59O1xuLy8gUmVhbFRpbWVDb25uZWN0aW9uIHByb3BlcnRpZXMgdGhhdCB3ZSB1c2UgaW4gdGVzdHMuXG5leHBvcnRzLlJlYWxUaW1lQ29ubmVjdGlvbiA9IENvbm5lY3Rpb25fMS5Db25uZWN0aW9uO1xuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHN0cmluZ30gbmV3SGFzaFxuICogQHJldHVybiB7ZnVuY3Rpb24oKX1cbiAqL1xuZXhwb3J0cy5oaWphY2tIYXNoID0gZnVuY3Rpb24gKG5ld0hhc2gpIHtcbiAgICB2YXIgb2xkUHV0ID0gUGVyc2lzdGVudENvbm5lY3Rpb25fMS5QZXJzaXN0ZW50Q29ubmVjdGlvbi5wcm90b3R5cGUucHV0O1xuICAgIFBlcnNpc3RlbnRDb25uZWN0aW9uXzEuUGVyc2lzdGVudENvbm5lY3Rpb24ucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChwYXRoU3RyaW5nLCBkYXRhLCBvcHRfb25Db21wbGV0ZSwgb3B0X2hhc2gpIHtcbiAgICAgICAgaWYgKG9wdF9oYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wdF9oYXNoID0gbmV3SGFzaCgpO1xuICAgICAgICB9XG4gICAgICAgIG9sZFB1dC5jYWxsKHRoaXMsIHBhdGhTdHJpbmcsIGRhdGEsIG9wdF9vbkNvbXBsZXRlLCBvcHRfaGFzaCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBQZXJzaXN0ZW50Q29ubmVjdGlvbl8xLlBlcnNpc3RlbnRDb25uZWN0aW9uLnByb3RvdHlwZS5wdXQgPSBvbGRQdXQ7XG4gICAgfTtcbn07XG4vKipcbiAqIEB0eXBlIHtmdW5jdGlvbihuZXc6UmVwb0luZm8sICFzdHJpbmcsIGJvb2xlYW4sICFzdHJpbmcsIGJvb2xlYW4pOiB1bmRlZmluZWR9XG4gKi9cbmV4cG9ydHMuQ29ubmVjdGlvblRhcmdldCA9IFJlcG9JbmZvXzEuUmVwb0luZm87XG4vKipcbiAqIEBwYXJhbSB7IVF1ZXJ5fSBxdWVyeVxuICogQHJldHVybiB7IXN0cmluZ31cbiAqL1xuZXhwb3J0cy5xdWVyeUlkZW50aWZpZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICByZXR1cm4gcXVlcnkucXVlcnlJZGVudGlmaWVyKCk7XG59O1xuLyoqXG4gKiBAcGFyYW0geyFRdWVyeX0gZmlyZWJhc2VSZWZcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbmV4cG9ydHMubGlzdGVucyA9IGZ1bmN0aW9uIChmaXJlYmFzZVJlZikge1xuICAgIHJldHVybiBmaXJlYmFzZVJlZi5yZXBvLnBlcnNpc3RlbnRDb25uZWN0aW9uXy5saXN0ZW5zXztcbn07XG4vKipcbiAqIEZvcmNlcyB0aGUgUmVwb01hbmFnZXIgdG8gY3JlYXRlIFJlcG9zIHRoYXQgdXNlIFJlYWRvbmx5UmVzdENsaWVudCBpbnN0ZWFkIG9mIFBlcnNpc3RlbnRDb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VSZXN0Q2xpZW50XG4gKi9cbmV4cG9ydHMuZm9yY2VSZXN0Q2xpZW50ID0gZnVuY3Rpb24gKGZvcmNlUmVzdENsaWVudCkge1xuICAgIFJlcG9NYW5hZ2VyXzEuUmVwb01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5mb3JjZVJlc3RDbGllbnQoZm9yY2VSZXN0Q2xpZW50KTtcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RfYWNjZXNzLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2RhdGFiYXNlL2Rpc3QvY2pzL3NyYy9hcGkvdGVzdF9hY2Nlc3MuanNcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCAqIGFzIGZpcmViYXNlIGZyb20gJ2ZpcmViYXNlJztcblxudmFyIGNvbmZpZyA9IHtcbiAgYXBpS2V5OiBcIkFJemFTeUJXeWQzbFJqa042Y1Y3aDlLYXZJRjNDNnZ1MTl0clBqNFwiLFxuICBhdXRoRG9tYWluOiBcInN1bmZsb3dlci0zMzE2NjI0Ny5maXJlYmFzZWFwcC5jb21cIixcbiAgZGF0YWJhc2VVUkw6IFwiaHR0cHM6Ly9zdW5mbG93ZXItMzMxNjYyNDcuZmlyZWJhc2Vpby5jb21cIixcbiAgcHJvamVjdElkOiBcInN1bmZsb3dlci0zMzE2NjI0N1wiLFxuICBzdG9yYWdlQnVja2V0OiBcInN1bmZsb3dlci0zMzE2NjI0Ny5hcHBzcG90LmNvbVwiLFxuICBtZXNzYWdpbmdTZW5kZXJJZDogXCIxMDQ3ODMzMjY5NDY1XCJcbn07XG5cbmZpcmViYXNlLmluaXRpYWxpemVBcHAoY29uZmlnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9jb21wb25lbnRzL2ZpcmViYXNlLWNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnZhciBmaXJlYmFzZSA9IHJlcXVpcmUoJy4vYXBwJyk7XG5yZXF1aXJlKCcuL2F1dGgnKTtcbnJlcXVpcmUoJy4vZGF0YWJhc2UnKTtcbnJlcXVpcmUoJy4vbWVzc2FnaW5nJyk7XG5yZXF1aXJlKCcuL3N0b3JhZ2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaXJlYmFzZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2ZpcmViYXNlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5yZXF1aXJlKCdAZmlyZWJhc2UvbWVzc2FnaW5nJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9maXJlYmFzZS9tZXNzYWdpbmcvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgV2luZG93Q29udHJvbGxlciBmcm9tICcuL3NyYy9jb250cm9sbGVycy93aW5kb3ctY29udHJvbGxlcic7XG5pbXBvcnQgU1dDb250cm9sbGVyIGZyb20gJy4vc3JjL2NvbnRyb2xsZXJzL3N3LWNvbnRyb2xsZXInO1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyTWVzc2FnaW5nKGluc3RhbmNlKSB7XG4gICAgdmFyIG1lc3NhZ2luZ05hbWUgPSAnbWVzc2FnaW5nJztcbiAgICB2YXIgZmFjdG9yeU1ldGhvZCA9IGZ1bmN0aW9uIChhcHApIHtcbiAgICAgICAgaWYgKHNlbGYgJiYgJ1NlcnZpY2VXb3JrZXJHbG9iYWxTY29wZScgaW4gc2VsZikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTV0NvbnRyb2xsZXIoYXBwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3N1bWUgd2UgYXJlIGluIHRoZSB3aW5kb3cgY29udGV4dC5cbiAgICAgICAgcmV0dXJuIG5ldyBXaW5kb3dDb250cm9sbGVyKGFwcCk7XG4gICAgfTtcbiAgICB2YXIgbmFtZXNwYWNlRXhwb3J0cyA9IHtcbiAgICAgICAgLy8gbm8taW5saW5lXG4gICAgICAgIE1lc3NhZ2luZzogV2luZG93Q29udHJvbGxlclxuICAgIH07XG4gICAgaW5zdGFuY2UuSU5URVJOQUwucmVnaXN0ZXJTZXJ2aWNlKG1lc3NhZ2luZ05hbWUsIGZhY3RvcnlNZXRob2QsIG5hbWVzcGFjZUV4cG9ydHMpO1xufVxucmVnaXN0ZXJNZXNzYWdpbmcoZmlyZWJhc2UpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbmltcG9ydCBDb250cm9sbGVySW50ZXJmYWNlIGZyb20gJy4vY29udHJvbGxlci1pbnRlcmZhY2UnO1xuaW1wb3J0IEVycm9ycyBmcm9tICcuLi9tb2RlbHMvZXJyb3JzJztcbmltcG9ydCBXb3JrZXJQYWdlTWVzc2FnZSBmcm9tICcuLi9tb2RlbHMvd29ya2VyLXBhZ2UtbWVzc2FnZSc7XG5pbXBvcnQgRGVmYXVsdFNXIGZyb20gJy4uL21vZGVscy9kZWZhdWx0LXN3JztcbmltcG9ydCBOT1RJRklDQVRJT05fUEVSTUlTU0lPTiBmcm9tICcuLi9tb2RlbHMvbm90aWZpY2F0aW9uLXBlcm1pc3Npb24nO1xuaW1wb3J0IHsgY3JlYXRlU3Vic2NyaWJlIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xudmFyIFdpbmRvd0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpbmRvd0NvbnRyb2xsZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQSBzZXJ2aWNlIHRoYXQgcHJvdmlkZXMgYSBNZXNzYWdpbmdTZXJ2aWNlIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLmFwcC5BcHB9IGFwcFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFdpbmRvd0NvbnRyb2xsZXIoYXBwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGFwcCkgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMucmVnaXN0cmF0aW9uVG9Vc2VfO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge1Byb21pc2V9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tYW5pZmVzdENoZWNrUHJvbWlzZV87XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZmlyZWJhc2UuT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5tZXNzYWdlT2JzZXJ2ZXJfID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlIHshZmlyZWJhc2UuU3Vic2NyaWJlfSBUaGUgc3Vic2NyaWJlIGZ1bmN0aW9uIHRvIHRoZSBvbk1lc3NhZ2VcbiAgICAgICAgICogb2JzZXJ2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vbk1lc3NhZ2VfID0gY3JlYXRlU3Vic2NyaWJlKGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICAgICAgX3RoaXMubWVzc2FnZU9ic2VydmVyXyA9IG9ic2VydmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEB0eXBlIHtmaXJlYmFzZS5PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRva2VuUmVmcmVzaE9ic2VydmVyXyA9IG51bGw7XG4gICAgICAgIF90aGlzLm9uVG9rZW5SZWZyZXNoXyA9IGNyZWF0ZVN1YnNjcmliZShmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnRva2VuUmVmcmVzaE9ic2VydmVyXyA9IG9ic2VydmVyO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMuc2V0dXBTV01lc3NhZ2VMaXN0ZW5lcl8oKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGFuIEZDTSB0b2tlbiBpZiBpdCBjYW4gYmUgZ2VuZXJhdGVkLlxuICAgICAqIFRoZSByZXR1cm4gcHJvbWlzZSB3aWxsIHJlamVjdCBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAgKiBGQ00sIGlmIHBlcm1pc3Npb24gaXMgZGVuaWVkIGZvciBub3RpZmljYXRpb25zIG9yIGl0J3Mgbm90XG4gICAgICogcG9zc2libGUgdG8gZ2VuZXJhdGUgYSB0b2tlbi5cbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHJldHVybiB7UHJvbWlzZTxzdHJpbmc+IHwgUHJvbWlzZTxudWxsPn0gUmV0dXJucyBhIHByb21pc2UgdGhlXG4gICAgICogcmVzb2x2ZXMgdG8gYW4gRkNNIHRva2VuIG9yIG51bGwgaWYgcGVybWlzc2lvbiBpc24ndCBncmFudGVkLlxuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSByZXF1aXJlZCBBUEkncyBhcmUgYXZhaWxhYmxlXG4gICAgICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZF8oKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLlVOU1VQUE9SVEVEX0JST1dTRVIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdENoZWNrXygpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0VG9rZW4uY2FsbChfdGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCBjaGVja3MgdGhhdCBhIG1hbmlmZXN0IGlzIGRlZmluZWQgYW5kIGhhcyB0aGUgY29ycmVjdCBHQ01cbiAgICAgKiBzZW5kZXIgSUQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGlmIHRoZSBtYW5pZmVzdCBtYXRjaGVzXG4gICAgICogb3VyIHJlcXVpcmVkIHNlbmRlciBJRFxuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLm1hbmlmZXN0Q2hlY2tfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5tYW5pZmVzdENoZWNrUHJvbWlzZV8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hbmlmZXN0Q2hlY2tQcm9taXNlXztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFuaWZlc3RUYWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsaW5rW3JlbD1cIm1hbmlmZXN0XCJdJyk7XG4gICAgICAgIGlmICghbWFuaWZlc3RUYWcpIHtcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3RDaGVja1Byb21pc2VfID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hbmlmZXN0Q2hlY2tQcm9taXNlXyA9IGZldGNoKG1hbmlmZXN0VGFnLmhyZWYpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZG93bmxvYWQgb3IgcGFyc2luZyBmYWlscyBhbGxvdyBjaGVjay5cbiAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gZXJyb3IgaWYgd2UgS05PVyB0aGF0IHRoZSBnY21fc2VuZGVyX2lkIGlzIGluY29ycmVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChtYW5pZmVzdENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hbmlmZXN0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWFuaWZlc3RDb250ZW50WydnY21fc2VuZGVyX2lkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3RDb250ZW50WydnY21fc2VuZGVyX2lkJ10gIT09ICcxMDM5NTM4MDA1MDcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5JTkNPUlJFQ1RfR0NNX1NFTkRFUl9JRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWFuaWZlc3RDaGVja1Byb21pc2VfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBwZXJtaXNzaW9uIGlmIGl0IGlzIG5vdCBjdXJyZW50bHkgZ3JhbnRlZFxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmVzb2x2ZXMgaWYgdGhlIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIG90aGVyd2lzZVxuICAgICAqIHJlamVjdHNcbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS5yZXF1ZXN0UGVybWlzc2lvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKE5vdGlmaWNhdGlvbi5wZXJtaXNzaW9uID09PSBOT1RJRklDQVRJT05fUEVSTUlTU0lPTi5ncmFudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciBtYW5hZ2VQZXJtaXNzaW9uUmVzdWx0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IE5PVElGSUNBVElPTl9QRVJNSVNTSU9OLmdyYW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0ID09PSBOT1RJRklDQVRJT05fUEVSTUlTU0lPTi5kZW5pZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuUEVSTUlTU0lPTl9CTE9DS0VEKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5QRVJNSVNTSU9OX0RFRkFVTFQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gVGhlIE5vdGlmaWNhdGlvbi5yZXF1ZXN0UGVybWlzc2lvbiBBUEkgd2FzIGNoYW5nZWQgdG9cbiAgICAgICAgICAgIC8vIHJldHVybiBhIHByb21pc2Ugc28gbm93IGhhdmUgdG8gaGFuZGxlIGJvdGggaW4gY2FzZVxuICAgICAgICAgICAgLy8gYnJvd3NlcnMgc3RvcCBzdXBwb3J0IGNhbGxiYWNrcyBmb3IgcHJvbWlzZWQgdmVyc2lvblxuICAgICAgICAgICAgdmFyIHBlcm1pc3Npb25Qcm9taXNlID0gTm90aWZpY2F0aW9uLnJlcXVlc3RQZXJtaXNzaW9uKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGVybWlzc2lvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSBwcm9taXNlIG1hbmFnZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFuYWdlUGVybWlzc2lvblJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGVybWlzc2lvblByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVmZXIgdGhlIHByb21pc2UgdmVyc2lvbiBhcyBpdCdzIHRoZSBmdXR1cmUgQVBJLlxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25Qcm9taXNlLnRoZW4obWFuYWdlUGVybWlzc2lvblJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGEgZGV2ZWxvcGVyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNlcnZpY2Ugd29ya2VyIGFuZFxuICAgICAqIGluc3RlYWQgdXNlIGEgY3VzdG9tIHNlcnZpY2Ugd29ya2VyLlxuICAgICAqIEBleHBvcnRcbiAgICAgKiBAcGFyYW0geyFTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9ufSByZWdpc3RyYXRpb24gVGhlIHNlcnZpY2Ugd29ya2VyXG4gICAgICogcmVnaXN0cmF0aW9uIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVjZWl2ZSB0aGUgcHVzaCBtZXNzYWdlcy5cbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS51c2VTZXJ2aWNlV29ya2VyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbikge1xuICAgICAgICBpZiAoIShyZWdpc3RyYXRpb24gaW5zdGFuY2VvZiBTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU1dfUkVHSVNUUkFUSU9OX0VYUEVDVEVEKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucmVnaXN0cmF0aW9uVG9Vc2VfICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuVVNFX1NXX0JFRk9SRV9HRVRfVE9LRU4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0cmF0aW9uVG9Vc2VfID0gcmVnaXN0cmF0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLk9ic2VydmVyfGZ1bmN0aW9uKCopfSBuZXh0T3JPYnNlcnZlciBBbiBvYnNlcnZlciBvYmplY3RcbiAgICAgKiBvciBhIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUVycm9yKT19IG9wdEVycm9yIE9wdGlvbmFsIEEgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uXG4gICAgICogbWVzc2FnZSBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRDb21wbGV0ZWQgT3B0aW9uYWwgZnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gdGhlXG4gICAgICogb2JzZXJ2ZXIgaXMgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX0gVGhlIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIGZvciB0aGUgb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUub25NZXNzYWdlID0gZnVuY3Rpb24gKG5leHRPck9ic2VydmVyLCBvcHRFcnJvciwgb3B0Q29tcGxldGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uTWVzc2FnZV8obmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGV4cG9ydFxuICAgICAqIEBwYXJhbSB7IWZpcmViYXNlLk9ic2VydmVyfGZ1bmN0aW9uKCl9IG5leHRPck9ic2VydmVyIEFuIG9ic2VydmVyIG9iamVjdFxuICAgICAqIG9yIGEgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIHRva2VuIHJlZnJlc2guXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbighRXJyb3IpPX0gb3B0RXJyb3IgT3B0aW9uYWwgQSBmdW5jdGlvblxuICAgICAqIHRyaWdnZXJlZCBvbiB0b2tlbiByZWZyZXNoIGVycm9yLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdENvbXBsZXRlZCBPcHRpb25hbCBmdW5jdGlvbiB0cmlnZ2VyZWQgd2hlbiB0aGVcbiAgICAgKiBvYnNlcnZlciBpcyByZW1vdmVkLlxuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBUaGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24gZm9yIHRoZSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS5vblRva2VuUmVmcmVzaCA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgb3B0RXJyb3IsIG9wdENvbXBsZXRlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblRva2VuUmVmcmVzaF8obmV4dE9yT2JzZXJ2ZXIsIG9wdEVycm9yLCBvcHRDb21wbGV0ZWQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSByZWdpc3RyYXRpb24sIHdhaXQgZm9yIHRoZSBzZXJ2aWNlIHdvcmtlciBpdCByZWxhdGVzIHRvXG4gICAgICogYmVjb21lIGFjdGl2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge1NlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb259IHJlZ2lzdHJhdGlvbiBSZWdpc3RyYXRpb24gdG8gd2FpdFxuICAgICAqIGZvciBzZXJ2aWNlIHdvcmtlciB0byBiZWNvbWUgYWN0aXZlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTwhU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbj59IFdhaXQgZm9yIHNlcnZpY2Ugd29ya2VyXG4gICAgICogcmVnaXN0cmF0aW9uIHRvIGJlY29tZSBhY3RpdmVcbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS53YWl0Rm9yUmVnaXN0cmF0aW9uVG9BY3RpdmF0ZV8gPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzZXJ2aWNlV29ya2VyID0gcmVnaXN0cmF0aW9uLmluc3RhbGxpbmcgfHwgcmVnaXN0cmF0aW9uLndhaXRpbmcgfHwgcmVnaXN0cmF0aW9uLmFjdGl2ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICghc2VydmljZVdvcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSByYXJlIHNjZW5hcmlvIGJ1dCBoYXMgb2NjdXJlZCBpbiBmaXJlZm94XG4gICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5OT19TV19JTl9SRUcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBQcm9taXNlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBuZXh0IHRpY2sgdGhlcmUgaXMgYVxuICAgICAgICAgICAgLy8gc21hbGwgY2hhbmNlIHRoYXQgdGhlIHdvcmtlciBiZWNhbWUgYWN0aXZlIG9yIHJlZHVuZGFudCBhbHJlYWR5LlxuICAgICAgICAgICAgaWYgKHNlcnZpY2VXb3JrZXIuc3RhdGUgPT09ICdhY3RpdmF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZWdpc3RyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXJ2aWNlV29ya2VyLnN0YXRlID09PSAncmVkdW5kYW50Jykge1xuICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU1dfUkVHX1JFRFVOREFOVCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGF0ZUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlV29ya2VyLnN0YXRlID09PSAnYWN0aXZhdGVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlZ2lzdHJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlcnZpY2VXb3JrZXIuc3RhdGUgPT09ICdyZWR1bmRhbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU1dfUkVHX1JFRFVOREFOVCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGFuZCB3YWl0IHRvIG5leHQgc3RhdGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VydmljZVdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKCdzdGF0ZWNoYW5nZScsIHN0YXRlQ2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlcnZpY2VXb3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCBzdGF0ZUNoYW5nZUxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgcmVnaWF0ZXIgdGhlIGRlZmF1bHQgc2VydmljZSB3b3JrZXIgYW5kIHJldHVybiB0aGUgcmVnaXN0cmF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPCFTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9uPn0gVGhlIHNlcnZpY2Ugd29ya2VyXG4gICAgICogcmVnaXN0cmF0aW9uIHRvIGJlIHVzZWQgZm9yIHRoZSBwdXNoIHNlcnZpY2UuXG4gICAgICovXG4gICAgV2luZG93Q29udHJvbGxlci5wcm90b3R5cGUuZ2V0U1dSZWdpc3RyYXRpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RyYXRpb25Ub1VzZV8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhaXRGb3JSZWdpc3RyYXRpb25Ub0FjdGl2YXRlXyh0aGlzLnJlZ2lzdHJhdGlvblRvVXNlXyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSB0aGUgcmVnaXN0cmF0aW9uIG51bGwgc28gd2Uga25vdyB1c2VTZXJ2aWNlV29ya2VyIHdpbGwgbm90XG4gICAgICAgIC8vIHVzZSBhIG5ldyBzZXJ2aWNlIHdvcmtlciBhcyByZWdpc3RyYXRpb25Ub1VzZV8gaXMgbm8gbG9uZ2VyIHVuZGVmaW5lZFxuICAgICAgICB0aGlzLnJlZ2lzdHJhdGlvblRvVXNlXyA9IG51bGw7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlclxuICAgICAgICAgICAgLnJlZ2lzdGVyKERlZmF1bHRTVy5wYXRoLCB7XG4gICAgICAgICAgICBzY29wZTogRGVmYXVsdFNXLnNjb3BlXG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLkZBSUxFRF9ERUZBVUxUX1JFR0lTVFJBVElPTiwge1xuICAgICAgICAgICAgICAgIGJyb3dzZXJFcnJvck1lc3NhZ2U6IGVyci5tZXNzYWdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWdpc3RyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy53YWl0Rm9yUmVnaXN0cmF0aW9uVG9BY3RpdmF0ZV8ocmVnaXN0cmF0aW9uKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWdpc3RyYXRpb25Ub1VzZV8gPSByZWdpc3RyYXRpb247XG4gICAgICAgICAgICAgICAgLy8gV2UgdXBkYXRlIGFmdGVyIGFjdGl2YXRpb24gZHVlIHRvIGFuIGlzc3VlIHdpdGggRmlyZWZveCB2NDkgd2hlcmVcbiAgICAgICAgICAgICAgICAvLyBhIHJhY2UgY29uZGl0aW9uIG9jY2Fzc2lvbmFsbHkgY2F1c2VzIHRoZSBzZXJ2aWNlIHdvcmsgdG8gbm90XG4gICAgICAgICAgICAgICAgLy8gaW5zdGFsbFxuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnaXN0cmF0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBzZXQgdXAgYSBtZXNzYWdlIGxpc3RlbmVyIHRvIGhhbmRsZVxuICAgICAqIGV2ZW50cyBmcm9tIHRoZSBzZXJ2aWNlIHdvcmtlciB0aGF0IHNob3VsZCB0cmlnZ2VyXG4gICAgICogZXZlbnRzIGluIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBXaW5kb3dDb250cm9sbGVyLnByb3RvdHlwZS5zZXR1cFNXTWVzc2FnZUxpc3RlbmVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEoJ3NlcnZpY2VXb3JrZXInIGluIG5hdmlnYXRvcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuYXZpZ2F0b3Iuc2VydmljZVdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWV2ZW50LmRhdGEgfHwgIWV2ZW50LmRhdGFbV29ya2VyUGFnZU1lc3NhZ2UuUEFSQU1TLlRZUEVfT0ZfTVNHXSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBhIG1lc3NhZ2UgZnJvbSBGQ01cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgd29ya2VyUGFnZU1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgc3dpdGNoICh3b3JrZXJQYWdlTWVzc2FnZVtXb3JrZXJQYWdlTWVzc2FnZS5QQVJBTVMuVFlQRV9PRl9NU0ddKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJQYWdlTWVzc2FnZS5UWVBFU19PRl9NU0cuUFVTSF9NU0dfUkVDRUlWRUQ6XG4gICAgICAgICAgICAgICAgY2FzZSBXb3JrZXJQYWdlTWVzc2FnZS5UWVBFU19PRl9NU0cuTk9USUZJQ0FUSU9OX0NMSUNLRUQ6XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdXNoTWVzc2FnZSA9IHdvcmtlclBhZ2VNZXNzYWdlW1dvcmtlclBhZ2VNZXNzYWdlLlBBUkFNUy5EQVRBXTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWVzc2FnZU9ic2VydmVyXy5uZXh0KHB1c2hNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gTm9vcC5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHJlcXVpcmVkIEFQSSdzIGFyZSB2YWxpZCBvciBub3QuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGRlc2lyZWQgQVBJcyBhcmUgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIFdpbmRvd0NvbnRyb2xsZXIucHJvdG90eXBlLmlzU3VwcG9ydGVkXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICgnc2VydmljZVdvcmtlcicgaW4gbmF2aWdhdG9yICYmXG4gICAgICAgICAgICAnUHVzaE1hbmFnZXInIGluIHdpbmRvdyAmJlxuICAgICAgICAgICAgJ05vdGlmaWNhdGlvbicgaW4gd2luZG93ICYmXG4gICAgICAgICAgICAnZmV0Y2gnIGluIHdpbmRvdyAmJlxuICAgICAgICAgICAgU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbi5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ3Nob3dOb3RpZmljYXRpb24nKSAmJlxuICAgICAgICAgICAgUHVzaFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2dldEtleScpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaW5kb3dDb250cm9sbGVyO1xufShDb250cm9sbGVySW50ZXJmYWNlKSk7XG5leHBvcnQgZGVmYXVsdCBXaW5kb3dDb250cm9sbGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13aW5kb3ctY29udHJvbGxlci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL2NvbnRyb2xsZXJzL3dpbmRvdy1jb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgRXJyb3JGYWN0b3J5IH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IEVycm9ycyBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgYXJyYXlCdWZmZXJUb0Jhc2U2NCBmcm9tICcuLi9oZWxwZXJzL2FycmF5LWJ1ZmZlci10by1iYXNlNjQnO1xuaW1wb3J0IEZDTURldGFpbHMgZnJvbSAnLi9mY20tZGV0YWlscyc7XG52YXIgRkNNX1RPS0VOX09CSl9TVE9SRSA9ICdmY21fdG9rZW5fb2JqZWN0X1N0b3JlJztcbnZhciBGQ01fVE9LRU5fREVUQUlMU19EQl9WRVJTSU9OID0gMTtcbnZhciBUb2tlbk1hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVG9rZW5NYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLmVycm9yRmFjdG9yeV8gPSBuZXcgRXJyb3JGYWN0b3J5KCdtZXNzYWdpbmcnLCAnTWVzc2FnaW5nJywgRXJyb3JzLm1hcCk7XG4gICAgICAgIHRoaXMub3BlbkRiUHJvbWlzZV8gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGluZGV4ZWREQiBhcyBhIHByb21zaWUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPElEQkRhdGFiYXNlPn0gVGhlIEluZGV4ZWREQiBkYXRhYmFzZVxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUub3BlbkRhdGFiYXNlXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3BlbkRiUHJvbWlzZV8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5EYlByb21pc2VfO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbkRiUHJvbWlzZV8gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4ZWREQi5vcGVuKFRva2VuTWFuYWdlci5EQl9OQU1FLCBGQ01fVE9LRU5fREVUQUlMU19EQl9WRVJTSU9OKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoRkNNX1RPS0VOX09CSl9TVE9SRSwge1xuICAgICAgICAgICAgICAgICAgICBrZXlQYXRoOiAnc3dTY29wZSdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIHNlbmRlciBJRCBjYW4gYmUgc2VhcmNoZWRcbiAgICAgICAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgnZmNtU2VuZGVySWQnLCAnZmNtU2VuZGVySWQnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYmplY3RTdG9yZS5jcmVhdGVJbmRleCgnZmNtVG9rZW4nLCAnZmNtVG9rZW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW5EYlByb21pc2VfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGN1cnJlbnRseSBvcGVuIGRhdGFiYXNlLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8Pz59IFJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSBjaGFpbi5cbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlRGF0YWJhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm9wZW5EYlByb21pc2VfKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGJQcm9taXNlXy50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbkRiUHJvbWlzZV8gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSB0b2tlbiwgdGhpcyBtZXRob2Qgd2lsbCBsb29rIHVwIHRoZSBkZXRhaWxzIGluIGluZGV4ZWREQi5cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZjbVRva2VuXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBUaGUgZGV0YWlscyBhc3NvY2lhdGVkIHdpdGggdGhhdCB0b2tlbi5cbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldFRva2VuRGV0YWlsc0Zyb21Ub2tlbiA9IGZ1bmN0aW9uIChmY21Ub2tlbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleCgnZmNtVG9rZW4nKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IGluZGV4LmdldChmY21Ub2tlbik7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShldmVudC50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRUb2tlbkRldGFpbHNGcm9tU1dTY29wZV8gPSBmdW5jdGlvbiAoc3dTY29wZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGVSZXF1ZXN0ID0gb2JqZWN0U3RvcmUuZ2V0KHN3U2NvcGUpO1xuICAgICAgICAgICAgICAgIHNjb3BlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NvcGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmdldEFsbFRva2VuRGV0YWlsc0ZvclNlbmRlcklkXyA9IGZ1bmN0aW9uIChzZW5kZXJJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuRGF0YWJhc2VfKCkudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZDTV9UT0tFTl9PQkpfU1RPUkVdKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VuZGVySWRUb2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUmVxdWVzdCA9IG9iamVjdFN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGV2ZW50LnRhcmdldC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjdXJzb3JSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci52YWx1ZVsnZmNtU2VuZGVySWQnXSA9PT0gc2VuZGVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJJZFRva2Vucy5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoc2VuZGVySWRUb2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgUHVzaFN1YnNjcmlwdGlvbiBhbmQgbWVzc2FnaW5nU2VuZGVySWQsIGdldCBhbiBGQ00gdG9rZW4uXG4gICAgICogQHB1YmxpY1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc2VuZGVySWQgVGhlICdtZXNzYWdpbmdTZW5kZXJJZCcgdG8gdGllIHRoZSB0b2tlbiB0by5cbiAgICAgKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIFB1c2hTdXNiY3JpcHRpb24gdG8gXCJmZWRlcmF0ZVwiLlxuICAgICAqIEBwYXJhbSAge3N0cmluZz19IHB1c2hTZXQgSWYgZGVmaW5lZCB0aGlzIHdpbGwgc3dhcCB0aGUgc3Vic2NyaXB0aW9uIGZvclxuICAgICAqIG1hdGNoaW5nIEZDTSB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPCFPYmplY3Q+fSBSZXR1cm5zIHRoZSBGQ00gdG9rZW4gdG8gYmUgdXNlZCBpbiBwbGFjZVxuICAgICAqIG9mIHRoZSBQdXNoU3Vic2NyaXB0aW9uLlxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUuc3Vic2NyaWJlVG9GQ00gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN1YnNjcmlwdGlvbiwgcHVzaFNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcDI1NmRoID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChzdWJzY3JpcHRpb25bJ2dldEtleSddKCdwMjU2ZGgnKSk7XG4gICAgICAgIHZhciBhdXRoID0gYXJyYXlCdWZmZXJUb0Jhc2U2NChzdWJzY3JpcHRpb25bJ2dldEtleSddKCdhdXRoJykpO1xuICAgICAgICB2YXIgZmNtU3Vic2NyaWJlQm9keSA9IFwiYXV0aG9yaXplZF9lbnRpdHk9XCIgKyBzZW5kZXJJZCArIFwiJlwiICtcbiAgICAgICAgICAgIChcImVuZHBvaW50PVwiICsgc3Vic2NyaXB0aW9uLmVuZHBvaW50ICsgXCImXCIpICtcbiAgICAgICAgICAgIChcImVuY3J5cHRpb25fa2V5PVwiICsgcDI1NmRoICsgXCImXCIpICtcbiAgICAgICAgICAgIChcImVuY3J5cHRpb25fYXV0aD1cIiArIGF1dGgpO1xuICAgICAgICBpZiAocHVzaFNldCkge1xuICAgICAgICAgICAgZmNtU3Vic2NyaWJlQm9keSArPSBcIiZwdXNoU2V0PVwiICsgcHVzaFNldDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyk7XG4gICAgICAgIHZhciBzdWJzY3JpYmVPcHRpb25zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgYm9keTogZmNtU3Vic2NyaWJlQm9keVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZmV0Y2goRkNNRGV0YWlscy5FTkRQT0lOVCArICcvZmNtL2Nvbm5lY3Qvc3Vic2NyaWJlJywgc3Vic2NyaWJlT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuanNvbigpOyB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICB2YXIgZmNtVG9rZW5SZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKGZjbVRva2VuUmVzcG9uc2VbJ2Vycm9yJ10pIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGZjbVRva2VuUmVzcG9uc2VbJ2Vycm9yJ11bJ21lc3NhZ2UnXTtcbiAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuVE9LRU5fU1VCU0NSSUJFX0ZBSUxFRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWZjbVRva2VuUmVzcG9uc2VbJ3Rva2VuJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuVE9LRU5fU1VCU0NSSUJFX05PX1RPS0VOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZmNtVG9rZW5SZXNwb25zZVsncHVzaFNldCddKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLlRPS0VOX1NVQlNDUklCRV9OT19QVVNIX1NFVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRva2VuOiBmY21Ub2tlblJlc3BvbnNlWyd0b2tlbiddLFxuICAgICAgICAgICAgICAgIHB1c2hTZXQ6IGZjbVRva2VuUmVzcG9uc2VbJ3B1c2hTZXQnXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIHRoYXQgZmllbGRzIGluIHRoZSBQdXNoU3Vic2NyaXB0aW9uIGFyZSBlcXVpdmFsZW50IHRvIHRoZVxuICAgICAqIGRldGFpbHMgc3RvcmVzIGluIHRoZSBtYXN0ZXJUb2tlbkRldGFpbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtQdXNoU3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIHB1c2ggc3Vic2NyaXB0aW9uIHdlIGV4cGVjdFxuICAgICAqIHRoZSBtYXN0ZXIgdG9rZW4gdG8gbWF0Y2guXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSAgbWFzdGVyVG9rZW5EZXRhaWxzIFRoZSBzYXZlZCBkZXRhaWxzIHdlIHdpc2ggdG8gY29tcGFyZVxuICAgICAqIHdpdGggdGhlIFB1c2hTdWJzY3JpcHRpb25cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzdWJzY3JpcHRpb24gYW5kIHRva2VuIGRldGFpbHMgYXJlXG4gICAgICogZXF1aXZhbGVudC5cbiAgICAgKi9cbiAgICBUb2tlbk1hbmFnZXIucHJvdG90eXBlLmlzU2FtZVN1YnNjcmlwdGlvbl8gPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uLCBtYXN0ZXJUb2tlbkRldGFpbHMpIHtcbiAgICAgICAgLy8gZ2V0S2V5KCkgaXNuJ3QgZGVmaW5lZCBpbiB0aGUgUHVzaFN1YnNjcmlwdGlvbiBleHRlcm5zIGZpbGUsIGhlbmNlXG4gICAgICAgIC8vIHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJzxrZXkgbmFtZT4nKS5cbiAgICAgICAgcmV0dXJuIChzdWJzY3JpcHRpb24uZW5kcG9pbnQgPT09IG1hc3RlclRva2VuRGV0YWlsc1snZW5kcG9pbnQnXSAmJlxuICAgICAgICAgICAgYXJyYXlCdWZmZXJUb0Jhc2U2NChzdWJzY3JpcHRpb25bJ2dldEtleSddKCdhdXRoJykpID09PVxuICAgICAgICAgICAgICAgIG1hc3RlclRva2VuRGV0YWlsc1snYXV0aCddICYmXG4gICAgICAgICAgICBhcnJheUJ1ZmZlclRvQmFzZTY0KHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJ3AyNTZkaCcpKSA9PT1cbiAgICAgICAgICAgICAgICBtYXN0ZXJUb2tlbkRldGFpbHNbJ3AyNTZkaCddKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGRldGFpbHMgZm9yIHRoZSBmY20gdG9rZW4gZm9yIHJlLXVzZSBhdCBhIGxhdGVyIGRhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHNlbmRlcklkIFRoZSAnbWVzc2FnaW5nU2VuZGVySWQnIHVzZWQgZm9yIHRoaXMgcHJvamVjdFxuICAgICAqIEBwYXJhbSAge1NlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb259IHN3UmVnaXN0cmF0aW9uIFRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIHVzZWQgdG8gc3Vic2NyaWJlIHRoZSB1c2VyIGZvciB3ZWIgcHVzaFxuICAgICAqIEBwYXJhbSAge1B1c2hTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgcHVzaCBzdWJzY3JpcHRpb24gcGFzc2VkIHRvXG4gICAgICogRkNNIGZvciB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZjbVRva2VuIFRoZSBGQ00gdG9rZW4gY3VycmVudGx5IHVzZWQgb24gdGhpc1xuICAgICAqIGRldmljZS5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZjbVB1c2hTZXQgVGhlIEZDTSBwdXNoIHRpZWQgdG8gdGhlIGZjbSB0b2tlbi5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUuc2F2ZVRva2VuRGV0YWlsc18gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN3UmVnaXN0cmF0aW9uLCBzdWJzY3JpcHRpb24sIGZjbVRva2VuLCBmY21QdXNoU2V0KSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0ge1xuICAgICAgICAgICAgc3dTY29wZTogc3dSZWdpc3RyYXRpb24uc2NvcGUsXG4gICAgICAgICAgICBlbmRwb2ludDogc3Vic2NyaXB0aW9uLmVuZHBvaW50LFxuICAgICAgICAgICAgYXV0aDogYXJyYXlCdWZmZXJUb0Jhc2U2NChzdWJzY3JpcHRpb25bJ2dldEtleSddKCdhdXRoJykpLFxuICAgICAgICAgICAgcDI1NmRoOiBhcnJheUJ1ZmZlclRvQmFzZTY0KHN1YnNjcmlwdGlvblsnZ2V0S2V5J10oJ3AyNTZkaCcpKSxcbiAgICAgICAgICAgIGZjbVRva2VuOiBmY21Ub2tlbixcbiAgICAgICAgICAgIGZjbVB1c2hTZXQ6IGZjbVB1c2hTZXQsXG4gICAgICAgICAgICBmY21TZW5kZXJJZDogc2VuZGVySWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlbkRhdGFiYXNlXygpLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGQ01fVE9LRU5fT0JKX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKEZDTV9UT0tFTl9PQkpfU1RPUkUpO1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gb2JqZWN0U3RvcmUucHV0KGRldGFpbHMpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2F2ZWQgRkNNIFRva2VuIGlmIG9uZSBpcyBhdmFpbGFibGUgYW5kIHN0aWxsIHZhbGlkLFxuICAgICAqIG90aGVyd2lzZSBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbmRlcklkIFRoaXMgc2hvdWxkIGJlIHRoZSBzZW5kZXIgSUQgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqIEZDTSBUb2tlbiBiZWluZyByZXRyaWV2ZWQuXG4gICAgICogQHBhcmFtIHtTZXJ2aWNlV29ya2VyUmVnaXN0cmF0aW9ufSBzd1JlZ2lzdHJhdGlvbiBSZWdpc3RyYXRpb24gdG8gYmUgdXNlZFxuICAgICAqIHRvIHN1YnNjcmliZSB0aGUgdXNlciB0byBwdXNoLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nPiB8IFByb21pc2V9IFJldHVybnMgdGhlIHNhdmVkIEZDTSBUb2tlbiBpZlxuICAgICAqIGF2aWxhYmxlIGFuZCB2YWxpZC5cbiAgICAgKiBAZXhwb3J0XG4gICAgICovXG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5nZXRTYXZlZFRva2VuID0gZnVuY3Rpb24gKHNlbmRlcklkLCBzd1JlZ2lzdHJhdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIShzd1JlZ2lzdHJhdGlvbiBpbnN0YW5jZW9mIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU1dfUkVHSVNUUkFUSU9OX0VYUEVDVEVEKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZW5kZXJJZCAhPT0gJ3N0cmluZycgfHwgc2VuZGVySWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuQkFEX1NFTkRFUl9JRCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRva2VuRGV0YWlsc0ZvclNlbmRlcklkXyhzZW5kZXJJZClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChhbGxUb2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmIChhbGxUb2tlbkRldGFpbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsVG9rZW5EZXRhaWxzLmZpbmRJbmRleChmdW5jdGlvbiAodG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzd1JlZ2lzdHJhdGlvbi5zY29wZSA9PT0gdG9rZW5EZXRhaWxzWydzd1Njb3BlJ10gJiZcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVySWQgPT09IHRva2VuRGV0YWlsc1snZmNtU2VuZGVySWQnXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWxsVG9rZW5EZXRhaWxzW2luZGV4XTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN3UmVnaXN0cmF0aW9uLnB1c2hNYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldFN1YnNjcmlwdGlvbigpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuR0VUX1NVQlNDUklQVElPTl9GQUlMRUQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pc1NhbWVTdWJzY3JpcHRpb25fKHN1YnNjcmlwdGlvbiwgdG9rZW5EZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5EZXRhaWxzWydmY21Ub2tlbiddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRkNNIHRva2VuLlxuICAgICAqL1xuICAgIFRva2VuTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVG9rZW4gPSBmdW5jdGlvbiAoc2VuZGVySWQsIHN3UmVnaXN0cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VuZGVySWQgIT09ICdzdHJpbmcnIHx8IHNlbmRlcklkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLkJBRF9TRU5ERVJfSUQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzd1JlZ2lzdHJhdGlvbiBpbnN0YW5jZW9mIFNlcnZpY2VXb3JrZXJSZWdpc3RyYXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuU1dfUkVHSVNUUkFUSU9OX0VYUEVDVEVEKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiBmaXJzdFxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICB2YXIgZmNtVG9rZW5EZXRhaWxzO1xuICAgICAgICByZXR1cm4gc3dSZWdpc3RyYXRpb24ucHVzaE1hbmFnZXJcbiAgICAgICAgICAgIC5nZXRTdWJzY3JpcHRpb24oKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3dSZWdpc3RyYXRpb24ucHVzaE1hbmFnZXIuc3Vic2NyaWJlKEZDTURldGFpbHMuU1VCU0NSSVBUSU9OX09QVElPTlMpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN1Yikge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gc3ViO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN1YnNjcmliZVRvRkNNKHNlbmRlcklkLCBzdWJzY3JpcHRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgZmNtVG9rZW5EZXRhaWxzID0gdG9rZW5EZXRhaWxzO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNhdmVUb2tlbkRldGFpbHNfKHNlbmRlcklkLCBzd1JlZ2lzdHJhdGlvbiwgc3Vic2NyaXB0aW9uLCBmY21Ub2tlbkRldGFpbHNbJ3Rva2VuJ10sIGZjbVRva2VuRGV0YWlsc1sncHVzaFNldCddKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZjbVRva2VuRGV0YWlsc1sndG9rZW4nXTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBkZWxldGVzIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgRkNNIHRva2VuLlxuICAgICAqIEl0J3MgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiBjYXNlIHdlIG5lZWQgdG8gbW92ZSB0byBhbiBhc3luY1xuICAgICAqIG1ldGhvZCBmb3IgZGVsZXRpbmcgYXQgYSBsYXRlciBkYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlbiB0byBiZSBkZWxldGVkXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3Q+fSBSZXNvbHZlcyBvbmNlIHRoZSBGQ00gdG9rZW4gZGV0YWlscyBoYXZlIGJlZW5cbiAgICAgKiBkZWxldGVkIGFuZCByZXR1cm5zIHRoZSBkZWxldGVkIGRldGFpbHMuXG4gICAgICovXG4gICAgVG9rZW5NYW5hZ2VyLnByb3RvdHlwZS5kZWxldGVUb2tlbiA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJyB8fCB0b2tlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5JTlZBTElEX0RFTEVURV9UT0tFTikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRva2VuRGV0YWlsc0Zyb21Ub2tlbih0b2tlbikudGhlbihmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLkRFTEVURV9UT0tFTl9OT1RfRk9VTkQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLm9wZW5EYXRhYmFzZV8oKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtGQ01fVE9LRU5fT0JKX1NUT1JFXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGQ01fVE9LRU5fT0JKX1NUT1JFKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBvYmplY3RTdG9yZS5kZWxldGUoZGV0YWlsc1snc3dTY29wZSddKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQucmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5GQUlMRURfVE9fREVMRVRFX1RPS0VOKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUb2tlbk1hbmFnZXI7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgVG9rZW5NYW5hZ2VyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbi1tYW5hZ2VyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvbW9kZWxzL3Rva2VuLW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiB0b0Jhc2U2NChhcnJheUJ1ZmZlcikge1xuICAgIHZhciB1aW50OFZlcnNpb24gPSBuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcik7XG4gICAgcmV0dXJuIHdpbmRvdy5idG9hKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdWludDhWZXJzaW9uKSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgYmFzZTY0U3RyaW5nID0gdG9CYXNlNjQoYXJyYXlCdWZmZXIpO1xuICAgIHJldHVybiBiYXNlNjRTdHJpbmdcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJy0nKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csICdfJyk7XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS1idWZmZXItdG8tYmFzZTY0LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL21lc3NhZ2luZy9kaXN0L2VzbS9zcmMvaGVscGVycy9hcnJheS1idWZmZXItdG8tYmFzZTY0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIHBhdGg6ICcvZmlyZWJhc2UtbWVzc2FnaW5nLXN3LmpzJyxcbiAgICBzY29wZTogJy9maXJlYmFzZS1jbG91ZC1tZXNzYWdpbmctcHVzaC1zY29wZSdcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmF1bHQtc3cuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvbWVzc2FnaW5nL2Rpc3QvZXNtL3NyYy9tb2RlbHMvZGVmYXVsdC1zdy5qc1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuaW1wb3J0IENvbnRyb2xsZXJJbnRlcmZhY2UgZnJvbSAnLi9jb250cm9sbGVyLWludGVyZmFjZSc7XG5pbXBvcnQgRXJyb3JzIGZyb20gJy4uL21vZGVscy9lcnJvcnMnO1xuaW1wb3J0IFdvcmtlclBhZ2VNZXNzYWdlIGZyb20gJy4uL21vZGVscy93b3JrZXItcGFnZS1tZXNzYWdlJztcbmltcG9ydCBGQ01EZXRhaWxzIGZyb20gJy4uL21vZGVscy9mY20tZGV0YWlscyc7XG52YXIgRkNNX01TRyA9ICdGQ01fTVNHJztcbnZhciBTV0NvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNXQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTV0NvbnRyb2xsZXIoYXBwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGFwcCkgfHwgdGhpcztcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdwdXNoJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLm9uUHVzaF8oZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdwdXNoc3Vic2NyaXB0aW9uY2hhbmdlJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLm9uU3ViQ2hhbmdlXyhlKTsgfSwgZmFsc2UpO1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ25vdGlmaWNhdGlvbmNsaWNrJywgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLm9uTm90aWZpY2F0aW9uQ2xpY2tfKGUpOyB9LCBmYWxzZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oT2JqZWN0KXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYmdNZXNzYWdlSGFuZGxlcl8gPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaGFuZGxlciBmb3IgcHVzaCBldmVudHMgdGhhdCBzaG93cyBub3RpZmljYXRpb25zIGJhc2VkIG9uIHRoZSBjb250ZW50IG9mXG4gICAgICogdGhlIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBUaGUgcGF5bG9hZCBtdXN0IGJlIGEgSlNPTi1lbmNvZGVkIE9iamVjdCB3aXRoIGEgYG5vdGlmaWNhdGlvbmAga2V5LiBUaGVcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYG5vdGlmaWNhdGlvbmAgcHJvcGVydHkgd2lsbCBiZSB1c2VkIGFzIHRoZSBOb3RpZmljYXRpb25PcHRpb25zXG4gICAgICogb2JqZWN0IHBhc3NlZCB0byBzaG93Tm90aWZpY2F0aW9uLiBBZGRpdGlvbmFsbHksIHRoZSBgdGl0bGVgIHByb3BlcnR5IG9mIHRoZVxuICAgICAqIG5vdGlmaWNhdGlvbiBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHRoZSB0aXRsZS5cbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIG5vdGlmaWNhdGlvbiBkYXRhIGluIHRoZSBwYXlsb2FkIHRoZW4gbm8gbm90aWZpY2F0aW9uIHdpbGwgYmVcbiAgICAgKiBzaG93bi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUub25QdXNoXyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbXNnUGF5bG9hZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1zZ1BheWxvYWQgPSBldmVudC5kYXRhLmpzb24oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBOb3QgSlNPTiBzbyBub3QgYW4gRkNNIG1lc3NhZ2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFuZGxlTXNnUHJvbWlzZSA9IHRoaXMuaGFzVmlzaWJsZUNsaWVudHNfKCkudGhlbihmdW5jdGlvbiAoaGFzVmlzaWJsZUNsaWVudHMpIHtcbiAgICAgICAgICAgIGlmIChoYXNWaXNpYmxlQ2xpZW50cykge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdCBuZWVkIHRvIHNob3cgYSBub3RpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKG1zZ1BheWxvYWQubm90aWZpY2F0aW9uIHx8IF90aGlzLmJnTWVzc2FnZUhhbmRsZXJfKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgdG8gcGFnZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZE1lc3NhZ2VUb1dpbmRvd0NsaWVudHNfKG1zZ1BheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uRGV0YWlscyA9IF90aGlzLmdldE5vdGlmaWNhdGlvbkRhdGFfKG1zZ1BheWxvYWQpO1xuICAgICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uVGl0bGUgPSBub3RpZmljYXRpb25EZXRhaWxzLnRpdGxlIHx8ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnJlZ2lzdHJhdGlvbi5zaG93Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvblRpdGxlLCBub3RpZmljYXRpb25EZXRhaWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmJnTWVzc2FnZUhhbmRsZXJfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJnTWVzc2FnZUhhbmRsZXJfKG1zZ1BheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKGhhbmRsZU1zZ1Byb21pc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLm9uU3ViQ2hhbmdlXyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvbWlzZUNoYWluID0gdGhpcy5nZXRUb2tlbigpLnRoZW4oZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgcmVzdWJzY3JpYmUgaWYgd2UgZG9uJ3QgaGF2ZSBhbiBGQ00gdG9rZW4gZm9yIHRoaXMgc2NvcGUuXG4gICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLk5PX0ZDTV9UT0tFTl9GT1JfUkVTVUJTQ1JJQkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgdG9rZW5NYW5hZ2VyID0gX3RoaXMuZ2V0VG9rZW5NYW5hZ2VyKCk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyXG4gICAgICAgICAgICAgICAgLmdldFRva2VuRGV0YWlsc0Zyb21Ub2tlbih0b2tlbilcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRva2VuRGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLklOVkFMSURfU0FWRURfVE9LRU4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdldCBhIG5ldyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yZWdpc3RyYXRpb24ucHVzaE1hbmFnZXIuc3Vic2NyaWJlKEZDTURldGFpbHMuU1VCU0NSSVBUSU9OX09QVElPTlMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAobmV3U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VuZCBuZXcgc3Vic2NyaXB0aW9uIHRvIEZDTS5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyLnN1YnNjcmliZVRvRkNNKHRva2VuRGV0YWlscy5mY21TZW5kZXJJZCwgbmV3U3Vic2NyaXB0aW9uLCB0b2tlbkRldGFpbHMuZmNtUHVzaFNldCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGJlc3QgdGhpbmcgd2UgY2FuIGRvIGlzIGxvZyB0aGlzIHRvIHRoZSB0ZXJtaW5hbCBzb1xuICAgICAgICAgICAgICAgIC8vIGRldmVsb3BlcnMgbWlnaHQgbm90aWNlIHRoZSBlcnJvci5cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5NYW5hZ2VyLmRlbGV0ZVRva2VuKHRva2VuRGV0YWlscy5mY21Ub2tlbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmVycm9yRmFjdG9yeV8uY3JlYXRlKEVycm9ycy5jb2Rlcy5VTkFCTEVfVE9fUkVTVUJTQ1JJQkUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHByb21pc2VDaGFpbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUub25Ob3RpZmljYXRpb25DbGlja18gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCEoZXZlbnQubm90aWZpY2F0aW9uICYmXG4gICAgICAgICAgICBldmVudC5ub3RpZmljYXRpb24uZGF0YSAmJlxuICAgICAgICAgICAgZXZlbnQubm90aWZpY2F0aW9uLmRhdGFbRkNNX01TR10pKSB7XG4gICAgICAgICAgICAvLyBOb3QgYW4gRkNNIG5vdGlmaWNhdGlvbiwgZG8gbm90aGluZy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IG90aGVyIGxpc3RlbmVycyBmcm9tIHJlY2VpdmluZyB0aGUgZXZlbnRcbiAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50Lm5vdGlmaWNhdGlvbi5jbG9zZSgpO1xuICAgICAgICB2YXIgbXNnUGF5bG9hZCA9IGV2ZW50Lm5vdGlmaWNhdGlvbi5kYXRhW0ZDTV9NU0ddO1xuICAgICAgICB2YXIgY2xpY2tBY3Rpb24gPSBtc2dQYXlsb2FkWydub3RpZmljYXRpb24nXVsnY2xpY2tfYWN0aW9uJ107XG4gICAgICAgIGlmICghY2xpY2tBY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2VDaGFpbiA9IHRoaXMuZ2V0V2luZG93Q2xpZW50XyhjbGlja0FjdGlvbilcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICh3aW5kb3dDbGllbnQpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93Q2xpZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVW5hYmxlIHRvIGZpbmQgd2luZG93IGNsaWVudCBzbyBuZWVkIHRvIG9wZW4gb25lLlxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNsaWVudHMub3BlbldpbmRvdyhjbGlja0FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2luZG93Q2xpZW50O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHdpbmRvd0NsaWVudCkge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dDbGllbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3cgQ2xpZW50IHdpbGwgbm90IGJlIHJldHVybmVkIGlmIGl0J3MgZm9yIGEgdGhpcmQgcGFydHkgb3JpZ2luLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSBub3RpZmljYXRpb24gZGF0YSBmcm9tIHBheWxvYWQgYmVmb3JlIHNlbmRpbmcgdG8gdGhlIHBhZ2UuXG4gICAgICAgICAgICB2YXIgbm90aWZpY2F0aW9uRGF0YSA9IG1zZ1BheWxvYWRbJ25vdGlmaWNhdGlvbiddO1xuICAgICAgICAgICAgZGVsZXRlIG1zZ1BheWxvYWRbJ25vdGlmaWNhdGlvbiddO1xuICAgICAgICAgICAgdmFyIGludGVybmFsTXNnID0gV29ya2VyUGFnZU1lc3NhZ2UuY3JlYXRlTmV3TXNnKFdvcmtlclBhZ2VNZXNzYWdlLlRZUEVTX09GX01TRy5OT1RJRklDQVRJT05fQ0xJQ0tFRCwgbXNnUGF5bG9hZCk7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIHNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjbGllbnQgdG8gaGFuZGxlIHRoZSBkYXRhXG4gICAgICAgICAgICAvLyBJcyBhZmZlY3RlZCBieTogaHR0cHM6Ly9naXRodWIuY29tL3NsaWdodGx5b2ZmL1NlcnZpY2VXb3JrZXIvaXNzdWVzLzcyOFxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmF0dGVtcHRUb01lc3NhZ2VDbGllbnRfKHdpbmRvd0NsaWVudCwgaW50ZXJuYWxNc2cpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnQud2FpdFVudGlsKHByb21pc2VDaGFpbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXlsb2FkXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uT3B0aW9uc3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgU1dDb250cm9sbGVyLnByb3RvdHlwZS5nZXROb3RpZmljYXRpb25EYXRhXyA9IGZ1bmN0aW9uIChtc2dQYXlsb2FkKSB7XG4gICAgICAgIGlmICghbXNnUGF5bG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbXNnUGF5bG9hZC5ub3RpZmljYXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vdGlmaWNhdGlvbkluZm9ybWF0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgbXNnUGF5bG9hZC5ub3RpZmljYXRpb24pO1xuICAgICAgICAvLyBQdXQgdGhlIG1lc3NhZ2UgcGF5bG9hZCB1bmRlciBGQ01fTVNHIG5hbWUgc28gd2UgY2FuIGlkZW50aWZ5IHRoZVxuICAgICAgICAvLyBub3RpZmljYXRpb24gYXMgYmVpbmcgYW4gRkNNIG5vdGlmaWNhdGlvbiB2cyBhIG5vdGlmaWNhdGlvbiBmcm9tXG4gICAgICAgIC8vIHNvbWV3aGVyZSBlbHNlIChpLmUuIG5vcm1hbCB3ZWIgcHVzaCBvciBkZXZlbG9wZXIgZ2VuZXJhdGVkXG4gICAgICAgIC8vIG5vdGlmaWNhdGlvbikuXG4gICAgICAgIG5vdGlmaWNhdGlvbkluZm9ybWF0aW9uWydkYXRhJ10gPSAoX2EgPSB7fSxcbiAgICAgICAgICAgIF9hW0ZDTV9NU0ddID0gbXNnUGF5bG9hZCxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvbkluZm9ybWF0aW9uO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIHNldEJhY2tncm91bmRNZXNzYWdlSGFuZGxlciB3aWxsIG9wdCBpbiB0byBzb21lIHNwZWNpZmljXG4gICAgICogYmVoYXZpb3Vycy5cbiAgICAgKiAxLikgSWYgYSBub3RpZmljYXRpb24gZG9lc24ndCBuZWVkIHRvIGJlIHNob3duIGR1ZSB0byBhIHdpbmRvdyBhbHJlYWR5XG4gICAgICogYmVpbmcgdmlzaWJsZSwgdGhlbiBwdXNoIG1lc3NhZ2VzIHdpbGwgYmUgc2VudCB0byB0aGUgcGFnZS5cbiAgICAgKiAyLikgSWYgYSBub3RpZmljYXRpb24gbmVlZHMgdG8gYmUgc2hvd24sIGFuZCB0aGUgbWVzc2FnZSBjb250YWlucyBub1xuICAgICAqIG5vdGlmaWNhdGlvbiBkYXRhIHRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkXG4gICAgICogYW5kIHRoZSBwcm9taXNlIGl0IHJldHVybnMgd2lsbCBiZSBwYXNzZWQgdG8gZXZlbnQud2FpdFVudGlsLlxuICAgICAqIElmIHlvdSBkbyBub3Qgc2V0IHRoaXMgY2FsbGJhY2sgdGhlbiBhbGwgcHVzaCBtZXNzYWdlcyB3aWxsIGxldCBhbmQgdGhlXG4gICAgICogZGV2ZWxvcGVyIGNhbiBoYW5kbGUgdGhlbSBpbiBhIHRoZWlyIG93biAncHVzaCcgZXZlbnQgY2FsbGJhY2tcbiAgICAgKiBAZXhwb3J0XG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHdoZW4gYSBwdXNoXG4gICAgICogbWVzc2FnZSBpcyByZWNlaXZlZCBhbmQgYSBub3RpZmljYXRpb24gbXVzdCBiZSBzaG93bi4gVGhlIGNhbGxiYWNrIHdpbGxcbiAgICAgKiBiZSBnaXZlbiB0aGUgZGF0YSBmcm9tIHRoZSBwdXNoIG1lc3NhZ2UuXG4gICAgICovXG4gICAgU1dDb250cm9sbGVyLnByb3RvdHlwZS5zZXRCYWNrZ3JvdW5kTWVzc2FnZUhhbmRsZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnJvckZhY3RvcnlfLmNyZWF0ZShFcnJvcnMuY29kZXMuQkdfSEFORExFUl9GVU5DVElPTl9FWFBFQ1RFRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZ01lc3NhZ2VIYW5kbGVyXyA9IGNhbGxiYWNrO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gbG9vayBmb3Igd2hlbiBmb2N1c2luZyBhIGNsaWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gZXhpc3Rpbmcgd2luZG93IGNsaWVudCBvciBhIG5ld2x5IG9wZW5lZFxuICAgICAqIFdpbmRvd0NsaWVudC5cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLmdldFdpbmRvd0NsaWVudF8gPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIC8vIFVzZSBVUkwgdG8gbm9ybWFsaXplIHRoZSBVUkwgd2hlbiBjb21wYXJpbmcgdG8gd2luZG93Q2xpZW50cy5cbiAgICAgICAgLy8gVGhpcyBhdCBsZWFzdCBoYW5kbGVzIHdoZXRoZXIgdG8gaW5jbHVkZSB0cmFpbGluZyBzbGFzaGVzIG9yIG5vdFxuICAgICAgICB2YXIgcGFyc2VkVVJMID0gbmV3IFVSTCh1cmwpLmhyZWY7XG4gICAgICAgIHJldHVybiBzZWxmLmNsaWVudHNcbiAgICAgICAgICAgIC5tYXRjaEFsbCh7XG4gICAgICAgICAgICB0eXBlOiAnd2luZG93JyxcbiAgICAgICAgICAgIGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWVcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChjbGllbnRMaXN0KSB7XG4gICAgICAgICAgICB2YXIgc3VpdGFibGVDbGllbnQgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGllbnRMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZENsaWVudFVybCA9IG5ldyBVUkwoY2xpZW50TGlzdFtpXS51cmwpLmhyZWY7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZENsaWVudFVybCA9PT0gcGFyc2VkVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1aXRhYmxlQ2xpZW50ID0gY2xpZW50TGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1aXRhYmxlQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgc3VpdGFibGVDbGllbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VpdGFibGVDbGllbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXNzYWdlIHdpbGwgYXR0ZW1wdCB0byBzZW5kIHRoZSBtZXNzYWdlIHRvIGEgd2luZG93IGNsaWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnQgVGhlIFdpbmRvd0NsaWVudCB0byBzZW5kIHRoZSBtZXNzYWdlIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHNlbmQgdG8gdGhlIGNsaWVudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBzZW5kaW5nIHRoZVxuICAgICAqIG1lc3NhZ2UuIFRoaXMgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXQgdGhlIG1lc3NhZ2Ugd2FzIHN1Y2Nlc3NmdWxseVxuICAgICAqIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUuYXR0ZW1wdFRvTWVzc2FnZUNsaWVudF8gPSBmdW5jdGlvbiAoY2xpZW50LCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoX3RoaXMuZXJyb3JGYWN0b3J5Xy5jcmVhdGUoRXJyb3JzLmNvZGVzLk5PX1dJTkRPV19DTElFTlRfVE9fTVNHKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGllbnQucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gSWYgdGhlcmUgaXMgY3VycmVudGx5IGEgdmlzaWJsZSBXaW5kb3dDbGllbnQsXG4gICAgICogdGhpcyBtZXRob2Qgd2lsbCByZXNvbHZlIHRvIHRydWUsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICBTV0NvbnRyb2xsZXIucHJvdG90eXBlLmhhc1Zpc2libGVDbGllbnRzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuY2xpZW50c1xuICAgICAgICAgICAgLm1hdGNoQWxsKHtcbiAgICAgICAgICAgIHR5cGU6ICd3aW5kb3cnLFxuICAgICAgICAgICAgaW5jbHVkZVVuY29udHJvbGxlZDogdHJ1ZVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGNsaWVudExpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBjbGllbnRMaXN0LnNvbWUoZnVuY3Rpb24gKGNsaWVudCkgeyByZXR1cm4gY2xpZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ3Zpc2libGUnOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtc2dQYXlsb2FkIFRoZSBkYXRhIGZyb20gdGhlIHB1c2ggZXZlbnQgdGhhdCBzaG91bGQgYmUgc2VudFxuICAgICAqIHRvIGFsbCBhdmFpbGFibGUgcGFnZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9IFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgbWVzc2FnZVxuICAgICAqIGhhcyBiZWVuIHNlbnQgdG8gYWxsIFdpbmRvd0NsaWVudHMuXG4gICAgICovXG4gICAgU1dDb250cm9sbGVyLnByb3RvdHlwZS5zZW5kTWVzc2FnZVRvV2luZG93Q2xpZW50c18gPSBmdW5jdGlvbiAobXNnUGF5bG9hZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5jbGllbnRzXG4gICAgICAgICAgICAubWF0Y2hBbGwoe1xuICAgICAgICAgICAgdHlwZTogJ3dpbmRvdycsXG4gICAgICAgICAgICBpbmNsdWRlVW5jb250cm9sbGVkOiB0cnVlXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoY2xpZW50TGlzdCkge1xuICAgICAgICAgICAgdmFyIGludGVybmFsTXNnID0gV29ya2VyUGFnZU1lc3NhZ2UuY3JlYXRlTmV3TXNnKFdvcmtlclBhZ2VNZXNzYWdlLlRZUEVTX09GX01TRy5QVVNIX01TR19SRUNFSVZFRCwgbXNnUGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2xpZW50TGlzdC5tYXAoZnVuY3Rpb24gKGNsaWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdHRlbXB0VG9NZXNzYWdlQ2xpZW50XyhjbGllbnQsIGludGVybmFsTXNnKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgcmVnaXN0ZXIgdGhlIGRlZmF1bHQgc2VydmljZSB3b3JrZXIgYW5kIHJldHVybiB0aGUgcmVnaXN0cmF0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UHJvbWlzZTwhU2VydmljZVdvcmtlclJlZ2lzdHJhdGlvbj59IFRoZSBzZXJ2aWNlIHdvcmtlclxuICAgICAqIHJlZ2lzdHJhdGlvbiB0byBiZSB1c2VkIGZvciB0aGUgcHVzaCBzZXJ2aWNlLlxuICAgICAqL1xuICAgIFNXQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U1dSZWdpc3RyYXRpb25fID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNlbGYucmVnaXN0cmF0aW9uKTtcbiAgICB9O1xuICAgIHJldHVybiBTV0NvbnRyb2xsZXI7XG59KENvbnRyb2xsZXJJbnRlcmZhY2UpKTtcbmV4cG9ydCBkZWZhdWx0IFNXQ29udHJvbGxlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ctY29udHJvbGxlci5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9tZXNzYWdpbmcvZGlzdC9lc20vc3JjL2NvbnRyb2xsZXJzL3N3LWNvbnRyb2xsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbnJlcXVpcmUoJ0BmaXJlYmFzZS9zdG9yYWdlJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9maXJlYmFzZS9zdG9yYWdlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgU3RyaW5nRm9ybWF0IH0gZnJvbSAnLi9zcmMvaW1wbGVtZW50YXRpb24vc3RyaW5nJztcbmltcG9ydCB7IFRhc2tFdmVudCB9IGZyb20gJy4vc3JjL2ltcGxlbWVudGF0aW9uL3Rhc2tlbnVtcyc7XG5pbXBvcnQgeyBUYXNrU3RhdGUgfSBmcm9tICcuL3NyYy9pbXBsZW1lbnRhdGlvbi90YXNrZW51bXMnO1xuaW1wb3J0IHsgWGhySW9Qb29sIH0gZnJvbSAnLi9zcmMvaW1wbGVtZW50YXRpb24veGhyaW9wb29sJztcbmltcG9ydCB7IFJlZmVyZW5jZSB9IGZyb20gJy4vc3JjL3JlZmVyZW5jZSc7XG5pbXBvcnQgeyBTZXJ2aWNlIH0gZnJvbSAnLi9zcmMvc2VydmljZSc7XG4vKipcbiAqIFR5cGUgY29uc3RhbnQgZm9yIEZpcmViYXNlIFN0b3JhZ2UuXG4gKi9cbnZhciBTVE9SQUdFX1RZUEUgPSAnc3RvcmFnZSc7XG5mdW5jdGlvbiBmYWN0b3J5KGFwcCwgdW51c2VkLCBvcHRfdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlKGFwcCwgbmV3IFhocklvUG9vbCgpLCBvcHRfdXJsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlclN0b3JhZ2UoaW5zdGFuY2UpIHtcbiAgICB2YXIgbmFtZXNwYWNlRXhwb3J0cyA9IHtcbiAgICAgICAgLy8gbm8taW5saW5lXG4gICAgICAgIFRhc2tTdGF0ZTogVGFza1N0YXRlLFxuICAgICAgICBUYXNrRXZlbnQ6IFRhc2tFdmVudCxcbiAgICAgICAgU3RyaW5nRm9ybWF0OiBTdHJpbmdGb3JtYXQsXG4gICAgICAgIFN0b3JhZ2U6IFNlcnZpY2UsXG4gICAgICAgIFJlZmVyZW5jZTogUmVmZXJlbmNlXG4gICAgfTtcbiAgICBpbnN0YW5jZS5JTlRFUk5BTC5yZWdpc3RlclNlcnZpY2UoU1RPUkFHRV9UWVBFLCBmYWN0b3J5LCBuYW1lc3BhY2VFeHBvcnRzLCB1bmRlZmluZWQsIFxuICAgIC8vIEFsbG93IG11bHRpcGxlIHN0b3JhZ2UgaW5zdGFuY2VzIHBlciBhcHAuXG4gICAgdHJ1ZSk7XG59XG5yZWdpc3RlclN0b3JhZ2UoZmlyZWJhc2UpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgTmV0d29ya1hocklvIH0gZnJvbSAnLi94aHJpb19uZXR3b3JrJztcbi8qKlxuICogRmFjdG9yeS1saWtlIGNsYXNzIGZvciBjcmVhdGluZyBYaHJJbyBpbnN0YW5jZXMuXG4gKi9cbnZhciBYaHJJb1Bvb2wgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGhySW9Qb29sKCkge1xuICAgIH1cbiAgICBYaHJJb1Bvb2wucHJvdG90eXBlLmNyZWF0ZVhocklvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IE5ldHdvcmtYaHJJbygpO1xuICAgIH07XG4gICAgcmV0dXJuIFhocklvUG9vbDtcbn0oKSk7XG5leHBvcnQgeyBYaHJJb1Bvb2wgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eGhyaW9wb29sLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3hocmlvcG9vbC5qc1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIGVycm9yc0V4cG9ydHMgZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnLi9vYmplY3QnO1xuaW1wb3J0ICogYXMgcHJvbWlzZWltcGwgZnJvbSAnLi9wcm9taXNlX2V4dGVybmFsJztcbmltcG9ydCAqIGFzIHR5cGUgZnJvbSAnLi90eXBlJztcbmltcG9ydCAqIGFzIFhocklvRXhwb3J0cyBmcm9tICcuL3hocmlvJztcbi8qKlxuICogV2UgdXNlIHRoaXMgaW5zdGVhZCBvZiBnb29nLm5ldC5YaHJJbyBiZWNhdXNlIGdvb2cubmV0LlhocklvIGlzIGh5dXV1dWdlIGFuZFxuICogZG9lc24ndCB3b3JrIGluIFJlYWN0IE5hdGl2ZSBvbiBBbmRyb2lkLlxuICovXG52YXIgTmV0d29ya1hocklvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ldHdvcmtYaHJJbygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zZW50XyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnhocl8gPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5lcnJvckNvZGVfID0gWGhySW9FeHBvcnRzLkVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZV8gPSBwcm9taXNlaW1wbC5tYWtlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lcnJvckNvZGVfID0gWGhySW9FeHBvcnRzLkVycm9yQ29kZS5BQk9SVDtcbiAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMueGhyXy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9yQ29kZV8gPSBYaHJJb0V4cG9ydHMuRXJyb3JDb2RlLk5FVFdPUktfRVJST1I7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnhocl8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoX3RoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAodXJsLCBtZXRob2QsIG9wdF9ib2R5LCBvcHRfaGVhZGVycykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnRlcm5hbEVycm9yKCdjYW5ub3QgLnNlbmQoKSBtb3JlIHRoYW4gb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VudF8gPSB0cnVlO1xuICAgICAgICB0aGlzLnhocl8ub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKG9wdF9oZWFkZXJzKSkge1xuICAgICAgICAgICAgdmFyIGhlYWRlcnMgPSBvcHRfaGVhZGVycztcbiAgICAgICAgICAgIG9iamVjdC5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnhocl8uc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKG9wdF9ib2R5KSkge1xuICAgICAgICAgICAgdGhpcy54aHJfLnNlbmQob3B0X2JvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54aHJfLnNlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUHJvbWlzZV87XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLmdldEVycm9yQ29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbnRfKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNFeHBvcnRzLmludGVybmFsRXJyb3IoJ2Nhbm5vdCAuZ2V0RXJyb3JDb2RlKCkgYmVmb3JlIHNlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvZGVfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5nZXRTdGF0dXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5zZW50Xykge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzRXhwb3J0cy5pbnRlcm5hbEVycm9yKCdjYW5ub3QgLmdldFN0YXR1cygpIGJlZm9yZSBzZW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnhocl8uc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIE5ldHdvcmtYaHJJby5wcm90b3R5cGUuZ2V0UmVzcG9uc2VUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2VudF8pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuaW50ZXJuYWxFcnJvcignY2Fubm90IC5nZXRSZXNwb25zZVRleHQoKSBiZWZvcmUgc2VuZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnhocl8ucmVzcG9uc2VUZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIE5ldHdvcmtYaHJJby5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMueGhyXy5hYm9ydCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5nZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueGhyXy5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgTmV0d29ya1hocklvLnByb3RvdHlwZS5hZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0eXBlLmlzRGVmKHRoaXMueGhyXy51cGxvYWQpKSB7XG4gICAgICAgICAgICB0aGlzLnhocl8udXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBOZXR3b3JrWGhySW8ucHJvdG90eXBlLnJlbW92ZVVwbG9hZFByb2dyZXNzTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHR5cGUuaXNEZWYodGhpcy54aHJfLnVwbG9hZCkpIHtcbiAgICAgICAgICAgIHRoaXMueGhyXy51cGxvYWQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrWGhySW87XG59KCkpO1xuZXhwb3J0IHsgTmV0d29ya1hocklvIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXhocmlvX25ldHdvcmsuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24veGhyaW9fbmV0d29yay5qc1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIHR5cGUgZnJvbSAnLi90eXBlJztcbi8qKlxuICogUmV0dXJucyB0aGUgT2JqZWN0IHJlc3VsdGluZyBmcm9tIHBhcnNpbmcgdGhlIGdpdmVuIEpTT04sIG9yIG51bGwgaWYgdGhlXG4gKiBnaXZlbiBzdHJpbmcgZG9lcyBub3QgcmVwcmVzZW50IGEgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqc29uT2JqZWN0T3JOdWxsKHMpIHtcbiAgICB2YXIgb2JqO1xuICAgIHRyeSB7XG4gICAgICAgIG9iaiA9IEpTT04ucGFyc2Uocyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZS5pc05vbkFycmF5T2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9qc29uLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vdHlwZSc7XG5mdW5jdGlvbiBnZXRCbG9iQnVpbGRlcigpIHtcbiAgICBpZiAodHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gQmxvYkJ1aWxkZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBXZWJLaXRCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIFdlYktpdEJsb2JCdWlsZGVyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyBvbmUgb3IgbW9yZSB2YWx1ZXMgdG9nZXRoZXIgYW5kIGNvbnZlcnRzIHRoZW0gdG8gYSBCbG9iLlxuICpcbiAqIEBwYXJhbSB2YXJfYXJncyBUaGUgdmFsdWVzIHRoYXQgd2lsbCBtYWtlIHVwIHRoZSByZXN1bHRpbmcgYmxvYi5cbiAqIEByZXR1cm4gVGhlIGJsb2IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCbG9iKCkge1xuICAgIHZhciB2YXJfYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhcl9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBCbG9iQnVpbGRlciA9IGdldEJsb2JCdWlsZGVyKCk7XG4gICAgaWYgKEJsb2JCdWlsZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFyX2FyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJiLmFwcGVuZCh2YXJfYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJiLmdldEJsb2IoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlLmlzTmF0aXZlQmxvYkRlZmluZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKHZhcl9hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc2VlbSB0byBzdXBwb3J0IGNyZWF0aW5nIEJsb2JzXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTbGljZXMgdGhlIGJsb2IuIFRoZSByZXR1cm5lZCBibG9iIGNvbnRhaW5zIGRhdGEgZnJvbSB0aGUgc3RhcnQgYnl0ZVxuICogKGluY2x1c2l2ZSkgdGlsbCB0aGUgZW5kIGJ5dGUgKGV4Y2x1c2l2ZSkuIE5lZ2F0aXZlIGluZGljZXMgY2Fubm90IGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIGJsb2IgVGhlIGJsb2IgdG8gYmUgc2xpY2VkLlxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBzdGFydGluZyBieXRlLlxuICogQHBhcmFtIGVuZCBJbmRleCBvZiB0aGUgZW5kaW5nIGJ5dGUuXG4gKiBAcmV0dXJuIFRoZSBibG9iIHNsaWNlIG9yIG51bGwgaWYgbm90IHN1cHBvcnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlQmxvYihibG9iLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGJsb2Iud2Via2l0U2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iud2Via2l0U2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJsb2IubW96U2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2IubW96U2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJsb2Iuc2xpY2UpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9mcy5qc1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwidmFyIFJlcXVlc3RJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlcXVlc3RJbmZvKHVybCwgbWV0aG9kLCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHZhbHVlIHdpdGggd2hpY2ggdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCdzIHByb21pc2UuIE9ubHkgY2FsbGVkXG4gICAgICAgICAqIGlmIHRoZSByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuIFRocm93IGZyb20gdGhpcyBmdW5jdGlvbiB0byByZWplY3QgdGhlXG4gICAgICAgICAqIHJldHVybmVkIFJlcXVlc3QncyBwcm9taXNlIHdpdGggdGhlIHRocm93biBlcnJvci5cbiAgICAgICAgICogTm90ZTogVGhlIFhocklvIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIG1heSBiZSByZXVzZWQgYWZ0ZXIgdGhpcyBjYWxsYmFja1xuICAgICAgICAgKiByZXR1cm5zLiBEbyBub3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdCBpbiBhbnkgd2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMudXJsUGFyYW1zID0ge307XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHt9O1xuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2l0aCB0aGUgY3VycmVudCBudW1iZXIgb2YgYnl0ZXMgdXBsb2FkZWQgYW5kIHRvdGFsIHNpemUgKC0xIGlmIG5vdFxuICAgICAgICAgKiBjb21wdXRhYmxlKSBvZiB0aGUgcmVxdWVzdCBib2R5IChpLmUuIHVzZWQgdG8gcmVwb3J0IHVwbG9hZCBwcm9ncmVzcykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2dyZXNzQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NDb2RlcyA9IFsyMDBdO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxSZXRyeUNvZGVzID0gW107XG4gICAgfVxuICAgIHJldHVybiBSZXF1ZXN0SW5mbztcbn0oKSk7XG5leHBvcnQgeyBSZXF1ZXN0SW5mbyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0aW5mby5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0aW5mby5qc1xuLy8gbW9kdWxlIGlkID0gMTUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQGZpbGVvdmVydmlldyBEZWZpbmVzIHR5cGVzIGZvciBpbnRlcmFjdGluZyB3aXRoIGJsb2IgdHJhbnNmZXIgdGFza3MuXG4gKi9cbmltcG9ydCB7IEludGVybmFsVGFza1N0YXRlIH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi90YXNrZW51bXMnO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuL2ltcGxlbWVudGF0aW9uL29ic2VydmVyJztcbmltcG9ydCB7IFRhc2tFdmVudCwgVGFza1N0YXRlIH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi90YXNrZW51bXMnO1xuaW1wb3J0IHsgVXBsb2FkVGFza1NuYXBzaG90IH0gZnJvbSAnLi90YXNrc25hcHNob3QnO1xuaW1wb3J0ICogYXMgZmJzQXJncyBmcm9tICcuL2ltcGxlbWVudGF0aW9uL2FyZ3MnO1xuaW1wb3J0ICogYXMgZmJzQXJyYXkgZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9hcnJheSc7XG5pbXBvcnQgeyBhc3luYyBhcyBmYnNBc3luYyB9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vYXN5bmMnO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4vaW1wbGVtZW50YXRpb24vZXJyb3InO1xuaW1wb3J0ICogYXMgZmJzUHJvbWlzZWltcGwgZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9wcm9taXNlX2V4dGVybmFsJztcbmltcG9ydCAqIGFzIGZic1JlcXVlc3RzIGZyb20gJy4vaW1wbGVtZW50YXRpb24vcmVxdWVzdHMnO1xuaW1wb3J0ICogYXMgZmJzVGFza0VudW1zIGZyb20gJy4vaW1wbGVtZW50YXRpb24vdGFza2VudW1zJztcbmltcG9ydCAqIGFzIHR5cGVVdGlscyBmcm9tICcuL2ltcGxlbWVudGF0aW9uL3R5cGUnO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgYmxvYiBiZWluZyB1cGxvYWRlZC4gQ2FuIGJlIHVzZWQgdG8gcGF1c2UvcmVzdW1lL2NhbmNlbCB0aGVcbiAqIHVwbG9hZCBhbmQgbWFuYWdlIGNhbGxiYWNrcyBmb3IgdmFyaW91cyBldmVudHMuXG4gKi9cbnZhciBVcGxvYWRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSByZWYgVGhlIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2Ugb2JqZWN0IHRoaXMgdGFzayBjYW1lXG4gICAgICogICAgIGZyb20sIHVudHlwZWQgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY2llcy5cbiAgICAgKiBAcGFyYW0gYmxvYiBUaGUgYmxvYiB0byB1cGxvYWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gVXBsb2FkVGFzayhyZWYsIGF1dGhXcmFwcGVyLCBsb2NhdGlvbiwgbWFwcGluZ3MsIGJsb2IsIG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSA9PT0gdm9pZCAwKSB7IG1ldGFkYXRhID0gbnVsbDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zZmVycmVkXyA9IDA7XG4gICAgICAgIHRoaXMubmVlZFRvRmV0Y2hTdGF0dXNfID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmVlZFRvRmV0Y2hNZXRhZGF0YV8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JfID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGxvYWRVcmxfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0XyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2h1bmtNdWx0aXBsaWVyXyA9IDE7XG4gICAgICAgIHRoaXMucmVzb2x2ZV8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlamVjdF8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlZl8gPSByZWY7XG4gICAgICAgIHRoaXMuYXV0aFdyYXBwZXJfID0gYXV0aFdyYXBwZXI7XG4gICAgICAgIHRoaXMubG9jYXRpb25fID0gbG9jYXRpb247XG4gICAgICAgIHRoaXMuYmxvYl8gPSBibG9iO1xuICAgICAgICB0aGlzLm1ldGFkYXRhXyA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLm1hcHBpbmdzXyA9IG1hcHBpbmdzO1xuICAgICAgICB0aGlzLnJlc3VtYWJsZV8gPSB0aGlzLnNob3VsZERvUmVzdW1hYmxlXyh0aGlzLmJsb2JfKTtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HO1xuICAgICAgICB0aGlzLmVycm9ySGFuZGxlcl8gPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLmNodW5rTXVsdGlwbGllcl8gPSAxO1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGVFcXVhbHMoZXJyb3JzLkNvZGUuQ0FOQ0VMRUQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubmVlZFRvRmV0Y2hTdGF0dXNfID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXJyb3JfID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvbl8oSW50ZXJuYWxUYXNrU3RhdGUuRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1ldGFkYXRhRXJyb3JIYW5kbGVyXyA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGVFcXVhbHMoZXJyb3JzLkNvZGUuQ0FOQ0VMRUQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGVUcmFuc2l0aW9uc18oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmVycm9yXyA9IGVycm9yO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLkVSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IGZic1Byb21pc2VpbXBsLm1ha2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZV8gPSByZXNvbHZlO1xuICAgICAgICAgICAgX3RoaXMucmVqZWN0XyA9IHJlamVjdDtcbiAgICAgICAgICAgIF90aGlzLnN0YXJ0XygpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUHJldmVudCB1bmNhdWdodCByZWplY3Rpb25zIG9uIHRoZSBpbnRlcm5hbCBwcm9taXNlIGZyb20gYnViYmxpbmcgb3V0XG4gICAgICAgIC8vIHRvIHRoZSB0b3AgbGV2ZWwgd2l0aCBhIGR1bW15IGhhbmRsZXIuXG4gICAgICAgIHRoaXMucHJvbWlzZV8udGhlbihudWxsLCBmdW5jdGlvbiAoKSB7IH0pO1xuICAgIH1cbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5tYWtlUHJvZ3Jlc3NDYWxsYmFja18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzaXplQmVmb3JlID0gdGhpcy50cmFuc2ZlcnJlZF87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobG9hZGVkLCB0b3RhbCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlUHJvZ3Jlc3NfKHNpemVCZWZvcmUgKyBsb2FkZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuc2hvdWxkRG9SZXN1bWFibGVfID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgICAgcmV0dXJuIGJsb2Iuc2l6ZSgpID4gMjU2ICogMTAyNDtcbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnN0YXJ0XyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGVfICE9PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgc29tZW9uZSBwYXVzZXMgdXMgaW4gYSByZXN1bWUgY2FsbGJhY2ssIGZvciBleGFtcGxlLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3RfICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVzdW1hYmxlXykge1xuICAgICAgICAgICAgaWYgKHRoaXMudXBsb2FkVXJsXyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVzdW1hYmxlXygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmVlZFRvRmV0Y2hTdGF0dXNfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hTdGF0dXNfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkVG9GZXRjaE1ldGFkYXRhXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFwcGVucyBpZiB3ZSBtaXNzIHRoZSBtZXRhZGF0YSBvbiB1cGxvYWQgY29tcGxldGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hNZXRhZGF0YV8oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVVcGxvYWRfKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uZVNob3RVcGxvYWRfKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnJlc29sdmVUb2tlbl8gPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5hdXRoV3JhcHBlcl8uZ2V0QXV0aFRva2VuKCkudGhlbihmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF90aGlzLnN0YXRlXykge1xuICAgICAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soYXV0aFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkc6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyhJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIFRPRE8oYW5keXNvdG8pOiBhc3NlcnQgZmFsc2VcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5jcmVhdGVSZXN1bWFibGVfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJlc29sdmVUb2tlbl8oZnVuY3Rpb24gKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RJbmZvID0gZmJzUmVxdWVzdHMuY3JlYXRlUmVzdW1hYmxlVXBsb2FkKF90aGlzLmF1dGhXcmFwcGVyXywgX3RoaXMubG9jYXRpb25fLCBfdGhpcy5tYXBwaW5nc18sIF90aGlzLmJsb2JfLCBfdGhpcy5tZXRhZGF0YV8pO1xuICAgICAgICAgICAgdmFyIGNyZWF0ZVJlcXVlc3QgPSBfdGhpcy5hdXRoV3JhcHBlcl8ubWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbik7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IGNyZWF0ZVJlcXVlc3Q7XG4gICAgICAgICAgICBjcmVhdGVSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IG51bGw7XG4gICAgICAgICAgICAgICAgX3RoaXMudXBsb2FkVXJsXyA9IHVybDtcbiAgICAgICAgICAgICAgICBfdGhpcy5uZWVkVG9GZXRjaFN0YXR1c18gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfSwgX3RoaXMuZXJyb3JIYW5kbGVyXyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuZmV0Y2hTdGF0dXNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnVwbG9hZFVybF87XG4gICAgICAgIHRoaXMucmVzb2x2ZVRva2VuXyhmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSBmYnNSZXF1ZXN0cy5nZXRSZXN1bWFibGVVcGxvYWRTdGF0dXMoX3RoaXMuYXV0aFdyYXBwZXJfLCBfdGhpcy5sb2NhdGlvbl8sIHVybCwgX3RoaXMuYmxvYl8pO1xuICAgICAgICAgICAgdmFyIHN0YXR1c1JlcXVlc3QgPSBfdGhpcy5hdXRoV3JhcHBlcl8ubWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbik7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IHN0YXR1c1JlcXVlc3Q7XG4gICAgICAgICAgICBzdGF0dXNSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVByb2dyZXNzXyhzdGF0dXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubmVlZFRvRmV0Y2hTdGF0dXNfID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubmVlZFRvRmV0Y2hNZXRhZGF0YV8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZVRyYW5zaXRpb25zXygpO1xuICAgICAgICAgICAgfSwgX3RoaXMuZXJyb3JIYW5kbGVyXyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuY29udGludWVVcGxvYWRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2h1bmtTaXplID0gZmJzUmVxdWVzdHMucmVzdW1hYmxlVXBsb2FkQ2h1bmtTaXplICogdGhpcy5jaHVua011bHRpcGxpZXJfO1xuICAgICAgICB2YXIgc3RhdHVzID0gbmV3IGZic1JlcXVlc3RzLlJlc3VtYWJsZVVwbG9hZFN0YXR1cyh0aGlzLnRyYW5zZmVycmVkXywgdGhpcy5ibG9iXy5zaXplKCkpO1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KHRoaXMudXBsb2FkVXJsXyAhPT0gbnVsbCk7XG4gICAgICAgIHZhciB1cmwgPSB0aGlzLnVwbG9hZFVybF87XG4gICAgICAgIHRoaXMucmVzb2x2ZVRva2VuXyhmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm87XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJbmZvID0gZmJzUmVxdWVzdHMuY29udGludWVSZXN1bWFibGVVcGxvYWQoX3RoaXMubG9jYXRpb25fLCBfdGhpcy5hdXRoV3JhcHBlcl8sIHVybCwgX3RoaXMuYmxvYl8sIGNodW5rU2l6ZSwgX3RoaXMubWFwcGluZ3NfLCBzdGF0dXMsIF90aGlzLm1ha2VQcm9ncmVzc0NhbGxiYWNrXygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXJyb3JfID0gZTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyhJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHVwbG9hZFJlcXVlc3QgPSBfdGhpcy5hdXRoV3JhcHBlcl8ubWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbik7XG4gICAgICAgICAgICBfdGhpcy5yZXF1ZXN0XyA9IHVwbG9hZFJlcXVlc3Q7XG4gICAgICAgICAgICB1cGxvYWRSZXF1ZXN0XG4gICAgICAgICAgICAgICAgLmdldFByb21pc2UoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChuZXdTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbmNyZWFzZU11bHRpcGxpZXJfKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVByb2dyZXNzXyhuZXdTdGF0dXMuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXR1cy5maW5hbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWV0YWRhdGFfID0gbmV3U3RhdHVzLm1ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyhJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlVHJhbnNpdGlvbnNfKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX3RoaXMuZXJyb3JIYW5kbGVyXyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuaW5jcmVhc2VNdWx0aXBsaWVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTaXplID0gZmJzUmVxdWVzdHMucmVzdW1hYmxlVXBsb2FkQ2h1bmtTaXplICogdGhpcy5jaHVua011bHRpcGxpZXJfO1xuICAgICAgICAvLyBNYXggY2h1bmsgc2l6ZSBpcyAzMk0uXG4gICAgICAgIGlmIChjdXJyZW50U2l6ZSA8IDMyICogMTAyNCAqIDEwMjQpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtNdWx0aXBsaWVyXyAqPSAyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5mZXRjaE1ldGFkYXRhXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvbHZlVG9rZW5fKGZ1bmN0aW9uIChhdXRoVG9rZW4pIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0SW5mbyA9IGZic1JlcXVlc3RzLmdldE1ldGFkYXRhKF90aGlzLmF1dGhXcmFwcGVyXywgX3RoaXMubG9jYXRpb25fLCBfdGhpcy5tYXBwaW5nc18pO1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhUmVxdWVzdCA9IF90aGlzLmF1dGhXcmFwcGVyXy5tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKTtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbWV0YWRhdGFSZXF1ZXN0O1xuICAgICAgICAgICAgbWV0YWRhdGFSZXF1ZXN0LmdldFByb21pc2UoKS50aGVuKGZ1bmN0aW9uIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXRhZGF0YV8gPSBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2l0aW9uXyhJbnRlcm5hbFRhc2tTdGF0ZS5TVUNDRVNTKTtcbiAgICAgICAgICAgIH0sIF90aGlzLm1ldGFkYXRhRXJyb3JIYW5kbGVyXyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUub25lU2hvdFVwbG9hZF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzb2x2ZVRva2VuXyhmdW5jdGlvbiAoYXV0aFRva2VuKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdEluZm8gPSBmYnNSZXF1ZXN0cy5tdWx0aXBhcnRVcGxvYWQoX3RoaXMuYXV0aFdyYXBwZXJfLCBfdGhpcy5sb2NhdGlvbl8sIF90aGlzLm1hcHBpbmdzXywgX3RoaXMuYmxvYl8sIF90aGlzLm1ldGFkYXRhXyk7XG4gICAgICAgICAgICB2YXIgbXVsdGlwYXJ0UmVxdWVzdCA9IF90aGlzLmF1dGhXcmFwcGVyXy5tYWtlUmVxdWVzdChyZXF1ZXN0SW5mbywgYXV0aFRva2VuKTtcbiAgICAgICAgICAgIF90aGlzLnJlcXVlc3RfID0gbXVsdGlwYXJ0UmVxdWVzdDtcbiAgICAgICAgICAgIG11bHRpcGFydFJlcXVlc3QuZ2V0UHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdF8gPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLm1ldGFkYXRhXyA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVByb2dyZXNzXyhfdGhpcy5ibG9iXy5zaXplKCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLlNVQ0NFU1MpO1xuICAgICAgICAgICAgfSwgX3RoaXMuZXJyb3JIYW5kbGVyXyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUudXBkYXRlUHJvZ3Jlc3NfID0gZnVuY3Rpb24gKHRyYW5zZmVycmVkKSB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLnRyYW5zZmVycmVkXztcbiAgICAgICAgdGhpcy50cmFuc2ZlcnJlZF8gPSB0cmFuc2ZlcnJlZDtcbiAgICAgICAgLy8gQSBwcm9ncmVzcyB1cGRhdGUgY2FuIG1ha2UgdGhlIFwidHJhbnNmZXJyZWRcIiB2YWx1ZSBzbWFsbGVyIChlLmcuIGFcbiAgICAgICAgLy8gcGFydGlhbCB1cGxvYWQgbm90IGNvbXBsZXRlZCBieSBzZXJ2ZXIsIGFmdGVyIHdoaWNoIHRoZSBcInRyYW5zZmVycmVkXCJcbiAgICAgICAgLy8gdmFsdWUgbWF5IHJlc2V0IHRvIHRoZSB2YWx1ZSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZXF1ZXN0KS5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNmZXJyZWRfICE9PSBvbGQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJzXygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS50cmFuc2l0aW9uXyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZV8gPT09IHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5DQU5DRUxJTkc6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdF8uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXF1ZXN0XyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RfLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNFRCB8fFxuICAgICAgICAgICAgICAgIC8vICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgdmFyIHdhc1BhdXNlZCA9IHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAod2FzUGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJzXygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgICAgIC8vIFRPRE8oYW5keXNvdG8pOlxuICAgICAgICAgICAgICAgIC8vIGFzc2VydCh0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuQ0FOQ0VMRUQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6XG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0KHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcl8gPSBlcnJvcnMuY2FuY2VsZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlXyA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJzXygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBJbnRlcm5hbFRhc2tTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTpcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnQodGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlBBVVNJTkcgfHxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZV8gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVyc18oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuY29tcGxldGVUcmFuc2l0aW9uc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZV8pIHtcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORzpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLlBBVVNFRCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLkNBTkNFTEVEKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0XygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogYXNzZXJ0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVwbG9hZFRhc2sucHJvdG90eXBlLCBcInNuYXBzaG90XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxTdGF0ZSA9IGZic1Rhc2tFbnVtcy50YXNrU3RhdGVGcm9tSW50ZXJuYWxUYXNrU3RhdGUodGhpcy5zdGF0ZV8pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGxvYWRUYXNrU25hcHNob3QodGhpcy50cmFuc2ZlcnJlZF8sIHRoaXMuYmxvYl8uc2l6ZSgpLCBleHRlcm5hbFN0YXRlLCB0aGlzLm1ldGFkYXRhXywgdGhpcywgdGhpcy5yZWZfKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNhbGxiYWNrIGZvciBhbiBldmVudC5cbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciA9PT0gdm9pZCAwKSB7IG5leHRPck9ic2VydmVyID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gdW5kZWZpbmVkOyB9XG4gICAgICAgIGlmIChjb21wbGV0ZWQgPT09IHZvaWQgMCkgeyBjb21wbGV0ZWQgPSB1bmRlZmluZWQ7IH1cbiAgICAgICAgZnVuY3Rpb24gdHlwZVZhbGlkYXRvcihfcCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IFRhc2tFdmVudC5TVEFURV9DSEFOR0VEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJFeHBlY3RlZCBvbmUgb2YgdGhlIGV2ZW50IHR5cGVzOiBbXCIgKyBUYXNrRXZlbnQuU1RBVEVfQ0hBTkdFRCArIFwiXS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dE9yT2JzZXJ2ZXJNZXNzYWdlID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24gb3IgYW4gT2JqZWN0IHdpdGggb25lIG9mICcgK1xuICAgICAgICAgICAgJ2BuZXh0YCwgYGVycm9yYCwgYGNvbXBsZXRlYCBwcm9wZXJ0aWVzLic7XG4gICAgICAgIHZhciBuZXh0VmFsaWRhdG9yID0gZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpLnZhbGlkYXRvcjtcbiAgICAgICAgdmFyIG9ic2VydmVyVmFsaWRhdG9yID0gZmJzQXJncy5sb29zZU9iamVjdFNwZWMobnVsbCwgdHJ1ZSkudmFsaWRhdG9yO1xuICAgICAgICBmdW5jdGlvbiBuZXh0T3JPYnNlcnZlclZhbGlkYXRvcihwKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5leHRWYWxpZGF0b3IocCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlclZhbGlkYXRvcihwKTtcbiAgICAgICAgICAgICAgICB2YXIgYW55RGVmaW5lZCA9IHR5cGVVdGlscy5pc0p1c3REZWYocFsnbmV4dCddKSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlVXRpbHMuaXNKdXN0RGVmKHBbJ2Vycm9yJ10pIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVVdGlscy5pc0p1c3REZWYocFsnY29tcGxldGUnXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFhbnlEZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5leHRPck9ic2VydmVyTWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc3BlY3MgPSBbXG4gICAgICAgICAgICBmYnNBcmdzLnN0cmluZ1NwZWModHlwZVZhbGlkYXRvciksXG4gICAgICAgICAgICBmYnNBcmdzLmxvb3NlT2JqZWN0U3BlYyhuZXh0T3JPYnNlcnZlclZhbGlkYXRvciwgdHJ1ZSksXG4gICAgICAgICAgICBmYnNBcmdzLm51bGxGdW5jdGlvblNwZWModHJ1ZSksXG4gICAgICAgICAgICBmYnNBcmdzLm51bGxGdW5jdGlvblNwZWModHJ1ZSlcbiAgICAgICAgXTtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgnb24nLCBzcGVjcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBtYWtlQmluZGVyKHNwZWNzKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBiaW5kZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBvcHRfY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BlY3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgnb24nLCBzcGVjcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IE9ic2VydmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZE9ic2VydmVyXyhvYnNlcnZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZW1vdmVPYnNlcnZlcl8ob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmluZGVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJpbmRlck5leHRPck9ic2VydmVyVmFsaWRhdG9yKHApIHtcbiAgICAgICAgICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV4dE9yT2JzZXJ2ZXJNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IocCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJpbmRlclNwZWNzID0gW1xuICAgICAgICAgICAgZmJzQXJncy5sb29zZU9iamVjdFNwZWMoYmluZGVyTmV4dE9yT2JzZXJ2ZXJWYWxpZGF0b3IpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpLFxuICAgICAgICAgICAgZmJzQXJncy5udWxsRnVuY3Rpb25TcGVjKHRydWUpXG4gICAgICAgIF07XG4gICAgICAgIHZhciB0eXBlT25seSA9ICEodHlwZVV0aWxzLmlzSnVzdERlZihuZXh0T3JPYnNlcnZlcikgfHxcbiAgICAgICAgICAgIHR5cGVVdGlscy5pc0p1c3REZWYoZXJyb3IpIHx8XG4gICAgICAgICAgICB0eXBlVXRpbHMuaXNKdXN0RGVmKGNvbXBsZXRlZCkpO1xuICAgICAgICBpZiAodHlwZU9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlQmluZGVyKGJpbmRlclNwZWNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlQmluZGVyKG51bGwpKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGVkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgYmVoYXZlcyBsaWtlIGEgUHJvbWlzZSwgYW5kIHJlc29sdmVzIHdpdGggaXRzIHNuYXBzaG90IGRhdGFcbiAgICAgKiB3aGVuIHRoZSB1cGxvYWQgY29tcGxldGVzLlxuICAgICAqIEBwYXJhbSBvbkZ1bGZpbGxlZCBUaGUgZnVsZmlsbG1lbnQgY2FsbGJhY2suIFByb21pc2UgY2hhaW5pbmcgd29ya3MgYXMgbm9ybWFsLlxuICAgICAqIEBwYXJhbSBvblJlamVjdGVkIFRoZSByZWplY3Rpb24gY2FsbGJhY2suXG4gICAgICovXG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBUaGVzZSBjYXN0cyBhcmUgbmVlZGVkIHNvIHRoYXQgVHlwZVNjcmlwdCBjYW4gaW5mZXIgdGhlIHR5cGVzIG9mIHRoZVxuICAgICAgICAvLyByZXN1bHRpbmcgUHJvbWlzZS5cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV8udGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHRoZW4obnVsbCwgb25SZWplY3RlZClgLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmFkZE9ic2VydmVyXyA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHRoaXMubm90aWZ5T2JzZXJ2ZXJfKG9ic2VydmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIG9ic2VydmVyLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnJlbW92ZU9ic2VydmVyXyA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBmYnNBcnJheS5yZW1vdmUodGhpcy5vYnNlcnZlcnNfLCBvYnNlcnZlcik7XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5ub3RpZnlPYnNlcnZlcnNfID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbmlzaFByb21pc2VfKCk7XG4gICAgICAgIHZhciBvYnNlcnZlcnMgPSBmYnNBcnJheS5jbG9uZSh0aGlzLm9ic2VydmVyc18pO1xuICAgICAgICBvYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIF90aGlzLm5vdGlmeU9ic2VydmVyXyhvYnNlcnZlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVXBsb2FkVGFzay5wcm90b3R5cGUuZmluaXNoUHJvbWlzZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVfICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmJzVGFza0VudW1zLnRhc2tTdGF0ZUZyb21JbnRlcm5hbFRhc2tTdGF0ZSh0aGlzLnN0YXRlXykpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5TVUNDRVNTOlxuICAgICAgICAgICAgICAgICAgICBmYnNBc3luYyh0aGlzLnJlc29sdmVfLmJpbmQobnVsbCwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkNBTkNFTEVEOlxuICAgICAgICAgICAgICAgIGNhc2UgVGFza1N0YXRlLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdG9DYWxsID0gdGhpcy5yZWplY3RfO1xuICAgICAgICAgICAgICAgICAgICBmYnNBc3luYyh0b0NhbGwuYmluZChudWxsLCB0aGlzLmVycm9yXykpKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmlnZ2VyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVfID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdF8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5ub3RpZnlPYnNlcnZlcl8gPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgdmFyIGV4dGVybmFsU3RhdGUgPSBmYnNUYXNrRW51bXMudGFza1N0YXRlRnJvbUludGVybmFsVGFza1N0YXRlKHRoaXMuc3RhdGVfKTtcbiAgICAgICAgc3dpdGNoIChleHRlcm5hbFN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5SVU5OSU5HOlxuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuUEFVU0VEOlxuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZic0FzeW5jKG9ic2VydmVyLm5leHQuYmluZChvYnNlcnZlciwgdGhpcy5zbmFwc2hvdCkpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuU1VDQ0VTUzpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuY29tcGxldGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmJzQXN5bmMob2JzZXJ2ZXIuY29tcGxldGUuYmluZChvYnNlcnZlcikpKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUYXNrU3RhdGUuQ0FOQ0VMRUQ6XG4gICAgICAgICAgICBjYXNlIFRhc2tTdGF0ZS5FUlJPUjpcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIuZXJyb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmJzQXN5bmMob2JzZXJ2ZXIuZXJyb3IuYmluZChvYnNlcnZlciwgdGhpcy5lcnJvcl8pKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhhbmR5c290byk6IGFzc2VydChmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyLmVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZic0FzeW5jKG9ic2VydmVyLmVycm9yLmJpbmQob2JzZXJ2ZXIsIHRoaXMuZXJyb3JfKSkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgYSBwYXVzZWQgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIGN1cnJlbnRseSBydW5uaW5nIG9yIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgncmVzdW1lJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTRUQgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HO1xuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbl8oSW50ZXJuYWxUYXNrU3RhdGUuUlVOTklORyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGEgY3VycmVudGx5IHJ1bm5pbmcgdGFzay4gSGFzIG5vIGVmZmVjdCBvbiBhIHBhdXNlZCBvciBmYWlsZWQgdGFzay5cbiAgICAgKiBAcmV0dXJuIFRydWUgaWYgdGhlIG9wZXJhdGlvbiB0b29rIGVmZmVjdCwgZmFsc2UgaWYgaWdub3JlZC5cbiAgICAgKi9cbiAgICBVcGxvYWRUYXNrLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgncGF1c2UnLCBbXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHZhbGlkID0gdGhpcy5zdGF0ZV8gPT09IEludGVybmFsVGFza1N0YXRlLlJVTk5JTkc7XG4gICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uXyhJbnRlcm5hbFRhc2tTdGF0ZS5QQVVTSU5HKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgY3VycmVudGx5IHJ1bm5pbmcgb3IgcGF1c2VkIHRhc2suIEhhcyBubyBlZmZlY3Qgb24gYSBjb21wbGV0ZSBvclxuICAgICAqIGZhaWxlZCB0YXNrLlxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiB0aGUgb3BlcmF0aW9uIHRvb2sgZWZmZWN0LCBmYWxzZSBpZiBpZ25vcmVkLlxuICAgICAqL1xuICAgIFVwbG9hZFRhc2sucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmJzQXJncy52YWxpZGF0ZSgnY2FuY2VsJywgW10sIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMuc3RhdGVfID09PSBJbnRlcm5hbFRhc2tTdGF0ZS5SVU5OSU5HIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlXyA9PT0gSW50ZXJuYWxUYXNrU3RhdGUuUEFVU0lORztcbiAgICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25fKEludGVybmFsVGFza1N0YXRlLkNBTkNFTElORyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH07XG4gICAgcmV0dXJuIFVwbG9hZFRhc2s7XG59KCkpO1xuZXhwb3J0IHsgVXBsb2FkVGFzayB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXNrLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL3Rhc2suanNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vdHlwZSc7XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIE9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVyKG5leHRPck9ic2VydmVyLCBvcHRfZXJyb3IsIG9wdF9jb21wbGV0ZSkge1xuICAgICAgICB2YXIgYXNGdW5jdGlvbnMgPSB0eXBlLmlzRnVuY3Rpb24obmV4dE9yT2JzZXJ2ZXIpIHx8XG4gICAgICAgICAgICB0eXBlLmlzRGVmKG9wdF9lcnJvcikgfHxcbiAgICAgICAgICAgIHR5cGUuaXNEZWYob3B0X2NvbXBsZXRlKTtcbiAgICAgICAgaWYgKGFzRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBvcHRfZXJyb3IgfHwgbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUgPSBvcHRfY29tcGxldGUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb2JzZXJ2ZXIubmV4dCB8fCBudWxsO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IG9ic2VydmVyLmVycm9yIHx8IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGUgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZXI7XG59KCkpO1xuZXhwb3J0IHsgT2JzZXJ2ZXIgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZXIuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvaW1wbGVtZW50YXRpb24vb2JzZXJ2ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsInZhciBVcGxvYWRUYXNrU25hcHNob3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVXBsb2FkVGFza1NuYXBzaG90KGJ5dGVzVHJhbnNmZXJyZWQsIHRvdGFsQnl0ZXMsIHN0YXRlLCBtZXRhZGF0YSwgdGFzaywgcmVmKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNUcmFuc2ZlcnJlZCA9IGJ5dGVzVHJhbnNmZXJyZWQ7XG4gICAgICAgIHRoaXMudG90YWxCeXRlcyA9IHRvdGFsQnl0ZXM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnRhc2sgPSB0YXNrO1xuICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFVwbG9hZFRhc2tTbmFwc2hvdC5wcm90b3R5cGUsIFwiZG93bmxvYWRVUkxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVybHMgPSB0aGlzLm1ldGFkYXRhWydkb3dubG9hZFVSTHMnXTtcbiAgICAgICAgICAgICAgICBpZiAodXJscyAhPSBudWxsICYmIHVybHNbMF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsc1swXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gVXBsb2FkVGFza1NuYXBzaG90O1xufSgpKTtcbmV4cG9ydCB7IFVwbG9hZFRhc2tTbmFwc2hvdCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXNrc25hcHNob3QuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZmlyZWJhc2Uvc3RvcmFnZS9kaXN0L2VzbS9zcmMvdGFza3NuYXBzaG90LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IE1ldGhvZCBmb3IgaW52b2tpbmcgYSBjYWxsYmFjayBhc3luY2hyb25vdXNseS5cbiAqL1xuaW1wb3J0ICogYXMgcHJvbWlzZWltcGwgZnJvbSAnLi9wcm9taXNlX2V4dGVybmFsJztcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBmIHdpdGggaXRzIGFyZ3VtZW50cyBhc3luY2hyb25vdXNseSBhcyBhXG4gKiBtaWNyb3Rhc2ssIGkuZS4gYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQgcmV0dXJucyBiYWNrXG4gKiBpbnRvIGJyb3dzZXIgY29kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJnc1RvRm9yd2FyZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1RvRm9yd2FyZFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHByb21pc2VpbXBsLnJlc29sdmUodHJ1ZSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmLmFwcGx5KG51bGwsIGFyZ3NUb0ZvcndhcmQpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCAxIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCAqIGFzIGFyZ3MgZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9hcmdzJztcbmltcG9ydCB7IEF1dGhXcmFwcGVyIH0gZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9hdXRod3JhcHBlcic7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJy4vaW1wbGVtZW50YXRpb24vbG9jYXRpb24nO1xuaW1wb3J0ICogYXMgZmJzUHJvbWlzZUltcGwgZnJvbSAnLi9pbXBsZW1lbnRhdGlvbi9wcm9taXNlX2V4dGVybmFsJztcbmltcG9ydCAqIGFzIFJlcXVlc3RFeHBvcnRzIGZyb20gJy4vaW1wbGVtZW50YXRpb24vcmVxdWVzdCc7XG5pbXBvcnQgeyBSZWZlcmVuY2UgfSBmcm9tICcuL3JlZmVyZW5jZSc7XG4vKipcbiAqIEEgc2VydmljZSB0aGF0IHByb3ZpZGVzIGZpcmViYXNlU3RvcmFnZS5SZWZlcmVuY2UgaW5zdGFuY2VzLlxuICogQHBhcmFtIG9wdF91cmwgZ3M6Ly8gdXJsIHRvIGEgY3VzdG9tIFN0b3JhZ2UgQnVja2V0XG4gKlxuICogQHN0cnVjdFxuICovXG52YXIgU2VydmljZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXJ2aWNlKGFwcCwgcG9vbCwgdXJsKSB7XG4gICAgICAgIHRoaXMuYnVja2V0XyA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VyKGF1dGhXcmFwcGVyLCBsb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVmZXJlbmNlKGF1dGhXcmFwcGVyLCBsb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0aFdyYXBwZXJfID0gbmV3IEF1dGhXcmFwcGVyKGFwcCwgbWFrZXIsIFJlcXVlc3RFeHBvcnRzLm1ha2VSZXF1ZXN0LCB0aGlzLCBwb29sKTtcbiAgICAgICAgdGhpcy5hcHBfID0gYXBwO1xuICAgICAgICBpZiAodXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYnVja2V0XyA9IExvY2F0aW9uLm1ha2VGcm9tQnVja2V0U3BlYyh1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGF1dGhXcmFwcGVyQnVja2V0ID0gdGhpcy5hdXRoV3JhcHBlcl8uYnVja2V0KCk7XG4gICAgICAgICAgICBpZiAoYXV0aFdyYXBwZXJCdWNrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVja2V0XyA9IG5ldyBMb2NhdGlvbihhdXRoV3JhcHBlckJ1Y2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxzXyA9IG5ldyBTZXJ2aWNlSW50ZXJuYWxzKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZmlyZWJhc2VTdG9yYWdlLlJlZmVyZW5jZSBmb3IgdGhlIGdpdmVuIHBhdGggaW4gdGhlIGRlZmF1bHRcbiAgICAgKiBidWNrZXQuXG4gICAgICovXG4gICAgU2VydmljZS5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdG9yKHBhdGgpIHtcbiAgICAgICAgICAgIGlmICgvXltBLVphLXpdKzpcXC9cXC8vLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnRXhwZWN0ZWQgY2hpbGQgcGF0aCBidXQgZ290IGEgVVJMLCB1c2UgcmVmRnJvbVVSTCBpbnN0ZWFkLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncmVmJywgW2FyZ3Muc3RyaW5nU3BlYyh2YWxpZGF0b3IsIHRydWUpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuYnVja2V0XyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFN0b3JhZ2UgQnVja2V0IGRlZmluZWQgaW4gRmlyZWJhc2UgT3B0aW9ucy4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gbmV3IFJlZmVyZW5jZSh0aGlzLmF1dGhXcmFwcGVyXywgdGhpcy5idWNrZXRfKTtcbiAgICAgICAgaWYgKHBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZi5jaGlsZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZWY7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCBmb3IgdGhlIGdpdmVuIGFic29sdXRlIFVSTCxcbiAgICAgKiB3aGljaCBtdXN0IGJlIGEgZ3M6Ly8gb3IgaHR0cFtzXTovLyBVUkwuXG4gICAgICovXG4gICAgU2VydmljZS5wcm90b3R5cGUucmVmRnJvbVVSTCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgZnVuY3Rpb24gdmFsaWRhdG9yKHApIHtcbiAgICAgICAgICAgIGlmICghL15bQS1aYS16XSs6XFwvXFwvLy50ZXN0KHApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0V4cGVjdGVkIGZ1bGwgVVJMIGJ1dCBnb3QgYSBjaGlsZCBwYXRoLCB1c2UgcmVmIGluc3RlYWQuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgTG9jYXRpb24ubWFrZUZyb21VcmwocCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93ICdFeHBlY3RlZCB2YWxpZCBmdWxsIFVSTCBidXQgZ290IGFuIGludmFsaWQgb25lLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJncy52YWxpZGF0ZSgncmVmRnJvbVVSTCcsIFthcmdzLnN0cmluZ1NwZWModmFsaWRhdG9yLCBmYWxzZSldLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZmVyZW5jZSh0aGlzLmF1dGhXcmFwcGVyXywgdXJsKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTZXJ2aWNlLnByb3RvdHlwZSwgXCJtYXhVcGxvYWRSZXRyeVRpbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF1dGhXcmFwcGVyXy5tYXhVcGxvYWRSZXRyeVRpbWUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU2VydmljZS5wcm90b3R5cGUuc2V0TWF4VXBsb2FkUmV0cnlUaW1lID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgYXJncy52YWxpZGF0ZSgnc2V0TWF4VXBsb2FkUmV0cnlUaW1lJywgW2FyZ3Mubm9uTmVnYXRpdmVOdW1iZXJTcGVjKCldLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmF1dGhXcmFwcGVyXy5zZXRNYXhVcGxvYWRSZXRyeVRpbWUodGltZSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2VydmljZS5wcm90b3R5cGUsIFwibWF4T3BlcmF0aW9uUmV0cnlUaW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoV3JhcHBlcl8ubWF4T3BlcmF0aW9uUmV0cnlUaW1lKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFNlcnZpY2UucHJvdG90eXBlLnNldE1heE9wZXJhdGlvblJldHJ5VGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgIGFyZ3MudmFsaWRhdGUoJ3NldE1heE9wZXJhdGlvblJldHJ5VGltZScsIFthcmdzLm5vbk5lZ2F0aXZlTnVtYmVyU3BlYygpXSwgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hdXRoV3JhcHBlcl8uc2V0TWF4T3BlcmF0aW9uUmV0cnlUaW1lKHRpbWUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcImFwcFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwXztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIklOVEVSTkFMXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbHNfO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU2VydmljZTtcbn0oKSk7XG5leHBvcnQgeyBTZXJ2aWNlIH07XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFNlcnZpY2VJbnRlcm5hbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VydmljZUludGVybmFscyhzZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuc2VydmljZV8gPSBzZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBhcHAgaXMgZGVsZXRlZC5cbiAgICAgKiBAc2VlIHshZmJzLkF1dGhXcmFwcGVyLnByb3RvdHlwZS5kZWxldGVBcHB9XG4gICAgICovXG4gICAgU2VydmljZUludGVybmFscy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2VfLmF1dGhXcmFwcGVyXy5kZWxldGVBcHAoKTtcbiAgICAgICAgcmV0dXJuIGZic1Byb21pc2VJbXBsLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXJ2aWNlSW50ZXJuYWxzO1xufSgpKTtcbmV4cG9ydCB7IFNlcnZpY2VJbnRlcm5hbHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9zZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0ICogYXMgZXJyb3JzRXhwb3J0cyBmcm9tICcuL2Vycm9yJztcbmltcG9ydCB7IEZhaWxSZXF1ZXN0IH0gZnJvbSAnLi9mYWlscmVxdWVzdCc7XG5pbXBvcnQgeyBMb2NhdGlvbiB9IGZyb20gJy4vbG9jYXRpb24nO1xuaW1wb3J0ICogYXMgcHJvbWlzZWltcGwgZnJvbSAnLi9wcm9taXNlX2V4dGVybmFsJztcbmltcG9ydCB7IFJlcXVlc3RNYXAgfSBmcm9tICcuL3JlcXVlc3RtYXAnO1xuaW1wb3J0ICogYXMgdHlwZSBmcm9tICcuL3R5cGUnO1xuLyoqXG4gKiBAcGFyYW0gYXBwIElmIG51bGwsIGdldEF1dGhUb2tlbiBhbHdheXMgcmVzb2x2ZXMgd2l0aCBudWxsLlxuICogQHBhcmFtIHNlcnZpY2UgVGhlIHN0b3JhZ2Ugc2VydmljZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBhdXRoIHdyYXBwZXIuXG4gKiAgICAgVW50eXBlZCB0byBhdm9pZCBjaXJjdWxhciB0eXBlIGRlcGVuZGVuY2llcy5cbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIEF1dGhXcmFwcGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGhXcmFwcGVyKGFwcCwgbWFrZXIsIHJlcXVlc3RNYWtlciwgc2VydmljZSwgcG9vbCkge1xuICAgICAgICB0aGlzLmJ1Y2tldF8gPSBudWxsO1xuICAgICAgICB0aGlzLmRlbGV0ZWRfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXBwXyA9IGFwcDtcbiAgICAgICAgaWYgKHRoaXMuYXBwXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmFwcF8ub3B0aW9ucztcbiAgICAgICAgICAgIGlmICh0eXBlLmlzRGVmKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWNrZXRfID0gQXV0aFdyYXBwZXIuZXh0cmFjdEJ1Y2tldF8ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlUmVmTWFrZXJfID0gbWFrZXI7XG4gICAgICAgIHRoaXMucmVxdWVzdE1ha2VyXyA9IHJlcXVlc3RNYWtlcjtcbiAgICAgICAgdGhpcy5wb29sXyA9IHBvb2w7XG4gICAgICAgIHRoaXMuc2VydmljZV8gPSBzZXJ2aWNlO1xuICAgICAgICB0aGlzLm1heE9wZXJhdGlvblJldHJ5VGltZV8gPSBjb25zdGFudHMuZGVmYXVsdE1heE9wZXJhdGlvblJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5tYXhVcGxvYWRSZXRyeVRpbWVfID0gY29uc3RhbnRzLmRlZmF1bHRNYXhVcGxvYWRSZXRyeVRpbWU7XG4gICAgICAgIHRoaXMucmVxdWVzdE1hcF8gPSBuZXcgUmVxdWVzdE1hcCgpO1xuICAgIH1cbiAgICBBdXRoV3JhcHBlci5leHRyYWN0QnVja2V0XyA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgdmFyIGJ1Y2tldFN0cmluZyA9IGNvbmZpZ1tjb25zdGFudHMuY29uZmlnT3B0aW9uXSB8fCBudWxsO1xuICAgICAgICBpZiAoYnVja2V0U3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2MgPSBMb2NhdGlvbi5tYWtlRnJvbUJ1Y2tldFNwZWMoYnVja2V0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIGxvYy5idWNrZXQ7XG4gICAgfTtcbiAgICBBdXRoV3JhcHBlci5wcm90b3R5cGUuZ2V0QXV0aFRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPKGFuZHlzb3RvKTogcmVtb3ZlIGlmRGVmIGNoZWNrcyBhZnRlciBmaXJlYmFzZS1hcHAgaW1wbGVtZW50cyBzdHVic1xuICAgICAgICAvLyAoYi8yODY3MzgxOCkuXG4gICAgICAgIGlmICh0aGlzLmFwcF8gIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGUuaXNEZWYodGhpcy5hcHBfLklOVEVSTkFMKSAmJlxuICAgICAgICAgICAgdHlwZS5pc0RlZih0aGlzLmFwcF8uSU5URVJOQUwuZ2V0VG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBfLklOVEVSTkFMLmdldFRva2VuKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFjY2Vzc1Rva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKF9lcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZWltcGwucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLmJ1Y2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZXRlZF8pIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yc0V4cG9ydHMuYXBwRGVsZXRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0XztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYXV0aCB3cmFwcGVyLiBVbnR5cGVkIHRvIGF2b2lkIGNpcmN1bGFyXG4gICAgICogdHlwZSBkZXBlbmRlbmNpZXMuXG4gICAgICovXG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLnNlcnZpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2VfO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlIG9iamVjdCByZWZlcmVuY2luZyB0aGlzIEF1dGhXcmFwcGVyXG4gICAgICogYXQgdGhlIGdpdmVuIExvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBsb2MgVGhlIExvY2F0aW9uLlxuICAgICAqIEByZXR1cm4gQWN0dWFsbHkgYSBmaXJlYmFzZVN0b3JhZ2UuUmVmZXJlbmNlLCB0eXBpbmcgbm90IGFsbG93ZWRcbiAgICAgKiAgICAgYmVjYXVzZSBvZiBjaXJjdWxhciBkZXBlbmRlbmN5IHByb2JsZW1zLlxuICAgICAqL1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5tYWtlU3RvcmFnZVJlZmVyZW5jZSA9IGZ1bmN0aW9uIChsb2MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVJlZk1ha2VyXyh0aGlzLCBsb2MpO1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24gKHJlcXVlc3RJbmZvLCBhdXRoVG9rZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZWRfKSB7XG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdE1ha2VyXyhyZXF1ZXN0SW5mbywgYXV0aFRva2VuLCB0aGlzLnBvb2xfKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hcF8uYWRkUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGYWlsUmVxdWVzdChlcnJvcnNFeHBvcnRzLmFwcERlbGV0ZWQoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgcnVubmluZyByZXF1ZXN0cyBhbmQgcHJldmVudCBtb3JlIGZyb20gYmVpbmcgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBBdXRoV3JhcHBlci5wcm90b3R5cGUuZGVsZXRlQXBwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlbGV0ZWRfID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hcHBfID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0TWFwXy5jbGVhcigpO1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLm1heFVwbG9hZFJldHJ5VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4VXBsb2FkUmV0cnlUaW1lXztcbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5zZXRNYXhVcGxvYWRSZXRyeVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLm1heFVwbG9hZFJldHJ5VGltZV8gPSB0aW1lO1xuICAgIH07XG4gICAgQXV0aFdyYXBwZXIucHJvdG90eXBlLm1heE9wZXJhdGlvblJldHJ5VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4T3BlcmF0aW9uUmV0cnlUaW1lXztcbiAgICB9O1xuICAgIEF1dGhXcmFwcGVyLnByb3RvdHlwZS5zZXRNYXhPcGVyYXRpb25SZXRyeVRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICB0aGlzLm1heE9wZXJhdGlvblJldHJ5VGltZV8gPSB0aW1lO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGhXcmFwcGVyO1xufSgpKTtcbmV4cG9ydCB7IEF1dGhXcmFwcGVyIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGh3cmFwcGVyLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2F1dGh3cmFwcGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCJpbXBvcnQgKiBhcyBwcm9taXNlaW1wbCBmcm9tICcuL3Byb21pc2VfZXh0ZXJuYWwnO1xuLyoqXG4gKiBBIHJlcXVlc3Qgd2hvc2UgcHJvbWlzZSBhbHdheXMgZmFpbHMuXG4gKiBAc3RydWN0XG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgRmFpbFJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmFpbFJlcXVlc3QoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IHByb21pc2VpbXBsLnJlamVjdChlcnJvcik7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIEZhaWxSZXF1ZXN0LnByb3RvdHlwZS5nZXRQcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlXztcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICAgIEZhaWxSZXF1ZXN0LnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoYXBwRGVsZXRlKSB7XG4gICAgICAgIGlmIChhcHBEZWxldGUgPT09IHZvaWQgMCkgeyBhcHBEZWxldGUgPSBmYWxzZTsgfVxuICAgIH07XG4gICAgcmV0dXJuIEZhaWxSZXF1ZXN0O1xufSgpKTtcbmV4cG9ydCB7IEZhaWxSZXF1ZXN0IH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhaWxyZXF1ZXN0LmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2ZhaWxyZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCAqIGFzIGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG4vKipcbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFJlcXVlc3RNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdE1hcCgpIHtcbiAgICAgICAgdGhpcy5tYXBfID0ge307XG4gICAgICAgIHRoaXMuaWRfID0gY29uc3RhbnRzLm1pblNhZmVJbnRlZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGdpdmVuIHJlcXVlc3Qgd2l0aCB0aGlzIG1hcC5cbiAgICAgKiBUaGUgcmVxdWVzdCBpcyB1bnJlZ2lzdGVyZWQgd2hlbiBpdCBjb21wbGV0ZXMuXG4gICAgICogQHBhcmFtIHIgVGhlIHJlcXVlc3QgdG8gcmVnaXN0ZXIuXG4gICAgICovXG4gICAgUmVxdWVzdE1hcC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uIChyKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWRfO1xuICAgICAgICB0aGlzLmlkXysrO1xuICAgICAgICB0aGlzLm1hcF9baWRdID0gcjtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBmdW5jdGlvbiB1bm1hcCgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLm1hcF9baWRdO1xuICAgICAgICB9XG4gICAgICAgIHIuZ2V0UHJvbWlzZSgpLnRoZW4odW5tYXAsIHVubWFwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYWxsIHJlZ2lzdGVyZWQgcmVxdWVzdHMuXG4gICAgICovXG4gICAgUmVxdWVzdE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iamVjdC5mb3JFYWNoKHRoaXMubWFwXywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdmFsLmNhbmNlbCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFwXyA9IHt9O1xuICAgIH07XG4gICAgcmV0dXJuIFJlcXVlc3RNYXA7XG59KCkpO1xuZXhwb3J0IHsgUmVxdWVzdE1hcCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0bWFwLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL3JlcXVlc3RtYXAuanNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5lcyBtZXRob2RzIHVzZWQgdG8gYWN0dWFsbHkgc2VuZCBIVFRQIHJlcXVlc3RzIGZyb21cbiAqIGFic3RyYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAqL1xuaW1wb3J0IGZpcmViYXNlIGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheSc7XG5pbXBvcnQgKiBhcyBiYWNrb2ZmIGZyb20gJy4vYmFja29mZic7XG5pbXBvcnQgKiBhcyBlcnJvcnNFeHBvcnRzIGZyb20gJy4vZXJyb3InO1xuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJy4vb2JqZWN0JztcbmltcG9ydCAqIGFzIHByb21pc2VpbXBsIGZyb20gJy4vcHJvbWlzZV9leHRlcm5hbCc7XG5pbXBvcnQgKiBhcyB0eXBlIGZyb20gJy4vdHlwZSc7XG5pbXBvcnQgKiBhcyBVcmxVdGlscyBmcm9tICcuL3VybCc7XG5pbXBvcnQgKiBhcyBYaHJJb0V4cG9ydHMgZnJvbSAnLi94aHJpbyc7XG4vKipcbiAqIEBzdHJ1Y3RcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBOZXR3b3JrUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZXR3b3JrUmVxdWVzdCh1cmwsIG1ldGhvZCwgaGVhZGVycywgYm9keSwgc3VjY2Vzc0NvZGVzLCBhZGRpdGlvbmFsUmV0cnlDb2RlcywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2ssIHRpbWVvdXQsIHByb2dyZXNzQ2FsbGJhY2ssIHBvb2wpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nWGhyXyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmFja29mZklkXyA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x2ZV8gPSBudWxsO1xuICAgICAgICB0aGlzLnJlamVjdF8gPSBudWxsO1xuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFwcERlbGV0ZV8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cmxfID0gdXJsO1xuICAgICAgICB0aGlzLm1ldGhvZF8gPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuaGVhZGVyc18gPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmJvZHlfID0gYm9keTtcbiAgICAgICAgdGhpcy5zdWNjZXNzQ29kZXNfID0gc3VjY2Vzc0NvZGVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfID0gYWRkaXRpb25hbFJldHJ5Q29kZXMuc2xpY2UoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5lcnJvckNhbGxiYWNrXyA9IGVycm9yQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDYWxsYmFja18gPSBwcm9ncmVzc0NhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVvdXRfID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5wb29sXyA9IHBvb2w7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm9taXNlXyA9IHByb21pc2VpbXBsLm1ha2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgc2VsZi5yZXNvbHZlXyA9IHJlc29sdmU7XG4gICAgICAgICAgICBzZWxmLnJlamVjdF8gPSByZWplY3Q7XG4gICAgICAgICAgICBzZWxmLnN0YXJ0XygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgc3RhcnRzIHRoZSByZXRyeSBsb29wLlxuICAgICAqL1xuICAgIE5ldHdvcmtSZXF1ZXN0LnByb3RvdHlwZS5zdGFydF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gZG9UaGVSZXF1ZXN0KGJhY2tvZmZDYWxsYmFjaywgY2FuY2VsZWQpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgIGJhY2tvZmZDYWxsYmFjayhmYWxzZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoZmFsc2UsIG51bGwsIHRydWUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeGhyID0gc2VsZi5wb29sXy5jcmVhdGVYaHJJbygpO1xuICAgICAgICAgICAgc2VsZi5wZW5kaW5nWGhyXyA9IHhocjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByb2dyZXNzTGlzdGVuZXIocHJvZ3Jlc3NFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2FkZWQgPSBwcm9ncmVzc0V2ZW50LmxvYWRlZDtcbiAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSBwcm9ncmVzc0V2ZW50Lmxlbmd0aENvbXB1dGFibGUgPyBwcm9ncmVzc0V2ZW50LnRvdGFsIDogLTE7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYucHJvZ3Jlc3NDYWxsYmFja18gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wcm9ncmVzc0NhbGxiYWNrXyhsb2FkZWQsIHRvdGFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5wcm9ncmVzc0NhbGxiYWNrXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHhoci5hZGRVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyXG4gICAgICAgICAgICAgICAgLnNlbmQoc2VsZi51cmxfLCBzZWxmLm1ldGhvZF8sIHNlbGYuYm9keV8sIHNlbGYuaGVhZGVyc18pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHhocikge1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnByb2dyZXNzQ2FsbGJhY2tfICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5yZW1vdmVVcGxvYWRQcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnBlbmRpbmdYaHJfID0gbnVsbDtcbiAgICAgICAgICAgICAgICB4aHIgPSB4aHI7XG4gICAgICAgICAgICAgICAgdmFyIGhpdFNlcnZlciA9IHhoci5nZXRFcnJvckNvZGUoKSA9PT0gWGhySW9FeHBvcnRzLkVycm9yQ29kZS5OT19FUlJPUjtcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0geGhyLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgICAgIGlmICghaGl0U2VydmVyIHx8IHNlbGYuaXNSZXRyeVN0YXR1c0NvZGVfKHN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhc0NhbmNlbGVkID0geGhyLmdldEVycm9yQ29kZSgpID09PSBYaHJJb0V4cG9ydHMuRXJyb3JDb2RlLkFCT1JUO1xuICAgICAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2soZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB3YXNDYW5jZWxlZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzdWNjZXNzQ29kZSA9IGFycmF5LmNvbnRhaW5zKHNlbGYuc3VjY2Vzc0NvZGVzXywgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBiYWNrb2ZmQ2FsbGJhY2sodHJ1ZSwgbmV3IFJlcXVlc3RFbmRTdGF0dXMoc3VjY2Vzc0NvZGUsIHhocikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0V2VudFRocm91Z2ggVHJ1ZSBpZiB0aGUgcmVxdWVzdCBldmVudHVhbGx5IHdlbnRcbiAgICAgICAgICogICAgIHRocm91Z2gsIGZhbHNlIGlmIGl0IGhpdCB0aGUgcmV0cnkgbGltaXQgb3Igd2FzIGNhbmNlbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmFja29mZkRvbmUocmVxdWVzdFdlbnRUaHJvdWdoLCBzdGF0dXMpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gc2VsZi5yZXNvbHZlXztcbiAgICAgICAgICAgIHZhciByZWplY3QgPSBzZWxmLnJlamVjdF87XG4gICAgICAgICAgICB2YXIgeGhyID0gc3RhdHVzLnhocjtcbiAgICAgICAgICAgIGlmIChzdGF0dXMud2FzU3VjY2Vzc0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5jYWxsYmFja18oeGhyLCB4aHIuZ2V0UmVzcG9uc2VUZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZS5pc0p1c3REZWYocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvcnNFeHBvcnRzLnVua25vd24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnNldFNlcnZlclJlc3BvbnNlUHJvcCh4aHIuZ2V0UmVzcG9uc2VUZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5lcnJvckNhbGxiYWNrXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHNlbGYuZXJyb3JDYWxsYmFja18oeGhyLCBlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gc2VsZi5hcHBEZWxldGVfXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvcnNFeHBvcnRzLmFwcERlbGV0ZWQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZXJyb3JzRXhwb3J0cy5jYW5jZWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JzRXhwb3J0cy5yZXRyeUxpbWl0RXhjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbGVkXykge1xuICAgICAgICAgICAgYmFja29mZkRvbmUoZmFsc2UsIG5ldyBSZXF1ZXN0RW5kU3RhdHVzKGZhbHNlLCBudWxsLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZJZF8gPSBiYWNrb2ZmLnN0YXJ0KGRvVGhlUmVxdWVzdCwgYmFja29mZkRvbmUsIHRoaXMudGltZW91dF8pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBOZXR3b3JrUmVxdWVzdC5wcm90b3R5cGUuZ2V0UHJvbWlzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZV87XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgICBOZXR3b3JrUmVxdWVzdC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGFwcERlbGV0ZSkge1xuICAgICAgICB0aGlzLmNhbmNlbGVkXyA9IHRydWU7XG4gICAgICAgIHRoaXMuYXBwRGVsZXRlXyA9IGFwcERlbGV0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZklkXyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFja29mZi5zdG9wKHRoaXMuYmFja29mZklkXyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1hocl8gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1hocl8uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTmV0d29ya1JlcXVlc3QucHJvdG90eXBlLmlzUmV0cnlTdGF0dXNDb2RlXyA9IGZ1bmN0aW9uIChzdGF0dXMpIHtcbiAgICAgICAgLy8gVGhlIGNvZGVzIGZvciB3aGljaCB0byByZXRyeSBjYW1lIGZyb20gdGhpcyBwYWdlOlxuICAgICAgICAvLyBodHRwczovL2Nsb3VkLmdvb2dsZS5jb20vc3RvcmFnZS9kb2NzL2V4cG9uZW50aWFsLWJhY2tvZmZcbiAgICAgICAgdmFyIGlzRml2ZUh1bmRyZWRDb2RlID0gc3RhdHVzID49IDUwMCAmJiBzdGF0dXMgPCA2MDA7XG4gICAgICAgIHZhciBleHRyYVJldHJ5Q29kZXMgPSBbXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IFRpbWVvdXQ6IHdlYiBzZXJ2ZXIgZGlkbid0IHJlY2VpdmUgZnVsbCByZXF1ZXN0IGluIHRpbWUuXG4gICAgICAgICAgICA0MDgsXG4gICAgICAgICAgICAvLyBUb28gTWFueSBSZXF1ZXN0czogeW91J3JlIGdldHRpbmcgcmF0ZS1saW1pdGVkLCBiYXNpY2FsbHkuXG4gICAgICAgICAgICA0MjlcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGlzRXh0cmFSZXRyeUNvZGUgPSBhcnJheS5jb250YWlucyhleHRyYVJldHJ5Q29kZXMsIHN0YXR1cyk7XG4gICAgICAgIHZhciBpc1JlcXVlc3RTcGVjaWZpY1JldHJ5Q29kZSA9IGFycmF5LmNvbnRhaW5zKHRoaXMuYWRkaXRpb25hbFJldHJ5Q29kZXNfLCBzdGF0dXMpO1xuICAgICAgICByZXR1cm4gaXNGaXZlSHVuZHJlZENvZGUgfHwgaXNFeHRyYVJldHJ5Q29kZSB8fCBpc1JlcXVlc3RTcGVjaWZpY1JldHJ5Q29kZTtcbiAgICB9O1xuICAgIHJldHVybiBOZXR3b3JrUmVxdWVzdDtcbn0oKSk7XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVzdWx0IG9mIGEgbmV0d29yayByZXF1ZXN0LlxuICogQHBhcmFtIG9wdF9jYW5jZWxlZCBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEBzdHJ1Y3RcbiAqL1xudmFyIFJlcXVlc3RFbmRTdGF0dXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdEVuZFN0YXR1cyh3YXNTdWNjZXNzQ29kZSwgeGhyLCBvcHRfY2FuY2VsZWQpIHtcbiAgICAgICAgdGhpcy53YXNTdWNjZXNzQ29kZSA9IHdhc1N1Y2Nlc3NDb2RlO1xuICAgICAgICB0aGlzLnhociA9IHhocjtcbiAgICAgICAgdGhpcy5jYW5jZWxlZCA9ICEhb3B0X2NhbmNlbGVkO1xuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdEVuZFN0YXR1cztcbn0oKSk7XG5leHBvcnQgeyBSZXF1ZXN0RW5kU3RhdHVzIH07XG5leHBvcnQgZnVuY3Rpb24gYWRkQXV0aEhlYWRlcl8oaGVhZGVycywgYXV0aFRva2VuKSB7XG4gICAgaWYgKGF1dGhUb2tlbiAhPT0gbnVsbCAmJiBhdXRoVG9rZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSAnRmlyZWJhc2UgJyArIGF1dGhUb2tlbjtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycykge1xuICAgIHZhciBudW1iZXIgPSB0eXBlb2YgZmlyZWJhc2UgIT09ICd1bmRlZmluZWQnID8gZmlyZWJhc2UuU0RLX1ZFUlNJT04gOiAnQXBwTWFuYWdlcic7XG4gICAgaGVhZGVyc1snWC1GaXJlYmFzZS1TdG9yYWdlLVZlcnNpb24nXSA9ICd3ZWJqcy8nICsgbnVtYmVyO1xufVxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZVJlcXVlc3QocmVxdWVzdEluZm8sIGF1dGhUb2tlbiwgcG9vbCkge1xuICAgIHZhciBxdWVyeVBhcnQgPSBVcmxVdGlscy5tYWtlUXVlcnlTdHJpbmcocmVxdWVzdEluZm8udXJsUGFyYW1zKTtcbiAgICB2YXIgdXJsID0gcmVxdWVzdEluZm8udXJsICsgcXVlcnlQYXJ0O1xuICAgIHZhciBoZWFkZXJzID0gb2JqZWN0LmNsb25lKHJlcXVlc3RJbmZvLmhlYWRlcnMpO1xuICAgIGFkZEF1dGhIZWFkZXJfKGhlYWRlcnMsIGF1dGhUb2tlbik7XG4gICAgYWRkVmVyc2lvbkhlYWRlcl8oaGVhZGVycyk7XG4gICAgcmV0dXJuIG5ldyBOZXR3b3JrUmVxdWVzdCh1cmwsIHJlcXVlc3RJbmZvLm1ldGhvZCwgaGVhZGVycywgcmVxdWVzdEluZm8uYm9keSwgcmVxdWVzdEluZm8uc3VjY2Vzc0NvZGVzLCByZXF1ZXN0SW5mby5hZGRpdGlvbmFsUmV0cnlDb2RlcywgcmVxdWVzdEluZm8uaGFuZGxlciwgcmVxdWVzdEluZm8uZXJyb3JIYW5kbGVyLCByZXF1ZXN0SW5mby50aW1lb3V0LCByZXF1ZXN0SW5mby5wcm9ncmVzc0NhbGxiYWNrLCBwb29sKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVxdWVzdC5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0BmaXJlYmFzZS9zdG9yYWdlL2Rpc3QvZXNtL3NyYy9pbXBsZW1lbnRhdGlvbi9yZXF1ZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAcGFyYW0gZiBNYXkgYmUgaW52b2tlZFxuICogICAgIGJlZm9yZSB0aGUgZnVuY3Rpb24gcmV0dXJucy5cbiAqIEBwYXJhbSBjYWxsYmFjayBHZXQgYWxsIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuICogICAgIHBhc3NlZCB0byBmLCBpbmNsdWRpbmcgdGhlIGluaXRpYWwgYm9vbGVhbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0KGYsIGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgLy8gVE9ETyhhbmR5c290byk6IG1ha2UgdGhpcyBjb2RlIGNsZWFuZXIgKHByb2JhYmx5IHJlZmFjdG9yIGludG8gYW4gYWN0dWFsXG4gICAgLy8gdHlwZSBpbnN0ZWFkIG9mIGEgYnVuY2ggb2YgZnVuY3Rpb25zIHdpdGggc3RhdGUgc2hhcmVkIGluIHRoZSBjbG9zdXJlKVxuICAgIHZhciB3YWl0U2Vjb25kcyA9IDE7XG4gICAgLy8gV291bGQgdHlwZSB0aGlzIGFzIFwibnVtYmVyXCIgYnV0IHRoYXQgZG9lc24ndCB3b3JrIGZvciBOb2RlIHNvIMKvXFxfKOODhClfL8KvXG4gICAgdmFyIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgdmFyIGhpdFRpbWVvdXQgPSBmYWxzZTtcbiAgICB2YXIgY2FuY2VsU3RhdGUgPSAwO1xuICAgIGZ1bmN0aW9uIGNhbmNlbGVkKCkge1xuICAgICAgICByZXR1cm4gY2FuY2VsU3RhdGUgPT09IDI7XG4gICAgfVxuICAgIHZhciB0cmlnZ2VyZWRDYWxsYmFjayA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjaygpIHtcbiAgICAgICAgaWYgKCF0cmlnZ2VyZWRDYWxsYmFjaykge1xuICAgICAgICAgICAgdHJpZ2dlcmVkQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjYWxsV2l0aERlbGF5KG1pbGxpcykge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICBmKGhhbmRsZXIsIGNhbmNlbGVkKCkpO1xuICAgICAgICB9LCBtaWxsaXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVyKHN1Y2Nlc3MpIHtcbiAgICAgICAgdmFyIHZhcl9hcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXJfYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgdHJpZ2dlckNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG11c3RTdG9wID0gY2FuY2VsZWQoKSB8fCBoaXRUaW1lb3V0O1xuICAgICAgICBpZiAobXVzdFN0b3ApIHtcbiAgICAgICAgICAgIHRyaWdnZXJDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YWl0U2Vjb25kcyA8IDY0KSB7XG4gICAgICAgICAgICAvKiBUT0RPKGFuZHlzb3RvKTogZG9uJ3QgYmFjayBvZmYgc28gcXVpY2tseSBpZiB3ZSBrbm93IHdlJ3JlIG9mZmxpbmUuICovXG4gICAgICAgICAgICB3YWl0U2Vjb25kcyAqPSAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YWl0TWlsbGlzO1xuICAgICAgICBpZiAoY2FuY2VsU3RhdGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNhbmNlbFN0YXRlID0gMjtcbiAgICAgICAgICAgIHdhaXRNaWxsaXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FpdE1pbGxpcyA9ICh3YWl0U2Vjb25kcyArIE1hdGgucmFuZG9tKCkpICogMTAwMDtcbiAgICAgICAgfVxuICAgICAgICBjYWxsV2l0aERlbGF5KHdhaXRNaWxsaXMpO1xuICAgIH1cbiAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIHN0b3Aod2FzVGltZW91dCkge1xuICAgICAgICBpZiAoc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHJpZ2dlcmVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdhc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIGNhbGxXaXRoRGVsYXkoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXdhc1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjYW5jZWxTdGF0ZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbFdpdGhEZWxheSgwKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGl0VGltZW91dCA9IHRydWU7XG4gICAgICAgIHN0b3AodHJ1ZSk7XG4gICAgfSwgdGltZW91dCk7XG4gICAgcmV0dXJuIHN0b3A7XG59XG4vKipcbiAqIFN0b3BzIHRoZSByZXRyeSBsb29wIGZyb20gcmVwZWF0aW5nLlxuICogSWYgdGhlIGZ1bmN0aW9uIGlzIGN1cnJlbnRseSBcImluIGJldHdlZW5cIiByZXRyaWVzLCBpdCBpcyBpbnZva2VkIGltbWVkaWF0ZWx5XG4gKiB3aXRoIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGFzIFwidHJ1ZVwiLiBPdGhlcndpc2UsIGl0IHdpbGwgYmUgaW52b2tlZCBvbmNlIG1vcmVcbiAqIGFmdGVyIHRoZSBjdXJyZW50IGludm9jYXRpb24gZmluaXNoZXMgaWZmIHRoZSBjdXJyZW50IGludm9jYXRpb24gd291bGQgaGF2ZVxuICogdHJpZ2dlcmVkIGFub3RoZXIgcmV0cnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdG9wKGlkKSB7XG4gICAgaWQoZmFsc2UpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrb2ZmLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL3N0b3JhZ2UvZGlzdC9lc20vc3JjL2ltcGxlbWVudGF0aW9uL2JhY2tvZmYuanNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSIsImltcG9ydCAnLi9jb21wb25lbnRzL3N5bmFwc2UtY29yZS9zeW5hcHNlLWNvcmUuanMnO1xuaW1wb3J0ICcuL2NvbXBvbmVudHMvc3luYXBzZS11aS9zeW5hcHNlLXVpLmpzJztcbmltcG9ydCAnLi9jb21wb25lbnRzL3N5bmFwc2Utc3luYy9zeW5hcHNlLXN5bmMuanMnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2luZGV4LmpzIiwiaW1wb3J0ICdDb21wb25lbnRzL3N5bmFwc2UtY29yZS9zeW5hcHNlLWNvcmUuc2Nzcyc7XG5pbXBvcnQgZDMgZnJvbSAnZDMnO1xuaW1wb3J0ICogYXMgZmlyZWJhc2UgZnJvbSAnZmlyZWJhc2UvYXBwJztcbmltcG9ydCAnZmlyZWJhc2UvYXV0aCc7XG5pbXBvcnQgJ2ZpcmViYXNlL2RhdGFiYXNlJztcbmltcG9ydCAnQ29tcG9uZW50cy9maXJlYmFzZS1jb25maWcnO1xuXG4vLyBHbG9iYWwgZGF0YSB2YXJzXG5cbnZhciBub2RlcyxcbiAgICBsYXN0Tm9kZUlkLFxuICAgIGxpbmtzO1xuXG52YXIgbm9kZXNNYXAgPSB7fTtcblxuLy8gRklSRUJBU0UgU1lOQ1xuXG4vLyA8LS0gd3JpdGUgZGF0YVxudmFyIHN5blVJU3luYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zeW4tdWktc3luYycpO1xudmFyIHVzZXJJZDtcblxuZmlyZWJhc2UuYXV0aCgpLm9uQXV0aFN0YXRlQ2hhbmdlZChmdW5jdGlvbih1c2VyKSB7XG4gICAgaWYgKHVzZXIpIHtcbiAgICAgICAgdXNlcklkID0gZmlyZWJhc2UuYXV0aCgpLmN1cnJlbnRVc2VyLnVpZDtcbiAgICB9XG4gICAgZWxzZSB7fVxufSk7XG5cbnN5blVJU3luYy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgIGZpcmViYXNlLmRhdGFiYXNlKCkucmVmKCkuY2hpbGQodXNlcklkKS5zZXQoe1xuICAgICAgICBub2RlcyxcbiAgICAgICAgbGFzdE5vZGVJZCxcbiAgICAgICAgbGlua3NcbiAgICB9KTtcbn0pXG4vLyAtLT5cblxuLy8gPC0tIHJlYWQgZGF0YVxuXG52YXIgZGJSZWYgPSBmaXJlYmFzZS5kYXRhYmFzZSgpLnJlZigpO1xuXG4vLyBnZXQgbm9kZXMgYW5kIGxpbmtzIGZyb20gZGIgYW5kIGluaXQgZm9yY2UgbGF5b3V0XG5kYlJlZi5vbmNlKCd2YWx1ZScpLnRoZW4oZnVuY3Rpb24oc25hcHNob3QpIHtcblxuICAgIC8vIGdldCBub2Rlc1xuICAgIG5vZGVzID0gc25hcHNob3QuY2hpbGQodXNlcklkICsgXCIvbm9kZXNcIikudmFsKCk7XG4gICAgbGFzdE5vZGVJZCA9IHNuYXBzaG90LmNoaWxkKHVzZXJJZCArIFwiL2xhc3ROb2RlSWRcIikudmFsKCk7XG4gICAgbGlua3MgPSBzbmFwc2hvdC5jaGlsZCh1c2VySWQgKyBcIi9saW5rc1wiKS52YWwoKTtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBub2RlcyAoZmlyc3QgdGltZSBsb2dpbikg4oCTIGluaXQgc3RhcnRlciBkYXRhXG4gICAgaWYgKG5vZGVzID09PSBudWxsKSB7XG4gICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAge2lkOiAwLCByZWZsZXhpdmU6IGZhbHNlfSxcbiAgICAgICAgICAgIHtpZDogMSwgcmVmbGV4aXZlOiBmYWxzZX0sXG4gICAgICAgICAgICB7aWQ6IDIsIHJlZmxleGl2ZTogZmFsc2V9XG4gICAgICAgIF07XG5cbiAgICAgICAgbGFzdE5vZGVJZCA9IDI7XG5cbiAgICAgICAgbGlua3MgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBub2Rlc1swXSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IG5vZGVzWzFdLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogbm9kZXNbMV0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBub2Rlc1syXSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByaWdodDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF07XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgLy8gSXZvJ3MgZml4IGZvciBtYXBwaW5nIHRoZSByaWdodCBub2RlcyB0byBsaW5rc1xuICAgIGZvciAodmFyIG4gaW4gbm9kZXMpIHtcbiAgICAgICAgbm9kZXNNYXBbbm9kZXNbbl0uaWRdID0gbm9kZXNbbl07XG4gICAgfVxuXG4gICAgdmFyIHRlbXBMaW5rcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgbCBpbiBsaW5rcykge1xuICAgICAgICB0ZW1wTGlua3MucHVzaCh7XG4gICAgICAgICAgICBzb3VyY2U6IG5vZGVzTWFwW2xpbmtzW2xdLnNvdXJjZS5pZF0sXG4gICAgICAgICAgICB0YXJnZXQ6IG5vZGVzTWFwW2xpbmtzW2xdLnRhcmdldC5pZF1cbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBsb29wZWQgdGVtcExpbmtzIG92ZXJyaWRlIGxlZnQgJiByaWdodCBrZXktdmFsdWVzLCB0aHVzIGFycm93cyBhcmUgbG9zdFxuICAgIGxpbmtzID0gdGVtcExpbmtzO1xuXG4gICAgLy8gbGlua3MgYXBwZWFycyB0byBiZSBhbiBvYmplY3QsIGRlc3BpdGUgaXQgYmVpbmcgYW4gYXJyYXlcbiAgICBjb25zb2xlLmxvZyh0eXBlb2YobGlua3MpKTtcbiAgICB9XG5cbiAgICAvLyBpbml0IGZvcmNlIGxheW91dFxuICAgIGZvcmNlSW5pdCgpO1xuXG4vLyAtLT5cblxufSk7XG5cbi8vIGQzIGZvcmNlIGxheW91dCBjb3JlIChhcHAgY29yZSlcbmZ1bmN0aW9uIGZvcmNlSW5pdCgpIHtcblxuICAgIC8vIHNldCB1cCB0aGUgU1ZHXG4gICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICA7XG5cbiAgICB2YXIgem9vbSA9IGQzLmJlaGF2aW9yLnpvb20oKVxuICAgICAgICAuc2NhbGVFeHRlbnQoWzAuMjUsIDFdKVxuICAgICAgICAub24oXCJ6b29tXCIsIHpvb21lZClcbiAgICAgICAgO1xuXG4gICAgdmFyIGJvZHkgPSBkMy5zZWxlY3QoJ2JvZHknKVxuICAgICAgICAuY2FsbCh6b29tKVxuICAgICAgICA7XG5cbiAgICB2YXIgZnVsbE5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZnVsbC1ub2RlJyk7XG5cbiAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KCdib2R5JylcbiAgICAgIC5hcHBlbmQoJ3N2ZzpzdmcnKVxuICAgICAgLmF0dHIoJ29uY29udGV4dG1lbnUnLCAncmV0dXJuIGZhbHNlOycpXG4gICAgICAuYXR0cignd2lkdGgnLCB3aWR0aClcbiAgICAgIC5hdHRyKCdoZWlnaHQnLCBoZWlnaHQpXG4gICAgICAuY2xhc3NlZCgnY2FudmFzJywgdHJ1ZSlcbiAgICAgIDtcblxuICAgIHZhciBjb250YWluZXIgPSBkMy5zZWxlY3QoJ3N2ZycpXG4gICAgICAuYXBwZW5kKFwic3ZnOmdcIilcbiAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxuICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodClcbiAgICAgIC5jbGFzc2VkKCdjb250YWluZXInLCB0cnVlKVxuICAgICAgO1xuXG4gICAgdmFyIGN1cnJlbnRTeW5Db2xvciA9ICcjNEE5MEUyJztcblxuICAgIHZhciBmaWx0ZXIgPSBzdmcuYXBwZW5kKFwiZGVmc1wiKVxuICAgICAgLmFwcGVuZChcImZpbHRlclwiKVxuICAgICAgLmF0dHIoXCJpZFwiLCBcImJsdXJcIilcbiAgICAgIC5hcHBlbmQoXCJmZUdhdXNzaWFuQmx1clwiKVxuICAgICAgLmF0dHIoXCJzdGREZXZpYXRpb25cIiwgNSlcbiAgICAgIDtcblxuICAgIC8vIHNldCB1cCBpbml0aWFsIG5vZGVzIGFuZCBsaW5rc1xuICAgIC8vICAtIG5vZGVzIGFyZSBrbm93biBieSAnaWQnLCBub3QgYnkgaW5kZXggaW4gYXJyYXkuXG4gICAgLy8gIC0gcmVmbGV4aXZlIGVkZ2VzIGFyZSBpbmRpY2F0ZWQgb24gdGhlIG5vZGUgKGFzIGEgYm9sZCBibGFjayBjaXJjbGUpLlxuICAgIC8vICAtIGxpbmtzIGFyZSBhbHdheXMgc291cmNlIDwgdGFyZ2V0OyBlZGdlIGRpcmVjdGlvbnMgYXJlIHNldCBieSAnbGVmdCcgYW5kICdyaWdodCcuXG5cbiAgICAvLyBpbml0IEQzIGZvcmNlIGxheW91dFxuICAgIHZhciBmb3JjZSA9IGQzLmxheW91dC5mb3JjZSgpXG4gICAgICAgIC5ub2Rlcyhub2RlcylcbiAgICAgICAgLmxpbmtzKGxpbmtzKVxuICAgICAgICAuc2l6ZShbd2lkdGgsIGhlaWdodF0pXG4gICAgICAgIC5saW5rRGlzdGFuY2UoNTUwKVxuICAgICAgICAuY2hhcmdlKC01MDApXG4gICAgICAgIC5vbigndGljaycsIHRpY2spXG4gICAgICAgIC5zdGFydCgpXG4gICAgICAgIDtcbiAgICAgICAgd2luZG93LmZvcmNlID0gZm9yY2U7XG4gICAgICAgIHdpbmRvdy5saW5rcyA9IGxpbmtzO1xuXG4gICAgdmFyIGRyYWcgPSBmb3JjZS5kcmFnKClcbiAgICAgIC5vbihcImRyYWdzdGFydFwiLCBkcmFnc3RhcnQpO1xuXG4gICAgLy8gZGVmaW5lIGFycm93IG1hcmtlcnMgZm9yIGdyYXBoIGxpbmtzXG4gICAgc3ZnLmFwcGVuZCgnc3ZnOmRlZnMnKS5hcHBlbmQoJ3N2ZzptYXJrZXInKVxuICAgICAgICAuYXR0cignaWQnLCAnZW5kLWFycm93JylcbiAgICAgICAgLmF0dHIoJ3ZpZXdCb3gnLCAnMCAtNSAxMCAxMCcpXG4gICAgICAgIC5hdHRyKCdyZWZYJywgNilcbiAgICAgICAgLmF0dHIoJ21hcmtlcldpZHRoJywgNClcbiAgICAgICAgLmF0dHIoJ21hcmtlckhlaWdodCcsIDQpXG4gICAgICAgIC5hdHRyKCdvcmllbnQnLCAnYXV0bycpXG4gICAgICAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdkJywgJ00wLC01TDEwLDBMMCw1JylcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBjdXJyZW50U3luQ29sb3IpXG4gICAgICAgIC5zdHlsZSgnY3Vyc29yJywgJy13ZWJraXQtZ3JhYmJpbmcnKVxuICAgICAgICA7XG5cbiAgICBzdmcuYXBwZW5kKCdzdmc6ZGVmcycpLmFwcGVuZCgnc3ZnOm1hcmtlcicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdzdGFydC1hcnJvdycpXG4gICAgICAgIC5hdHRyKCd2aWV3Qm94JywgJzAgLTUgMTAgMTAnKVxuICAgICAgICAuYXR0cigncmVmWCcsIDQpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJXaWR0aCcsIDQpXG4gICAgICAgIC5hdHRyKCdtYXJrZXJIZWlnaHQnLCA0KVxuICAgICAgICAuYXR0cignb3JpZW50JywgJ2F1dG8nKVxuICAgICAgLmFwcGVuZCgnc3ZnOnBhdGgnKVxuICAgICAgICAuYXR0cignZCcsICdNMTAsLTVMMCwwTDEwLDUnKVxuICAgICAgICAuYXR0cignZmlsbCcsIGN1cnJlbnRTeW5Db2xvcik7XG5cbiAgICAvLyBsaW5lIGRpc3BsYXllZCB3aGVuIGRyYWdnaW5nIG5ldyBub2Rlc1xuICAgIHZhciBkcmFnX2xpbmUgPSBjb250YWluZXIuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAuYXR0cignY2xhc3MnLCAnbGluayBkcmFnbGluZSBoaWRkZW4nKVxuICAgICAgLmF0dHIoJ2QnLCAnTTAsMEwwLDAnKVxuICAgICAgO1xuXG4gICAgLy8gaGFuZGxlcyB0byBsaW5rIGFuZCBub2RlIGVsZW1lbnQgZ3JvdXBzXG4gICAgdmFyIHBhdGggPSBjb250YWluZXIuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgncGF0aCcpLFxuICAgICAgICBjaXJjbGUgPSBjb250YWluZXIuYXBwZW5kKCdzdmc6ZycpLnNlbGVjdEFsbCgnZycpO1xuXG5cbiAgICAvLyBmaXggbW91c2UgY29vcmRpbmF0ZXMgdHJhbnNmb3JtIGlzc3VlXG4gICAgdmFyIHpvb21UcmFuc2xhdGVYID0gMDtcbiAgICB2YXIgem9vbVRyYW5zbGF0ZVkgPSAwO1xuICAgIHZhciB6b29tU2NhbGUgPSAxO1xuXG4gICAgLy8gbW91c2UgZXZlbnQgdmFyc1xuICAgIHZhciBzZWxlY3RlZF9ub2RlID0gbnVsbCxcbiAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGwsXG4gICAgICAgIG1vdXNlZG93bl9saW5rID0gbnVsbCxcbiAgICAgICAgbW91c2Vkb3duX25vZGUgPSBudWxsLFxuICAgICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gcmVzZXRNb3VzZVZhcnMoKSB7XG4gICAgICBtb3VzZWRvd25fbm9kZSA9IG51bGw7XG4gICAgICBtb3VzZXVwX25vZGUgPSBudWxsO1xuICAgICAgbW91c2Vkb3duX2xpbmsgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBmb3JjZSBsYXlvdXQgKGNhbGxlZCBhdXRvbWF0aWNhbGx5IGVhY2ggaXRlcmF0aW9uKVxuICAgIGZ1bmN0aW9uIHRpY2soKSB7XG4gICAgICAvLyBkcmF3IGRpcmVjdGVkIGVkZ2VzIHdpdGggcHJvcGVyIHBhZGRpbmcgZnJvbSBub2RlIGNlbnRlcnNcbiAgICAgIHBhdGguYXR0cignZCcsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGRlbHRhWCA9IGQudGFyZ2V0LnggLSBkLnNvdXJjZS54LFxuICAgICAgICAgICAgZGVsdGFZID0gZC50YXJnZXQueSAtIGQuc291cmNlLnksXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KGRlbHRhWCAqIGRlbHRhWCArIGRlbHRhWSAqIGRlbHRhWSksXG4gICAgICAgICAgICBub3JtWCA9IGRlbHRhWCAvIGRpc3QsXG4gICAgICAgICAgICBub3JtWSA9IGRlbHRhWSAvIGRpc3QsXG4gICAgICAgICAgICBzb3VyY2VQYWRkaW5nID0gZC5sZWZ0ID8gMzIgOiAwLFxuICAgICAgICAgICAgdGFyZ2V0UGFkZGluZyA9IGQucmlnaHQgPyAzMiA6IDAsXG4gICAgICAgICAgICBzb3VyY2VYID0gZC5zb3VyY2UueCArIChzb3VyY2VQYWRkaW5nICogbm9ybVgpLFxuICAgICAgICAgICAgc291cmNlWSA9IGQuc291cmNlLnkgKyAoc291cmNlUGFkZGluZyAqIG5vcm1ZKSxcbiAgICAgICAgICAgIHRhcmdldFggPSBkLnRhcmdldC54IC0gKHRhcmdldFBhZGRpbmcgKiBub3JtWCksXG4gICAgICAgICAgICB0YXJnZXRZID0gZC50YXJnZXQueSAtICh0YXJnZXRQYWRkaW5nICogbm9ybVkpO1xuICAgICAgICByZXR1cm4gJ00nICsgc291cmNlWCArICcsJyArIHNvdXJjZVkgKyAnTCcgKyB0YXJnZXRYICsgJywnICsgdGFyZ2V0WTtcbiAgICAgIH0pO1xuXG4gICAgICBjaXJjbGUuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgZC54ICsgJywnICsgZC55ICsgJyknO1xuICAgICAgfSk7XG5cbiAgICAgIHJlc3RhcnQoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZ3JhcGggKGNhbGxlZCB3aGVuIG5lZWRlZClcbiAgICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuXG4gICAgICAvLyBwYXRoIChsaW5rKSBncm91cFxuICAgICAgcGF0aCA9IHBhdGguZGF0YShsaW5rcyk7XG5cbiAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBsaW5rc1xuICAgICAgcGF0aC5jbGFzc2VkKCdzZWxlY3RlZCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQgPT09IHNlbGVjdGVkX2xpbms7IH0pXG4gICAgICAgIC5zdHlsZSgnbWFya2VyLXN0YXJ0JywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5sZWZ0ID8gJ3VybCgjc3RhcnQtYXJyb3cpJyA6ICcnOyB9KVxuICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnJpZ2h0ID8gJ3VybCgjZW5kLWFycm93KScgOiAnJzsgfSlcbiAgICAgICAgO1xuXG4gICAgICAvLyBhZGQgbmV3IGxpbmtzXG4gICAgICBwYXRoLmVudGVyKCkuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsaW5rJylcbiAgICAgICAgLmNsYXNzZWQoJ3NlbGVjdGVkJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZCA9PT0gc2VsZWN0ZWRfbGluazsgfSlcbiAgICAgICAgLnN0eWxlKCdtYXJrZXItc3RhcnQnLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmxlZnQgPyAndXJsKCNzdGFydC1hcnJvdyknIDogJyc7IH0pXG4gICAgICAgIC5zdHlsZSgnbWFya2VyLWVuZCcsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQucmlnaHQgPyAndXJsKCNlbmQtYXJyb3cpJyA6ICcnOyB9KVxuICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBpZihkMy5ldmVudC5jdHJsS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBzZWxlY3QgbGlua1xuICAgICAgICAgIG1vdXNlZG93bl9saW5rID0gZDtcbiAgICAgICAgICBpZiAobW91c2Vkb3duX2xpbmsgPT09IHNlbGVjdGVkX2xpbmspIHNlbGVjdGVkX2xpbmsgPSBudWxsO1xuICAgICAgICAgIGVsc2Ugc2VsZWN0ZWRfbGluayA9IG1vdXNlZG93bl9saW5rO1xuICAgICAgICAgIHNlbGVjdGVkX25vZGUgPSBudWxsO1xuICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZW1vdmUgb2xkIGxpbmtzXG4gICAgICBwYXRoLmV4aXQoKS5yZW1vdmUoKTtcblxuXG4gICAgICAvLyBjaXJjbGUgKG5vZGUpIGdyb3VwXG4gICAgICAvLyBOQjogdGhlIGZ1bmN0aW9uIGFyZyBpcyBjcnVjaWFsIGhlcmUhIG5vZGVzIGFyZSBrbm93biBieSBpZCwgbm90IGJ5IGluZGV4IVxuICAgICAgY2lyY2xlID0gY2lyY2xlLmRhdGEobm9kZXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuaWQ7IH0pO1xuXG4gICAgICAvLyB1cGRhdGUgZXhpc3Rpbmcgbm9kZXMgKHJlZmxleGl2ZSAmIHNlbGVjdGVkIHZpc3VhbCBzdGF0ZXMpXG4gICAgICBjaXJjbGUuc2VsZWN0QWxsKCdjaXJjbGUnKVxuICAgICAgICAuY2xhc3NlZCgncmVmbGV4aXZlJywgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5yZWZsZXhpdmU7IH0pO1xuXG4gICAgICAvLyBjcmVhdGUgc3luIGdyb3VwXG4gICAgICB2YXIgc3luR3JvdXAgPSBjaXJjbGUuZW50ZXIoKS5hcHBlbmQoJ3N2ZzpnJylcbiAgICAgICAgLmNhbGwoZHJhZylcbiAgICAgICAgLy8gZnV0dXJlIGludGVyYWN0aW9uXG4gICAgICAgIC8vIC5vbignY2xpY2snLCBzeW5FeHBhbmQpXG4gICAgICAgIC5vbignbW91c2Vkb3duJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jbGFzc2VkKCdzeW4nLCB0cnVlKVxuICAgICAgICA7XG5cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3luKCkge1xuXG4gICAgICAgICAgICB2YXIgY2FyZFdpZHRoID0gMTg2LFxuICAgICAgICAgICAgICAgIGNhcmRIZWlnaHQgPSAxMDBcbiAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIHZhciBjYXJkT2Zmc2V0WCA9IC1jYXJkV2lkdGggLTE1LFxuICAgICAgICAgICAgICAgIGNhcmRPZmZzZXRZID0gLWNhcmRIZWlnaHQgLTE1XG4gICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZEV4cGFuZGVyID0gc3luR3JvdXAuYXBwZW5kKCdzdmc6cmVjdCcpXG4gICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxOTApXG4gICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDI5MClcbiAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtMjcwKVxuICAgICAgICAgICAgICAuYXR0cigneScsIC0xNjApXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3JnYmEoMCwwLDAsMCknKVxuICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIHZhciBzaGFkb3dDYXJkID0gc3luR3JvdXAuYXBwZW5kKCdzdmc6cmVjdCcpXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJ3JnYmEoMCwgMTcsIDQ5LCAwLjEpJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMTk0KVxuICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMTA4KVxuICAgICAgICAgICAgICAuYXR0cigncnknLCAxMilcbiAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgMTIpXG4gICAgICAgICAgICAgIC5hdHRyKCd4JywgY2FyZE9mZnNldFggLSA0KVxuICAgICAgICAgICAgICAuYXR0cigneScsIGNhcmRPZmZzZXRZIC0gNClcbiAgICAgICAgICAgICAgLmNsYXNzZWQoJ2NhcmQtc2hhZG93JywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZE5vZGVTaGFkb3cgPSBzeW5Hcm91cC5hcHBlbmQoJ3N2ZzpjaXJjbGUnKVxuICAgICAgICAgICAgICAuYXR0cigncicsIDEwKVxuICAgICAgICAgICAgICAuYXR0cignY3gnLCAwKVxuICAgICAgICAgICAgICAuYXR0cignY3knLCAwKVxuICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBjdXJyZW50U3luQ29sb3IpXG4gICAgICAgICAgICAgIC5jbGFzc2VkKCdjYXJkLW5vZGUtc2hhZG93JywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZCA9IHN5bkdyb3VwLmFwcGVuZCgnc3ZnOnJlY3QnKVxuICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICdyZ2JhKDI1NSwyNTUsMjU1LDEnKVxuICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjYXJkV2lkdGgpXG4gICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjYXJkSGVpZ2h0KVxuICAgICAgICAgICAgICAuYXR0cigneCcsIGNhcmRPZmZzZXRYKVxuICAgICAgICAgICAgICAuYXR0cigneScsIGNhcmRPZmZzZXRZKVxuICAgICAgICAgICAgICAuYXR0cigncngnLCAxMClcbiAgICAgICAgICAgICAgLmF0dHIoJ3J5JywgMTApXG4gICAgICAgICAgICAgIC5jbGFzc2VkKCdjYXJkJywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZEhUTUxXcmFwID0gc3luR3JvdXAuYXBwZW5kKCdzdmc6Zm9yZWlnbk9iamVjdCcpXG4gICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNhcmRXaWR0aClcbiAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGNhcmRIZWlnaHQpXG4gICAgICAgICAgICAgIC5hdHRyKCd4JywgY2FyZE9mZnNldFgpXG4gICAgICAgICAgICAgIC5hdHRyKCd5JywgY2FyZE9mZnNldFkpXG4gICAgICAgICAgICAgIC5jbGFzc2VkKCdjYXJkLWh0bWwtd3JhcCcsIHRydWUpXG4gICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgdmFyIGNhcmRJbnB1dCA9IGNhcmRIVE1MV3JhcC5hcHBlbmQoJ3hodG1sOnRleHRhcmVhJylcbiAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgICAgICAgIC5hdHRyKCdzcGVsbGNoZWNrJywgZmFsc2UpXG4gICAgICAgICAgICAgIC5jbGFzc2VkKCdjYXJkLWlucHV0JywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZENvcm5lciA9IHN5bkdyb3VwLmFwcGVuZCgnc3ZnOnJlY3QnKVxuICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxMSlcbiAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDExKVxuICAgICAgICAgICAgICAuYXR0cigneCcsIC0yNilcbiAgICAgICAgICAgICAgLmF0dHIoJ3knLCAtMjYpXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNmZmYnKVxuICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgIHZhciBjYXJkQWN0aW9uID0gc3luR3JvdXAuYXBwZW5kKCdzdmc6cmVjdCcpXG4gICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDI1KVxuICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgMjUpXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY3VycmVudFN5bkNvbG9yKVxuICAgICAgICAgICAgICAuYXR0cigneCcsIC0yMTUpXG4gICAgICAgICAgICAgIC5hdHRyKCd5JywgLTEwNSlcbiAgICAgICAgICAgICAgLmNsYXNzZWQoJ2NhcmQtYWN0aW9uJywgdHJ1ZSlcbiAgICAgICAgICAgICAgLm9uKCdjbGljaycsIHN5bkV4cGFuZClcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZEFjdGlvbkNpcmNsZSA9IHN5bkdyb3VwLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAgIC5hdHRyKCdyJywgMTIpXG4gICAgICAgICAgICAgIC5hdHRyKCdjeCcsIC0yNTUpXG4gICAgICAgICAgICAgIC5hdHRyKCdjeScsIC0xNDApXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNGRjVFOUMnKVxuICAgICAgICAgICAgICAuY2xhc3NlZCgnY2FyZC1hY3Rpb24tY2lyY2xlJywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICB2YXIgY2FyZEFjdGlvblNxdWFyZSA9IHN5bkdyb3VwLmFwcGVuZCgnc3ZnOnJlY3QnKVxuICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCA5KVxuICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgOSlcbiAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtMjAwKVxuICAgICAgICAgICAgICAuYXR0cigneScsIC0xNTApXG4gICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyNmZmZmZmYnKVxuICAgICAgICAgICAgICAuY2xhc3NlZCgnY2FyZC1hY3Rpb24tc3F1YXJlJywgdHJ1ZSlcbiAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FyZC1pbnB1dCcpLnZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJub2RlVmFsdWVcIik7XG5cbiAgICAgICAgICAgIHZhciBjYXJkTm9kZSA9IHN5bkdyb3VwLmFwcGVuZCgnc3ZnOmNpcmNsZScpXG4gICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdjYXJkLW5vZGUnKVxuICAgICAgICAgICAgICAuYXR0cigncicsIDEwKVxuICAgICAgICAgICAgICAuYXR0cignY3gnLCAwKVxuICAgICAgICAgICAgICAuYXR0cignY3knLCAwKVxuICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCAnIzM1NjQ5QycpXG4gICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmKCFtb3VzZWRvd25fbm9kZSB8fCBkID09PSBtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgIGlmKCFtb3VzZWRvd25fbm9kZSB8fCBkID09PSBtb3VzZWRvd25fbm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICBpZihkMy5ldmVudC5jdHJsS2V5KSByZXR1cm47XG4gICAgICAgICAgICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Qgbm9kZVxuICAgICAgICAgICAgICAgIG1vdXNlZG93bl9ub2RlID0gZDtcbiAgICAgICAgICAgICAgICBpZihtb3VzZWRvd25fbm9kZSA9PT0gc2VsZWN0ZWRfbm9kZSkgc2VsZWN0ZWRfbm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZWxzZSBzZWxlY3RlZF9ub2RlID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRfbGluayA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBvc2l0aW9uIGRyYWcgbGluZVxuXG4gICAgICAgICAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgICAgICAgICAuc3R5bGUoJ21hcmtlci1lbmQnLCAndXJsKCNlbmQtYXJyb3cpJylcbiAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdkJywgJ00nICsgbW91c2Vkb3duX25vZGUueCArICcsJyArIG1vdXNlZG93bl9ub2RlLnkgKyAnTCcgKyBtb3VzZWRvd25fbm9kZS54ICsgJywnICsgbW91c2Vkb3duX25vZGUueSlcbiAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAub24oJ21vdXNldXAnLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICAgICAgaWYoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvLyBuZWVkZWQgYnkgRkZcbiAgICAgICAgICAgICAgICBkcmFnX2xpbmVcbiAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdoaWRkZW4nLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRyYWctdG8tc2VsZlxuICAgICAgICAgICAgICAgIG1vdXNldXBfbm9kZSA9IGQ7XG4gICAgICAgICAgICAgICAgaWYobW91c2V1cF9ub2RlID09PSBtb3VzZWRvd25fbm9kZSkgeyByZXNldE1vdXNlVmFycygpOyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIC8vIHVuZW5sYXJnZSB0YXJnZXQgbm9kZVxuICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5hdHRyKCd0cmFuc2Zvcm0nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhZGQgbGluayB0byBncmFwaCAodXBkYXRlIGlmIGV4aXN0cylcbiAgICAgICAgICAgICAgICAvLyBOQjogbGlua3MgYXJlIHN0cmljdGx5IHNvdXJjZSA8IHRhcmdldDsgYXJyb3dzIHNlcGFyYXRlbHkgc3BlY2lmaWVkIGJ5IGJvb2xlYW5zXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSwgdGFyZ2V0LCBkaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgaWYobW91c2Vkb3duX25vZGUuaWQgPCBtb3VzZXVwX25vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IG1vdXNlZG93bl9ub2RlO1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc291cmNlID0gbW91c2V1cF9ub2RlO1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gbW91c2Vkb3duX25vZGU7XG4gICAgICAgICAgICAgICAgICBkaXJlY3Rpb24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGxpbms7XG4gICAgICAgICAgICAgICAgbGluayA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gKGwuc291cmNlID09PSBzb3VyY2UgJiYgbC50YXJnZXQgPT09IHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSlbMF07XG5cbiAgICAgICAgICAgICAgICBpZihsaW5rKSB7XG4gICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsaW5rID0ge3NvdXJjZTogc291cmNlLCB0YXJnZXQ6IHRhcmdldCwgbGVmdDogZmFsc2UsIHJpZ2h0OiBmYWxzZX07XG4gICAgICAgICAgICAgICAgICBsaW5rW2RpcmVjdGlvbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgbGlua3MucHVzaChsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzZWxlY3QgbmV3IGxpbmtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9saW5rID0gbGluaztcbiAgICAgICAgICAgICAgICBzZWxlY3RlZF9ub2RlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHJlc3RhcnQoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICBmdW5jdGlvbiBzeW5FeHBhbmQoZCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNhcmRFeHBhbmRlZFdpZHRoID0gMzgwLFxuICAgICAgICAgICAgICAgICAgICBjYXJkRXhwYW5kZWRIZWlnaHQgPSAyNjBcbiAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDYXJkQWN0aW9uID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgZDMuc2VsZWN0QWxsKFwiLnN5blwiKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWx0ZXJcIiwgXCJ1cmwoI2JsdXIpXCIpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwLjkpXG4gICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudFN5biA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdzeW4tZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cihcImZpbHRlclwiLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRDYXJkID0gY3VycmVudFN5bi5zZWxlY3QoJy5zeW4gLmNhcmQnKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAtKGNhcmRFeHBhbmRlZFdpZHRoICsxNSkpXG4gICAgICAgICAgICAgICAgICAuYXR0cigneScsIC0oY2FyZEV4cGFuZGVkSGVpZ2h0ICsxNSkpXG4gICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCBjYXJkRXhwYW5kZWRXaWR0aClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjYXJkRXhwYW5kZWRIZWlnaHQpXG4gICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudENhcmRIVE1MV3JhcCA9IGN1cnJlbnRTeW4uc2VsZWN0KCcuc3luIC5jYXJkLWh0bWwtd3JhcCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cigneCcsIC0oY2FyZEV4cGFuZGVkV2lkdGggKzE1KSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgLShjYXJkRXhwYW5kZWRIZWlnaHQgKzE1KSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNhcmRFeHBhbmRlZFdpZHRoKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGNhcmRFeHBhbmRlZEhlaWdodClcbiAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QWN0aW9uID0gY3VycmVudFN5bi5zZWxlY3QoJy5zeW4gLmNhcmQtYWN0aW9uJylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDUwKS5hdHRyKCdoZWlnaHQnLCA1MClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTQ1NSkuYXR0cigneScsIC0yNjApXG4gICAgICAgICAgICAgICAgICAuYXR0cigncngnLCA1MCkuYXR0cigncnknLCA1MClcbiAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCBzeW5Db2xsYXBzZSlcbiAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgIHZhciBzYXZlR3JvdXAgPSBjdXJyZW50U3luLmFwcGVuZCgnc3ZnOmcnKVxuICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ2NhcmQtc2F2ZScsIHRydWUpXG4gICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgtNDQzLCAtMjQ4KSBzY2FsZSgxKScpXG4gICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgc3luQ29sbGFwc2UpXG4gICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2F2ZVJlY3QxID0gc2F2ZUdyb3VwLmFwcGVuZCgnc3ZnOnJlY3QnKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnI2ZmZmZmZicpXG4gICAgICAgICAgICAgICAgICAuYXR0cigneCcsIDApLmF0dHIoJ3knLDApXG4gICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAyNikuYXR0cignaGVpZ2h0JywgMjYpXG4gICAgICAgICAgICAgICAgICAuYXR0cigncngnLCAzKVxuICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNhdmVSZWN0MiA9IHNhdmVHcm91cC5hcHBlbmQoJ3N2ZzpyZWN0JylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgJyM0QTkwRTInKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ29wYWNpdHknLCAwLjY1KVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAzKS5hdHRyKCd5JywxMilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIDIwKS5hdHRyKCdoZWlnaHQnLCAxMSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeCcsIDIpXG4gICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2F2ZVBhdGggPSBzYXZlR3JvdXAuYXBwZW5kKCdzdmc6cGF0aCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cignZCcsICdNOSwwIEwyMywwIEwyMyw2IEwyMyw2IEMyMyw3LjEwNDU2OTUgMjIuMTA0NTY5NSw4IDIxLDggTDExLDggTDExLDggQzkuODk1NDMwNSw4IDksNy4xMDQ1Njk1IDksNiBMOSwwIFonKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwnLCAnIzRBOTBFMicpXG4gICAgICAgICAgICAgICAgICAuYXR0cignb3BhY2l0eScsICcwLjY1JylcbiAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgIHZhciBzYXZlUmVjdDMgPSBzYXZlR3JvdXAuYXBwZW5kKCdzdmc6cmVjdCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICcjZmZmZmZmJylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMTgpLmF0dHIoJ3knLCAxKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMykuYXR0cignaGVpZ2h0JywgNilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeCcsIDEuNSlcbiAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgIHZhciBzYXZlUmVjdDQgPSBzYXZlR3JvdXAuYXBwZW5kKCdzdmc6cmVjdCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsICcjNEE5MEUyJylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdvcGFjaXR5JywgMC42NSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgMykuYXR0cigneScsIDMpXG4gICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAzKS5hdHRyKCdoZWlnaHQnLCAzKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgMS41KVxuICAgICAgICAgICAgICAgICAgO1xuXG5cbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN5bkNvbGxhcHNlKGQpIHtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5jYXJkLWlucHV0JykudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2h5IHN0cmluZ2Z5IGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjdXJyZW50Tm9kZSA9IEpTT04uc3RyaW5naWZ5KG5vZGVzW2QuaWRdKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBub2Rlc1tkLmlkXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIGNvbnRlbnQgdG8gbm9kZVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vZGVWYWx1ZSA9IGN1cnJlbnROb2RlLmNvbnRlbnQgPSBjdXJyZW50VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY3VycmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGVzKVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjdXJyZW50Tm9kZVZhbHVlKVxuXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwibm9kZVZhbHVlXCIsIGN1cnJlbnROb2RlVmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN5biA9IGQzLnNlbGVjdCh0aGlzLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgLmNsYXNzZWQoJ3N5bi1leHBhbmRlZCcsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3RBbGwoXCIuc3luXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWx0ZXJcIiwgZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgMSlcbiAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICAgICAgc2F2ZUdyb3VwLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYXJkXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgY2FyZFdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCBjYXJkSGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgY2FyZE9mZnNldFgpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3knLCBjYXJkT2Zmc2V0WSlcbiAgICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhcmRIVE1MV3JhcFxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNhcmRXaWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY2FyZEhlaWdodClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneCcsIGNhcmRPZmZzZXRYKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd5JywgY2FyZE9mZnNldFkpXG4gICAgICAgICAgICAgICAgICAgICAgO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDYXJkQWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3dpZHRoJywgMjUpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIDI1KVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdmaWxsJywgY3VycmVudFN5bkNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd4JywgLTIxNSlcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIC0xMDUpXG4gICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3J4JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAuYXR0cigncnknLCAwKVxuICAgICAgICAgICAgICAgICAgICAgIC5jbGFzc2VkKCdjYXJkLWFjdGlvbicsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIHN5bkV4cGFuZClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0ZVN5bigpO1xuXG5cbiAgICAgIC8vIHJlbW92ZSBvbGQgbm9kZXNcbiAgICAgIGNpcmNsZS5leGl0KCkucmVtb3ZlKCk7XG5cbiAgICAgIC8vIHNldCB0aGUgZ3JhcGggaW4gbW90aW9uXG5cbiAgICAgIC8vIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdsaW5rcycsIEpTT04uc3RyaW5naWZ5KGxpbmtzKSk7XG4gICAgICAvLyBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnbm9kZXMnLCBKU09OLnN0cmluZ2lmeShub2RlcykpO1xuXG4gICAgICBmb3JjZS5zdGFydCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bigpIHtcbiAgICAgIC8vIHByZXZlbnQgSS1iYXIgb24gZHJhZ1xuICAgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgc3ZnLmNsYXNzZWQoJ2FjdGl2ZScsIHRydWUpO1xuXG4gICAgICBpZihkMy5ldmVudC5jdHJsS2V5IHx8IG1vdXNlZG93bl9ub2RlIHx8IG1vdXNlZG93bl9saW5rKSByZXR1cm47XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZW1vdmUoZSkge1xuXG4gICAgICAvLyBzY2FsZSBjbHVzdGVyZnVjayBtb3VzZSBmaXhcbiAgICAgIHZhciBhZGp1c3RlZE1vdXNlWCA9IChkMy5tb3VzZSh0aGlzKVswXSAtIHpvb21UcmFuc2xhdGVYKSAvIHpvb21TY2FsZTtcbiAgICAgIHZhciBhZGp1c3RlZE1vdXNlWSA9IChkMy5tb3VzZSh0aGlzKVsxXSAtIHpvb21UcmFuc2xhdGVZKSAvIHpvb21TY2FsZTtcblxuICAgICAgaWYoIW1vdXNlZG93bl9ub2RlKSByZXR1cm47XG5cbiAgICAgIC8vIHVwZGF0ZSBkcmFnIGxpbmVcbiAgICAgIGRyYWdfbGluZS5hdHRyKFxuICAgICAgICAgICdkJywgJ00nICtcbiAgICAgICAgICBtb3VzZWRvd25fbm9kZS54ICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIG1vdXNlZG93bl9ub2RlLnkgK1xuICAgICAgICAgICdMJyArXG4gICAgICAgICAgYWRqdXN0ZWRNb3VzZVggK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgYWRqdXN0ZWRNb3VzZVlcbiAgICAgICk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb3VzZXVwKCkge1xuICAgICAgaWYobW91c2Vkb3duX25vZGUpIHtcbiAgICAgICAgLy8gaGlkZSBkcmFnIGxpbmVcbiAgICAgICAgZHJhZ19saW5lXG4gICAgICAgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpXG4gICAgICAgICAgLnN0eWxlKCdtYXJrZXItZW5kJywgJycpO1xuICAgICAgfVxuXG4gICAgICBzdmcuY2xhc3NlZCgnYWN0aXZlJywgZmFsc2UpO1xuXG4gICAgICAvLyBjbGVhciBtb3VzZSBldmVudCB2YXJzXG4gICAgICByZXNldE1vdXNlVmFycygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpZ2h0Y2xpY2soKSB7XG5cbiAgICAgICAgLy8gem9vbSAvIHNjYWxlIGZpeFxuICAgICAgICB2YXIgYWRqdXN0ZWRNb3VzZVggPSAoZDMubW91c2UodGhpcylbMF0gLSB6b29tVHJhbnNsYXRlWCkgLyB6b29tU2NhbGU7XG4gICAgICAgIHZhciBhZGp1c3RlZE1vdXNlWSA9IChkMy5tb3VzZSh0aGlzKVsxXSAtIHpvb21UcmFuc2xhdGVZKSAvIHpvb21TY2FsZTtcblxuICAgICAgICAvLyBpbnNlcnQgYSBuZXcgbm9kZSBhdCBtb3VzZSBwb3NpdGlvblxuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiArK2xhc3ROb2RlSWQsXG4gICAgICAgICAgICByZWZsZXhpdmU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gZml4ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZS54ID0gYWRqdXN0ZWRNb3VzZVg7XG4gICAgICAgIG5vZGUueSA9IGFkanVzdGVkTW91c2VZO1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuXG4gICAgICByZXN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsaWNlTGlua3NGb3JOb2RlKG5vZGUpIHtcbiAgICAgIHZhciB0b1NwbGljZSA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7XG4gICAgICAgIHJldHVybiAobC5zb3VyY2UgPT09IG5vZGUgfHwgbC50YXJnZXQgPT09IG5vZGUpO1xuICAgICAgfSk7XG4gICAgICB0b1NwbGljZS5tYXAoZnVuY3Rpb24obCkge1xuICAgICAgICBsaW5rcy5zcGxpY2UobGlua3MuaW5kZXhPZihsKSwgMSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6b29tZWQoKSB7XG5cbiAgICAgICAgY29udGFpbmVyLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBkMy5ldmVudC50cmFuc2xhdGUgKyBcIilzY2FsZShcIiArIGQzLmV2ZW50LnNjYWxlICsgXCIpXCIpO1xuXG4gICAgICAgIC8vIGZpeCBtb3VzZSBwb3NpdGlvbiBvZmZzZXQgYnkgdHJhbnNmb3JtXG4gICAgICAgIHpvb21UcmFuc2xhdGVYID0gZDMuZXZlbnQudHJhbnNsYXRlWzBdO1xuICAgICAgICB6b29tVHJhbnNsYXRlWSA9IGQzLmV2ZW50LnRyYW5zbGF0ZVsxXTtcblxuICAgICAgICB6b29tU2NhbGUgPSBkMy5ldmVudC5zY2FsZTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydChkKSB7XG4gICAgICBkMy5zZWxlY3QodGhpcykuY2xhc3NlZChcImZpeGVkXCIsIGQuZml4ZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICAvLyBhcHAgc3RhcnRzIGhlcmVcbiAgICBzdmcub24oJ21vdXNlZG93bicsIG1vdXNlZG93bilcbiAgICAgIC5vbignbW91c2Vtb3ZlJywgbW91c2Vtb3ZlKVxuICAgICAgLm9uKCdtb3VzZXVwJywgbW91c2V1cClcbiAgICAgIC5vbignY29udGV4dG1lbnUnLCByaWdodGNsaWNrKTtcblxuXG4gICAgcmVzdGFydCgpO1xuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9zeW5hcHNlLWNvcmUvc3luYXBzZS1jb3JlLmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3N5bmFwc2UtY29yZS9zeW5hcHNlLWNvcmUuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIiFmdW5jdGlvbigpIHtcbiAgdmFyIGQzID0ge1xuICAgIHZlcnNpb246IFwiMy41LjEzXCJcbiAgfTtcbiAgdmFyIGQzX2FycmF5U2xpY2UgPSBbXS5zbGljZSwgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIGQzX2FycmF5U2xpY2UuY2FsbChsaXN0KTtcbiAgfTtcbiAgdmFyIGQzX2RvY3VtZW50ID0gdGhpcy5kb2N1bWVudDtcbiAgZnVuY3Rpb24gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiAobm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUuZG9jdW1lbnQgfHwgbm9kZSkuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3dpbmRvdyhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgbm9kZS5kb2N1bWVudCAmJiBub2RlIHx8IG5vZGUuZGVmYXVsdFZpZXcpO1xuICB9XG4gIGlmIChkM19kb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBkM19hcnJheShkM19kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2hpbGROb2RlcylbMF0ubm9kZVR5cGU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZDNfYXJyYXkgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIHZhciBpID0gbGlzdC5sZW5ndGgsIGFycmF5ID0gbmV3IEFycmF5KGkpO1xuICAgICAgICB3aGlsZSAoaS0tKSBhcnJheVtpXSA9IGxpc3RbaV07XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmICghRGF0ZS5ub3cpIERhdGUubm93ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICB9O1xuICBpZiAoZDNfZG9jdW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgZDNfZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKS5zdHlsZS5zZXRQcm9wZXJ0eShcIm9wYWNpdHlcIiwgMCwgXCJcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHZhciBkM19lbGVtZW50X3Byb3RvdHlwZSA9IHRoaXMuRWxlbWVudC5wcm90b3R5cGUsIGQzX2VsZW1lbnRfc2V0QXR0cmlidXRlID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlLCBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TID0gZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsIGQzX3N0eWxlX3Byb3RvdHlwZSA9IHRoaXMuQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUsIGQzX3N0eWxlX3NldFByb3BlcnR5ID0gZDNfc3R5bGVfcHJvdG90eXBlLnNldFByb3BlcnR5O1xuICAgICAgZDNfZWxlbWVudF9wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgZDNfZWxlbWVudF9zZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX2VsZW1lbnRfcHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TID0gZnVuY3Rpb24oc3BhY2UsIGxvY2FsLCB2YWx1ZSkge1xuICAgICAgICBkM19lbGVtZW50X3NldEF0dHJpYnV0ZU5TLmNhbGwodGhpcywgc3BhY2UsIGxvY2FsLCB2YWx1ZSArIFwiXCIpO1xuICAgICAgfTtcbiAgICAgIGQzX3N0eWxlX3Byb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgICBkM19zdHlsZV9zZXRQcm9wZXJ0eS5jYWxsKHRoaXMsIG5hbWUsIHZhbHVlICsgXCJcIiwgcHJpb3JpdHkpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZDMuYXNjZW5kaW5nID0gZDNfYXNjZW5kaW5nO1xuICBmdW5jdGlvbiBkM19hc2NlbmRpbmcoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbiAgfVxuICBkMy5kZXNjZW5kaW5nID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBiIDwgYSA/IC0xIDogYiA+IGEgPyAxIDogYiA+PSBhID8gMCA6IE5hTjtcbiAgfTtcbiAgZDMubWluID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBiO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBhID4gYikgYSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSAhPSBudWxsICYmIGEgPiBiKSBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH07XG4gIGQzLm1heCA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgYjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICgoYiA9IGFycmF5W2ldKSAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gYXJyYXlbaV0pICE9IG51bGwgJiYgYiA+IGEpIGEgPSBiO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBmLmNhbGwoYXJyYXksIGFycmF5W2ldLCBpKSkgIT0gbnVsbCAmJiBiID4gYSkgYSA9IGI7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9O1xuICBkMy5leHRlbnQgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGIsIGM7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCAmJiBiID49IGIpIHtcbiAgICAgICAgYSA9IGMgPSBiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKGIgPSBhcnJheVtpXSkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIGEgPSBiO1xuICAgICAgICBpZiAoYyA8IGIpIGMgPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKChiID0gZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGEgPiBiKSBhID0gYjtcbiAgICAgICAgaWYgKGMgPCBiKSBjID0gYjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsgYSwgYyBdO1xuICB9O1xuICBmdW5jdGlvbiBkM19udW1iZXIoeCkge1xuICAgIHJldHVybiB4ID09PSBudWxsID8gTmFOIDogK3g7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbnVtZXJpYyh4KSB7XG4gICAgcmV0dXJuICFpc05hTih4KTtcbiAgfVxuICBkMy5zdW0gPSBmdW5jdGlvbihhcnJheSwgZikge1xuICAgIHZhciBzID0gMCwgbiA9IGFycmF5Lmxlbmd0aCwgYSwgaSA9IC0xO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGQzX251bWVyaWMoYSA9ICthcnJheVtpXSkpIHMgKz0gYTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSArZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSBzICs9IGE7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9O1xuICBkMy5tZWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgcyA9IDAsIG4gPSBhcnJheS5sZW5ndGgsIGEsIGkgPSAtMSwgaiA9IG47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGYuY2FsbChhcnJheSwgYXJyYXlbaV0sIGkpKSkpIHMgKz0gYTsgZWxzZSAtLWo7XG4gICAgfVxuICAgIGlmIChqKSByZXR1cm4gcyAvIGo7XG4gIH07XG4gIGQzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBwKSB7XG4gICAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsIGggPSBNYXRoLmZsb29yKEgpLCB2ID0gK3ZhbHVlc1toIC0gMV0sIGUgPSBIIC0gaDtcbiAgICByZXR1cm4gZSA/IHYgKyBlICogKHZhbHVlc1toXSAtIHYpIDogdjtcbiAgfTtcbiAgZDMubWVkaWFuID0gZnVuY3Rpb24oYXJyYXksIGYpIHtcbiAgICB2YXIgbnVtYmVycyA9IFtdLCBuID0gYXJyYXkubGVuZ3RoLCBhLCBpID0gLTE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoZDNfbnVtZXJpYyhhID0gZDNfbnVtYmVyKGFycmF5W2ldKSkpIG51bWJlcnMucHVzaChhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkgbnVtYmVycy5wdXNoKGEpO1xuICAgIH1cbiAgICBpZiAobnVtYmVycy5sZW5ndGgpIHJldHVybiBkMy5xdWFudGlsZShudW1iZXJzLnNvcnQoZDNfYXNjZW5kaW5nKSwgLjUpO1xuICB9O1xuICBkMy52YXJpYW5jZSA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGgsIG0gPSAwLCBhLCBkLCBzID0gMCwgaSA9IC0xLCBqID0gMDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKGQzX251bWVyaWMoYSA9IGQzX251bWJlcihhcnJheVtpXSkpKSB7XG4gICAgICAgICAgZCA9IGEgLSBtO1xuICAgICAgICAgIG0gKz0gZCAvICsrajtcbiAgICAgICAgICBzICs9IGQgKiAoYSAtIG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkM19udW1lcmljKGEgPSBkM19udW1iZXIoZi5jYWxsKGFycmF5LCBhcnJheVtpXSwgaSkpKSkge1xuICAgICAgICAgIGQgPSBhIC0gbTtcbiAgICAgICAgICBtICs9IGQgLyArK2o7XG4gICAgICAgICAgcyArPSBkICogKGEgLSBtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiA+IDEpIHJldHVybiBzIC8gKGogLSAxKTtcbiAgfTtcbiAgZDMuZGV2aWF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBkMy52YXJpYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB2ID8gTWF0aC5zcXJ0KHYpIDogdjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmlzZWN0b3IoY29tcGFyZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBsbyA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxOyBlbHNlIGhpID0gbWlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsbztcbiAgICAgIH0sXG4gICAgICByaWdodDogZnVuY3Rpb24oYSwgeCwgbG8sIGhpKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykgbG8gPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDQpIGhpID0gYS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgICAgaWYgKGNvbXBhcmUoYVttaWRdLCB4KSA+IDApIGhpID0gbWlkOyBlbHNlIGxvID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG87XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfYmlzZWN0ID0gZDNfYmlzZWN0b3IoZDNfYXNjZW5kaW5nKTtcbiAgZDMuYmlzZWN0TGVmdCA9IGQzX2Jpc2VjdC5sZWZ0O1xuICBkMy5iaXNlY3QgPSBkMy5iaXNlY3RSaWdodCA9IGQzX2Jpc2VjdC5yaWdodDtcbiAgZDMuYmlzZWN0b3IgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIGQzX2Jpc2VjdG9yKGYubGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZCwgeCkge1xuICAgICAgcmV0dXJuIGQzX2FzY2VuZGluZyhmKGQpLCB4KTtcbiAgICB9IDogZik7XG4gIH07XG4gIGQzLnNodWZmbGUgPSBmdW5jdGlvbihhcnJheSwgaTAsIGkxKSB7XG4gICAgaWYgKChtID0gYXJndW1lbnRzLmxlbmd0aCkgPCAzKSB7XG4gICAgICBpMSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmIChtIDwgMikgaTAgPSAwO1xuICAgIH1cbiAgICB2YXIgbSA9IGkxIC0gaTAsIHQsIGk7XG4gICAgd2hpbGUgKG0pIHtcbiAgICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICAgIHQgPSBhcnJheVttICsgaTBdLCBhcnJheVttICsgaTBdID0gYXJyYXlbaSArIGkwXSwgYXJyYXlbaSArIGkwXSA9IHQ7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfTtcbiAgZDMucGVybXV0ZSA9IGZ1bmN0aW9uKGFycmF5LCBpbmRleGVzKSB7XG4gICAgdmFyIGkgPSBpbmRleGVzLmxlbmd0aCwgcGVybXV0ZXMgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgICByZXR1cm4gcGVybXV0ZXM7XG4gIH07XG4gIGQzLnBhaXJzID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGggLSAxLCBwMCwgcDEgPSBhcnJheVswXSwgcGFpcnMgPSBuZXcgQXJyYXkobiA8IDAgPyAwIDogbik7XG4gICAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IFsgcDAgPSBwMSwgcDEgPSBhcnJheVsrK2ldIF07XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuICBkMy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShuID0gYXJndW1lbnRzLmxlbmd0aCkpIHJldHVybiBbXTtcbiAgICBmb3IgKHZhciBpID0gLTEsIG0gPSBkMy5taW4oYXJndW1lbnRzLCBkM196aXBMZW5ndGgpLCB6aXBzID0gbmV3IEFycmF5KG0pOyArK2kgPCBtOyApIHtcbiAgICAgIGZvciAodmFyIGogPSAtMSwgbiwgemlwID0gemlwc1tpXSA9IG5ldyBBcnJheShuKTsgKytqIDwgbjsgKSB7XG4gICAgICAgIHppcFtqXSA9IGFyZ3VtZW50c1tqXVtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHppcHM7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3ppcExlbmd0aChkKSB7XG4gICAgcmV0dXJuIGQubGVuZ3RoO1xuICB9XG4gIGQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHJldHVybiBkMy56aXAuYXBwbHkoZDMsIG1hdHJpeCk7XG4gIH07XG4gIGQzLmtleXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuICBkMy52YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkgdmFsdWVzLnB1c2gobWFwW2tleV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG4gIGQzLmVudHJpZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBtYXApIGVudHJpZXMucHVzaCh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiBtYXBba2V5XVxuICAgIH0pO1xuICAgIHJldHVybiBlbnRyaWVzO1xuICB9O1xuICBkMy5tZXJnZSA9IGZ1bmN0aW9uKGFycmF5cykge1xuICAgIHZhciBuID0gYXJyYXlzLmxlbmd0aCwgbSwgaSA9IC0xLCBqID0gMCwgbWVyZ2VkLCBhcnJheTtcbiAgICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgIG1lcmdlZCA9IG5ldyBBcnJheShqKTtcbiAgICB3aGlsZSAoLS1uID49IDApIHtcbiAgICAgIGFycmF5ID0gYXJyYXlzW25dO1xuICAgICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHdoaWxlICgtLW0gPj0gMCkge1xuICAgICAgICBtZXJnZWRbLS1qXSA9IGFycmF5W21dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9O1xuICB2YXIgYWJzID0gTWF0aC5hYnM7XG4gIGQzLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgcmFuZ2VcIik7XG4gICAgdmFyIHJhbmdlID0gW10sIGsgPSBkM19yYW5nZV9pbnRlZ2VyU2NhbGUoYWJzKHN0ZXApKSwgaSA9IC0xLCBqO1xuICAgIHN0YXJ0ICo9IGssIHN0b3AgKj0gaywgc3RlcCAqPSBrO1xuICAgIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaiAvIGspOyBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGogLyBrKTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JhbmdlX2ludGVnZXJTY2FsZSh4KSB7XG4gICAgdmFyIGsgPSAxO1xuICAgIHdoaWxlICh4ICogayAlIDEpIGsgKj0gMTA7XG4gICAgcmV0dXJuIGs7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY2xhc3MoY3RvciwgcHJvcGVydGllcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsIGtleSwge1xuICAgICAgICB2YWx1ZTogcHJvcGVydGllc1trZXldLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGQzLm1hcCA9IGZ1bmN0aW9uKG9iamVjdCwgZikge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCk7XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIGQzX01hcCkge1xuICAgICAgb2JqZWN0LmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBvYmplY3QubGVuZ3RoLCBvO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGksIG9iamVjdFtpXSk7IGVsc2Ugd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoZi5jYWxsKG9iamVjdCwgbyA9IG9iamVjdFtpXSwgaSksIG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBtYXAuc2V0KGtleSwgb2JqZWN0W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xuICB9O1xuICBmdW5jdGlvbiBkM19NYXAoKSB7XG4gICAgdGhpcy5fID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICB2YXIgZDNfbWFwX3Byb3RvID0gXCJfX3Byb3RvX19cIiwgZDNfbWFwX3plcm8gPSBcIlxceDAwXCI7XG4gIGQzX2NsYXNzKGQzX01hcCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX1tkM19tYXBfZXNjYXBlKGtleSldO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5KV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIHJlbW92ZTogZDNfbWFwX3JlbW92ZSxcbiAgICBrZXlzOiBkM19tYXBfa2V5cyxcbiAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgdmFsdWVzLnB1c2godGhpcy5fW2tleV0pO1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9LFxuICAgIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGVudHJpZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGVudHJpZXMucHVzaCh7XG4gICAgICAgIGtleTogZDNfbWFwX3VuZXNjYXBlKGtleSksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ba2V5XVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZW50cmllcztcbiAgICB9LFxuICAgIHNpemU6IGQzX21hcF9zaXplLFxuICAgIGVtcHR5OiBkM19tYXBfZW1wdHksXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oZikge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgZi5jYWxsKHRoaXMsIGQzX21hcF91bmVzY2FwZShrZXkpLCB0aGlzLl9ba2V5XSk7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gZDNfbWFwX2VzY2FwZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSArPSBcIlwiKSA9PT0gZDNfbWFwX3Byb3RvIHx8IGtleVswXSA9PT0gZDNfbWFwX3plcm8gPyBkM19tYXBfemVybyArIGtleSA6IGtleTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfdW5lc2NhcGUoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkgKz0gXCJcIilbMF0gPT09IGQzX21hcF96ZXJvID8ga2V5LnNsaWNlKDEpIDoga2V5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX21hcF9oYXMoa2V5KSB7XG4gICAgcmV0dXJuIGQzX21hcF9lc2NhcGUoa2V5KSBpbiB0aGlzLl87XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3JlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gKGtleSA9IGQzX21hcF9lc2NhcGUoa2V5KSkgaW4gdGhpcy5fICYmIGRlbGV0ZSB0aGlzLl9ba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfa2V5cygpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pIGtleXMucHVzaChkM19tYXBfdW5lc2NhcGUoa2V5KSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbWFwX3NpemUoKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl8pICsrc2l6ZTtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19tYXBfZW1wdHkoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuXykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGQzLm5lc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmVzdCA9IHt9LCBrZXlzID0gW10sIHNvcnRLZXlzID0gW10sIHNvcnRWYWx1ZXMsIHJvbGx1cDtcbiAgICBmdW5jdGlvbiBtYXAobWFwVHlwZSwgYXJyYXksIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiByb2xsdXAgPyByb2xsdXAuY2FsbChuZXN0LCBhcnJheSkgOiBzb3J0VmFsdWVzID8gYXJyYXkuc29ydChzb3J0VmFsdWVzKSA6IGFycmF5O1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGFycmF5Lmxlbmd0aCwga2V5ID0ga2V5c1tkZXB0aCsrXSwga2V5VmFsdWUsIG9iamVjdCwgc2V0dGVyLCB2YWx1ZXNCeUtleSA9IG5ldyBkM19NYXAoKSwgdmFsdWVzO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9IHZhbHVlc0J5S2V5LmdldChrZXlWYWx1ZSA9IGtleShvYmplY3QgPSBhcnJheVtpXSkpKSB7XG4gICAgICAgICAgdmFsdWVzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFsgb2JqZWN0IF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWFwVHlwZSkge1xuICAgICAgICBvYmplY3QgPSBtYXBUeXBlKCk7XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Quc2V0KGtleVZhbHVlLCBtYXAobWFwVHlwZSwgdmFsdWVzLCBkZXB0aCkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0ID0ge307XG4gICAgICAgIHNldHRlciA9IGZ1bmN0aW9uKGtleVZhbHVlLCB2YWx1ZXMpIHtcbiAgICAgICAgICBvYmplY3Rba2V5VmFsdWVdID0gbWFwKG1hcFR5cGUsIHZhbHVlcywgZGVwdGgpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFsdWVzQnlLZXkuZm9yRWFjaChzZXR0ZXIpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW50cmllcyhtYXAsIGRlcHRoKSB7XG4gICAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgICB2YXIgYXJyYXkgPSBbXSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoKytdO1xuICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24oa2V5LCBrZXlNYXApIHtcbiAgICAgICAgYXJyYXkucHVzaCh7XG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWVzOiBlbnRyaWVzKGtleU1hcCwgZGVwdGgpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc29ydEtleSA/IGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gc29ydEtleShhLmtleSwgYi5rZXkpO1xuICAgICAgfSkgOiBhcnJheTtcbiAgICB9XG4gICAgbmVzdC5tYXAgPSBmdW5jdGlvbihhcnJheSwgbWFwVHlwZSkge1xuICAgICAgcmV0dXJuIG1hcChtYXBUeXBlLCBhcnJheSwgMCk7XG4gICAgfTtcbiAgICBuZXN0LmVudHJpZXMgPSBmdW5jdGlvbihhcnJheSkge1xuICAgICAgcmV0dXJuIGVudHJpZXMobWFwKGQzLm1hcCwgYXJyYXksIDApLCAwKTtcbiAgICB9O1xuICAgIG5lc3Qua2V5ID0gZnVuY3Rpb24oZCkge1xuICAgICAga2V5cy5wdXNoKGQpO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICBuZXN0LnNvcnRLZXlzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5zb3J0VmFsdWVzID0gZnVuY3Rpb24ob3JkZXIpIHtcbiAgICAgIHNvcnRWYWx1ZXMgPSBvcmRlcjtcbiAgICAgIHJldHVybiBuZXN0O1xuICAgIH07XG4gICAgbmVzdC5yb2xsdXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICByb2xsdXAgPSBmO1xuICAgICAgcmV0dXJuIG5lc3Q7XG4gICAgfTtcbiAgICByZXR1cm4gbmVzdDtcbiAgfTtcbiAgZDMuc2V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgc2V0ID0gbmV3IGQzX1NldCgpO1xuICAgIGlmIChhcnJheSkgZm9yICh2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGg7IGkgPCBuOyArK2kpIHNldC5hZGQoYXJyYXlbaV0pO1xuICAgIHJldHVybiBzZXQ7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX1NldCgpIHtcbiAgICB0aGlzLl8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGQzX2NsYXNzKGQzX1NldCwge1xuICAgIGhhczogZDNfbWFwX2hhcyxcbiAgICBhZGQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5fW2QzX21hcF9lc2NhcGUoa2V5ICs9IFwiXCIpXSA9IHRydWU7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH0sXG4gICAgcmVtb3ZlOiBkM19tYXBfcmVtb3ZlLFxuICAgIHZhbHVlczogZDNfbWFwX2tleXMsXG4gICAgc2l6ZTogZDNfbWFwX3NpemUsXG4gICAgZW1wdHk6IGQzX21hcF9lbXB0eSxcbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fKSBmLmNhbGwodGhpcywgZDNfbWFwX3VuZXNjYXBlKGtleSkpO1xuICAgIH1cbiAgfSk7XG4gIGQzLmJlaGF2aW9yID0ge307XG4gIGZ1bmN0aW9uIGQzX2lkZW50aXR5KGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICBkMy5yZWJpbmQgPSBmdW5jdGlvbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1ldGhvZDtcbiAgICB3aGlsZSAoKytpIDwgbikgdGFyZ2V0W21ldGhvZCA9IGFyZ3VtZW50c1tpXV0gPSBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIHNvdXJjZVttZXRob2RdKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICBmdW5jdGlvbiBkM19yZWJpbmQodGFyZ2V0LCBzb3VyY2UsIG1ldGhvZCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1ldGhvZC5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHNvdXJjZSA/IHRhcmdldCA6IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdmVuZG9yU3ltYm9sKG9iamVjdCwgbmFtZSkge1xuICAgIGlmIChuYW1lIGluIG9iamVjdCkgcmV0dXJuIG5hbWU7XG4gICAgbmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gZDNfdmVuZG9yUHJlZml4ZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgcHJlZml4TmFtZSA9IGQzX3ZlbmRvclByZWZpeGVzW2ldICsgbmFtZTtcbiAgICAgIGlmIChwcmVmaXhOYW1lIGluIG9iamVjdCkgcmV0dXJuIHByZWZpeE5hbWU7XG4gICAgfVxuICB9XG4gIHZhciBkM192ZW5kb3JQcmVmaXhlcyA9IFsgXCJ3ZWJraXRcIiwgXCJtc1wiLCBcIm1velwiLCBcIk1velwiLCBcIm9cIiwgXCJPXCIgXTtcbiAgZnVuY3Rpb24gZDNfbm9vcCgpIHt9XG4gIGQzLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gbmV3IGQzX2Rpc3BhdGNoKCksIGkgPSAtMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGRpc3BhdGNoW2FyZ3VtZW50c1tpXV0gPSBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCk7XG4gICAgcmV0dXJuIGRpc3BhdGNoO1xuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaCgpIHt9XG4gIGQzX2Rpc3BhdGNoLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCBuYW1lID0gXCJcIjtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBuYW1lID0gdHlwZS5zbGljZShpICsgMSk7XG4gICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IHRoaXNbdHlwZV0ub24obmFtZSkgOiB0aGlzW3R5cGVdLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGxpc3RlbmVyID09IG51bGwpIGZvciAodHlwZSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHR5cGUpKSB0aGlzW3R5cGVdLm9uKG5hbWUsIG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19kaXNwYXRjaF9ldmVudChkaXNwYXRjaCkge1xuICAgIHZhciBsaXN0ZW5lcnMgPSBbXSwgbGlzdGVuZXJCeU5hbWUgPSBuZXcgZDNfTWFwKCk7XG4gICAgZnVuY3Rpb24gZXZlbnQoKSB7XG4gICAgICB2YXIgeiA9IGxpc3RlbmVycywgaSA9IC0xLCBuID0gei5sZW5ndGgsIGw7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKGwgPSB6W2ldLm9uKSBsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZGlzcGF0Y2g7XG4gICAgfVxuICAgIGV2ZW50Lm9uID0gZnVuY3Rpb24obmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsID0gbGlzdGVuZXJCeU5hbWUuZ2V0KG5hbWUpLCBpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gbCAmJiBsLm9uO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgbC5vbiA9IG51bGw7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwLCBpID0gbGlzdGVuZXJzLmluZGV4T2YobCkpLmNvbmNhdChsaXN0ZW5lcnMuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgbGlzdGVuZXJCeU5hbWUucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lckJ5TmFtZS5zZXQobmFtZSwge1xuICAgICAgICBvbjogbGlzdGVuZXJcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBkaXNwYXRjaDtcbiAgICB9O1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICBkMy5ldmVudCA9IG51bGw7XG4gIGZ1bmN0aW9uIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKSB7XG4gICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19ldmVudFNvdXJjZSgpIHtcbiAgICB2YXIgZSA9IGQzLmV2ZW50LCBzO1xuICAgIHdoaWxlIChzID0gZS5zb3VyY2VFdmVudCkgZSA9IHM7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZXZlbnREaXNwYXRjaCh0YXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBuZXcgZDNfZGlzcGF0Y2goKSwgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkaXNwYXRjaFthcmd1bWVudHNbaV1dID0gZDNfZGlzcGF0Y2hfZXZlbnQoZGlzcGF0Y2gpO1xuICAgIGRpc3BhdGNoLm9mID0gZnVuY3Rpb24odGhpeiwgYXJndW1lbnR6KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZTEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgZTAgPSBlMS5zb3VyY2VFdmVudCA9IGQzLmV2ZW50O1xuICAgICAgICAgIGUxLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICBkMy5ldmVudCA9IGUxO1xuICAgICAgICAgIGRpc3BhdGNoW2UxLnR5cGVdLmFwcGx5KHRoaXosIGFyZ3VtZW50eik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDMuZXZlbnQgPSBlMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBkaXNwYXRjaDtcbiAgfVxuICBkMy5yZXF1b3RlID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoZDNfcmVxdW90ZV9yZSwgXCJcXFxcJCZcIik7XG4gIH07XG4gIHZhciBkM19yZXF1b3RlX3JlID0gL1tcXFxcXFxeXFwkXFwqXFwrXFw/XFx8XFxbXFxdXFwoXFwpXFwuXFx7XFx9XS9nO1xuICB2YXIgZDNfc3ViY2xhc3MgPSB7fS5fX3Byb3RvX18gPyBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gIH0gOiBmdW5jdGlvbihvYmplY3QsIHByb3RvdHlwZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHByb3RvdHlwZSkgb2JqZWN0W3Byb3BlcnR5XSA9IHByb3RvdHlwZVtwcm9wZXJ0eV07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbihncm91cHMpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3NlbGVjdGlvblByb3RvdHlwZSk7XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuICB2YXIgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgIHJldHVybiBuLnF1ZXJ5U2VsZWN0b3Iocyk7XG4gIH0sIGQzX3NlbGVjdEFsbCA9IGZ1bmN0aW9uKHMsIG4pIHtcbiAgICByZXR1cm4gbi5xdWVyeVNlbGVjdG9yQWxsKHMpO1xuICB9LCBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgIHZhciBkM19zZWxlY3RNYXRjaGVyID0gbi5tYXRjaGVzIHx8IG5bZDNfdmVuZG9yU3ltYm9sKG4sIFwibWF0Y2hlc1NlbGVjdG9yXCIpXTtcbiAgICBkM19zZWxlY3RNYXRjaGVzID0gZnVuY3Rpb24obiwgcykge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdE1hdGNoZXIuY2FsbChuLCBzKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zZWxlY3RNYXRjaGVzKG4sIHMpO1xuICB9O1xuICBpZiAodHlwZW9mIFNpenpsZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZDNfc2VsZWN0ID0gZnVuY3Rpb24ocywgbikge1xuICAgICAgcmV0dXJuIFNpenpsZShzLCBuKVswXSB8fCBudWxsO1xuICAgIH07XG4gICAgZDNfc2VsZWN0QWxsID0gU2l6emxlO1xuICAgIGQzX3NlbGVjdE1hdGNoZXMgPSBTaXp6bGUubWF0Y2hlc1NlbGVjdG9yO1xuICB9XG4gIGQzLnNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zZWxlY3QoZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgfTtcbiAgdmFyIGQzX3NlbGVjdGlvblByb3RvdHlwZSA9IGQzLnNlbGVjdGlvbi5wcm90b3R5cGUgPSBbXTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgZ3JvdXAsIG5vZGU7XG4gICAgc2VsZWN0b3IgPSBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIGZvciAodmFyIGogPSAtMSwgbSA9IHRoaXMubGVuZ3RoOyArK2ogPCBtOyApIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IChncm91cCA9IHRoaXNbal0pLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChzdWJub2RlID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgICAgICAgaWYgKHN1Ym5vZGUgJiYgXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3RvciA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NlbGVjdChzZWxlY3RvciwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2VsZWN0QWxsID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IGQzX2FycmF5KHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpKTtcbiAgICAgICAgICBzdWJncm91cC5wYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiA/IHNlbGVjdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0QWxsKHNlbGVjdG9yLCB0aGlzKTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19uc1ByZWZpeCA9IHtcbiAgICBzdmc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB4aHRtbDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gICAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgIHhtbDogXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zL1wiXG4gIH07XG4gIGQzLm5zID0ge1xuICAgIHByZWZpeDogZDNfbnNQcmVmaXgsXG4gICAgcXVhbGlmeTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCI6XCIpLCBwcmVmaXggPSBuYW1lO1xuICAgICAgaWYgKGkgPj0gMCAmJiAocHJlZml4ID0gbmFtZS5zbGljZSgwLCBpKSkgIT09IFwieG1sbnNcIikgbmFtZSA9IG5hbWUuc2xpY2UoaSArIDEpO1xuICAgICAgcmV0dXJuIGQzX25zUHJlZml4Lmhhc093blByb3BlcnR5KHByZWZpeCkgPyB7XG4gICAgICAgIHNwYWNlOiBkM19uc1ByZWZpeFtwcmVmaXhdLFxuICAgICAgICBsb2NhbDogbmFtZVxuICAgICAgfSA6IG5hbWU7XG4gICAgfVxuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuYXR0ciA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICAgICAgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZSk7XG4gICAgICAgIHJldHVybiBuYW1lLmxvY2FsID8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSA6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2F0dHIodmFsdWUsIG5hbWVbdmFsdWVdKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpO1xuICAgIGZ1bmN0aW9uIGF0dHJOdWxsKCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJOdWxsTlMoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJGdW5jdGlvbigpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpOyBlbHNlIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyRnVuY3Rpb25OUygpIHtcbiAgICAgIHZhciB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmICh4ID09IG51bGwpIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7IGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsLCB4KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBuYW1lLmxvY2FsID8gYXR0ck51bGxOUyA6IGF0dHJOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lLmxvY2FsID8gYXR0ckZ1bmN0aW9uTlMgOiBhdHRyRnVuY3Rpb24gOiBuYW1lLmxvY2FsID8gYXR0ckNvbnN0YW50TlMgOiBhdHRyQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfY29sbGFwc2Uocykge1xuICAgIHJldHVybiBzLnRyaW0oKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2xhc3NlZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKSwgbiA9IChuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkpLmxlbmd0aCwgaSA9IC0xO1xuICAgICAgICBpZiAodmFsdWUgPSBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIXZhbHVlLmNvbnRhaW5zKG5hbWVbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoIWQzX3NlbGVjdGlvbl9jbGFzc2VkUmUobmFtZVtpXSkudGVzdCh2YWx1ZSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFsdWUgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9jbGFzc2VkKHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWRSZShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefFxcXFxzKylcIiArIGQzLnJlcXVvdGUobmFtZSkgKyBcIig/OlxcXFxzK3wkKVwiLCBcImdcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkge1xuICAgIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWQobmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NsYXNzZXMobmFtZSkubWFwKGQzX3NlbGVjdGlvbl9jbGFzc2VkTmFtZSk7XG4gICAgdmFyIG4gPSBuYW1lLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBjbGFzc2VkQ29uc3RhbnQoKSB7XG4gICAgICB2YXIgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIG5hbWVbaV0odGhpcywgdmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGFzc2VkRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IC0xLCB4ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBuYW1lW2ldKHRoaXMsIHgpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjbGFzc2VkRnVuY3Rpb24gOiBjbGFzc2VkQ29uc3RhbnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2NsYXNzZWROYW1lKG5hbWUpIHtcbiAgICB2YXIgcmUgPSBkM19zZWxlY3Rpb25fY2xhc3NlZFJlKG5hbWUpO1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKGMgPSBub2RlLmNsYXNzTGlzdCkgcmV0dXJuIHZhbHVlID8gYy5hZGQobmFtZSkgOiBjLnJlbW92ZShuYW1lKTtcbiAgICAgIHZhciBjID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmICghcmUudGVzdChjKSkgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBkM19jb2xsYXBzZShjICsgXCIgXCIgKyBuYW1lKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGQzX2NvbGxhcHNlKGMucmVwbGFjZShyZSwgXCIgXCIpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAocHJpb3JpdHkgaW4gbmFtZSkgdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShwcmlvcml0eSwgbmFtZVtwcmlvcml0eV0sIHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCAyKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlKCk7XG4gICAgICAgIHJldHVybiBkM193aW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgfVxuICAgICAgcHJpb3JpdHkgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3N0eWxlKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlQ29uc3RhbnQoKSB7XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlRnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoeCA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpOyBlbHNlIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgeCwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHN0eWxlTnVsbCA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gc3R5bGVGdW5jdGlvbiA6IHN0eWxlQ29uc3RhbnQ7XG4gIH1cbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnByb3BlcnR5ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHRoaXMubm9kZSgpW25hbWVdO1xuICAgICAgZm9yICh2YWx1ZSBpbiBuYW1lKSB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KHZhbHVlLCBuYW1lW3ZhbHVlXSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVhY2goZDNfc2VsZWN0aW9uX3Byb3BlcnR5KG5hbWUsIHZhbHVlKSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5TnVsbCgpIHtcbiAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUNvbnN0YW50KCkge1xuICAgICAgdGhpc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9wZXJ0eUZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKHggPT0gbnVsbCkgZGVsZXRlIHRoaXNbbmFtZV07IGVsc2UgdGhpc1tuYW1lXSA9IHg7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gcHJvcGVydHlOdWxsIDogdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBwcm9wZXJ0eUZ1bmN0aW9uIDogcHJvcGVydHlDb25zdGFudDtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmVhY2godHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH0pIDogdGhpcy5ub2RlKCkudGV4dENvbnRlbnQ7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5odG1sID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuZWFjaCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSB2ID09IG51bGwgPyBcIlwiIDogdjtcbiAgICB9IDogdmFsdWUgPT0gbnVsbCA/IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xuICAgIH0gOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gICAgfSkgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFwcGVuZENoaWxkKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9jcmVhdG9yKG5hbWUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsIG5hbWVzcGFjZSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgICAgcmV0dXJuIG5hbWVzcGFjZSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIG5hbWUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTlMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgPyBuYW1lIDogKG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWUpKS5sb2NhbCA/IGNyZWF0ZU5TIDogY3JlYXRlO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihuYW1lLCBiZWZvcmUpIHtcbiAgICBuYW1lID0gZDNfc2VsZWN0aW9uX2NyZWF0b3IobmFtZSk7XG4gICAgYmVmb3JlID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKGJlZm9yZSk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKG5hbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgYmVmb3JlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgbnVsbCk7XG4gICAgfSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGQzX3NlbGVjdGlvblJlbW92ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvblJlbW92ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gdGhpcy5sZW5ndGgsIGdyb3VwLCBub2RlO1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSBuZXcgQXJyYXkobiA9IChncm91cCA9IHRoaXNbMF0pLmxlbmd0aCk7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdmFsdWVbaV0gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJpbmQoZ3JvdXAsIGdyb3VwRGF0YSkge1xuICAgICAgdmFyIGksIG4gPSBncm91cC5sZW5ndGgsIG0gPSBncm91cERhdGEubGVuZ3RoLCBuMCA9IE1hdGgubWluKG4sIG0pLCB1cGRhdGVOb2RlcyA9IG5ldyBBcnJheShtKSwgZW50ZXJOb2RlcyA9IG5ldyBBcnJheShtKSwgZXhpdE5vZGVzID0gbmV3IEFycmF5KG4pLCBub2RlLCBub2RlRGF0YTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIG5vZGVCeUtleVZhbHVlID0gbmV3IGQzX01hcCgpLCBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkobiksIGtleVZhbHVlO1xuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbjsgKSB7XG4gICAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgICAgaWYgKG5vZGVCeUtleVZhbHVlLmhhcyhrZXlWYWx1ZSA9IGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpKSkge1xuICAgICAgICAgICAgICBleGl0Tm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9kZUJ5S2V5VmFsdWUuc2V0KGtleVZhbHVlLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleVZhbHVlc1tpXSA9IGtleVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAtMTsgKytpIDwgbTsgKSB7XG4gICAgICAgICAgaWYgKCEobm9kZSA9IG5vZGVCeUtleVZhbHVlLmdldChrZXlWYWx1ZSA9IGtleS5jYWxsKGdyb3VwRGF0YSwgbm9kZURhdGEgPSBncm91cERhdGFbaV0sIGkpKSkpIHtcbiAgICAgICAgICAgIGVudGVyTm9kZXNbaV0gPSBkM19zZWxlY3Rpb25fZGF0YU5vZGUobm9kZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdXBkYXRlTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5fX2RhdGFfXyA9IG5vZGVEYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlQnlLZXlWYWx1ZS5zZXQoa2V5VmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IC0xOyArK2kgPCBuOyApIHtcbiAgICAgICAgICBpZiAoaSBpbiBrZXlWYWx1ZXMgJiYgbm9kZUJ5S2V5VmFsdWUuZ2V0KGtleVZhbHVlc1tpXSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gLTE7ICsraSA8IG4wOyApIHtcbiAgICAgICAgICBub2RlID0gZ3JvdXBbaV07XG4gICAgICAgICAgbm9kZURhdGEgPSBncm91cERhdGFbaV07XG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuX19kYXRhX18gPSBub2RlRGF0YTtcbiAgICAgICAgICAgIHVwZGF0ZU5vZGVzW2ldID0gbm9kZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50ZXJOb2Rlc1tpXSA9IGQzX3NlbGVjdGlvbl9kYXRhTm9kZShub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoO2kgPCBtOyArK2kpIHtcbiAgICAgICAgICBlbnRlck5vZGVzW2ldID0gZDNfc2VsZWN0aW9uX2RhdGFOb2RlKGdyb3VwRGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7aSA8IG47ICsraSkge1xuICAgICAgICAgIGV4aXROb2Rlc1tpXSA9IGdyb3VwW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbnRlck5vZGVzLnVwZGF0ZSA9IHVwZGF0ZU5vZGVzO1xuICAgICAgZW50ZXJOb2Rlcy5wYXJlbnROb2RlID0gdXBkYXRlTm9kZXMucGFyZW50Tm9kZSA9IGV4aXROb2Rlcy5wYXJlbnROb2RlID0gZ3JvdXAucGFyZW50Tm9kZTtcbiAgICAgIGVudGVyLnB1c2goZW50ZXJOb2Rlcyk7XG4gICAgICB1cGRhdGUucHVzaCh1cGRhdGVOb2Rlcyk7XG4gICAgICBleGl0LnB1c2goZXhpdE5vZGVzKTtcbiAgICB9XG4gICAgdmFyIGVudGVyID0gZDNfc2VsZWN0aW9uX2VudGVyKFtdKSwgdXBkYXRlID0gZDNfc2VsZWN0aW9uKFtdKSwgZXhpdCA9IGQzX3NlbGVjdGlvbihbXSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUuY2FsbChncm91cCwgZ3JvdXAucGFyZW50Tm9kZS5fX2RhdGFfXywgaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBiaW5kKGdyb3VwID0gdGhpc1tpXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUuZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBlbnRlcjtcbiAgICB9O1xuICAgIHVwZGF0ZS5leGl0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhpdDtcbiAgICB9O1xuICAgIHJldHVybiB1cGRhdGU7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9kYXRhTm9kZShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fZGF0YV9fOiBkYXRhXG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZGF0dW0gPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5wcm9wZXJ0eShcIl9fZGF0YV9fXCIsIHZhbHVlKSA6IHRoaXMucHJvcGVydHkoXCJfX2RhdGFfX1wiKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgIHZhciBzdWJncm91cHMgPSBbXSwgc3ViZ3JvdXAsIGdyb3VwLCBub2RlO1xuICAgIGlmICh0eXBlb2YgZmlsdGVyICE9PSBcImZ1bmN0aW9uXCIpIGZpbHRlciA9IGQzX3NlbGVjdGlvbl9maWx0ZXIoZmlsdGVyKTtcbiAgICBmb3IgKHZhciBqID0gMCwgbSA9IHRoaXMubGVuZ3RoOyBqIDwgbTsgaisrKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIHN1Ymdyb3VwLnBhcmVudE5vZGUgPSAoZ3JvdXAgPSB0aGlzW2pdKS5wYXJlbnROb2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIGZpbHRlci5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKHN1Ymdyb3Vwcyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9maWx0ZXIoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2VsZWN0TWF0Y2hlcyh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfTtcbiAgfVxuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUub3JkZXIgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSBncm91cC5sZW5ndGggLSAxLCBuZXh0ID0gZ3JvdXBbaV0sIG5vZGU7IC0taSA+PSAwOyApIHtcbiAgICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgICAgbmV4dCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24oY29tcGFyYXRvcikge1xuICAgIGNvbXBhcmF0b3IgPSBkM19zZWxlY3Rpb25fc29ydENvbXBhcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB0aGlzW2pdLnNvcnQoY29tcGFyYXRvcik7XG4gICAgcmV0dXJuIHRoaXMub3JkZXIoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX3NvcnRDb21wYXJhdG9yKGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGNvbXBhcmF0b3IgPSBkM19hc2NlbmRpbmc7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiBhICYmIGIgPyBjb21wYXJhdG9yKGEuX19kYXRhX18sIGIuX19kYXRhX18pIDogIWEgLSAhYjtcbiAgICB9O1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgY2FsbGJhY2suY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKTtcbiAgICB9KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX2VhY2goZ3JvdXBzLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrKG5vZGUsIGksIGopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgYXJncyA9IGQzX2FycmF5KGFyZ3VtZW50cyk7XG4gICAgY2FsbGJhY2suYXBwbHkoYXJnc1swXSA9IHRoaXMsIGFyZ3MpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMubm9kZSgpO1xuICB9O1xuICBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBncm91cFtpXTtcbiAgICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IDA7XG4gICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICArK247XG4gICAgfSk7XG4gICAgcmV0dXJuIG47XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9lbnRlcihzZWxlY3Rpb24pIHtcbiAgICBkM19zdWJjbGFzcyhzZWxlY3Rpb24sIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuICB2YXIgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlID0gW107XG4gIGQzLnNlbGVjdGlvbi5lbnRlciA9IGQzX3NlbGVjdGlvbl9lbnRlcjtcbiAgZDMuc2VsZWN0aW9uLmVudGVyLnByb3RvdHlwZSA9IGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmFwcGVuZCA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5hcHBlbmQ7XG4gIGQzX3NlbGVjdGlvbl9lbnRlclByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLm5vZGUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUubm9kZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNpemUgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuc2l6ZTtcbiAgZDNfc2VsZWN0aW9uX2VudGVyUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgc3Vibm9kZSwgdXBncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgdXBncm91cCA9IChncm91cCA9IHRoaXNbal0pLnVwZGF0ZTtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgc3ViZ3JvdXAucGFyZW50Tm9kZSA9IGdyb3VwLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKHZhciBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgc3ViZ3JvdXAucHVzaCh1cGdyb3VwW2ldID0gc3Vibm9kZSA9IHNlbGVjdG9yLmNhbGwoZ3JvdXAucGFyZW50Tm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpO1xuICAgICAgICAgIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbihzdWJncm91cHMpO1xuICB9O1xuICBkM19zZWxlY3Rpb25fZW50ZXJQcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24obmFtZSwgYmVmb3JlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBiZWZvcmUgPSBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUodGhpcyk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvblByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBuYW1lLCBiZWZvcmUpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fZW50ZXJJbnNlcnRCZWZvcmUoZW50ZXIpIHtcbiAgICB2YXIgaTAsIGowO1xuICAgIHJldHVybiBmdW5jdGlvbihkLCBpLCBqKSB7XG4gICAgICB2YXIgZ3JvdXAgPSBlbnRlcltqXS51cGRhdGUsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7XG4gICAgICBpZiAoaiAhPSBqMCkgajAgPSBqLCBpMCA9IDA7XG4gICAgICBpZiAoaSA+PSBpMCkgaTAgPSBpICsgMTtcbiAgICAgIHdoaWxlICghKG5vZGUgPSBncm91cFtpMF0pICYmICsraTAgPCBuKSA7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICB9XG4gIGQzLnNlbGVjdCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cCA9IFsgZDNfc2VsZWN0KG5vZGUsIGQzX2RvY3VtZW50KSBdO1xuICAgICAgZ3JvdXAucGFyZW50Tm9kZSA9IGQzX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXAgPSBbIG5vZGUgXTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBkM19kb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBkM19zZWxlY3Rpb24oWyBncm91cCBdKTtcbiAgfTtcbiAgZDMuc2VsZWN0QWxsID0gZnVuY3Rpb24obm9kZXMpIHtcbiAgICB2YXIgZ3JvdXA7XG4gICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZ3JvdXAgPSBkM19hcnJheShkM19zZWxlY3RBbGwobm9kZXMsIGQzX2RvY3VtZW50KSk7XG4gICAgICBncm91cC5wYXJlbnROb2RlID0gZDNfZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cCA9IGQzX2FycmF5KG5vZGVzKTtcbiAgICAgIGdyb3VwLnBhcmVudE5vZGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uKFsgZ3JvdXAgXSk7XG4gIH07XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMykge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChuIDwgMikgbGlzdGVuZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjYXB0dXJlIGluIHR5cGUpIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24oY2FwdHVyZSwgdHlwZVtjYXB0dXJlXSwgbGlzdGVuZXIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAobiA8IDIpIHJldHVybiAobiA9IHRoaXMubm9kZSgpW1wiX19vblwiICsgdHlwZV0pICYmIG4uXztcbiAgICAgIGNhcHR1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZWFjaChkM19zZWxlY3Rpb25fb24odHlwZSwgbGlzdGVuZXIsIGNhcHR1cmUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2VsZWN0aW9uX29uKHR5cGUsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIG5hbWUgPSBcIl9fb25cIiArIHR5cGUsIGkgPSB0eXBlLmluZGV4T2YoXCIuXCIpLCB3cmFwID0gZDNfc2VsZWN0aW9uX29uTGlzdGVuZXI7XG4gICAgaWYgKGkgPiAwKSB0eXBlID0gdHlwZS5zbGljZSgwLCBpKTtcbiAgICB2YXIgZmlsdGVyID0gZDNfc2VsZWN0aW9uX29uRmlsdGVycy5nZXQodHlwZSk7XG4gICAgaWYgKGZpbHRlcikgdHlwZSA9IGZpbHRlciwgd3JhcCA9IGQzX3NlbGVjdGlvbl9vbkZpbHRlcjtcbiAgICBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICAgIHZhciBsID0gdGhpc1tuYW1lXTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsLCBsLiQpO1xuICAgICAgICBkZWxldGUgdGhpc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25BZGQoKSB7XG4gICAgICB2YXIgbCA9IHdyYXAobGlzdGVuZXIsIGQzX2FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgb25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzW25hbWVdID0gbCwgbC4kID0gY2FwdHVyZSk7XG4gICAgICBsLl8gPSBsaXN0ZW5lcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsKCkge1xuICAgICAgdmFyIHJlID0gbmV3IFJlZ0V4cChcIl5fX29uKFteLl0rKVwiICsgZDMucmVxdW90ZSh0eXBlKSArIFwiJFwiKSwgbWF0Y2g7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKG1hdGNoID0gbmFtZS5tYXRjaChyZSkpIHtcbiAgICAgICAgICB2YXIgbCA9IHRoaXNbbmFtZV07XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG1hdGNoWzFdLCBsLCBsLiQpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpID8gbGlzdGVuZXIgPyBvbkFkZCA6IG9uUmVtb3ZlIDogbGlzdGVuZXIgPyBkM19ub29wIDogcmVtb3ZlQWxsO1xuICB9XG4gIHZhciBkM19zZWxlY3Rpb25fb25GaWx0ZXJzID0gZDMubWFwKHtcbiAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgIG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIlxuICB9KTtcbiAgaWYgKGQzX2RvY3VtZW50KSB7XG4gICAgZDNfc2VsZWN0aW9uX29uRmlsdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChcIm9uXCIgKyBrIGluIGQzX2RvY3VtZW50KSBkM19zZWxlY3Rpb25fb25GaWx0ZXJzLnJlbW92ZShrKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBvID0gZDMuZXZlbnQ7XG4gICAgICBkMy5ldmVudCA9IGU7XG4gICAgICBhcmd1bWVudHpbMF0gPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnR6KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NlbGVjdGlvbl9vbkZpbHRlcihsaXN0ZW5lciwgYXJndW1lbnR6KSB7XG4gICAgdmFyIGwgPSBkM19zZWxlY3Rpb25fb25MaXN0ZW5lcihsaXN0ZW5lciwgYXJndW1lbnR6KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIHJlbGF0ZWQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBpZiAoIXJlbGF0ZWQgfHwgcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0YXJnZXQpICYgOCkpIHtcbiAgICAgICAgbC5jYWxsKHRhcmdldCwgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZXZlbnRfZHJhZ1NlbGVjdCwgZDNfZXZlbnRfZHJhZ0lkID0gMDtcbiAgZnVuY3Rpb24gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKG5vZGUpIHtcbiAgICB2YXIgbmFtZSA9IFwiLmRyYWdzdXBwcmVzcy1cIiArICsrZDNfZXZlbnRfZHJhZ0lkLCBjbGljayA9IFwiY2xpY2tcIiArIG5hbWUsIHcgPSBkMy5zZWxlY3QoZDNfd2luZG93KG5vZGUpKS5vbihcInRvdWNobW92ZVwiICsgbmFtZSwgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCkub24oXCJkcmFnc3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpLm9uKFwic2VsZWN0c3RhcnRcIiArIG5hbWUsIGQzX2V2ZW50UHJldmVudERlZmF1bHQpO1xuICAgIGlmIChkM19ldmVudF9kcmFnU2VsZWN0ID09IG51bGwpIHtcbiAgICAgIGQzX2V2ZW50X2RyYWdTZWxlY3QgPSBcIm9uc2VsZWN0c3RhcnRcIiBpbiBub2RlID8gZmFsc2UgOiBkM192ZW5kb3JTeW1ib2wobm9kZS5zdHlsZSwgXCJ1c2VyU2VsZWN0XCIpO1xuICAgIH1cbiAgICBpZiAoZDNfZXZlbnRfZHJhZ1NlbGVjdCkge1xuICAgICAgdmFyIHN0eWxlID0gZDNfZG9jdW1lbnRFbGVtZW50KG5vZGUpLnN0eWxlLCBzZWxlY3QgPSBzdHlsZVtkM19ldmVudF9kcmFnU2VsZWN0XTtcbiAgICAgIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihzdXBwcmVzc0NsaWNrKSB7XG4gICAgICB3Lm9uKG5hbWUsIG51bGwpO1xuICAgICAgaWYgKGQzX2V2ZW50X2RyYWdTZWxlY3QpIHN0eWxlW2QzX2V2ZW50X2RyYWdTZWxlY3RdID0gc2VsZWN0O1xuICAgICAgaWYgKHN1cHByZXNzQ2xpY2spIHtcbiAgICAgICAgdmFyIG9mZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHcub24oY2xpY2ssIG51bGwpO1xuICAgICAgICB9O1xuICAgICAgICB3Lm9uKGNsaWNrLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBkM19ldmVudFByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgb2ZmKCk7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICBzZXRUaW1lb3V0KG9mZiwgMCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5tb3VzZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHJldHVybiBkM19tb3VzZVBvaW50KGNvbnRhaW5lciwgZDNfZXZlbnRTb3VyY2UoKSk7XG4gIH07XG4gIHZhciBkM19tb3VzZV9idWc0NDA4MyA9IHRoaXMubmF2aWdhdG9yICYmIC9XZWJLaXQvLnRlc3QodGhpcy5uYXZpZ2F0b3IudXNlckFnZW50KSA/IC0xIDogMDtcbiAgZnVuY3Rpb24gZDNfbW91c2VQb2ludChjb250YWluZXIsIGUpIHtcbiAgICBpZiAoZS5jaGFuZ2VkVG91Y2hlcykgZSA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgdmFyIHN2ZyA9IGNvbnRhaW5lci5vd25lclNWR0VsZW1lbnQgfHwgY29udGFpbmVyO1xuICAgIGlmIChzdmcuY3JlYXRlU1ZHUG9pbnQpIHtcbiAgICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgaWYgKGQzX21vdXNlX2J1ZzQ0MDgzIDwgMCkge1xuICAgICAgICB2YXIgd2luZG93ID0gZDNfd2luZG93KGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh3aW5kb3cuc2Nyb2xsWCB8fCB3aW5kb3cuc2Nyb2xsWSkge1xuICAgICAgICAgIHN2ZyA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic3ZnXCIpLnN0eWxlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCJcbiAgICAgICAgICB9LCBcImltcG9ydGFudFwiKTtcbiAgICAgICAgICB2YXIgY3RtID0gc3ZnWzBdWzBdLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgIGQzX21vdXNlX2J1ZzQ0MDgzID0gIShjdG0uZiB8fCBjdG0uZSk7XG4gICAgICAgICAgc3ZnLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZDNfbW91c2VfYnVnNDQwODMpIHBvaW50LnggPSBlLnBhZ2VYLCBwb2ludC55ID0gZS5wYWdlWTsgZWxzZSBwb2ludC54ID0gZS5jbGllbnRYLCBcbiAgICAgIHBvaW50LnkgPSBlLmNsaWVudFk7XG4gICAgICBwb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShjb250YWluZXIuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICAgIHJldHVybiBbIHBvaW50LngsIHBvaW50LnkgXTtcbiAgICB9XG4gICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsgZS5jbGllbnRYIC0gcmVjdC5sZWZ0IC0gY29udGFpbmVyLmNsaWVudExlZnQsIGUuY2xpZW50WSAtIHJlY3QudG9wIC0gY29udGFpbmVyLmNsaWVudFRvcCBdO1xuICB9XG4gIGQzLnRvdWNoID0gZnVuY3Rpb24oY29udGFpbmVyLCB0b3VjaGVzLCBpZGVudGlmaWVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkuY2hhbmdlZFRvdWNoZXM7XG4gICAgaWYgKHRvdWNoZXMpIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGgsIHRvdWNoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHRvdWNoID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGQzLmJlaGF2aW9yLmRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKGRyYWcsIFwiZHJhZ1wiLCBcImRyYWdzdGFydFwiLCBcImRyYWdlbmRcIiksIG9yaWdpbiA9IG51bGwsIG1vdXNlZG93biA9IGRyYWdzdGFydChkM19ub29wLCBkMy5tb3VzZSwgZDNfd2luZG93LCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIiksIHRvdWNoc3RhcnQgPSBkcmFnc3RhcnQoZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQsIGQzLnRvdWNoLCBkM19pZGVudGl0eSwgXCJ0b3VjaG1vdmVcIiwgXCJ0b3VjaGVuZFwiKTtcbiAgICBmdW5jdGlvbiBkcmFnKCkge1xuICAgICAgdGhpcy5vbihcIm1vdXNlZG93bi5kcmFnXCIsIG1vdXNlZG93bikub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydChpZCwgcG9zaXRpb24sIHN1YmplY3QsIG1vdmUsIGVuZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHRhcmdldCA9IGQzLmV2ZW50LnRhcmdldCwgcGFyZW50ID0gdGhhdC5wYXJlbnROb2RlLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBkcmFnSWQgPSBpZCgpLCBkcmFnTmFtZSA9IFwiLmRyYWdcIiArIChkcmFnSWQgPT0gbnVsbCA/IFwiXCIgOiBcIi1cIiArIGRyYWdJZCksIGRyYWdPZmZzZXQsIGRyYWdTdWJqZWN0ID0gZDMuc2VsZWN0KHN1YmplY3QodGFyZ2V0KSkub24obW92ZSArIGRyYWdOYW1lLCBtb3ZlZCkub24oZW5kICsgZHJhZ05hbWUsIGVuZGVkKSwgZHJhZ1Jlc3RvcmUgPSBkM19ldmVudF9kcmFnU3VwcHJlc3ModGFyZ2V0KSwgcG9zaXRpb24wID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IG9yaWdpbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIGRyYWdPZmZzZXQgPSBbIGRyYWdPZmZzZXQueCAtIHBvc2l0aW9uMFswXSwgZHJhZ09mZnNldC55IC0gcG9zaXRpb24wWzFdIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZHJhZ09mZnNldCA9IFsgMCwgMCBdO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICB0eXBlOiBcImRyYWdzdGFydFwiXG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24xID0gcG9zaXRpb24ocGFyZW50LCBkcmFnSWQpLCBkeCwgZHk7XG4gICAgICAgICAgaWYgKCFwb3NpdGlvbjEpIHJldHVybjtcbiAgICAgICAgICBkeCA9IHBvc2l0aW9uMVswXSAtIHBvc2l0aW9uMFswXTtcbiAgICAgICAgICBkeSA9IHBvc2l0aW9uMVsxXSAtIHBvc2l0aW9uMFsxXTtcbiAgICAgICAgICBkcmFnZ2VkIHw9IGR4IHwgZHk7XG4gICAgICAgICAgcG9zaXRpb24wID0gcG9zaXRpb24xO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ1wiLFxuICAgICAgICAgICAgeDogcG9zaXRpb24xWzBdICsgZHJhZ09mZnNldFswXSxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uMVsxXSArIGRyYWdPZmZzZXRbMV0sXG4gICAgICAgICAgICBkeDogZHgsXG4gICAgICAgICAgICBkeTogZHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmRlZCgpIHtcbiAgICAgICAgICBpZiAoIXBvc2l0aW9uKHBhcmVudCwgZHJhZ0lkKSkgcmV0dXJuO1xuICAgICAgICAgIGRyYWdTdWJqZWN0Lm9uKG1vdmUgKyBkcmFnTmFtZSwgbnVsbCkub24oZW5kICsgZHJhZ05hbWUsIG51bGwpO1xuICAgICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICAgIGRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZHJhZ2VuZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGRyYWcub3JpZ2luID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZ2luO1xuICAgICAgb3JpZ2luID0geDtcbiAgICAgIHJldHVybiBkcmFnO1xuICAgIH07XG4gICAgcmV0dXJuIGQzLnJlYmluZChkcmFnLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfYmVoYXZpb3JfZHJhZ1RvdWNoSWQoKSB7XG4gICAgcmV0dXJuIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXI7XG4gIH1cbiAgZDMudG91Y2hlcyA9IGZ1bmN0aW9uKGNvbnRhaW5lciwgdG91Y2hlcykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgdG91Y2hlcyA9IGQzX2V2ZW50U291cmNlKCkudG91Y2hlcztcbiAgICByZXR1cm4gdG91Y2hlcyA/IGQzX2FycmF5KHRvdWNoZXMpLm1hcChmdW5jdGlvbih0b3VjaCkge1xuICAgICAgdmFyIHBvaW50ID0gZDNfbW91c2VQb2ludChjb250YWluZXIsIHRvdWNoKTtcbiAgICAgIHBvaW50LmlkZW50aWZpZXIgPSB0b3VjaC5pZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0pIDogW107XG4gIH07XG4gIHZhciDOtSA9IDFlLTYsIM61MiA9IM61ICogzrUsIM+AID0gTWF0aC5QSSwgz4QgPSAyICogz4AsIM+EzrUgPSDPhCAtIM61LCBoYWxmz4AgPSDPgCAvIDIsIGQzX3JhZGlhbnMgPSDPgCAvIDE4MCwgZDNfZGVncmVlcyA9IDE4MCAvIM+AO1xuICBmdW5jdGlvbiBkM19zZ24oeCkge1xuICAgIHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDtcbiAgfVxuICBmdW5jdGlvbiBkM19jcm9zczJkKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGJbMF0gLSBhWzBdKSAqIChjWzFdIC0gYVsxXSkgLSAoYlsxXSAtIGFbMV0pICogKGNbMF0gLSBhWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19hY29zKHgpIHtcbiAgICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gz4AgOiBNYXRoLmFjb3MoeCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfYXNpbih4KSB7XG4gICAgcmV0dXJuIHggPiAxID8gaGFsZs+AIDogeCA8IC0xID8gLWhhbGbPgCA6IE1hdGguYXNpbih4KTtcbiAgfVxuICBmdW5jdGlvbiBkM19zaW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpIC0gMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19jb3NoKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoeCkpICsgMSAvIHgpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM190YW5oKHgpIHtcbiAgICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19oYXZlcnNpbih4KSB7XG4gICAgcmV0dXJuICh4ID0gTWF0aC5zaW4oeCAvIDIpKSAqIHg7XG4gIH1cbiAgdmFyIM+BID0gTWF0aC5TUVJUMiwgz4EyID0gMiwgz4E0ID0gNDtcbiAgZDMuaW50ZXJwb2xhdGVab29tID0gZnVuY3Rpb24ocDAsIHAxKSB7XG4gICAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSwgdXgxID0gcDFbMF0sIHV5MSA9IHAxWzFdLCB3MSA9IHAxWzJdLCBkeCA9IHV4MSAtIHV4MCwgZHkgPSB1eTEgLSB1eTAsIGQyID0gZHggKiBkeCArIGR5ICogZHksIGksIFM7XG4gICAgaWYgKGQyIDwgzrUyKSB7XG4gICAgICBTID0gTWF0aC5sb2codzEgLyB3MCkgLyDPgTtcbiAgICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbIHV4MCArIHQgKiBkeCwgdXkwICsgdCAqIGR5LCB3MCAqIE1hdGguZXhwKM+BICogdCAqIFMpIF07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZDEgPSBNYXRoLnNxcnQoZDIpLCBiMCA9ICh3MSAqIHcxIC0gdzAgKiB3MCArIM+BNCAqIGQyKSAvICgyICogdzAgKiDPgTIgKiBkMSksIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gz4E0ICogZDIpIC8gKDIgKiB3MSAqIM+BMiAqIGQxKSwgcjAgPSBNYXRoLmxvZyhNYXRoLnNxcnQoYjAgKiBiMCArIDEpIC0gYjApLCByMSA9IE1hdGgubG9nKE1hdGguc3FydChiMSAqIGIxICsgMSkgLSBiMSk7XG4gICAgICBTID0gKHIxIC0gcjApIC8gz4E7XG4gICAgICBpID0gZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcyA9IHQgKiBTLCBjb3NocjAgPSBkM19jb3NoKHIwKSwgdSA9IHcwIC8gKM+BMiAqIGQxKSAqIChjb3NocjAgKiBkM190YW5oKM+BICogcyArIHIwKSAtIGQzX3NpbmgocjApKTtcbiAgICAgICAgcmV0dXJuIFsgdXgwICsgdSAqIGR4LCB1eTAgKyB1ICogZHksIHcwICogY29zaHIwIC8gZDNfY29zaCjPgSAqIHMgKyByMCkgXTtcbiAgICAgIH07XG4gICAgfVxuICAgIGkuZHVyYXRpb24gPSBTICogMWUzO1xuICAgIHJldHVybiBpO1xuICB9O1xuICBkMy5iZWhhdmlvci56b29tID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZpZXcgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGs6IDFcbiAgICB9LCB0cmFuc2xhdGUwLCBjZW50ZXIwLCBjZW50ZXIsIHNpemUgPSBbIDk2MCwgNTAwIF0sIHNjYWxlRXh0ZW50ID0gZDNfYmVoYXZpb3Jfem9vbUluZmluaXR5LCBkdXJhdGlvbiA9IDI1MCwgem9vbWluZyA9IDAsIG1vdXNlZG93biA9IFwibW91c2Vkb3duLnpvb21cIiwgbW91c2Vtb3ZlID0gXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZXVwID0gXCJtb3VzZXVwLnpvb21cIiwgbW91c2V3aGVlbFRpbWVyLCB0b3VjaHN0YXJ0ID0gXCJ0b3VjaHN0YXJ0Lnpvb21cIiwgdG91Y2h0aW1lLCBldmVudCA9IGQzX2V2ZW50RGlzcGF0Y2goem9vbSwgXCJ6b29tc3RhcnRcIiwgXCJ6b29tXCIsIFwiem9vbWVuZFwiKSwgeDAsIHgxLCB5MCwgeTE7XG4gICAgaWYgKCFkM19iZWhhdmlvcl96b29tV2hlZWwpIHtcbiAgICAgIGQzX2JlaGF2aW9yX3pvb21XaGVlbCA9IFwib253aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLWQzLmV2ZW50LmRlbHRhWSAqIChkMy5ldmVudC5kZWx0YU1vZGUgPyAxMjAgOiAxKTtcbiAgICAgIH0sIFwid2hlZWxcIikgOiBcIm9ubW91c2V3aGVlbFwiIGluIGQzX2RvY3VtZW50ID8gKGQzX2JlaGF2aW9yX3pvb21EZWx0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZDMuZXZlbnQud2hlZWxEZWx0YTtcbiAgICAgIH0sIFwibW91c2V3aGVlbFwiKSA6IChkM19iZWhhdmlvcl96b29tRGVsdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC1kMy5ldmVudC5kZXRhaWw7XG4gICAgICB9LCBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb20oZykge1xuICAgICAgZy5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbihkM19iZWhhdmlvcl96b29tV2hlZWwgKyBcIi56b29tXCIsIG1vdXNld2hlZWxlZCkub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpLm9uKHRvdWNoc3RhcnQsIHRvdWNoc3RhcnRlZCk7XG4gICAgfVxuICAgIHpvb20uZXZlbnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoaXMsIGFyZ3VtZW50cyksIHZpZXcxID0gdmlldztcbiAgICAgICAgaWYgKGQzX3RyYW5zaXRpb25Jbmhlcml0SWQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmVhY2goXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmlldyA9IHRoaXMuX19jaGFydF9fIHx8IHtcbiAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgazogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KS50d2VlbihcInpvb206em9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkeCA9IHNpemVbMF0sIGR5ID0gc2l6ZVsxXSwgY3ggPSBjZW50ZXIwID8gY2VudGVyMFswXSA6IGR4IC8gMiwgY3kgPSBjZW50ZXIwID8gY2VudGVyMFsxXSA6IGR5IC8gMiwgaSA9IGQzLmludGVycG9sYXRlWm9vbShbIChjeCAtIHZpZXcueCkgLyB2aWV3LmssIChjeSAtIHZpZXcueSkgLyB2aWV3LmssIGR4IC8gdmlldy5rIF0sIFsgKGN4IC0gdmlldzEueCkgLyB2aWV3MS5rLCAoY3kgLSB2aWV3MS55KSAvIHZpZXcxLmssIGR4IC8gdmlldzEuayBdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHZhciBsID0gaSh0KSwgayA9IGR4IC8gbFsyXTtcbiAgICAgICAgICAgICAgdGhpcy5fX2NoYXJ0X18gPSB2aWV3ID0ge1xuICAgICAgICAgICAgICAgIHg6IGN4IC0gbFswXSAqIGssXG4gICAgICAgICAgICAgICAgeTogY3kgLSBsWzFdICogayxcbiAgICAgICAgICAgICAgICBrOiBrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmVhY2goXCJpbnRlcnJ1cHQuem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHpvb21lbmRlZChkaXNwYXRjaCk7XG4gICAgICAgICAgfSkuZWFjaChcImVuZC56b29tXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IHZpZXc7XG4gICAgICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB6b29tLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgdmlldy54LCB2aWV3LnkgXTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6ICtfWzBdLFxuICAgICAgICB5OiArX1sxXSxcbiAgICAgICAgazogdmlldy5rXG4gICAgICB9O1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmlldy5rO1xuICAgICAgdmlldyA9IHtcbiAgICAgICAgeDogdmlldy54LFxuICAgICAgICB5OiB2aWV3LnksXG4gICAgICAgIGs6IG51bGxcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKCtfKTtcbiAgICAgIHJlc2NhbGUoKTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNjYWxlRXh0ZW50O1xuICAgICAgc2NhbGVFeHRlbnQgPSBfID09IG51bGwgPyBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgOiBbICtfWzBdLCArX1sxXSBdO1xuICAgICAgcmV0dXJuIHpvb207XG4gICAgfTtcbiAgICB6b29tLmNlbnRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNlbnRlcjtcbiAgICAgIGNlbnRlciA9IF8gJiYgWyArX1swXSwgK19bMV0gXTtcbiAgICAgIHJldHVybiB6b29tO1xuICAgIH07XG4gICAgem9vbS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBfICYmIFsgK19bMF0sICtfWzFdIF07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20uZHVyYXRpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkdXJhdGlvbjtcbiAgICAgIGR1cmF0aW9uID0gK187XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgxO1xuICAgICAgeDEgPSB6O1xuICAgICAgeDAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIHpvb20ueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTEgPSB6O1xuICAgICAgeTAgPSB6LmNvcHkoKTtcbiAgICAgIHZpZXcgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIGs6IDFcbiAgICAgIH07XG4gICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGxvY2F0aW9uKHApIHtcbiAgICAgIHJldHVybiBbIChwWzBdIC0gdmlldy54KSAvIHZpZXcuaywgKHBbMV0gLSB2aWV3LnkpIC8gdmlldy5rIF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50KGwpIHtcbiAgICAgIHJldHVybiBbIGxbMF0gKiB2aWV3LmsgKyB2aWV3LngsIGxbMV0gKiB2aWV3LmsgKyB2aWV3LnkgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVUbyhzKSB7XG4gICAgICB2aWV3LmsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlVG8ocCwgbCkge1xuICAgICAgbCA9IHBvaW50KGwpO1xuICAgICAgdmlldy54ICs9IHBbMF0gLSBsWzBdO1xuICAgICAgdmlldy55ICs9IHBbMV0gLSBsWzFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tVG8odGhhdCwgcCwgbCwgaykge1xuICAgICAgdGhhdC5fX2NoYXJ0X18gPSB7XG4gICAgICAgIHg6IHZpZXcueCxcbiAgICAgICAgeTogdmlldy55LFxuICAgICAgICBrOiB2aWV3LmtcbiAgICAgIH07XG4gICAgICBzY2FsZVRvKE1hdGgucG93KDIsIGspKTtcbiAgICAgIHRyYW5zbGF0ZVRvKGNlbnRlcjAgPSBwLCBsKTtcbiAgICAgIHRoYXQgPSBkMy5zZWxlY3QodGhhdCk7XG4gICAgICBpZiAoZHVyYXRpb24gPiAwKSB0aGF0ID0gdGhhdC50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pO1xuICAgICAgdGhhdC5jYWxsKHpvb20uZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNjYWxlKCkge1xuICAgICAgaWYgKHgxKSB4MS5kb21haW4oeDAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gKHggLSB2aWV3LngpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHgwLmludmVydCkpO1xuICAgICAgaWYgKHkxKSB5MS5kb21haW4oeTAucmFuZ2UoKS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gKHkgLSB2aWV3LnkpIC8gdmlldy5rO1xuICAgICAgfSkubWFwKHkwLmludmVydCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tc3RhcnRlZChkaXNwYXRjaCkge1xuICAgICAgaWYgKCF6b29taW5nKyspIGRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJ6b29tc3RhcnRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHpvb21lZChkaXNwYXRjaCkge1xuICAgICAgcmVzY2FsZSgpO1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcInpvb21cIixcbiAgICAgICAgc2NhbGU6IHZpZXcuayxcbiAgICAgICAgdHJhbnNsYXRlOiBbIHZpZXcueCwgdmlldy55IF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB6b29tZW5kZWQoZGlzcGF0Y2gpIHtcbiAgICAgIGlmICghLS16b29taW5nKSBkaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiem9vbWVuZFwiXG4gICAgICB9KSwgY2VudGVyMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdXNlZG93bmVkKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBkaXNwYXRjaCA9IGV2ZW50Lm9mKHRoYXQsIGFyZ3VtZW50cyksIGRyYWdnZWQgPSAwLCBzdWJqZWN0ID0gZDMuc2VsZWN0KGQzX3dpbmRvdyh0aGF0KSkub24obW91c2Vtb3ZlLCBtb3ZlZCkub24obW91c2V1cCwgZW5kZWQpLCBsb2NhdGlvbjAgPSBsb2NhdGlvbihkMy5tb3VzZSh0aGF0KSksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRoYXQpO1xuICAgICAgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoYXQpO1xuICAgICAgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgZnVuY3Rpb24gbW92ZWQoKSB7XG4gICAgICAgIGRyYWdnZWQgPSAxO1xuICAgICAgICB0cmFuc2xhdGVUbyhkMy5tb3VzZSh0aGF0KSwgbG9jYXRpb24wKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBzdWJqZWN0Lm9uKG1vdXNlbW92ZSwgbnVsbCkub24obW91c2V1cCwgbnVsbCk7XG4gICAgICAgIGRyYWdSZXN0b3JlKGRyYWdnZWQpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsIGRpc3BhdGNoID0gZXZlbnQub2YodGhhdCwgYXJndW1lbnRzKSwgbG9jYXRpb25zMCA9IHt9LCBkaXN0YW5jZTAgPSAwLCBzY2FsZTAsIHpvb21OYW1lID0gXCIuem9vbS1cIiArIGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmlkZW50aWZpZXIsIHRvdWNobW92ZSA9IFwidG91Y2htb3ZlXCIgKyB6b29tTmFtZSwgdG91Y2hlbmQgPSBcInRvdWNoZW5kXCIgKyB6b29tTmFtZSwgdGFyZ2V0cyA9IFtdLCBzdWJqZWN0ID0gZDMuc2VsZWN0KHRoYXQpLCBkcmFnUmVzdG9yZSA9IGQzX2V2ZW50X2RyYWdTdXBwcmVzcyh0aGF0KTtcbiAgICAgIHN0YXJ0ZWQoKTtcbiAgICAgIHpvb21zdGFydGVkKGRpc3BhdGNoKTtcbiAgICAgIHN1YmplY3Qub24obW91c2Vkb3duLCBudWxsKS5vbih0b3VjaHN0YXJ0LCBzdGFydGVkKTtcbiAgICAgIGZ1bmN0aW9uIHJlbG9jYXRlKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCk7XG4gICAgICAgIHNjYWxlMCA9IHZpZXcuaztcbiAgICAgICAgdG91Y2hlcy5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICBpZiAodC5pZGVudGlmaWVyIGluIGxvY2F0aW9uczApIGxvY2F0aW9uczBbdC5pZGVudGlmaWVyXSA9IGxvY2F0aW9uKHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdGFydGVkKCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZDMuZXZlbnQudGFyZ2V0O1xuICAgICAgICBkMy5zZWxlY3QodGFyZ2V0KS5vbih0b3VjaG1vdmUsIG1vdmVkKS5vbih0b3VjaGVuZCwgZW5kZWQpO1xuICAgICAgICB0YXJnZXRzLnB1c2godGFyZ2V0KTtcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBjaGFuZ2VkLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGxvY2F0aW9uczBbY2hhbmdlZFtpXS5pZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdWNoZXMgPSByZWxvY2F0ZSgpLCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBpZiAobm93IC0gdG91Y2h0aW1lIDwgNTAwKSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRvdWNoZXNbMF07XG4gICAgICAgICAgICB6b29tVG8odGhhdCwgcCwgbG9jYXRpb25zMFtwLmlkZW50aWZpZXJdLCBNYXRoLmZsb29yKE1hdGgubG9nKHZpZXcuaykgLyBNYXRoLkxOMikgKyAxKTtcbiAgICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG91Y2h0aW1lID0gbm93O1xuICAgICAgICB9IGVsc2UgaWYgKHRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBwID0gdG91Y2hlc1swXSwgcSA9IHRvdWNoZXNbMV0sIGR4ID0gcFswXSAtIHFbMF0sIGR5ID0gcFsxXSAtIHFbMV07XG4gICAgICAgICAgZGlzdGFuY2UwID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1vdmVkKCkge1xuICAgICAgICB2YXIgdG91Y2hlcyA9IGQzLnRvdWNoZXModGhhdCksIHAwLCBsMCwgcDEsIGwxO1xuICAgICAgICBkM19zZWxlY3Rpb25faW50ZXJydXB0LmNhbGwodGhhdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBuOyArK2ksIGwxID0gbnVsbCkge1xuICAgICAgICAgIHAxID0gdG91Y2hlc1tpXTtcbiAgICAgICAgICBpZiAobDEgPSBsb2NhdGlvbnMwW3AxLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBpZiAobDApIGJyZWFrO1xuICAgICAgICAgICAgcDAgPSBwMSwgbDAgPSBsMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGwxKSB7XG4gICAgICAgICAgdmFyIGRpc3RhbmNlMSA9IChkaXN0YW5jZTEgPSBwMVswXSAtIHAwWzBdKSAqIGRpc3RhbmNlMSArIChkaXN0YW5jZTEgPSBwMVsxXSAtIHAwWzFdKSAqIGRpc3RhbmNlMSwgc2NhbGUxID0gZGlzdGFuY2UwICYmIE1hdGguc3FydChkaXN0YW5jZTEgLyBkaXN0YW5jZTApO1xuICAgICAgICAgIHAwID0gWyAocDBbMF0gKyBwMVswXSkgLyAyLCAocDBbMV0gKyBwMVsxXSkgLyAyIF07XG4gICAgICAgICAgbDAgPSBbIChsMFswXSArIGwxWzBdKSAvIDIsIChsMFsxXSArIGwxWzFdKSAvIDIgXTtcbiAgICAgICAgICBzY2FsZVRvKHNjYWxlMSAqIHNjYWxlMCk7XG4gICAgICAgIH1cbiAgICAgICAgdG91Y2h0aW1lID0gbnVsbDtcbiAgICAgICAgdHJhbnNsYXRlVG8ocDAsIGwwKTtcbiAgICAgICAgem9vbWVkKGRpc3BhdGNoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVuZGVkKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgY2hhbmdlZCA9IGQzLmV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gY2hhbmdlZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhdGlvbnMwW2NoYW5nZWRbaV0uaWRlbnRpZmllcl07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGlkZW50aWZpZXIgaW4gbG9jYXRpb25zMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZvaWQgcmVsb2NhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZDMuc2VsZWN0QWxsKHRhcmdldHMpLm9uKHpvb21OYW1lLCBudWxsKTtcbiAgICAgICAgc3ViamVjdC5vbihtb3VzZWRvd24sIG1vdXNlZG93bmVkKS5vbih0b3VjaHN0YXJ0LCB0b3VjaHN0YXJ0ZWQpO1xuICAgICAgICBkcmFnUmVzdG9yZSgpO1xuICAgICAgICB6b29tZW5kZWQoZGlzcGF0Y2gpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3VzZXdoZWVsZWQoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2ggPSBldmVudC5vZih0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKG1vdXNld2hlZWxUaW1lcikgY2xlYXJUaW1lb3V0KG1vdXNld2hlZWxUaW1lcik7IGVsc2UgZDNfc2VsZWN0aW9uX2ludGVycnVwdC5jYWxsKHRoaXMpLCBcbiAgICAgIHRyYW5zbGF0ZTAgPSBsb2NhdGlvbihjZW50ZXIwID0gY2VudGVyIHx8IGQzLm1vdXNlKHRoaXMpKSwgem9vbXN0YXJ0ZWQoZGlzcGF0Y2gpO1xuICAgICAgbW91c2V3aGVlbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgbW91c2V3aGVlbFRpbWVyID0gbnVsbDtcbiAgICAgICAgem9vbWVuZGVkKGRpc3BhdGNoKTtcbiAgICAgIH0sIDUwKTtcbiAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNjYWxlVG8oTWF0aC5wb3coMiwgZDNfYmVoYXZpb3Jfem9vbURlbHRhKCkgKiAuMDAyKSAqIHZpZXcuayk7XG4gICAgICB0cmFuc2xhdGVUbyhjZW50ZXIwLCB0cmFuc2xhdGUwKTtcbiAgICAgIHpvb21lZChkaXNwYXRjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRibGNsaWNrZWQoKSB7XG4gICAgICB2YXIgcCA9IGQzLm1vdXNlKHRoaXMpLCBrID0gTWF0aC5sb2codmlldy5rKSAvIE1hdGguTE4yO1xuICAgICAgem9vbVRvKHRoaXMsIHAsIGxvY2F0aW9uKHApLCBkMy5ldmVudC5zaGlmdEtleSA/IE1hdGguY2VpbChrKSAtIDEgOiBNYXRoLmZsb29yKGspICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkMy5yZWJpbmQoem9vbSwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIHZhciBkM19iZWhhdmlvcl96b29tSW5maW5pdHkgPSBbIDAsIEluZmluaXR5IF0sIGQzX2JlaGF2aW9yX3pvb21EZWx0YSwgZDNfYmVoYXZpb3Jfem9vbVdoZWVsO1xuICBkMy5jb2xvciA9IGQzX2NvbG9yO1xuICBmdW5jdGlvbiBkM19jb2xvcigpIHt9XG4gIGQzX2NvbG9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpICsgXCJcIjtcbiAgfTtcbiAgZDMuaHNsID0gZDNfaHNsO1xuICBmdW5jdGlvbiBkM19oc2woaCwgcywgbCkge1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgZDNfaHNsID8gdm9pZCAodGhpcy5oID0gK2gsIHRoaXMucyA9ICtzLCB0aGlzLmwgPSArbCkgOiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGggaW5zdGFuY2VvZiBkM19oc2wgPyBuZXcgZDNfaHNsKGguaCwgaC5zLCBoLmwpIDogZDNfcmdiX3BhcnNlKFwiXCIgKyBoLCBkM19yZ2JfaHNsLCBkM19oc2wpIDogbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICB2YXIgZDNfaHNsUHJvdG90eXBlID0gZDNfaHNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oc2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgayA9IE1hdGgucG93KC43LCBhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpO1xuICAgIHJldHVybiBuZXcgZDNfaHNsKHRoaXMuaCwgdGhpcy5zLCB0aGlzLmwgLyBrKTtcbiAgfTtcbiAgZDNfaHNsUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgcmV0dXJuIG5ldyBkM19oc2wodGhpcy5oLCB0aGlzLnMsIGsgKiB0aGlzLmwpO1xuICB9O1xuICBkM19oc2xQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2hzbF9yZ2IodGhpcy5oLCB0aGlzLnMsIHRoaXMubCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2hzbF9yZ2IoaCwgcywgbCkge1xuICAgIHZhciBtMSwgbTI7XG4gICAgaCA9IGlzTmFOKGgpID8gMCA6IChoICU9IDM2MCkgPCAwID8gaCArIDM2MCA6IGg7XG4gICAgcyA9IGlzTmFOKHMpID8gMCA6IHMgPCAwID8gMCA6IHMgPiAxID8gMSA6IHM7XG4gICAgbCA9IGwgPCAwID8gMCA6IGwgPiAxID8gMSA6IGw7XG4gICAgbTIgPSBsIDw9IC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIG0xID0gMiAqIGwgLSBtMjtcbiAgICBmdW5jdGlvbiB2KGgpIHtcbiAgICAgIGlmIChoID4gMzYwKSBoIC09IDM2MDsgZWxzZSBpZiAoaCA8IDApIGggKz0gMzYwO1xuICAgICAgaWYgKGggPCA2MCkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAvIDYwO1xuICAgICAgaWYgKGggPCAxODApIHJldHVybiBtMjtcbiAgICAgIGlmIChoIDwgMjQwKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMjQwIC0gaCkgLyA2MDtcbiAgICAgIHJldHVybiBtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdnYoaCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodihoKSAqIDI1NSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZDNfcmdiKHZ2KGggKyAxMjApLCB2dihoKSwgdnYoaCAtIDEyMCkpO1xuICB9XG4gIGQzLmhjbCA9IGQzX2hjbDtcbiAgZnVuY3Rpb24gZDNfaGNsKGgsIGMsIGwpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2hjbCA/IHZvaWQgKHRoaXMuaCA9ICtoLCB0aGlzLmMgPSArYywgdGhpcy5sID0gK2wpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBoIGluc3RhbmNlb2YgZDNfaGNsID8gbmV3IGQzX2hjbChoLmgsIGguYywgaC5sKSA6IGggaW5zdGFuY2VvZiBkM19sYWIgPyBkM19sYWJfaGNsKGgubCwgaC5hLCBoLmIpIDogZDNfbGFiX2hjbCgoaCA9IGQzX3JnYl9sYWIoKGggPSBkMy5yZ2IoaCkpLnIsIGguZywgaC5iKSkubCwgaC5hLCBoLmIpIDogbmV3IGQzX2hjbChoLCBjLCBsKTtcbiAgfVxuICB2YXIgZDNfaGNsUHJvdG90eXBlID0gZDNfaGNsLnByb3RvdHlwZSA9IG5ldyBkM19jb2xvcigpO1xuICBkM19oY2xQcm90b3R5cGUuYnJpZ2h0ZXIgPSBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBkM19oY2wodGhpcy5oLCB0aGlzLmMsIE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSkpO1xuICB9O1xuICBkM19oY2xQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfaGNsKHRoaXMuaCwgdGhpcy5jLCBNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSk7XG4gIH07XG4gIGQzX2hjbFByb3RvdHlwZS5yZ2IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaGNsX2xhYih0aGlzLmgsIHRoaXMuYywgdGhpcy5sKS5yZ2IoKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfaGNsX2xhYihoLCBjLCBsKSB7XG4gICAgaWYgKGlzTmFOKGgpKSBoID0gMDtcbiAgICBpZiAoaXNOYU4oYykpIGMgPSAwO1xuICAgIHJldHVybiBuZXcgZDNfbGFiKGwsIE1hdGguY29zKGggKj0gZDNfcmFkaWFucykgKiBjLCBNYXRoLnNpbihoKSAqIGMpO1xuICB9XG4gIGQzLmxhYiA9IGQzX2xhYjtcbiAgZnVuY3Rpb24gZDNfbGFiKGwsIGEsIGIpIHtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGQzX2xhYiA/IHZvaWQgKHRoaXMubCA9ICtsLCB0aGlzLmEgPSArYSwgdGhpcy5iID0gK2IpIDogYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBsIGluc3RhbmNlb2YgZDNfbGFiID8gbmV3IGQzX2xhYihsLmwsIGwuYSwgbC5iKSA6IGwgaW5zdGFuY2VvZiBkM19oY2wgPyBkM19oY2xfbGFiKGwuaCwgbC5jLCBsLmwpIDogZDNfcmdiX2xhYigobCA9IGQzX3JnYihsKSkuciwgbC5nLCBsLmIpIDogbmV3IGQzX2xhYihsLCBhLCBiKTtcbiAgfVxuICB2YXIgZDNfbGFiX0sgPSAxODtcbiAgdmFyIGQzX2xhYl9YID0gLjk1MDQ3LCBkM19sYWJfWSA9IDEsIGQzX2xhYl9aID0gMS4wODg4MztcbiAgdmFyIGQzX2xhYlByb3RvdHlwZSA9IGQzX2xhYi5wcm90b3R5cGUgPSBuZXcgZDNfY29sb3IoKTtcbiAgZDNfbGFiUHJvdG90eXBlLmJyaWdodGVyID0gZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgZDNfbGFiKE1hdGgubWluKDEwMCwgdGhpcy5sICsgZDNfbGFiX0sgKiAoYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKSksIHRoaXMuYSwgdGhpcy5iKTtcbiAgfTtcbiAgZDNfbGFiUHJvdG90eXBlLmRhcmtlciA9IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IGQzX2xhYihNYXRoLm1heCgwLCB0aGlzLmwgLSBkM19sYWJfSyAqIChhcmd1bWVudHMubGVuZ3RoID8gayA6IDEpKSwgdGhpcy5hLCB0aGlzLmIpO1xuICB9O1xuICBkM19sYWJQcm90b3R5cGUucmdiID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2xhYl9yZ2IodGhpcy5sLCB0aGlzLmEsIHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xhYl9yZ2IobCwgYSwgYikge1xuICAgIHZhciB5ID0gKGwgKyAxNikgLyAxMTYsIHggPSB5ICsgYSAvIDUwMCwgeiA9IHkgLSBiIC8gMjAwO1xuICAgIHggPSBkM19sYWJfeHl6KHgpICogZDNfbGFiX1g7XG4gICAgeSA9IGQzX2xhYl94eXooeSkgKiBkM19sYWJfWTtcbiAgICB6ID0gZDNfbGFiX3h5eih6KSAqIGQzX2xhYl9aO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKGQzX3h5el9yZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAuNDk4NTMxNCAqIHopLCBkM194eXpfcmdiKC0uOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAuMDQxNTU2ICogeiksIGQzX3h5el9yZ2IoLjA1NTY0MzQgKiB4IC0gLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xhYl9oY2wobCwgYSwgYikge1xuICAgIHJldHVybiBsID4gMCA/IG5ldyBkM19oY2woTWF0aC5hdGFuMihiLCBhKSAqIGQzX2RlZ3JlZXMsIE1hdGguc3FydChhICogYSArIGIgKiBiKSwgbCkgOiBuZXcgZDNfaGNsKE5hTiwgTmFOLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYWJfeHl6KHgpIHtcbiAgICByZXR1cm4geCA+IC4yMDY4OTMwMzQgPyB4ICogeCAqIHggOiAoeCAtIDQgLyAyOSkgLyA3Ljc4NzAzNztcbiAgfVxuICBmdW5jdGlvbiBkM194eXpfbGFiKHgpIHtcbiAgICByZXR1cm4geCA+IC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiA3Ljc4NzAzNyAqIHggKyA0IC8gMjk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfeHl6X3JnYihyKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoMjU1ICogKHIgPD0gLjAwMzA0ID8gMTIuOTIgKiByIDogMS4wNTUgKiBNYXRoLnBvdyhyLCAxIC8gMi40KSAtIC4wNTUpKTtcbiAgfVxuICBkMy5yZ2IgPSBkM19yZ2I7XG4gIGZ1bmN0aW9uIGQzX3JnYihyLCBnLCBiKSB7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBkM19yZ2IgPyB2b2lkICh0aGlzLnIgPSB+fnIsIHRoaXMuZyA9IH5+ZywgdGhpcy5iID0gfn5iKSA6IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gciBpbnN0YW5jZW9mIGQzX3JnYiA/IG5ldyBkM19yZ2Ioci5yLCByLmcsIHIuYikgOiBkM19yZ2JfcGFyc2UoXCJcIiArIHIsIGQzX3JnYiwgZDNfaHNsX3JnYikgOiBuZXcgZDNfcmdiKHIsIGcsIGIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYk51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgZDNfcmdiKHZhbHVlID4+IDE2LCB2YWx1ZSA+PiA4ICYgMjU1LCB2YWx1ZSAmIDI1NSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfcmdiU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIGQzX3JnYk51bWJlcih2YWx1ZSkgKyBcIlwiO1xuICB9XG4gIHZhciBkM19yZ2JQcm90b3R5cGUgPSBkM19yZ2IucHJvdG90eXBlID0gbmV3IGQzX2NvbG9yKCk7XG4gIGQzX3JnYlByb3RvdHlwZS5icmlnaHRlciA9IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gTWF0aC5wb3coLjcsIGFyZ3VtZW50cy5sZW5ndGggPyBrIDogMSk7XG4gICAgdmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmIsIGkgPSAzMDtcbiAgICBpZiAoIXIgJiYgIWcgJiYgIWIpIHJldHVybiBuZXcgZDNfcmdiKGksIGksIGkpO1xuICAgIGlmIChyICYmIHIgPCBpKSByID0gaTtcbiAgICBpZiAoZyAmJiBnIDwgaSkgZyA9IGk7XG4gICAgaWYgKGIgJiYgYiA8IGkpIGIgPSBpO1xuICAgIHJldHVybiBuZXcgZDNfcmdiKE1hdGgubWluKDI1NSwgciAvIGspLCBNYXRoLm1pbigyNTUsIGcgLyBrKSwgTWF0aC5taW4oMjU1LCBiIC8gaykpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUuZGFya2VyID0gZnVuY3Rpb24oaykge1xuICAgIGsgPSBNYXRoLnBvdyguNywgYXJndW1lbnRzLmxlbmd0aCA/IGsgOiAxKTtcbiAgICByZXR1cm4gbmV3IGQzX3JnYihrICogdGhpcy5yLCBrICogdGhpcy5nLCBrICogdGhpcy5iKTtcbiAgfTtcbiAgZDNfcmdiUHJvdG90eXBlLmhzbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19yZ2JfaHNsKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpO1xuICB9O1xuICBkM19yZ2JQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCIjXCIgKyBkM19yZ2JfaGV4KHRoaXMucikgKyBkM19yZ2JfaGV4KHRoaXMuZykgKyBkM19yZ2JfaGV4KHRoaXMuYik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3JnYl9oZXgodikge1xuICAgIHJldHVybiB2IDwgMTYgPyBcIjBcIiArIE1hdGgubWF4KDAsIHYpLnRvU3RyaW5nKDE2KSA6IE1hdGgubWluKDI1NSwgdikudG9TdHJpbmcoMTYpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl9wYXJzZShmb3JtYXQsIHJnYiwgaHNsKSB7XG4gICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIG0xLCBtMiwgY29sb3I7XG4gICAgbTEgPSAvKFthLXpdKylcXCgoLiopXFwpLy5leGVjKGZvcm1hdCA9IGZvcm1hdC50b0xvd2VyQ2FzZSgpKTtcbiAgICBpZiAobTEpIHtcbiAgICAgIG0yID0gbTFbMl0uc3BsaXQoXCIsXCIpO1xuICAgICAgc3dpdGNoIChtMVsxXSkge1xuICAgICAgIGNhc2UgXCJoc2xcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBoc2wocGFyc2VGbG9hdChtMlswXSksIHBhcnNlRmxvYXQobTJbMV0pIC8gMTAwLCBwYXJzZUZsb2F0KG0yWzJdKSAvIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgIGNhc2UgXCJyZ2JcIjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiByZ2IoZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzBdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzFdKSwgZDNfcmdiX3BhcnNlTnVtYmVyKG0yWzJdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbG9yID0gZDNfcmdiX25hbWVzLmdldChmb3JtYXQpKSB7XG4gICAgICByZXR1cm4gcmdiKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0LmNoYXJBdCgwKSA9PT0gXCIjXCIgJiYgIWlzTmFOKGNvbG9yID0gcGFyc2VJbnQoZm9ybWF0LnNsaWNlKDEpLCAxNikpKSB7XG4gICAgICBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICByID0gKGNvbG9yICYgMzg0MCkgPj4gNDtcbiAgICAgICAgciA9IHIgPj4gNCB8IHI7XG4gICAgICAgIGcgPSBjb2xvciAmIDI0MDtcbiAgICAgICAgZyA9IGcgPj4gNCB8IGc7XG4gICAgICAgIGIgPSBjb2xvciAmIDE1O1xuICAgICAgICBiID0gYiA8PCA0IHwgYjtcbiAgICAgIH0gZWxzZSBpZiAoZm9ybWF0Lmxlbmd0aCA9PT0gNykge1xuICAgICAgICByID0gKGNvbG9yICYgMTY3MTE2ODApID4+IDE2O1xuICAgICAgICBnID0gKGNvbG9yICYgNjUyODApID4+IDg7XG4gICAgICAgIGIgPSBjb2xvciAmIDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYihyLCBnLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfaHNsKHIsIGcsIGIpIHtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NSksIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBkID0gbWF4IC0gbWluLCBoLCBzLCBsID0gKG1heCArIG1pbikgLyAyO1xuICAgIGlmIChkKSB7XG4gICAgICBzID0gbCA8IC41ID8gZCAvIChtYXggKyBtaW4pIDogZCAvICgyIC0gbWF4IC0gbWluKTtcbiAgICAgIGlmIChyID09IG1heCkgaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBlbHNlIGlmIChnID09IG1heCkgaCA9IChiIC0gcikgLyBkICsgMjsgZWxzZSBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgaCAqPSA2MDtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IE5hTjtcbiAgICAgIHMgPSBsID4gMCAmJiBsIDwgMSA/IDAgOiBoO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGQzX2hzbChoLCBzLCBsKTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfbGFiKHIsIGcsIGIpIHtcbiAgICByID0gZDNfcmdiX3h5eihyKTtcbiAgICBnID0gZDNfcmdiX3h5eihnKTtcbiAgICBiID0gZDNfcmdiX3h5eihiKTtcbiAgICB2YXIgeCA9IGQzX3h5el9sYWIoKC40MTI0NTY0ICogciArIC4zNTc1NzYxICogZyArIC4xODA0Mzc1ICogYikgLyBkM19sYWJfWCksIHkgPSBkM194eXpfbGFiKCguMjEyNjcyOSAqIHIgKyAuNzE1MTUyMiAqIGcgKyAuMDcyMTc1ICogYikgLyBkM19sYWJfWSksIHogPSBkM194eXpfbGFiKCguMDE5MzMzOSAqIHIgKyAuMTE5MTkyICogZyArIC45NTAzMDQxICogYikgLyBkM19sYWJfWik7XG4gICAgcmV0dXJuIGQzX2xhYigxMTYgKiB5IC0gMTYsIDUwMCAqICh4IC0geSksIDIwMCAqICh5IC0geikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3JnYl94eXoocikge1xuICAgIHJldHVybiAociAvPSAyNTUpIDw9IC4wNDA0NSA/IHIgLyAxMi45MiA6IE1hdGgucG93KChyICsgLjA1NSkgLyAxLjA1NSwgMi40KTtcbiAgfVxuICBmdW5jdGlvbiBkM19yZ2JfcGFyc2VOdW1iZXIoYykge1xuICAgIHZhciBmID0gcGFyc2VGbG9hdChjKTtcbiAgICByZXR1cm4gYy5jaGFyQXQoYy5sZW5ndGggLSAxKSA9PT0gXCIlXCIgPyBNYXRoLnJvdW5kKGYgKiAyLjU1KSA6IGY7XG4gIH1cbiAgdmFyIGQzX3JnYl9uYW1lcyA9IGQzLm1hcCh7XG4gICAgYWxpY2VibHVlOiAxNTc5MjM4MyxcbiAgICBhbnRpcXVld2hpdGU6IDE2NDQ0Mzc1LFxuICAgIGFxdWE6IDY1NTM1LFxuICAgIGFxdWFtYXJpbmU6IDgzODg1NjQsXG4gICAgYXp1cmU6IDE1Nzk0MTc1LFxuICAgIGJlaWdlOiAxNjExOTI2MCxcbiAgICBiaXNxdWU6IDE2NzcwMjQ0LFxuICAgIGJsYWNrOiAwLFxuICAgIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSxcbiAgICBibHVlOiAyNTUsXG4gICAgYmx1ZXZpb2xldDogOTA1NTIwMixcbiAgICBicm93bjogMTA4MjQyMzQsXG4gICAgYnVybHl3b29kOiAxNDU5NjIzMSxcbiAgICBjYWRldGJsdWU6IDYyNjY1MjgsXG4gICAgY2hhcnRyZXVzZTogODM4ODM1MixcbiAgICBjaG9jb2xhdGU6IDEzNzg5NDcwLFxuICAgIGNvcmFsOiAxNjc0NDI3MixcbiAgICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSxcbiAgICBjb3Juc2lsazogMTY3NzUzODgsXG4gICAgY3JpbXNvbjogMTQ0MjMxMDAsXG4gICAgY3lhbjogNjU1MzUsXG4gICAgZGFya2JsdWU6IDEzOSxcbiAgICBkYXJrY3lhbjogMzU3MjMsXG4gICAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksXG4gICAgZGFya2dyYXk6IDExMTE5MDE3LFxuICAgIGRhcmtncmVlbjogMjU2MDAsXG4gICAgZGFya2dyZXk6IDExMTE5MDE3LFxuICAgIGRhcmtraGFraTogMTI0MzMyNTksXG4gICAgZGFya21hZ2VudGE6IDkxMDk2NDMsXG4gICAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksXG4gICAgZGFya29yYW5nZTogMTY3NDc1MjAsXG4gICAgZGFya29yY2hpZDogMTAwNDAwMTIsXG4gICAgZGFya3JlZDogOTEwOTUwNCxcbiAgICBkYXJrc2FsbW9uOiAxNTMwODQxMCxcbiAgICBkYXJrc2VhZ3JlZW46IDk0MTk5MTksXG4gICAgZGFya3NsYXRlYmx1ZTogNDczNDM0NyxcbiAgICBkYXJrc2xhdGVncmF5OiAzMTAwNDk1LFxuICAgIGRhcmtzbGF0ZWdyZXk6IDMxMDA0OTUsXG4gICAgZGFya3R1cnF1b2lzZTogNTI5NDUsXG4gICAgZGFya3Zpb2xldDogOTY5OTUzOSxcbiAgICBkZWVwcGluazogMTY3MTY5NDcsXG4gICAgZGVlcHNreWJsdWU6IDQ5MTUxLFxuICAgIGRpbWdyYXk6IDY5MDgyNjUsXG4gICAgZGltZ3JleTogNjkwODI2NSxcbiAgICBkb2RnZXJibHVlOiAyMDAzMTk5LFxuICAgIGZpcmVicmljazogMTE2NzQxNDYsXG4gICAgZmxvcmFsd2hpdGU6IDE2Nzc1OTIwLFxuICAgIGZvcmVzdGdyZWVuOiAyMjYzODQyLFxuICAgIGZ1Y2hzaWE6IDE2NzExOTM1LFxuICAgIGdhaW5zYm9ybzogMTQ0NzQ0NjAsXG4gICAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsXG4gICAgZ29sZDogMTY3NjY3MjAsXG4gICAgZ29sZGVucm9kOiAxNDMyOTEyMCxcbiAgICBncmF5OiA4NDIxNTA0LFxuICAgIGdyZWVuOiAzMjc2OCxcbiAgICBncmVlbnllbGxvdzogMTE0MDMwNTUsXG4gICAgZ3JleTogODQyMTUwNCxcbiAgICBob25leWRldzogMTU3OTQxNjAsXG4gICAgaG90cGluazogMTY3Mzg3NDAsXG4gICAgaW5kaWFucmVkOiAxMzQ1ODUyNCxcbiAgICBpbmRpZ286IDQ5MTUzMzAsXG4gICAgaXZvcnk6IDE2Nzc3MjAwLFxuICAgIGtoYWtpOiAxNTc4NzY2MCxcbiAgICBsYXZlbmRlcjogMTUxMzI0MTAsXG4gICAgbGF2ZW5kZXJibHVzaDogMTY3NzMzNjUsXG4gICAgbGF3bmdyZWVuOiA4MTkwOTc2LFxuICAgIGxlbW9uY2hpZmZvbjogMTY3NzU4ODUsXG4gICAgbGlnaHRibHVlOiAxMTM5MzI1NCxcbiAgICBsaWdodGNvcmFsOiAxNTc2MTUzNixcbiAgICBsaWdodGN5YW46IDE0NzQ1NTk5LFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAxNjQ0ODIxMCxcbiAgICBsaWdodGdyYXk6IDEzODgyMzIzLFxuICAgIGxpZ2h0Z3JlZW46IDk0OTgyNTYsXG4gICAgbGlnaHRncmV5OiAxMzg4MjMyMyxcbiAgICBsaWdodHBpbms6IDE2NzU4NDY1LFxuICAgIGxpZ2h0c2FsbW9uOiAxNjc1Mjc2MixcbiAgICBsaWdodHNlYWdyZWVuOiAyMTQyODkwLFxuICAgIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NixcbiAgICBsaWdodHNsYXRlZ3JheTogNzgzMzc1MyxcbiAgICBsaWdodHNsYXRlZ3JleTogNzgzMzc1MyxcbiAgICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsXG4gICAgbGlnaHR5ZWxsb3c6IDE2Nzc3MTg0LFxuICAgIGxpbWU6IDY1MjgwLFxuICAgIGxpbWVncmVlbjogMzMyOTMzMCxcbiAgICBsaW5lbjogMTY0NDU2NzAsXG4gICAgbWFnZW50YTogMTY3MTE5MzUsXG4gICAgbWFyb29uOiA4Mzg4NjA4LFxuICAgIG1lZGl1bWFxdWFtYXJpbmU6IDY3MzczMjIsXG4gICAgbWVkaXVtYmx1ZTogMjA1LFxuICAgIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsXG4gICAgbWVkaXVtcHVycGxlOiA5NjYyNjgzLFxuICAgIG1lZGl1bXNlYWdyZWVuOiAzOTc4MDk3LFxuICAgIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCxcbiAgICBtZWRpdW1zcHJpbmdncmVlbjogNjQxNTQsXG4gICAgbWVkaXVtdHVycXVvaXNlOiA0NzcyMzAwLFxuICAgIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsXG4gICAgbWlkbmlnaHRibHVlOiAxNjQ0OTEyLFxuICAgIG1pbnRjcmVhbTogMTYxMjE4NTAsXG4gICAgbWlzdHlyb3NlOiAxNjc3MDI3MyxcbiAgICBtb2NjYXNpbjogMTY3NzAyMjksXG4gICAgbmF2YWpvd2hpdGU6IDE2NzY4Njg1LFxuICAgIG5hdnk6IDEyOCxcbiAgICBvbGRsYWNlOiAxNjY0MzU1OCxcbiAgICBvbGl2ZTogODQyMTM3NixcbiAgICBvbGl2ZWRyYWI6IDcwNDg3MzksXG4gICAgb3JhbmdlOiAxNjc1MzkyMCxcbiAgICBvcmFuZ2VyZWQ6IDE2NzI5MzQ0LFxuICAgIG9yY2hpZDogMTQzMTU3MzQsXG4gICAgcGFsZWdvbGRlbnJvZDogMTU2NTcxMzAsXG4gICAgcGFsZWdyZWVuOiAxMDAyNTg4MCxcbiAgICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NixcbiAgICBwYWxldmlvbGV0cmVkOiAxNDM4MTIwMyxcbiAgICBwYXBheWF3aGlwOiAxNjc3MzA3NyxcbiAgICBwZWFjaHB1ZmY6IDE2NzY3NjczLFxuICAgIHBlcnU6IDEzNDY4OTkxLFxuICAgIHBpbms6IDE2NzYxMDM1LFxuICAgIHBsdW06IDE0NTI0NjM3LFxuICAgIHBvd2RlcmJsdWU6IDExNTkxOTEwLFxuICAgIHB1cnBsZTogODM4ODczNixcbiAgICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLFxuICAgIHJlZDogMTY3MTE2ODAsXG4gICAgcm9zeWJyb3duOiAxMjM1NzUxOSxcbiAgICByb3lhbGJsdWU6IDQyODY5NDUsXG4gICAgc2FkZGxlYnJvd246IDkxMjcxODcsXG4gICAgc2FsbW9uOiAxNjQxNjg4MixcbiAgICBzYW5keWJyb3duOiAxNjAzMjg2NCxcbiAgICBzZWFncmVlbjogMzA1MDMyNyxcbiAgICBzZWFzaGVsbDogMTY3NzQ2MzgsXG4gICAgc2llbm5hOiAxMDUwNjc5NyxcbiAgICBzaWx2ZXI6IDEyNjMyMjU2LFxuICAgIHNreWJsdWU6IDg5MDAzMzEsXG4gICAgc2xhdGVibHVlOiA2OTcwMDYxLFxuICAgIHNsYXRlZ3JheTogNzM3Mjk0NCxcbiAgICBzbGF0ZWdyZXk6IDczNzI5NDQsXG4gICAgc25vdzogMTY3NzU5MzAsXG4gICAgc3ByaW5nZ3JlZW46IDY1NDA3LFxuICAgIHN0ZWVsYmx1ZTogNDYyMDk4MCxcbiAgICB0YW46IDEzODA4NzgwLFxuICAgIHRlYWw6IDMyODk2LFxuICAgIHRoaXN0bGU6IDE0MjA0ODg4LFxuICAgIHRvbWF0bzogMTY3MzcwOTUsXG4gICAgdHVycXVvaXNlOiA0MjUxODU2LFxuICAgIHZpb2xldDogMTU2MzEwODYsXG4gICAgd2hlYXQ6IDE2MTEzMzMxLFxuICAgIHdoaXRlOiAxNjc3NzIxNSxcbiAgICB3aGl0ZXNtb2tlOiAxNjExOTI4NSxcbiAgICB5ZWxsb3c6IDE2Nzc2OTYwLFxuICAgIHllbGxvd2dyZWVuOiAxMDE0NTA3NFxuICB9KTtcbiAgZDNfcmdiX25hbWVzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGQzX3JnYl9uYW1lcy5zZXQoa2V5LCBkM19yZ2JOdW1iZXIodmFsdWUpKTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2Z1bmN0b3Iodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiID8gdiA6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgfVxuICBkMy5mdW5jdG9yID0gZDNfZnVuY3RvcjtcbiAgZDMueGhyID0gZDNfeGhyVHlwZShkM19pZGVudGl0eSk7XG4gIGZ1bmN0aW9uIGQzX3hoclR5cGUocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBtaW1lVHlwZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBtaW1lVHlwZSA9PT0gXCJmdW5jdGlvblwiKSBjYWxsYmFjayA9IG1pbWVUeXBlLCBcbiAgICAgIG1pbWVUeXBlID0gbnVsbDtcbiAgICAgIHJldHVybiBkM194aHIodXJsLCBtaW1lVHlwZSwgcmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hocih1cmwsIG1pbWVUeXBlLCByZXNwb25zZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgeGhyID0ge30sIGRpc3BhdGNoID0gZDMuZGlzcGF0Y2goXCJiZWZvcmVzZW5kXCIsIFwicHJvZ3Jlc3NcIiwgXCJsb2FkXCIsIFwiZXJyb3JcIiksIGhlYWRlcnMgPSB7fSwgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLCByZXNwb25zZVR5cGUgPSBudWxsO1xuICAgIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmICEoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiByZXF1ZXN0KSAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgXCJvbmxvYWRcIiBpbiByZXF1ZXN0ID8gcmVxdWVzdC5vbmxvYWQgPSByZXF1ZXN0Lm9uZXJyb3IgPSByZXNwb25kIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMgJiYgcmVzcG9uZCgpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cywgcmVzdWx0O1xuICAgICAgaWYgKCFzdGF0dXMgJiYgZDNfeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZXNwb25zZS5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BhdGNoLmxvYWQuY2FsbCh4aHIsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaC5lcnJvci5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB2YXIgbyA9IGQzLmV2ZW50O1xuICAgICAgZDMuZXZlbnQgPSBldmVudDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRpc3BhdGNoLnByb2dyZXNzLmNhbGwoeGhyLCByZXF1ZXN0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzLmV2ZW50ID0gbztcbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5oZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgbmFtZSA9IChuYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIGhlYWRlcnNbbmFtZV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgZGVsZXRlIGhlYWRlcnNbbmFtZV07IGVsc2UgaGVhZGVyc1tuYW1lXSA9IHZhbHVlICsgXCJcIjtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICB4aHIubWltZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWltZVR5cGU7XG4gICAgICBtaW1lVHlwZSA9IHZhbHVlID09IG51bGwgPyBudWxsIDogdmFsdWUgKyBcIlwiO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmVzcG9uc2VUeXBlO1xuICAgICAgcmVzcG9uc2VUeXBlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgeGhyLnJlc3BvbnNlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3BvbnNlID0gdmFsdWU7XG4gICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgWyBcImdldFwiLCBcInBvc3RcIiBdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICB4aHJbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geGhyLnNlbmQuYXBwbHkoeGhyLCBbIG1ldGhvZCBdLmNvbmNhdChkM19hcnJheShhcmd1bWVudHMpKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHhoci5zZW5kID0gZnVuY3Rpb24obWV0aG9kLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2sgPSBkYXRhLCBkYXRhID0gbnVsbDtcbiAgICAgIHJlcXVlc3Qub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiAhKFwiYWNjZXB0XCIgaW4gaGVhZGVycykpIGhlYWRlcnNbXCJhY2NlcHRcIl0gPSBtaW1lVHlwZSArIFwiLCovKlwiO1xuICAgICAgaWYgKHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcikgZm9yICh2YXIgbmFtZSBpbiBoZWFkZXJzKSByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICBpZiAobWltZVR5cGUgIT0gbnVsbCAmJiByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUpIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZShtaW1lVHlwZSk7XG4gICAgICBpZiAocmVzcG9uc2VUeXBlICE9IG51bGwpIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHhoci5vbihcImVycm9yXCIsIGNhbGxiYWNrKS5vbihcImxvYWRcIiwgZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgICAgZGlzcGF0Y2guYmVmb3Jlc2VuZC5jYWxsKHhociwgcmVxdWVzdCk7XG4gICAgICByZXF1ZXN0LnNlbmQoZGF0YSA9PSBudWxsID8gbnVsbCA6IGRhdGEpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIHhoci5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIGQzLnJlYmluZCh4aHIsIGRpc3BhdGNoLCBcIm9uXCIpO1xuICAgIHJldHVybiBjYWxsYmFjayA9PSBudWxsID8geGhyIDogeGhyLmdldChkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spKTtcbiAgfVxuICBmdW5jdGlvbiBkM194aHJfZml4Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICByZXR1cm4gY2FsbGJhY2subGVuZ3RoID09PSAxID8gZnVuY3Rpb24oZXJyb3IsIHJlcXVlc3QpIHtcbiAgICAgIGNhbGxiYWNrKGVycm9yID09IG51bGwgPyByZXF1ZXN0IDogbnVsbCk7XG4gICAgfSA6IGNhbGxiYWNrO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3hockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUgIT09IFwidGV4dFwiID8gcmVxdWVzdC5yZXNwb25zZSA6IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG4gIGQzLmRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlciwgbWltZVR5cGUpIHtcbiAgICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKCdbXCInICsgZGVsaW1pdGVyICsgXCJcXG5dXCIpLCBkZWxpbWl0ZXJDb2RlID0gZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCk7XG4gICAgZnVuY3Rpb24gZHN2KHVybCwgcm93LCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBjYWxsYmFjayA9IHJvdywgcm93ID0gbnVsbDtcbiAgICAgIHZhciB4aHIgPSBkM194aHIodXJsLCBtaW1lVHlwZSwgcm93ID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2Uocm93KSwgY2FsbGJhY2spO1xuICAgICAgeGhyLnJvdyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB4aHIucmVzcG9uc2UoKHJvdyA9IF8pID09IG51bGwgPyByZXNwb25zZSA6IHR5cGVkUmVzcG9uc2UoXykpIDogcm93O1xuICAgICAgfTtcbiAgICAgIHJldHVybiB4aHI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3BvbnNlKHJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0eXBlZFJlc3BvbnNlKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBkc3YucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQsIGYpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZHN2LnBhcnNlID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIG87XG4gICAgICByZXR1cm4gZHN2LnBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgICAgaWYgKG8pIHJldHVybiBvKHJvdywgaSAtIDEpO1xuICAgICAgICB2YXIgYSA9IG5ldyBGdW5jdGlvbihcImRcIiwgXCJyZXR1cm4ge1wiICsgcm93Lm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xuICAgICAgICBvID0gZiA/IGZ1bmN0aW9uKHJvdywgaSkge1xuICAgICAgICAgIHJldHVybiBmKGEocm93KSwgaSk7XG4gICAgICAgIH0gOiBhO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBkc3YucGFyc2VSb3dzID0gZnVuY3Rpb24odGV4dCwgZikge1xuICAgICAgdmFyIEVPTCA9IHt9LCBFT0YgPSB7fSwgcm93cyA9IFtdLCBOID0gdGV4dC5sZW5ndGgsIEkgPSAwLCBuID0gMCwgdCwgZW9sO1xuICAgICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICAgIGlmIChJID49IE4pIHJldHVybiBFT0Y7XG4gICAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuICAgICAgICB2YXIgaiA9IEk7XG4gICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IDM0KSB7XG4gICAgICAgICAgdmFyIGkgPSBqO1xuICAgICAgICAgIHdoaWxlIChpKysgPCBOKSB7XG4gICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkpID09PSAzNCkge1xuICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMzQpIGJyZWFrO1xuICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIEkgPSBpICsgMjtcbiAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgICAgaWYgKGMgPT09IDEzKSB7XG4gICAgICAgICAgICBlb2wgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleHQuY2hhckNvZGVBdChpICsgMikgPT09IDEwKSArK0k7XG4gICAgICAgICAgfSBlbHNlIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSwgayA9IDE7XG4gICAgICAgICAgaWYgKGMgPT09IDEwKSBlb2wgPSB0cnVlOyBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgZW9sID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoSSkgPT09IDEwKSArK0ksICsraztcbiAgICAgICAgICB9IGVsc2UgaWYgKGMgIT09IGRlbGltaXRlckNvZGUpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIEkgLSBrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dC5zbGljZShqKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgodCA9IHRva2VuKCkpICE9PSBFT0YpIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHtcbiAgICAgICAgICBhLnB1c2godCk7XG4gICAgICAgICAgdCA9IHRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYgJiYgKGEgPSBmKGEsIG4rKykpID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICByb3dzLnB1c2goYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm93cztcbiAgICB9O1xuICAgIGRzdi5mb3JtYXQgPSBmdW5jdGlvbihyb3dzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzWzBdKSkgcmV0dXJuIGRzdi5mb3JtYXRSb3dzKHJvd3MpO1xuICAgICAgdmFyIGZpZWxkU2V0ID0gbmV3IGQzX1NldCgpLCBmaWVsZHMgPSBbXTtcbiAgICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgZm9yICh2YXIgZmllbGQgaW4gcm93KSB7XG4gICAgICAgICAgaWYgKCFmaWVsZFNldC5oYXMoZmllbGQpKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChmaWVsZFNldC5hZGQoZmllbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFsgZmllbGRzLm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpIF0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICByZXR1cm4gZmllbGRzLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICAgIHJldHVybiBmb3JtYXRWYWx1ZShyb3dbZmllbGRdKTtcbiAgICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgICAgfSkpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBkc3YuZm9ybWF0Um93cyA9IGZ1bmN0aW9uKHJvd3MpIHtcbiAgICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh0ZXh0KSB7XG4gICAgICByZXR1cm4gcmVGb3JtYXQudGVzdCh0ZXh0KSA/ICdcIicgKyB0ZXh0LnJlcGxhY2UoL1xcXCIvZywgJ1wiXCInKSArICdcIicgOiB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gZHN2O1xuICB9O1xuICBkMy5jc3YgPSBkMy5kc3YoXCIsXCIsIFwidGV4dC9jc3ZcIik7XG4gIGQzLnRzdiA9IGQzLmRzdihcIlx0XCIsIFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiKTtcbiAgdmFyIGQzX3RpbWVyX3F1ZXVlSGVhZCwgZDNfdGltZXJfcXVldWVUYWlsLCBkM190aW1lcl9pbnRlcnZhbCwgZDNfdGltZXJfdGltZW91dCwgZDNfdGltZXJfZnJhbWUgPSB0aGlzW2QzX3ZlbmRvclN5bWJvbCh0aGlzLCBcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiKV0gfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxNyk7XG4gIH07XG4gIGQzLnRpbWVyID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdGltZXIoY2FsbGJhY2ssIGRlbGF5LCB0aGVuKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGlmIChuIDwgMikgZGVsYXkgPSAwO1xuICAgIGlmIChuIDwgMykgdGhlbiA9IERhdGUubm93KCk7XG4gICAgdmFyIHRpbWUgPSB0aGVuICsgZGVsYXksIHRpbWVyID0ge1xuICAgICAgYzogY2FsbGJhY2ssXG4gICAgICB0OiB0aW1lLFxuICAgICAgbjogbnVsbFxuICAgIH07XG4gICAgaWYgKGQzX3RpbWVyX3F1ZXVlVGFpbCkgZDNfdGltZXJfcXVldWVUYWlsLm4gPSB0aW1lcjsgZWxzZSBkM190aW1lcl9xdWV1ZUhlYWQgPSB0aW1lcjtcbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0aW1lcjtcbiAgICBpZiAoIWQzX3RpbWVyX2ludGVydmFsKSB7XG4gICAgICBkM190aW1lcl90aW1lb3V0ID0gY2xlYXJUaW1lb3V0KGQzX3RpbWVyX3RpbWVvdXQpO1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lcjtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lcl9zdGVwKCkge1xuICAgIHZhciBub3cgPSBkM190aW1lcl9tYXJrKCksIGRlbGF5ID0gZDNfdGltZXJfc3dlZXAoKSAtIG5vdztcbiAgICBpZiAoZGVsYXkgPiAyNCkge1xuICAgICAgaWYgKGlzRmluaXRlKGRlbGF5KSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoZDNfdGltZXJfdGltZW91dCk7XG4gICAgICAgIGQzX3RpbWVyX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGQzX3RpbWVyX3N0ZXAsIGRlbGF5KTtcbiAgICAgIH1cbiAgICAgIGQzX3RpbWVyX2ludGVydmFsID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfdGltZXJfaW50ZXJ2YWwgPSAxO1xuICAgICAgZDNfdGltZXJfZnJhbWUoZDNfdGltZXJfc3RlcCk7XG4gICAgfVxuICB9XG4gIGQzLnRpbWVyLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgZDNfdGltZXJfbWFyaygpO1xuICAgIGQzX3RpbWVyX3N3ZWVwKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX21hcmsoKSB7XG4gICAgdmFyIG5vdyA9IERhdGUubm93KCksIHRpbWVyID0gZDNfdGltZXJfcXVldWVIZWFkO1xuICAgIHdoaWxlICh0aW1lcikge1xuICAgICAgaWYgKG5vdyA+PSB0aW1lci50ICYmIHRpbWVyLmMobm93IC0gdGltZXIudCkpIHRpbWVyLmMgPSBudWxsO1xuICAgICAgdGltZXIgPSB0aW1lci5uO1xuICAgIH1cbiAgICByZXR1cm4gbm93O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVyX3N3ZWVwKCkge1xuICAgIHZhciB0MCwgdDEgPSBkM190aW1lcl9xdWV1ZUhlYWQsIHRpbWUgPSBJbmZpbml0eTtcbiAgICB3aGlsZSAodDEpIHtcbiAgICAgIGlmICh0MS5jKSB7XG4gICAgICAgIGlmICh0MS50IDwgdGltZSkgdGltZSA9IHQxLnQ7XG4gICAgICAgIHQxID0gKHQwID0gdDEpLm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MSA9IHQwID8gdDAubiA9IHQxLm4gOiBkM190aW1lcl9xdWV1ZUhlYWQgPSB0MS5uO1xuICAgICAgfVxuICAgIH1cbiAgICBkM190aW1lcl9xdWV1ZVRhaWwgPSB0MDtcbiAgICByZXR1cm4gdGltZTtcbiAgfVxuICBmdW5jdGlvbiBkM19mb3JtYXRfcHJlY2lzaW9uKHgsIHApIHtcbiAgICByZXR1cm4gcCAtICh4ID8gTWF0aC5jZWlsKE1hdGgubG9nKHgpIC8gTWF0aC5MTjEwKSA6IDEpO1xuICB9XG4gIGQzLnJvdW5kID0gZnVuY3Rpb24oeCwgbikge1xuICAgIHJldHVybiBuID8gTWF0aC5yb3VuZCh4ICogKG4gPSBNYXRoLnBvdygxMCwgbikpKSAvIG4gOiBNYXRoLnJvdW5kKHgpO1xuICB9O1xuICB2YXIgZDNfZm9ybWF0UHJlZml4ZXMgPSBbIFwieVwiLCBcInpcIiwgXCJhXCIsIFwiZlwiLCBcInBcIiwgXCJuXCIsIFwiwrVcIiwgXCJtXCIsIFwiXCIsIFwia1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCIsIFwiWlwiLCBcIllcIiBdLm1hcChkM19mb3JtYXRQcmVmaXgpO1xuICBkMy5mb3JtYXRQcmVmaXggPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh2YWx1ZSA9ICt2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgKj0gLTE7XG4gICAgICBpZiAocHJlY2lzaW9uKSB2YWx1ZSA9IGQzLnJvdW5kKHZhbHVlLCBkM19mb3JtYXRfcHJlY2lzaW9uKHZhbHVlLCBwcmVjaXNpb24pKTtcbiAgICAgIGkgPSAxICsgTWF0aC5mbG9vcigxZS0xMiArIE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4xMCk7XG4gICAgICBpID0gTWF0aC5tYXgoLTI0LCBNYXRoLm1pbigyNCwgTWF0aC5mbG9vcigoaSAtIDEpIC8gMykgKiAzKSk7XG4gICAgfVxuICAgIHJldHVybiBkM19mb3JtYXRQcmVmaXhlc1s4ICsgaSAvIDNdO1xuICB9O1xuICBmdW5jdGlvbiBkM19mb3JtYXRQcmVmaXgoZCwgaSkge1xuICAgIHZhciBrID0gTWF0aC5wb3coMTAsIGFicyg4IC0gaSkgKiAzKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IGkgPiA4ID8gZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAvIGs7XG4gICAgICB9IDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gZCAqIGs7XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiBkXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGVjaW1hbCA9IGxvY2FsZS5kZWNpbWFsLCBsb2NhbGVfdGhvdXNhbmRzID0gbG9jYWxlLnRob3VzYW5kcywgbG9jYWxlX2dyb3VwaW5nID0gbG9jYWxlLmdyb3VwaW5nLCBsb2NhbGVfY3VycmVuY3kgPSBsb2NhbGUuY3VycmVuY3ksIGZvcm1hdEdyb3VwID0gbG9jYWxlX2dyb3VwaW5nICYmIGxvY2FsZV90aG91c2FuZHMgPyBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICAgIHZhciBpID0gdmFsdWUubGVuZ3RoLCB0ID0gW10sIGogPSAwLCBnID0gbG9jYWxlX2dyb3VwaW5nWzBdLCBsZW5ndGggPSAwO1xuICAgICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICAgIGlmIChsZW5ndGggKyBnICsgMSA+IHdpZHRoKSBnID0gTWF0aC5tYXgoMSwgd2lkdGggLSBsZW5ndGgpO1xuICAgICAgICB0LnB1c2godmFsdWUuc3Vic3RyaW5nKGkgLT0gZywgaSArIGcpKTtcbiAgICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgICBnID0gbG9jYWxlX2dyb3VwaW5nW2ogPSAoaiArIDEpICUgbG9jYWxlX2dyb3VwaW5nLmxlbmd0aF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbihsb2NhbGVfdGhvdXNhbmRzKTtcbiAgICB9IDogZDNfaWRlbnRpdHk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIG1hdGNoID0gZDNfZm9ybWF0X3JlLmV4ZWMoc3BlY2lmaWVyKSwgZmlsbCA9IG1hdGNoWzFdIHx8IFwiIFwiLCBhbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiLCBzaWduID0gbWF0Y2hbM10gfHwgXCItXCIsIHN5bWJvbCA9IG1hdGNoWzRdIHx8IFwiXCIsIHpmaWxsID0gbWF0Y2hbNV0sIHdpZHRoID0gK21hdGNoWzZdLCBjb21tYSA9IG1hdGNoWzddLCBwcmVjaXNpb24gPSBtYXRjaFs4XSwgdHlwZSA9IG1hdGNoWzldLCBzY2FsZSA9IDEsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIGludGVnZXIgPSBmYWxzZSwgZXhwb25lbnQgPSB0cnVlO1xuICAgICAgaWYgKHByZWNpc2lvbikgcHJlY2lzaW9uID0gK3ByZWNpc2lvbi5zdWJzdHJpbmcoMSk7XG4gICAgICBpZiAoemZpbGwgfHwgZmlsbCA9PT0gXCIwXCIgJiYgYWxpZ24gPT09IFwiPVwiKSB7XG4gICAgICAgIHpmaWxsID0gZmlsbCA9IFwiMFwiO1xuICAgICAgICBhbGlnbiA9IFwiPVwiO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgY29tbWEgPSB0cnVlO1xuICAgICAgICB0eXBlID0gXCJnXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJmXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgc2NhbGUgPSAxMDA7XG4gICAgICAgIHN1ZmZpeCA9IFwiJVwiO1xuICAgICAgICB0eXBlID0gXCJyXCI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAgY2FzZSBcImJcIjpcbiAgICAgICBjYXNlIFwib1wiOlxuICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgaWYgKHN5bWJvbCA9PT0gXCIjXCIpIHByZWZpeCA9IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgZXhwb25lbnQgPSBmYWxzZTtcblxuICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgIGludGVnZXIgPSB0cnVlO1xuICAgICAgICBwcmVjaXNpb24gPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgIHNjYWxlID0gLTE7XG4gICAgICAgIHR5cGUgPSBcInJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3ltYm9sID09PSBcIiRcIikgcHJlZml4ID0gbG9jYWxlX2N1cnJlbmN5WzBdLCBzdWZmaXggPSBsb2NhbGVfY3VycmVuY3lbMV07XG4gICAgICBpZiAodHlwZSA9PSBcInJcIiAmJiAhcHJlY2lzaW9uKSB0eXBlID0gXCJnXCI7XG4gICAgICBpZiAocHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJnXCIpIHByZWNpc2lvbiA9IE1hdGgubWF4KDEsIE1hdGgubWluKDIxLCBwcmVjaXNpb24pKTsgZWxzZSBpZiAodHlwZSA9PSBcImVcIiB8fCB0eXBlID09IFwiZlwiKSBwcmVjaXNpb24gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyMCwgcHJlY2lzaW9uKSk7XG4gICAgICB9XG4gICAgICB0eXBlID0gZDNfZm9ybWF0X3R5cGVzLmdldCh0eXBlKSB8fCBkM19mb3JtYXRfdHlwZURlZmF1bHQ7XG4gICAgICB2YXIgemNvbW1hID0gemZpbGwgJiYgY29tbWE7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGZ1bGxTdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIGlmIChpbnRlZ2VyICYmIHZhbHVlICUgMSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBuZWdhdGl2ZSA9IHZhbHVlIDwgMCB8fCB2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwID8gKHZhbHVlID0gLXZhbHVlLCBcIi1cIikgOiBzaWduID09PSBcIi1cIiA/IFwiXCIgOiBzaWduO1xuICAgICAgICBpZiAoc2NhbGUgPCAwKSB7XG4gICAgICAgICAgdmFyIHVuaXQgPSBkMy5mb3JtYXRQcmVmaXgodmFsdWUsIHByZWNpc2lvbik7XG4gICAgICAgICAgdmFsdWUgPSB1bml0LnNjYWxlKHZhbHVlKTtcbiAgICAgICAgICBmdWxsU3VmZml4ID0gdW5pdC5zeW1ib2wgKyBzdWZmaXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgKj0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB0eXBlKHZhbHVlLCBwcmVjaXNpb24pO1xuICAgICAgICB2YXIgaSA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKSwgYmVmb3JlLCBhZnRlcjtcbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgdmFyIGogPSBleHBvbmVudCA/IHZhbHVlLmxhc3RJbmRleE9mKFwiZVwiKSA6IC0xO1xuICAgICAgICAgIGlmIChqIDwgMCkgYmVmb3JlID0gdmFsdWUsIGFmdGVyID0gXCJcIjsgZWxzZSBiZWZvcmUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgaiksIGFmdGVyID0gdmFsdWUuc3Vic3RyaW5nKGopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IHZhbHVlLnN1YnN0cmluZygwLCBpKTtcbiAgICAgICAgICBhZnRlciA9IGxvY2FsZV9kZWNpbWFsICsgdmFsdWUuc3Vic3RyaW5nKGkgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpmaWxsICYmIGNvbW1hKSBiZWZvcmUgPSBmb3JtYXRHcm91cChiZWZvcmUsIEluZmluaXR5KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHByZWZpeC5sZW5ndGggKyBiZWZvcmUubGVuZ3RoICsgYWZ0ZXIubGVuZ3RoICsgKHpjb21tYSA/IDAgOiBuZWdhdGl2ZS5sZW5ndGgpLCBwYWRkaW5nID0gbGVuZ3RoIDwgd2lkdGggPyBuZXcgQXJyYXkobGVuZ3RoID0gd2lkdGggLSBsZW5ndGggKyAxKS5qb2luKGZpbGwpIDogXCJcIjtcbiAgICAgICAgaWYgKHpjb21tYSkgYmVmb3JlID0gZm9ybWF0R3JvdXAocGFkZGluZyArIGJlZm9yZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIGFmdGVyLmxlbmd0aCA6IEluZmluaXR5KTtcbiAgICAgICAgbmVnYXRpdmUgKz0gcHJlZml4O1xuICAgICAgICB2YWx1ZSA9IGJlZm9yZSArIGFmdGVyO1xuICAgICAgICByZXR1cm4gKGFsaWduID09PSBcIjxcIiA/IG5lZ2F0aXZlICsgdmFsdWUgKyBwYWRkaW5nIDogYWxpZ24gPT09IFwiPlwiID8gcGFkZGluZyArIG5lZ2F0aXZlICsgdmFsdWUgOiBhbGlnbiA9PT0gXCJeXCIgPyBwYWRkaW5nLnN1YnN0cmluZygwLCBsZW5ndGggPj49IDEpICsgbmVnYXRpdmUgKyB2YWx1ZSArIHBhZGRpbmcuc3Vic3RyaW5nKGxlbmd0aCkgOiBuZWdhdGl2ZSArICh6Y29tbWEgPyB2YWx1ZSA6IHBhZGRpbmcgKyB2YWx1ZSkpICsgZnVsbFN1ZmZpeDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICB2YXIgZDNfZm9ybWF0X3JlID0gLyg/OihbXntdKT8oWzw+PV5dKSk/KFsrXFwtIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuLT9cXGQrKT8oW2EteiVdKT8vaTtcbiAgdmFyIGQzX2Zvcm1hdF90eXBlcyA9IGQzLm1hcCh7XG4gICAgYjogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMik7XG4gICAgfSxcbiAgICBjOiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh4KTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4LnRvU3RyaW5nKDgpO1xuICAgIH0sXG4gICAgeDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpO1xuICAgIH0sXG4gICAgWDogZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfSxcbiAgICBnOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b1ByZWNpc2lvbihwKTtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uKHgsIHApIHtcbiAgICAgIHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7XG4gICAgfSxcbiAgICBmOiBmdW5jdGlvbih4LCBwKSB7XG4gICAgICByZXR1cm4geC50b0ZpeGVkKHApO1xuICAgIH0sXG4gICAgcjogZnVuY3Rpb24oeCwgcCkge1xuICAgICAgcmV0dXJuICh4ID0gZDMucm91bmQoeCwgZDNfZm9ybWF0X3ByZWNpc2lvbih4LCBwKSkpLnRvRml4ZWQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIGQzX2Zvcm1hdF9wcmVjaXNpb24oeCAqICgxICsgMWUtMTUpLCBwKSkpKTtcbiAgICB9XG4gIH0pO1xuICBmdW5jdGlvbiBkM19mb3JtYXRfdHlwZURlZmF1bHQoeCkge1xuICAgIHJldHVybiB4ICsgXCJcIjtcbiAgfVxuICB2YXIgZDNfdGltZSA9IGQzLnRpbWUgPSB7fSwgZDNfZGF0ZSA9IERhdGU7XG4gIGZ1bmN0aW9uIGQzX2RhdGVfdXRjKCkge1xuICAgIHRoaXMuXyA9IG5ldyBEYXRlKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gRGF0ZS5VVEMuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGFyZ3VtZW50c1swXSk7XG4gIH1cbiAgZDNfZGF0ZV91dGMucHJvdG90eXBlID0ge1xuICAgIGdldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXRlKCk7XG4gICAgfSxcbiAgICBnZXREYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENEYXkoKTtcbiAgICB9LFxuICAgIGdldEZ1bGxZZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9LFxuICAgIGdldEhvdXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDSG91cnMoKTtcbiAgICB9LFxuICAgIGdldE1pbGxpc2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgIH0sXG4gICAgZ2V0TWludXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fLmdldFVUQ01pbnV0ZXMoKTtcbiAgICB9LFxuICAgIGdldE1vbnRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VVRDTW9udGgoKTtcbiAgICB9LFxuICAgIGdldFNlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuXy5nZXRVVENTZWNvbmRzKCk7XG4gICAgfSxcbiAgICBnZXRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8uZ2V0VGltZSgpO1xuICAgIH0sXG4gICAgZ2V0VGltZXpvbmVPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl8udmFsdWVPZigpO1xuICAgIH0sXG4gICAgc2V0RGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXRlLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldERheTogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENEYXkuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0RnVsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDRnVsbFllYXIuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0SG91cnM6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDSG91cnMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TWlsbGlzZWNvbmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbGxpc2Vjb25kcy5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBzZXRNaW51dGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX3RpbWVfcHJvdG90eXBlLnNldFVUQ01pbnV0ZXMuYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0TW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VVRDTW9udGguYXBwbHkodGhpcy5fLCBhcmd1bWVudHMpO1xuICAgIH0sXG4gICAgc2V0U2Vjb25kczogZnVuY3Rpb24oKSB7XG4gICAgICBkM190aW1lX3Byb3RvdHlwZS5zZXRVVENTZWNvbmRzLmFwcGx5KHRoaXMuXywgYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfdGltZV9wcm90b3R5cGUuc2V0VGltZS5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuICB2YXIgZDNfdGltZV9wcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbiAgZnVuY3Rpb24gZDNfdGltZV9pbnRlcnZhbChsb2NhbCwgc3RlcCwgbnVtYmVyKSB7XG4gICAgZnVuY3Rpb24gcm91bmQoZGF0ZSkge1xuICAgICAgdmFyIGQwID0gbG9jYWwoZGF0ZSksIGQxID0gb2Zmc2V0KGQwLCAxKTtcbiAgICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZWlsKGRhdGUpIHtcbiAgICAgIHN0ZXAoZGF0ZSA9IGxvY2FsKG5ldyBkM19kYXRlKGRhdGUgLSAxKSksIDEpO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZnNldChkYXRlLCBrKSB7XG4gICAgICBzdGVwKGRhdGUgPSBuZXcgZDNfZGF0ZSgrZGF0ZSksIGspO1xuICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlKHQwLCB0MSwgZHQpIHtcbiAgICAgIHZhciB0aW1lID0gY2VpbCh0MCksIHRpbWVzID0gW107XG4gICAgICBpZiAoZHQgPiAxKSB7XG4gICAgICAgIHdoaWxlICh0aW1lIDwgdDEpIHtcbiAgICAgICAgICBpZiAoIShudW1iZXIodGltZSkgJSBkdCkpIHRpbWVzLnB1c2gobmV3IERhdGUoK3RpbWUpKTtcbiAgICAgICAgICBzdGVwKHRpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAodGltZSA8IHQxKSB0aW1lcy5wdXNoKG5ldyBEYXRlKCt0aW1lKSksIHN0ZXAodGltZSwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmdlX3V0Yyh0MCwgdDEsIGR0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBkM19kYXRlID0gZDNfZGF0ZV91dGM7XG4gICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZV91dGMoKTtcbiAgICAgICAgdXRjLl8gPSB0MDtcbiAgICAgICAgcmV0dXJuIHJhbmdlKHV0YywgdDEsIGR0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX2RhdGUgPSBEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBsb2NhbC5mbG9vciA9IGxvY2FsO1xuICAgIGxvY2FsLnJvdW5kID0gcm91bmQ7XG4gICAgbG9jYWwuY2VpbCA9IGNlaWw7XG4gICAgbG9jYWwub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxvY2FsLnJhbmdlID0gcmFuZ2U7XG4gICAgdmFyIHV0YyA9IGxvY2FsLnV0YyA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKGxvY2FsKTtcbiAgICB1dGMuZmxvb3IgPSB1dGM7XG4gICAgdXRjLnJvdW5kID0gZDNfdGltZV9pbnRlcnZhbF91dGMocm91bmQpO1xuICAgIHV0Yy5jZWlsID0gZDNfdGltZV9pbnRlcnZhbF91dGMoY2VpbCk7XG4gICAgdXRjLm9mZnNldCA9IGQzX3RpbWVfaW50ZXJ2YWxfdXRjKG9mZnNldCk7XG4gICAgdXRjLnJhbmdlID0gcmFuZ2VfdXRjO1xuICAgIHJldHVybiBsb2NhbDtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2ludGVydmFsX3V0YyhtZXRob2QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgaykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICB2YXIgdXRjID0gbmV3IGQzX2RhdGVfdXRjKCk7XG4gICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgcmV0dXJuIG1ldGhvZCh1dGMsIGspLl87XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGQzX3RpbWUueWVhciA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIGRhdGUgPSBkM190aW1lLmRheShkYXRlKTtcbiAgICBkYXRlLnNldE1vbnRoKDAsIDEpO1xuICAgIHJldHVybiBkYXRlO1xuICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICB9KTtcbiAgZDNfdGltZS55ZWFycyA9IGQzX3RpbWUueWVhci5yYW5nZTtcbiAgZDNfdGltZS55ZWFycy51dGMgPSBkM190aW1lLnllYXIudXRjLnJhbmdlO1xuICBkM190aW1lLmRheSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciBkYXkgPSBuZXcgZDNfZGF0ZSgyZTMsIDApO1xuICAgIGRheS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgIHJldHVybiBkYXk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIG9mZnNldCkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIG9mZnNldCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXREYXRlKCkgLSAxO1xuICB9KTtcbiAgZDNfdGltZS5kYXlzID0gZDNfdGltZS5kYXkucmFuZ2U7XG4gIGQzX3RpbWUuZGF5cy51dGMgPSBkM190aW1lLmRheS51dGMucmFuZ2U7XG4gIGQzX3RpbWUuZGF5T2ZZZWFyID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHZhciB5ZWFyID0gZDNfdGltZS55ZWFyKGRhdGUpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlIC0geWVhciAtIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSB5ZWFyLmdldFRpbWV6b25lT2Zmc2V0KCkpICogNmU0KSAvIDg2NGU1KTtcbiAgfTtcbiAgWyBcInN1bmRheVwiLCBcIm1vbmRheVwiLCBcInR1ZXNkYXlcIiwgXCJ3ZWRuZXNkYXlcIiwgXCJ0aHVyc2RheVwiLCBcImZyaWRheVwiLCBcInNhdHVyZGF5XCIgXS5mb3JFYWNoKGZ1bmN0aW9uKGRheSwgaSkge1xuICAgIGkgPSA3IC0gaTtcbiAgICB2YXIgaW50ZXJ2YWwgPSBkM190aW1lW2RheV0gPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIChkYXRlID0gZDNfdGltZS5kYXkoZGF0ZSkpLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAoZGF0ZS5nZXREYXkoKSArIGkpICUgNyk7XG4gICAgICByZXR1cm4gZGF0ZTtcbiAgICB9LCBmdW5jdGlvbihkYXRlLCBvZmZzZXQpIHtcbiAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIE1hdGguZmxvb3Iob2Zmc2V0KSAqIDcpO1xuICAgIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpIC0gKGRheSAhPT0gaSk7XG4gICAgfSk7XG4gICAgZDNfdGltZVtkYXkgKyBcInNcIl0gPSBpbnRlcnZhbC5yYW5nZTtcbiAgICBkM190aW1lW2RheSArIFwic1wiXS51dGMgPSBpbnRlcnZhbC51dGMucmFuZ2U7XG4gICAgZDNfdGltZVtkYXkgKyBcIk9mWWVhclwiXSA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBkYXkgPSBkM190aW1lLnllYXIoZGF0ZSkuZ2V0RGF5KCk7XG4gICAgICByZXR1cm4gTWF0aC5mbG9vcigoZDNfdGltZS5kYXlPZlllYXIoZGF0ZSkgKyAoZGF5ICsgaSkgJSA3KSAvIDcpO1xuICAgIH07XG4gIH0pO1xuICBkM190aW1lLndlZWsgPSBkM190aW1lLnN1bmRheTtcbiAgZDNfdGltZS53ZWVrcyA9IGQzX3RpbWUuc3VuZGF5LnJhbmdlO1xuICBkM190aW1lLndlZWtzLnV0YyA9IGQzX3RpbWUuc3VuZGF5LnV0Yy5yYW5nZTtcbiAgZDNfdGltZS53ZWVrT2ZZZWFyID0gZDNfdGltZS5zdW5kYXlPZlllYXI7XG4gIGZ1bmN0aW9uIGQzX2xvY2FsZV90aW1lRm9ybWF0KGxvY2FsZSkge1xuICAgIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsIGxvY2FsZV9kYXRlID0gbG9jYWxlLmRhdGUsIGxvY2FsZV90aW1lID0gbG9jYWxlLnRpbWUsIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsIGxvY2FsZV9kYXlzID0gbG9jYWxlLmRheXMsIGxvY2FsZV9zaG9ydERheXMgPSBsb2NhbGUuc2hvcnREYXlzLCBsb2NhbGVfbW9udGhzID0gbG9jYWxlLm1vbnRocywgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKSB7XG4gICAgICB2YXIgbiA9IHRlbXBsYXRlLmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBbXSwgaSA9IC0xLCBqID0gMCwgYywgcCwgZjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICAgIHN0cmluZy5wdXNoKHRlbXBsYXRlLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgIGlmICgocCA9IGQzX3RpbWVfZm9ybWF0UGFkc1tjID0gdGVtcGxhdGUuY2hhckF0KCsraSldKSAhPSBudWxsKSBjID0gdGVtcGxhdGUuY2hhckF0KCsraSk7XG4gICAgICAgICAgICBpZiAoZiA9IGQzX3RpbWVfZm9ybWF0c1tjXSkgYyA9IGYoZGF0ZSwgcCA9PSBudWxsID8gYyA9PT0gXCJlXCIgPyBcIiBcIiA6IFwiMFwiIDogcCk7XG4gICAgICAgICAgICBzdHJpbmcucHVzaChjKTtcbiAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyaW5nLnB1c2godGVtcGxhdGUuc2xpY2UoaiwgaSkpO1xuICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgICBmb3JtYXQucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIGQgPSB7XG4gICAgICAgICAgeTogMTkwMCxcbiAgICAgICAgICBtOiAwLFxuICAgICAgICAgIGQ6IDEsXG4gICAgICAgICAgSDogMCxcbiAgICAgICAgICBNOiAwLFxuICAgICAgICAgIFM6IDAsXG4gICAgICAgICAgTDogMCxcbiAgICAgICAgICBaOiBudWxsXG4gICAgICAgIH0sIGkgPSBkM190aW1lX3BhcnNlKGQsIHRlbXBsYXRlLCBzdHJpbmcsIDApO1xuICAgICAgICBpZiAoaSAhPSBzdHJpbmcubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG4gICAgICAgIHZhciBsb2NhbFogPSBkLlogIT0gbnVsbCAmJiBkM19kYXRlICE9PSBkM19kYXRlX3V0YywgZGF0ZSA9IG5ldyAobG9jYWxaID8gZDNfZGF0ZV91dGMgOiBkM19kYXRlKSgpO1xuICAgICAgICBpZiAoXCJqXCIgaW4gZCkgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIGQuaik7IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICAgIGlmICghKFwid1wiIGluIGQpKSBkLncgPSBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcihkLnksIDAsIDEpO1xuICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoZC55LCAwLCBcIldcIiBpbiBkID8gKGQudyArIDYpICUgNyArIGQuVyAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDUpICUgNyA6IGQudyArIGQuVSAqIDcgLSAoZGF0ZS5nZXREYXkoKSArIDYpICUgNyk7XG4gICAgICAgIH0gZWxzZSBkYXRlLnNldEZ1bGxZZWFyKGQueSwgZC5tLCBkLmQpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGQuSCArIChkLlogLyAxMDAgfCAwKSwgZC5NICsgZC5aICUgMTAwLCBkLlMsIGQuTCk7XG4gICAgICAgIHJldHVybiBsb2NhbFogPyBkYXRlLl8gOiBkYXRlO1xuICAgICAgfTtcbiAgICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZShkYXRlLCB0ZW1wbGF0ZSwgc3RyaW5nLCBqKSB7XG4gICAgICB2YXIgYywgcCwgdCwgaSA9IDAsIG4gPSB0ZW1wbGF0ZS5sZW5ndGgsIG0gPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBuKSB7XG4gICAgICAgIGlmIChqID49IG0pIHJldHVybiAtMTtcbiAgICAgICAgYyA9IHRlbXBsYXRlLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgdCA9IHRlbXBsYXRlLmNoYXJBdChpKyspO1xuICAgICAgICAgIHAgPSBkM190aW1lX3BhcnNlcnNbdCBpbiBkM190aW1lX2Zvcm1hdFBhZHMgPyB0ZW1wbGF0ZS5jaGFyQXQoaSsrKSA6IHRdO1xuICAgICAgICAgIGlmICghcCB8fCAoaiA9IHAoZGF0ZSwgc3RyaW5nLCBqKSkgPCAwKSByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPSBzdHJpbmcuY2hhckNvZGVBdChqKyspKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gajtcbiAgICB9XG4gICAgZDNfdGltZV9mb3JtYXQudXRjID0gZnVuY3Rpb24odGVtcGxhdGUpIHtcbiAgICAgIHZhciBsb2NhbCA9IGQzX3RpbWVfZm9ybWF0KHRlbXBsYXRlKTtcbiAgICAgIGZ1bmN0aW9uIGZvcm1hdChkYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciB1dGMgPSBuZXcgZDNfZGF0ZSgpO1xuICAgICAgICAgIHV0Yy5fID0gZGF0ZTtcbiAgICAgICAgICByZXR1cm4gbG9jYWwodXRjKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBkM19kYXRlID0gRGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9ybWF0LnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IGQzX2RhdGVfdXRjO1xuICAgICAgICAgIHZhciBkYXRlID0gbG9jYWwucGFyc2Uoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZSAmJiBkYXRlLl87XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZDNfZGF0ZSA9IERhdGU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3JtYXQudG9TdHJpbmcgPSBsb2NhbC50b1N0cmluZztcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBkM190aW1lX2Zvcm1hdC5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0LnV0Yy5tdWx0aSA9IGQzX3RpbWVfZm9ybWF0TXVsdGk7XG4gICAgdmFyIGQzX3RpbWVfcGVyaW9kTG9va3VwID0gZDMubWFwKCksIGQzX3RpbWVfZGF5UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9kYXlzKSwgZDNfdGltZV9kYXlMb29rdXAgPSBkM190aW1lX2Zvcm1hdExvb2t1cChsb2NhbGVfZGF5cyksIGQzX3RpbWVfZGF5QWJicmV2UmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX2RheUFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydERheXMpLCBkM190aW1lX21vbnRoUmUgPSBkM190aW1lX2Zvcm1hdFJlKGxvY2FsZV9tb250aHMpLCBkM190aW1lX21vbnRoTG9va3VwID0gZDNfdGltZV9mb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksIGQzX3RpbWVfbW9udGhBYmJyZXZSZSA9IGQzX3RpbWVfZm9ybWF0UmUobG9jYWxlX3Nob3J0TW9udGhzKSwgZDNfdGltZV9tb250aEFiYnJldkxvb2t1cCA9IGQzX3RpbWVfZm9ybWF0TG9va3VwKGxvY2FsZV9zaG9ydE1vbnRocyk7XG4gICAgbG9jYWxlX3BlcmlvZHMuZm9yRWFjaChmdW5jdGlvbihwLCBpKSB7XG4gICAgICBkM190aW1lX3BlcmlvZExvb2t1cC5zZXQocC50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICB9KTtcbiAgICB2YXIgZDNfdGltZV9mb3JtYXRzID0ge1xuICAgICAgYTogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3Nob3J0RGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBBOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfZGF5c1tkLmdldERheSgpXTtcbiAgICAgIH0sXG4gICAgICBiOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgICAgIH0sXG4gICAgICBCOiBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGVfbW9udGhzW2QuZ2V0TW9udGgoKV07XG4gICAgICB9LFxuICAgICAgYzogZDNfdGltZV9mb3JtYXQobG9jYWxlX2RhdGVUaW1lKSxcbiAgICAgIGQ6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBlOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldERhdGUoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgSDogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRIb3VycygpLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBJOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldEhvdXJzKCkgJSAxMiB8fCAxMiwgcCwgMik7XG4gICAgICB9LFxuICAgICAgajogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoMSArIGQzX3RpbWUuZGF5T2ZZZWFyKGQpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBMOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbGxpc2Vjb25kcygpLCBwLCAzKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1vbnRoKCkgKyAxLCBwLCAyKTtcbiAgICAgIH0sXG4gICAgICBNOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldE1pbnV0ZXMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgcDogZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgICAgIH0sXG4gICAgICBTOiBmdW5jdGlvbihkLCBwKSB7XG4gICAgICAgIHJldHVybiBkM190aW1lX2Zvcm1hdFBhZChkLmdldFNlY29uZHMoKSwgcCwgMik7XG4gICAgICB9LFxuICAgICAgVTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5zdW5kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0RGF5KCk7XG4gICAgICB9LFxuICAgICAgVzogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZDNfdGltZS5tb25kYXlPZlllYXIoZCksIHAsIDIpO1xuICAgICAgfSxcbiAgICAgIHg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV9kYXRlKSxcbiAgICAgIFg6IGQzX3RpbWVfZm9ybWF0KGxvY2FsZV90aW1lKSxcbiAgICAgIHk6IGZ1bmN0aW9uKGQsIHApIHtcbiAgICAgICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0UGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgcCwgMik7XG4gICAgICB9LFxuICAgICAgWTogZnVuY3Rpb24oZCwgcCkge1xuICAgICAgICByZXR1cm4gZDNfdGltZV9mb3JtYXRQYWQoZC5nZXRGdWxsWWVhcigpICUgMWU0LCBwLCA0KTtcbiAgICAgIH0sXG4gICAgICBaOiBkM190aW1lX3pvbmUsXG4gICAgICBcIiVcIjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIiVcIjtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBkM190aW1lX3BhcnNlcnMgPSB7XG4gICAgICBhOiBkM190aW1lX3BhcnNlV2Vla2RheUFiYnJldixcbiAgICAgIEE6IGQzX3RpbWVfcGFyc2VXZWVrZGF5LFxuICAgICAgYjogZDNfdGltZV9wYXJzZU1vbnRoQWJicmV2LFxuICAgICAgQjogZDNfdGltZV9wYXJzZU1vbnRoLFxuICAgICAgYzogZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwsXG4gICAgICBkOiBkM190aW1lX3BhcnNlRGF5LFxuICAgICAgZTogZDNfdGltZV9wYXJzZURheSxcbiAgICAgIEg6IGQzX3RpbWVfcGFyc2VIb3VyMjQsXG4gICAgICBJOiBkM190aW1lX3BhcnNlSG91cjI0LFxuICAgICAgajogZDNfdGltZV9wYXJzZURheU9mWWVhcixcbiAgICAgIEw6IGQzX3RpbWVfcGFyc2VNaWxsaXNlY29uZHMsXG4gICAgICBtOiBkM190aW1lX3BhcnNlTW9udGhOdW1iZXIsXG4gICAgICBNOiBkM190aW1lX3BhcnNlTWludXRlcyxcbiAgICAgIHA6IGQzX3RpbWVfcGFyc2VBbVBtLFxuICAgICAgUzogZDNfdGltZV9wYXJzZVNlY29uZHMsXG4gICAgICBVOiBkM190aW1lX3BhcnNlV2Vla051bWJlclN1bmRheSxcbiAgICAgIHc6IGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyLFxuICAgICAgVzogZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXksXG4gICAgICB4OiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZSxcbiAgICAgIFg6IGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lLFxuICAgICAgeTogZDNfdGltZV9wYXJzZVllYXIsXG4gICAgICBZOiBkM190aW1lX3BhcnNlRnVsbFllYXIsXG4gICAgICBaOiBkM190aW1lX3BhcnNlWm9uZSxcbiAgICAgIFwiJVwiOiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5QWJicmV2KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheUFiYnJldlJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5QWJicmV2TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgZDNfdGltZV9kYXlSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX2RheVJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUudyA9IGQzX3RpbWVfZGF5TG9va3VwLmdldChuWzBdLnRvTG93ZXJDYXNlKCkpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aEFiYnJldihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIGQzX3RpbWVfbW9udGhBYmJyZXZSZS5sYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG4gPSBkM190aW1lX21vbnRoQWJicmV2UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gZDNfdGltZV9tb250aEFiYnJldkxvb2t1cC5nZXQoblswXS50b0xvd2VyQ2FzZSgpKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTW9udGgoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICBkM190aW1lX21vbnRoUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBuID0gZDNfdGltZV9tb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICAgIHJldHVybiBuID8gKGRhdGUubSA9IGQzX3RpbWVfbW9udGhMb29rdXAuZ2V0KG5bMF0udG9Mb3dlckNhc2UoKSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUxvY2FsZUZ1bGwoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9wYXJzZShkYXRlLCBkM190aW1lX2Zvcm1hdHMuYy50b1N0cmluZygpLCBzdHJpbmcsIGkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTG9jYWxlRGF0ZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICAgIHJldHVybiBkM190aW1lX3BhcnNlKGRhdGUsIGQzX3RpbWVfZm9ybWF0cy54LnRvU3RyaW5nKCksIHN0cmluZywgaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VMb2NhbGVUaW1lKGRhdGUsIHN0cmluZywgaSkge1xuICAgICAgcmV0dXJuIGQzX3RpbWVfcGFyc2UoZGF0ZSwgZDNfdGltZV9mb3JtYXRzLlgudG9TdHJpbmcoKSwgc3RyaW5nLCBpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUFtUG0oZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgICB2YXIgbiA9IGQzX3RpbWVfcGVyaW9kTG9va3VwLmdldChzdHJpbmcuc2xpY2UoaSwgaSArPSAyKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIHJldHVybiBuID09IG51bGwgPyAtMSA6IChkYXRlLnAgPSBuLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzX3RpbWVfZm9ybWF0O1xuICB9XG4gIHZhciBkM190aW1lX2Zvcm1hdFBhZHMgPSB7XG4gICAgXCItXCI6IFwiXCIsXG4gICAgXzogXCIgXCIsXG4gICAgXCIwXCI6IFwiMFwiXG4gIH0sIGQzX3RpbWVfbnVtYmVyUmUgPSAvXlxccypcXGQrLywgZDNfdGltZV9wZXJjZW50UmUgPSAvXiUvO1xuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdFBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMCA/IFwiLVwiIDogXCJcIiwgc3RyaW5nID0gKHNpZ24gPyAtdmFsdWUgOiB2YWx1ZSkgKyBcIlwiLCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHJldHVybiBzaWduICsgKGxlbmd0aCA8IHdpZHRoID8gbmV3IEFycmF5KHdpZHRoIC0gbGVuZ3RoICsgMSkuam9pbihmaWxsKSArIHN0cmluZyA6IHN0cmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9mb3JtYXRSZShuYW1lcykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgbmFtZXMubWFwKGQzLnJlcXVvdGUpLmpvaW4oXCJ8XCIpICsgXCIpXCIsIFwiaVwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdExvb2t1cChuYW1lcykge1xuICAgIHZhciBtYXAgPSBuZXcgZDNfTWFwKCksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgbWFwLnNldChuYW1lc1tpXS50b0xvd2VyQ2FzZSgpLCBpKTtcbiAgICByZXR1cm4gbWFwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrZGF5TnVtYmVyKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGRhdGUuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVdlZWtOdW1iZXJNb25kYXkoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRnVsbFllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZVllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICAgIHJldHVybiBuID8gKGRhdGUueSA9IGQzX3RpbWVfZXhwYW5kWWVhcigrblswXSksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlWm9uZShkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICByZXR1cm4gL15bKy1dXFxkezR9JC8udGVzdChzdHJpbmcgPSBzdHJpbmcuc2xpY2UoaSwgaSArIDUpKSA/IChkYXRlLlogPSAtc3RyaW5nLCBcbiAgICBpICsgNSkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2V4cGFuZFllYXIoZCkge1xuICAgIHJldHVybiBkICsgKGQgPiA2OCA/IDE5MDAgOiAyZTMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VNb250aE51bWJlcihkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlRGF5KGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLmQgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfcGFyc2VEYXlPZlllYXIoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9udW1iZXJSZS5sYXN0SW5kZXggPSAwO1xuICAgIHZhciBuID0gZDNfdGltZV9udW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMykpO1xuICAgIHJldHVybiBuID8gKGRhdGUuaiA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdGltZV9wYXJzZUhvdXIyNChkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5IID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWludXRlcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5NID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlU2Vjb25kcyhkYXRlLCBzdHJpbmcsIGkpIHtcbiAgICBkM190aW1lX251bWJlclJlLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIG4gPSBkM190aW1lX251bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gICAgcmV0dXJuIG4gPyAoZGF0ZS5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTWlsbGlzZWNvbmRzKGRhdGUsIHN0cmluZywgaSkge1xuICAgIGQzX3RpbWVfbnVtYmVyUmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgICByZXR1cm4gbiA/IChkYXRlLkwgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RpbWVfem9uZShkKSB7XG4gICAgdmFyIHogPSBkLmdldFRpbWV6b25lT2Zmc2V0KCksIHpzID0geiA+IDAgPyBcIi1cIiA6IFwiK1wiLCB6aCA9IGFicyh6KSAvIDYwIHwgMCwgem0gPSBhYnMoeikgJSA2MDtcbiAgICByZXR1cm4genMgKyBkM190aW1lX2Zvcm1hdFBhZCh6aCwgXCIwXCIsIDIpICsgZDNfdGltZV9mb3JtYXRQYWQoem0sIFwiMFwiLCAyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3BhcnNlTGl0ZXJhbFBlcmNlbnQoZGF0ZSwgc3RyaW5nLCBpKSB7XG4gICAgZDNfdGltZV9wZXJjZW50UmUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbiA9IGQzX3RpbWVfcGVyY2VudFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAxKSk7XG4gICAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX2Zvcm1hdE11bHRpKGZvcm1hdHMpIHtcbiAgICB2YXIgbiA9IGZvcm1hdHMubGVuZ3RoLCBpID0gLTE7XG4gICAgd2hpbGUgKCsraSA8IG4pIGZvcm1hdHNbaV1bMF0gPSB0aGlzKGZvcm1hdHNbaV1bMF0pO1xuICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICB2YXIgaSA9IDAsIGYgPSBmb3JtYXRzW2ldO1xuICAgICAgd2hpbGUgKCFmWzFdKGRhdGUpKSBmID0gZm9ybWF0c1srK2ldO1xuICAgICAgcmV0dXJuIGZbMF0oZGF0ZSk7XG4gICAgfTtcbiAgfVxuICBkMy5sb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyRm9ybWF0OiBkM19sb2NhbGVfbnVtYmVyRm9ybWF0KGxvY2FsZSksXG4gICAgICB0aW1lRm9ybWF0OiBkM19sb2NhbGVfdGltZUZvcm1hdChsb2NhbGUpXG4gICAgfTtcbiAgfTtcbiAgdmFyIGQzX2xvY2FsZV9lblVTID0gZDMubG9jYWxlKHtcbiAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB0aG91c2FuZHM6IFwiLFwiLFxuICAgIGdyb3VwaW5nOiBbIDMgXSxcbiAgICBjdXJyZW5jeTogWyBcIiRcIiwgXCJcIiBdLFxuICAgIGRhdGVUaW1lOiBcIiVhICViICVlICVYICVZXCIsXG4gICAgZGF0ZTogXCIlbS8lZC8lWVwiLFxuICAgIHRpbWU6IFwiJUg6JU06JVNcIixcbiAgICBwZXJpb2RzOiBbIFwiQU1cIiwgXCJQTVwiIF0sXG4gICAgZGF5czogWyBcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIgXSxcbiAgICBzaG9ydERheXM6IFsgXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiBdLFxuICAgIG1vbnRoczogWyBcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIgXSxcbiAgICBzaG9ydE1vbnRoczogWyBcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiIF1cbiAgfSk7XG4gIGQzLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLm51bWJlckZvcm1hdDtcbiAgZDMuZ2VvID0ge307XG4gIGZ1bmN0aW9uIGQzX2FkZGVyKCkge31cbiAgZDNfYWRkZXIucHJvdG90eXBlID0ge1xuICAgIHM6IDAsXG4gICAgdDogMCxcbiAgICBhZGQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgIGQzX2FkZGVyU3VtKHksIHRoaXMudCwgZDNfYWRkZXJUZW1wKTtcbiAgICAgIGQzX2FkZGVyU3VtKGQzX2FkZGVyVGVtcC5zLCB0aGlzLnMsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucykgdGhpcy50ICs9IGQzX2FkZGVyVGVtcC50OyBlbHNlIHRoaXMucyA9IGQzX2FkZGVyVGVtcC50O1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zID0gdGhpcy50ID0gMDtcbiAgICB9LFxuICAgIHZhbHVlT2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucztcbiAgICB9XG4gIH07XG4gIHZhciBkM19hZGRlclRlbXAgPSBuZXcgZDNfYWRkZXIoKTtcbiAgZnVuY3Rpb24gZDNfYWRkZXJTdW0oYSwgYiwgbykge1xuICAgIHZhciB4ID0gby5zID0gYSArIGIsIGJ2ID0geCAtIGEsIGF2ID0geCAtIGJ2O1xuICAgIG8udCA9IGEgLSBhdiArIChiIC0gYnYpO1xuICB9XG4gIGQzLmdlby5zdHJlYW0gPSBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgaWYgKG9iamVjdCAmJiBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZS5oYXNPd25Qcm9wZXJ0eShvYmplY3QudHlwZSkpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1PYmplY3RUeXBlW29iamVjdC50eXBlXShvYmplY3QsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KG9iamVjdCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBsaXN0ZW5lcikge1xuICAgIGlmIChnZW9tZXRyeSAmJiBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlLmhhc093blByb3BlcnR5KGdlb21ldHJ5LnR5cGUpKSB7XG4gICAgICBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlW2dlb21ldHJ5LnR5cGVdKGdlb21ldHJ5LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIHZhciBkM19nZW9fc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgICBGZWF0dXJlOiBmdW5jdGlvbihmZWF0dXJlLCBsaXN0ZW5lcikge1xuICAgICAgZDNfZ2VvX3N0cmVhbUdlb21ldHJ5KGZlYXR1cmUuZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZmVhdHVyZXMgPSBvYmplY3QuZmVhdHVyZXMsIGkgPSAtMSwgbiA9IGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZmVhdHVyZXNbaV0uZ2VvbWV0cnksIGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG4gIHZhciBkM19nZW9fc3RyZWFtR2VvbWV0cnlUeXBlID0ge1xuICAgIFNwaGVyZTogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIuc3BoZXJlKCk7XG4gICAgfSxcbiAgICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgICAgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBvYmplY3QgPSBjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIucG9pbnQob2JqZWN0WzBdLCBvYmplY3RbMV0sIG9iamVjdFsyXSk7XG4gICAgfSxcbiAgICBMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICBkM19nZW9fc3RyZWFtTGluZShvYmplY3QuY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLCAwKTtcbiAgICB9LFxuICAgIFBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgbGlzdGVuZXIpIHtcbiAgICAgIGQzX2dlb19zdHJlYW1Qb2x5Z29uKG9iamVjdC5jb29yZGluYXRlcywgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3N0cmVhbUxpbmUoY29vcmRpbmF0ZXMsIGxpc3RlbmVyLCBjbG9zZWQpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gY2xvc2VkLCBjb29yZGluYXRlO1xuICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBjb29yZGluYXRlID0gY29vcmRpbmF0ZXNbaV0sIGxpc3RlbmVyLnBvaW50KGNvb3JkaW5hdGVbMF0sIGNvb3JkaW5hdGVbMV0sIGNvb3JkaW5hdGVbMl0pO1xuICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fc3RyZWFtUG9seWdvbihjb29yZGluYXRlcywgbGlzdGVuZXIpIHtcbiAgICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpO1xuICAgIHdoaWxlICgrK2kgPCBuKSBkM19nZW9fc3RyZWFtTGluZShjb29yZGluYXRlc1tpXSwgbGlzdGVuZXIsIDEpO1xuICAgIGxpc3RlbmVyLnBvbHlnb25FbmQoKTtcbiAgfVxuICBkMy5nZW8uYXJlYSA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19hcmVhU3VtID0gMDtcbiAgICBkMy5nZW8uc3RyZWFtKG9iamVjdCwgZDNfZ2VvX2FyZWEpO1xuICAgIHJldHVybiBkM19nZW9fYXJlYVN1bTtcbiAgfTtcbiAgdmFyIGQzX2dlb19hcmVhU3VtLCBkM19nZW9fYXJlYVJpbmdTdW0gPSBuZXcgZDNfYWRkZXIoKTtcbiAgdmFyIGQzX2dlb19hcmVhID0ge1xuICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fYXJlYVN1bSArPSA0ICogz4A7XG4gICAgfSxcbiAgICBwb2ludDogZDNfbm9vcCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgICBkM19nZW9fYXJlYS5saW5lU3RhcnQgPSBkM19nZW9fYXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZWEgPSAyICogZDNfZ2VvX2FyZWFSaW5nU3VtO1xuICAgICAgZDNfZ2VvX2FyZWFTdW0gKz0gYXJlYSA8IDAgPyA0ICogz4AgKyBhcmVhIDogYXJlYTtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCA9IGQzX2dlb19hcmVhLmxpbmVFbmQgPSBkM19nZW9fYXJlYS5wb2ludCA9IGQzX25vb3A7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fYXJlYVJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgzrswLCBjb3PPhjAsIHNpbs+GMDtcbiAgICBkM19nZW9fYXJlYS5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgZDNfZ2VvX2FyZWEucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICDOuzAgPSAozrswMCA9IM67KSAqIGQzX3JhZGlhbnMsIGNvc8+GMCA9IE1hdGguY29zKM+GID0gKM+GMDAgPSDPhikgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNCksIFxuICAgICAgc2luz4YwID0gTWF0aC5zaW4oz4YpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIM+GID0gz4YgKiBkM19yYWRpYW5zIC8gMiArIM+AIC8gNDtcbiAgICAgIHZhciBkzrsgPSDOuyAtIM67MCwgc2TOuyA9IGTOuyA+PSAwID8gMSA6IC0xLCBhZM67ID0gc2TOuyAqIGTOuywgY29zz4YgPSBNYXRoLmNvcyjPhiksIHNpbs+GID0gTWF0aC5zaW4oz4YpLCBrID0gc2luz4YwICogc2luz4YsIHUgPSBjb3PPhjAgKiBjb3PPhiArIGsgKiBNYXRoLmNvcyhhZM67KSwgdiA9IGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyk7XG4gICAgICBkM19nZW9fYXJlYVJpbmdTdW0uYWRkKE1hdGguYXRhbjIodiwgdSkpO1xuICAgICAgzrswID0gzrssIGNvc8+GMCA9IGNvc8+GLCBzaW7PhjAgPSBzaW7PhjtcbiAgICB9XG4gICAgZDNfZ2VvX2FyZWEubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgbmV4dFBvaW50KM67MDAsIM+GMDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgICB2YXIgzrsgPSBzcGhlcmljYWxbMF0sIM+GID0gc3BoZXJpY2FsWzFdLCBjb3PPhiA9IE1hdGguY29zKM+GKTtcbiAgICByZXR1cm4gWyBjb3PPhiAqIE1hdGguY29zKM67KSwgY29zz4YgKiBNYXRoLnNpbijOuyksIE1hdGguc2luKM+GKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jYXJ0ZXNpYW5Eb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGEsIGIpIHtcbiAgICByZXR1cm4gWyBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhbkFkZChhLCBiKSB7XG4gICAgYVswXSArPSBiWzBdO1xuICAgIGFbMV0gKz0gYlsxXTtcbiAgICBhWzJdICs9IGJbMl07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NhcnRlc2lhblNjYWxlKHZlY3Rvciwgaykge1xuICAgIHJldHVybiBbIHZlY3RvclswXSAqIGssIHZlY3RvclsxXSAqIGssIHZlY3RvclsyXSAqIGsgXTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGQpIHtcbiAgICB2YXIgbCA9IE1hdGguc3FydChkWzBdICogZFswXSArIGRbMV0gKiBkWzFdICsgZFsyXSAqIGRbMl0pO1xuICAgIGRbMF0gLz0gbDtcbiAgICBkWzFdIC89IGw7XG4gICAgZFsyXSAvPSBsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWwoY2FydGVzaWFuKSB7XG4gICAgcmV0dXJuIFsgTWF0aC5hdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGQzX2FzaW4oY2FydGVzaWFuWzJdKSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19zcGhlcmljYWxFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGFicyhhWzBdIC0gYlswXSkgPCDOtSAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgzrU7XG4gIH1cbiAgZDMuZ2VvLmJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciDOuzAsIM+GMCwgzrsxLCDPhjEsIM67XywgzrtfXywgz4ZfXywgcDAsIGTOu1N1bSwgcmFuZ2VzLCByYW5nZTtcbiAgICB2YXIgYm91bmQgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBib3VuZC5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgZM67U3VtID0gMDtcbiAgICAgICAgZDNfZ2VvX2FyZWEucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGQzX2dlb19hcmVhLnBvbHlnb25FbmQoKTtcbiAgICAgICAgYm91bmQucG9pbnQgPSBwb2ludDtcbiAgICAgICAgYm91bmQubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBib3VuZC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgaWYgKGQzX2dlb19hcmVhUmluZ1N1bSA8IDApIM67MCA9IC0ozrsxID0gMTgwKSwgz4YwID0gLSjPhjEgPSA5MCk7IGVsc2UgaWYgKGTOu1N1bSA+IM61KSDPhjEgPSA5MDsgZWxzZSBpZiAoZM67U3VtIDwgLc61KSDPhjAgPSAtOTA7XG4gICAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KM67LCDPhikge1xuICAgICAgcmFuZ2VzLnB1c2gocmFuZ2UgPSBbIM67MCA9IM67LCDOuzEgPSDOuyBdKTtcbiAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICBpZiAoz4YgPiDPhjEpIM+GMSA9IM+GO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgcCA9IGQzX2dlb19jYXJ0ZXNpYW4oWyDOuyAqIGQzX3JhZGlhbnMsIM+GICogZDNfcmFkaWFucyBdKTtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgbm9ybWFsID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKHAwLCBwKSwgZXF1YXRvcmlhbCA9IFsgbm9ybWFsWzFdLCAtbm9ybWFsWzBdLCAwIF0sIGluZmxlY3Rpb24gPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MoZXF1YXRvcmlhbCwgbm9ybWFsKTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbk5vcm1hbGl6ZShpbmZsZWN0aW9uKTtcbiAgICAgICAgaW5mbGVjdGlvbiA9IGQzX2dlb19zcGhlcmljYWwoaW5mbGVjdGlvbik7XG4gICAgICAgIHZhciBkzrsgPSDOuyAtIM67XywgcyA9IGTOuyA+IDAgPyAxIDogLTEsIM67aSA9IGluZmxlY3Rpb25bMF0gKiBkM19kZWdyZWVzICogcywgYW50aW1lcmlkaWFuID0gYWJzKGTOuykgPiAxODA7XG4gICAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiAocyAqIM67XyA8IM67aSAmJiDOu2kgPCBzICogzrspKSB7XG4gICAgICAgICAgdmFyIM+GaSA9IGluZmxlY3Rpb25bMV0gKiBkM19kZWdyZWVzO1xuICAgICAgICAgIGlmICjPhmkgPiDPhjEpIM+GMSA9IM+GaTtcbiAgICAgICAgfSBlbHNlIGlmICjOu2kgPSAozrtpICsgMzYwKSAlIDM2MCAtIDE4MCwgYW50aW1lcmlkaWFuIF4gKHMgKiDOu18gPCDOu2kgJiYgzrtpIDwgcyAqIM67KSkge1xuICAgICAgICAgIHZhciDPhmkgPSAtaW5mbGVjdGlvblsxXSAqIGQzX2RlZ3JlZXM7XG4gICAgICAgICAgaWYgKM+GaSA8IM+GMCkgz4YwID0gz4ZpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICjPhiA8IM+GMCkgz4YwID0gz4Y7XG4gICAgICAgICAgaWYgKM+GID4gz4YxKSDPhjEgPSDPhjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW50aW1lcmlkaWFuKSB7XG4gICAgICAgICAgaWYgKM67IDwgzrtfKSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYW5nbGUozrssIM67MSkgPiBhbmdsZSjOuzAsIM67MSkpIM67MCA9IM67O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAozrsxID49IM67MCkge1xuICAgICAgICAgICAgaWYgKM67IDwgzrswKSDOuzAgPSDOuztcbiAgICAgICAgICAgIGlmICjOuyA+IM67MSkgzrsxID0gzrs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICjOuyA+IM67Xykge1xuICAgICAgICAgICAgICBpZiAoYW5nbGUozrswLCDOuykgPiBhbmdsZSjOuzAsIM67MSkpIM67MSA9IM67O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ2xlKM67LCDOuzEpID4gYW5nbGUozrswLCDOuzEpKSDOuzAgPSDOuztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBwMCA9IHAsIM67XyA9IM67O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBib3VuZC5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIGJvdW5kLnBvaW50ID0gcG9pbnQ7XG4gICAgICBwMCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgIGlmIChwMCkge1xuICAgICAgICB2YXIgZM67ID0gzrsgLSDOu187XG4gICAgICAgIGTOu1N1bSArPSBhYnMoZM67KSA+IDE4MCA/IGTOuyArIChkzrsgPiAwID8gMzYwIDogLTM2MCkgOiBkzrs7XG4gICAgICB9IGVsc2UgzrtfXyA9IM67LCDPhl9fID0gz4Y7XG4gICAgICBkM19nZW9fYXJlYS5wb2ludCjOuywgz4YpO1xuICAgICAgbGluZVBvaW50KM67LCDPhik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgIGQzX2dlb19hcmVhLmxpbmVTdGFydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmluZ1BvaW50KM67X18sIM+GX18pO1xuICAgICAgZDNfZ2VvX2FyZWEubGluZUVuZCgpO1xuICAgICAgaWYgKGFicyhkzrtTdW0pID4gzrUpIM67MCA9IC0ozrsxID0gMTgwKTtcbiAgICAgIHJhbmdlWzBdID0gzrswLCByYW5nZVsxXSA9IM67MTtcbiAgICAgIHAwID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYW5nbGUozrswLCDOuzEpIHtcbiAgICAgIHJldHVybiAozrsxIC09IM67MCkgPCAwID8gzrsxICsgMzYwIDogzrsxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlUmFuZ2VzKGEsIGIpIHtcbiAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aGluUmFuZ2UoeCwgcmFuZ2UpIHtcbiAgICAgIHJldHVybiByYW5nZVswXSA8PSByYW5nZVsxXSA/IHJhbmdlWzBdIDw9IHggJiYgeCA8PSByYW5nZVsxXSA6IHggPCByYW5nZVswXSB8fCByYW5nZVsxXSA8IHg7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICDPhjEgPSDOuzEgPSAtKM67MCA9IM+GMCA9IEluZmluaXR5KTtcbiAgICAgIHJhbmdlcyA9IFtdO1xuICAgICAgZDMuZ2VvLnN0cmVhbShmZWF0dXJlLCBib3VuZCk7XG4gICAgICB2YXIgbiA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBpZiAobikge1xuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGEgPSByYW5nZXNbMF0sIGIsIG1lcmdlZCA9IFsgYSBdOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgYiA9IHJhbmdlc1tpXTtcbiAgICAgICAgICBpZiAod2l0aGluUmFuZ2UoYlswXSwgYSkgfHwgd2l0aGluUmFuZ2UoYlsxXSwgYSkpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZShhWzBdLCBiWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzFdID0gYlsxXTtcbiAgICAgICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goYSA9IGIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVzdCA9IC1JbmZpbml0eSwgZM67O1xuICAgICAgICBmb3IgKHZhciBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dLCBiOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgICAgICBiID0gbWVyZ2VkW2ldO1xuICAgICAgICAgIGlmICgoZM67ID0gYW5nbGUoYVsxXSwgYlswXSkpID4gYmVzdCkgYmVzdCA9IGTOuywgzrswID0gYlswXSwgzrsxID0gYVsxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmFuZ2VzID0gcmFuZ2UgPSBudWxsO1xuICAgICAgcmV0dXJuIM67MCA9PT0gSW5maW5pdHkgfHwgz4YwID09PSBJbmZpbml0eSA/IFsgWyBOYU4sIE5hTiBdLCBbIE5hTiwgTmFOIF0gXSA6IFsgWyDOuzAsIM+GMCBdLCBbIM67MSwgz4YxIF0gXTtcbiAgICB9O1xuICB9KCk7XG4gIGQzLmdlby5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGQzX2dlb19jZW50cm9pZFcwID0gZDNfZ2VvX2NlbnRyb2lkVzEgPSBkM19nZW9fY2VudHJvaWRYMCA9IGQzX2dlb19jZW50cm9pZFkwID0gZDNfZ2VvX2NlbnRyb2lkWjAgPSBkM19nZW9fY2VudHJvaWRYMSA9IGQzX2dlb19jZW50cm9pZFkxID0gZDNfZ2VvX2NlbnRyb2lkWjEgPSBkM19nZW9fY2VudHJvaWRYMiA9IGQzX2dlb19jZW50cm9pZFkyID0gZDNfZ2VvX2NlbnRyb2lkWjIgPSAwO1xuICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBkM19nZW9fY2VudHJvaWQpO1xuICAgIHZhciB4ID0gZDNfZ2VvX2NlbnRyb2lkWDIsIHkgPSBkM19nZW9fY2VudHJvaWRZMiwgeiA9IGQzX2dlb19jZW50cm9pZFoyLCBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIGlmIChtIDwgzrUyKSB7XG4gICAgICB4ID0gZDNfZ2VvX2NlbnRyb2lkWDEsIHkgPSBkM19nZW9fY2VudHJvaWRZMSwgeiA9IGQzX2dlb19jZW50cm9pZFoxO1xuICAgICAgaWYgKGQzX2dlb19jZW50cm9pZFcxIDwgzrUpIHggPSBkM19nZW9fY2VudHJvaWRYMCwgeSA9IGQzX2dlb19jZW50cm9pZFkwLCB6ID0gZDNfZ2VvX2NlbnRyb2lkWjA7XG4gICAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgaWYgKG0gPCDOtTIpIHJldHVybiBbIE5hTiwgTmFOIF07XG4gICAgfVxuICAgIHJldHVybiBbIE1hdGguYXRhbjIoeSwgeCkgKiBkM19kZWdyZWVzLCBkM19hc2luKHogLyBNYXRoLnNxcnQobSkpICogZDNfZGVncmVlcyBdO1xuICB9O1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkVzAsIGQzX2dlb19jZW50cm9pZFcxLCBkM19nZW9fY2VudHJvaWRYMCwgZDNfZ2VvX2NlbnRyb2lkWTAsIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRYMSwgZDNfZ2VvX2NlbnRyb2lkWTEsIGQzX2dlb19jZW50cm9pZFoxLCBkM19nZW9fY2VudHJvaWRYMiwgZDNfZ2VvX2NlbnRyb2lkWTIsIGQzX2dlb19jZW50cm9pZFoyO1xuICB2YXIgZDNfZ2VvX2NlbnRyb2lkID0ge1xuICAgIHNwaGVyZTogZDNfbm9vcCxcbiAgICBwb2ludDogZDNfZ2VvX2NlbnRyb2lkUG9pbnQsXG4gICAgbGluZVN0YXJ0OiBkM19nZW9fY2VudHJvaWRMaW5lU3RhcnQsXG4gICAgbGluZUVuZDogZDNfZ2VvX2NlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZFJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVTdGFydCA9IGQzX2dlb19jZW50cm9pZExpbmVTdGFydDtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50KM67LCDPhikge1xuICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YgKj0gZDNfcmFkaWFucyk7XG4gICAgZDNfZ2VvX2NlbnRyb2lkUG9pbnRYWVooY29zz4YgKiBNYXRoLmNvcyjOuyksIGNvc8+GICogTWF0aC5zaW4ozrspLCBNYXRoLnNpbijPhikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgsIHksIHopIHtcbiAgICArK2QzX2dlb19jZW50cm9pZFcwO1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9ICh4IC0gZDNfZ2VvX2NlbnRyb2lkWDApIC8gZDNfZ2VvX2NlbnRyb2lkVzA7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0gKHkgLSBkM19nZW9fY2VudHJvaWRZMCkgLyBkM19nZW9fY2VudHJvaWRXMDtcbiAgICBkM19nZW9fY2VudHJvaWRaMCArPSAoeiAtIGQzX2dlb19jZW50cm9pZFowKSAvIGQzX2dlb19jZW50cm9pZFcwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZExpbmVTdGFydCgpIHtcbiAgICB2YXIgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKTtcbiAgICAgIHgwID0gY29zz4YgKiBNYXRoLmNvcyjOuyk7XG4gICAgICB5MCA9IGNvc8+GICogTWF0aC5zaW4ozrspO1xuICAgICAgejAgPSBNYXRoLnNpbijPhik7XG4gICAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fY2VudHJvaWRQb2ludFhZWih4MCwgeTAsIHowKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG5leHRQb2ludCjOuywgz4YpIHtcbiAgICAgIM67ICo9IGQzX3JhZGlhbnM7XG4gICAgICB2YXIgY29zz4YgPSBNYXRoLmNvcyjPhiAqPSBkM19yYWRpYW5zKSwgeCA9IGNvc8+GICogTWF0aC5jb3MozrspLCB5ID0gY29zz4YgKiBNYXRoLnNpbijOuyksIHogPSBNYXRoLnNpbijPhiksIHcgPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodyA9IHkwICogeiAtIHowICogeSkgKiB3ICsgKHcgPSB6MCAqIHggLSB4MCAqIHopICogdyArICh3ID0geDAgKiB5IC0geTAgKiB4KSAqIHcpLCB4MCAqIHggKyB5MCAqIHkgKyB6MCAqIHopO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2VudHJvaWRMaW5lRW5kKCkge1xuICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jZW50cm9pZFJpbmdTdGFydCgpIHtcbiAgICB2YXIgzrswMCwgz4YwMCwgeDAsIHkwLCB6MDtcbiAgICBkM19nZW9fY2VudHJvaWQucG9pbnQgPSBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgIM67MDAgPSDOuywgz4YwMCA9IM+GO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkLnBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpO1xuICAgICAgeDAgPSBjb3PPhiAqIE1hdGguY29zKM67KTtcbiAgICAgIHkwID0gY29zz4YgKiBNYXRoLnNpbijOuyk7XG4gICAgICB6MCA9IE1hdGguc2luKM+GKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH07XG4gICAgZDNfZ2VvX2NlbnRyb2lkLmxpbmVFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIG5leHRQb2ludCjOuzAwLCDPhjAwKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX2NlbnRyb2lkTGluZUVuZDtcbiAgICAgIGQzX2dlb19jZW50cm9pZC5wb2ludCA9IGQzX2dlb19jZW50cm9pZFBvaW50O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KM67LCDPhikge1xuICAgICAgzrsgKj0gZDNfcmFkaWFucztcbiAgICAgIHZhciBjb3PPhiA9IE1hdGguY29zKM+GICo9IGQzX3JhZGlhbnMpLCB4ID0gY29zz4YgKiBNYXRoLmNvcyjOuyksIHkgPSBjb3PPhiAqIE1hdGguc2luKM67KSwgeiA9IE1hdGguc2luKM+GKSwgY3ggPSB5MCAqIHogLSB6MCAqIHksIGN5ID0gejAgKiB4IC0geDAgKiB6LCBjeiA9IHgwICogeSAtIHkwICogeCwgbSA9IE1hdGguc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLCB1ID0geDAgKiB4ICsgeTAgKiB5ICsgejAgKiB6LCB2ID0gbSAmJiAtZDNfYWNvcyh1KSAvIG0sIHcgPSBNYXRoLmF0YW4yKG0sIHUpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDIgKz0gdiAqIGN4O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTIgKz0gdiAqIGN5O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjIgKz0gdiAqIGN6O1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkVzEgKz0gdztcbiAgICAgIGQzX2dlb19jZW50cm9pZFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWjEgKz0gdyAqICh6MCArICh6MCA9IHopKTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFBvaW50WFlaKHgwLCB5MCwgejApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY29tcG9zZShhLCBiKSB7XG4gICAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGEoeCwgeSksIGIoeFswXSwgeFsxXSk7XG4gICAgfVxuICAgIGlmIChhLmludmVydCAmJiBiLmludmVydCkgY29tcG9zZS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBvc2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGNvbXBhcmUsIGNsaXBTdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIHN1YmplY3QgPSBbXSwgY2xpcCA9IFtdO1xuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgaWYgKChuID0gc2VnbWVudC5sZW5ndGggLSAxKSA8PSAwKSByZXR1cm47XG4gICAgICB2YXIgbiwgcDAgPSBzZWdtZW50WzBdLCBwMSA9IHNlZ21lbnRbbl07XG4gICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhID0gbmV3IGQzX2dlb19jbGlwUG9seWdvbkludGVyc2VjdGlvbihwMCwgc2VnbWVudCwgbnVsbCwgdHJ1ZSksIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAwLCBudWxsLCBhLCBmYWxzZSk7XG4gICAgICBhLm8gPSBiO1xuICAgICAgc3ViamVjdC5wdXNoKGEpO1xuICAgICAgY2xpcC5wdXNoKGIpO1xuICAgICAgYSA9IG5ldyBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKTtcbiAgICAgIGIgPSBuZXcgZDNfZ2VvX2NsaXBQb2x5Z29uSW50ZXJzZWN0aW9uKHAxLCBudWxsLCBhLCB0cnVlKTtcbiAgICAgIGEubyA9IGI7XG4gICAgICBzdWJqZWN0LnB1c2goYSk7XG4gICAgICBjbGlwLnB1c2goYik7XG4gICAgfSk7XG4gICAgY2xpcC5zb3J0KGNvbXBhcmUpO1xuICAgIGQzX2dlb19jbGlwUG9seWdvbkxpbmtDaXJjdWxhcihzdWJqZWN0KTtcbiAgICBkM19nZW9fY2xpcFBvbHlnb25MaW5rQ2lyY3VsYXIoY2xpcCk7XG4gICAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuICAgIGZvciAodmFyIGkgPSAwLCBlbnRyeSA9IGNsaXBTdGFydEluc2lkZSwgbiA9IGNsaXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBjbGlwW2ldLmUgPSBlbnRyeSA9ICFlbnRyeTtcbiAgICB9XG4gICAgdmFyIHN0YXJ0ID0gc3ViamVjdFswXSwgcG9pbnRzLCBwb2ludDtcbiAgICB3aGlsZSAoMSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzdGFydCwgaXNTdWJqZWN0ID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudC52ID0gY3VycmVudC5vLnYgPSB0cnVlO1xuICAgICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgICAgaWYgKGlzU3ViamVjdCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbjsgKytpKSBsaXN0ZW5lci5wb2ludCgocG9pbnQgPSBwb2ludHNbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5uLngsIDEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgICBwb2ludHMgPSBjdXJyZW50LnAuejtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW50ZXJwb2xhdGUoY3VycmVudC54LCBjdXJyZW50LnAueCwgLTEsIGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgICBwb2ludHMgPSBjdXJyZW50Lno7XG4gICAgICAgIGlzU3ViamVjdCA9ICFpc1N1YmplY3Q7XG4gICAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBQb2x5Z29uTGlua0NpcmN1bGFyKGFycmF5KSB7XG4gICAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgICB2YXIgbiwgaSA9IDAsIGEgPSBhcnJheVswXSwgYjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgICAgYi5wID0gYTtcbiAgICAgIGEgPSBiO1xuICAgIH1cbiAgICBhLm4gPSBiID0gYXJyYXlbMF07XG4gICAgYi5wID0gYTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFBvbHlnb25JbnRlcnNlY3Rpb24ocG9pbnQsIHBvaW50cywgb3RoZXIsIGVudHJ5KSB7XG4gICAgdGhpcy54ID0gcG9pbnQ7XG4gICAgdGhpcy56ID0gcG9pbnRzO1xuICAgIHRoaXMubyA9IG90aGVyO1xuICAgIHRoaXMuZSA9IGVudHJ5O1xuICAgIHRoaXMudiA9IGZhbHNlO1xuICAgIHRoaXMubiA9IHRoaXMucCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXAocG9pbnRWaXNpYmxlLCBjbGlwTGluZSwgaW50ZXJwb2xhdGUsIGNsaXBTdGFydCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyb3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGluZSA9IGNsaXBMaW5lKGxpc3RlbmVyKSwgcm90YXRlZENsaXBTdGFydCA9IHJvdGF0ZS5pbnZlcnQoY2xpcFN0YXJ0WzBdLCBjbGlwU3RhcnRbMV0pO1xuICAgICAgdmFyIGNsaXAgPSB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50UmluZztcbiAgICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgICBjbGlwLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgICAgICAgIHNlZ21lbnRzID0gW107XG4gICAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgY2xpcC5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICAgICAgY2xpcC5saW5lRW5kID0gbGluZUVuZDtcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gZDNfZ2VvX3BvaW50SW5Qb2x5Z29uKHJvdGF0ZWRDbGlwU3RhcnQsIHBvbHlnb24pO1xuICAgICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghcG9seWdvblN0YXJ0ZWQpIGxpc3RlbmVyLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9fY2xpcFBvbHlnb24oc2VnbWVudHMsIGQzX2dlb19jbGlwU29ydCwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpcFN0YXJ0SW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBsaXN0ZW5lci5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIHNlZ21lbnRzID0gcG9seWdvbiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgaW50ZXJwb2xhdGUobnVsbCwgbnVsbCwgMSwgbGlzdGVuZXIpO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2x5Z29uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBwb2ludCjOuywgz4YpIHtcbiAgICAgICAgdmFyIHBvaW50ID0gcm90YXRlKM67LCDPhik7XG4gICAgICAgIGlmIChwb2ludFZpc2libGUozrsgPSBwb2ludFswXSwgz4YgPSBwb2ludFsxXSkpIGxpc3RlbmVyLnBvaW50KM67LCDPhik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludExpbmUozrssIM+GKSB7XG4gICAgICAgIHZhciBwb2ludCA9IHJvdGF0ZSjOuywgz4YpO1xuICAgICAgICBsaW5lLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICAgIGNsaXAucG9pbnQgPSBwb2ludExpbmU7XG4gICAgICAgIGxpbmUubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGxpbmUubGluZUVuZCgpO1xuICAgICAgfVxuICAgICAgdmFyIHNlZ21lbnRzO1xuICAgICAgdmFyIGJ1ZmZlciA9IGQzX2dlb19jbGlwQnVmZmVyTGlzdGVuZXIoKSwgcmluZ0xpc3RlbmVyID0gY2xpcExpbmUoYnVmZmVyKSwgcG9seWdvblN0YXJ0ZWQgPSBmYWxzZSwgcG9seWdvbiwgcmluZztcbiAgICAgIGZ1bmN0aW9uIHBvaW50UmluZyjOuywgz4YpIHtcbiAgICAgICAgcmluZy5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgICB2YXIgcG9pbnQgPSByb3RhdGUozrssIM+GKTtcbiAgICAgICAgcmluZ0xpc3RlbmVyLnBvaW50KHBvaW50WzBdLCBwb2ludFsxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByaW5nU3RhcnQoKSB7XG4gICAgICAgIHJpbmdMaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgcmluZyA9IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgICAgcG9pbnRSaW5nKHJpbmdbMF1bMF0sIHJpbmdbMF1bMV0pO1xuICAgICAgICByaW5nTGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICB2YXIgY2xlYW4gPSByaW5nTGlzdGVuZXIuY2xlYW4oKSwgcmluZ1NlZ21lbnRzID0gYnVmZmVyLmJ1ZmZlcigpLCBzZWdtZW50LCBuID0gcmluZ1NlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmluZy5wb3AoKTtcbiAgICAgICAgcG9seWdvbi5wdXNoKHJpbmcpO1xuICAgICAgICByaW5nID0gbnVsbDtcbiAgICAgICAgaWYgKCFuKSByZXR1cm47XG4gICAgICAgIGlmIChjbGVhbiAmIDEpIHtcbiAgICAgICAgICBzZWdtZW50ID0gcmluZ1NlZ21lbnRzWzBdO1xuICAgICAgICAgIHZhciBuID0gc2VnbWVudC5sZW5ndGggLSAxLCBpID0gLTEsIHBvaW50O1xuICAgICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgbGlzdGVuZXIucG9seWdvblN0YXJ0KCksIHBvbHlnb25TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IG4pIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IHNlZ21lbnRbaV0pWzBdLCBwb2ludFsxXSk7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDEgJiYgY2xlYW4gJiAyKSByaW5nU2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMucG9wKCkuY29uY2F0KHJpbmdTZWdtZW50cy5zaGlmdCgpKSk7XG4gICAgICAgIHNlZ21lbnRzLnB1c2gocmluZ1NlZ21lbnRzLmZpbHRlcihkM19nZW9fY2xpcFNlZ21lbnRMZW5ndGgxKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xpcDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwU2VnbWVudExlbmd0aDEoc2VnbWVudCkge1xuICAgIHJldHVybiBzZWdtZW50Lmxlbmd0aCA+IDE7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpIHtcbiAgICB2YXIgbGluZXMgPSBbXSwgbGluZTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuywgz4YpIHtcbiAgICAgICAgbGluZS5wdXNoKFsgzrssIM+GIF0pO1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgICBidWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gbGluZXM7XG4gICAgICAgIGxpbmVzID0gW107XG4gICAgICAgIGxpbmUgPSBudWxsO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgfSxcbiAgICAgIHJlam9pbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSBsaW5lcy5wdXNoKGxpbmVzLnBvcCgpLmNvbmNhdChsaW5lcy5zaGlmdCgpKSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcFNvcnQoYSwgYikge1xuICAgIHJldHVybiAoKGEgPSBhLngpWzBdIDwgMCA/IGFbMV0gLSBoYWxmz4AgLSDOtSA6IGhhbGbPgCAtIGFbMV0pIC0gKChiID0gYi54KVswXSA8IDAgPyBiWzFdIC0gaGFsZs+AIC0gzrUgOiBoYWxmz4AgLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW4gPSBkM19nZW9fY2xpcChkM190cnVlLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUsIGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJwb2xhdGUsIFsgLc+ALCAtz4AgLyAyIF0pO1xuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkxpbmUobGlzdGVuZXIpIHtcbiAgICB2YXIgzrswID0gTmFOLCDPhjAgPSBOYU4sIHPOuzAgPSBOYU4sIGNsZWFuO1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgY2xlYW4gPSAxO1xuICAgICAgfSxcbiAgICAgIHBvaW50OiBmdW5jdGlvbijOuzEsIM+GMSkge1xuICAgICAgICB2YXIgc867MSA9IM67MSA+IDAgPyDPgCA6IC3PgCwgZM67ID0gYWJzKM67MSAtIM67MCk7XG4gICAgICAgIGlmIChhYnMoZM67IC0gz4ApIDwgzrUpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCjOuzAsIM+GMCA9ICjPhjAgKyDPhjEpIC8gMiA+IDAgPyBoYWxmz4AgOiAtaGFsZs+AKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrswLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludChzzrsxLCDPhjApO1xuICAgICAgICAgIGxpc3RlbmVyLnBvaW50KM67MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc867MCAhPT0gc867MSAmJiBkzrsgPj0gz4ApIHtcbiAgICAgICAgICBpZiAoYWJzKM67MCAtIHPOuzApIDwgzrUpIM67MCAtPSBzzrswICogzrU7XG4gICAgICAgICAgaWYgKGFicyjOuzEgLSBzzrsxKSA8IM61KSDOuzEgLT0gc867MSAqIM61O1xuICAgICAgICAgIM+GMCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuSW50ZXJzZWN0KM67MCwgz4YwLCDOuzEsIM+GMSk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MCwgz4YwKTtcbiAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgbGlzdGVuZXIucG9pbnQoc867MSwgz4YwKTtcbiAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucG9pbnQozrswID0gzrsxLCDPhjAgPSDPhjEpO1xuICAgICAgICBzzrswID0gc867MTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICDOuzAgPSDPhjAgPSBOYU47XG4gICAgICB9LFxuICAgICAgY2xlYW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMiAtIGNsZWFuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NsaXBBbnRpbWVyaWRpYW5JbnRlcnNlY3QozrswLCDPhjAsIM67MSwgz4YxKSB7XG4gICAgdmFyIGNvc8+GMCwgY29zz4YxLCBzaW7OuzBfzrsxID0gTWF0aC5zaW4ozrswIC0gzrsxKTtcbiAgICByZXR1cm4gYWJzKHNpbs67MF/OuzEpID4gzrUgPyBNYXRoLmF0YW4oKE1hdGguc2luKM+GMCkgKiAoY29zz4YxID0gTWF0aC5jb3Moz4YxKSkgKiBNYXRoLnNpbijOuzEpIC0gTWF0aC5zaW4oz4YxKSAqIChjb3PPhjAgPSBNYXRoLmNvcyjPhjApKSAqIE1hdGguc2luKM67MCkpIC8gKGNvc8+GMCAqIGNvc8+GMSAqIHNpbs67MF/OuzEpKSA6ICjPhjAgKyDPhjEpIC8gMjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgdmFyIM+GO1xuICAgIGlmIChmcm9tID09IG51bGwpIHtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogaGFsZs+AO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCDPhik7XG4gICAgICBsaXN0ZW5lci5wb2ludCjPgCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIDApO1xuICAgICAgbGlzdGVuZXIucG9pbnQoz4AsIC3Phik7XG4gICAgICBsaXN0ZW5lci5wb2ludCgwLCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAtz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoLc+ALCAwKTtcbiAgICAgIGxpc3RlbmVyLnBvaW50KC3PgCwgz4YpO1xuICAgIH0gZWxzZSBpZiAoYWJzKGZyb21bMF0gLSB0b1swXSkgPiDOtSkge1xuICAgICAgdmFyIHMgPSBmcm9tWzBdIDwgdG9bMF0gPyDPgCA6IC3PgDtcbiAgICAgIM+GID0gZGlyZWN0aW9uICogcyAvIDI7XG4gICAgICBsaXN0ZW5lci5wb2ludCgtcywgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQoMCwgz4YpO1xuICAgICAgbGlzdGVuZXIucG9pbnQocywgz4YpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcG9pbnRJblBvbHlnb24ocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgbWVyaWRpYW4gPSBwb2ludFswXSwgcGFyYWxsZWwgPSBwb2ludFsxXSwgbWVyaWRpYW5Ob3JtYWwgPSBbIE1hdGguc2luKG1lcmlkaWFuKSwgLU1hdGguY29zKG1lcmlkaWFuKSwgMCBdLCBwb2xhckFuZ2xlID0gMCwgd2luZGluZyA9IDA7XG4gICAgZDNfZ2VvX2FyZWFSaW5nU3VtLnJlc2V0KCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIHJpbmcgPSBwb2x5Z29uW2ldLCBtID0gcmluZy5sZW5ndGg7XG4gICAgICBpZiAoIW0pIGNvbnRpbnVlO1xuICAgICAgdmFyIHBvaW50MCA9IHJpbmdbMF0sIM67MCA9IHBvaW50MFswXSwgz4YwID0gcG9pbnQwWzFdIC8gMiArIM+AIC8gNCwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgaiA9IDE7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoaiA9PT0gbSkgaiA9IDA7XG4gICAgICAgIHBvaW50ID0gcmluZ1tqXTtcbiAgICAgICAgdmFyIM67ID0gcG9pbnRbMF0sIM+GID0gcG9pbnRbMV0gLyAyICsgz4AgLyA0LCBzaW7PhiA9IE1hdGguc2luKM+GKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIGTOuyA9IM67IC0gzrswLCBzZM67ID0gZM67ID49IDAgPyAxIDogLTEsIGFkzrsgPSBzZM67ICogZM67LCBhbnRpbWVyaWRpYW4gPSBhZM67ID4gz4AsIGsgPSBzaW7PhjAgKiBzaW7PhjtcbiAgICAgICAgZDNfZ2VvX2FyZWFSaW5nU3VtLmFkZChNYXRoLmF0YW4yKGsgKiBzZM67ICogTWF0aC5zaW4oYWTOuyksIGNvc8+GMCAqIGNvc8+GICsgayAqIE1hdGguY29zKGFkzrspKSk7XG4gICAgICAgIHBvbGFyQW5nbGUgKz0gYW50aW1lcmlkaWFuID8gZM67ICsgc2TOuyAqIM+EIDogZM67O1xuICAgICAgICBpZiAoYW50aW1lcmlkaWFuIF4gzrswID49IG1lcmlkaWFuIF4gzrsgPj0gbWVyaWRpYW4pIHtcbiAgICAgICAgICB2YXIgYXJjID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKGQzX2dlb19jYXJ0ZXNpYW4ocG9pbnQwKSwgZDNfZ2VvX2NhcnRlc2lhbihwb2ludCkpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoYXJjKTtcbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG1lcmlkaWFuTm9ybWFsLCBhcmMpO1xuICAgICAgICAgIGQzX2dlb19jYXJ0ZXNpYW5Ob3JtYWxpemUoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICB2YXIgz4ZhcmMgPSAoYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAtMSA6IDEpICogZDNfYXNpbihpbnRlcnNlY3Rpb25bMl0pO1xuICAgICAgICAgIGlmIChwYXJhbGxlbCA+IM+GYXJjIHx8IHBhcmFsbGVsID09PSDPhmFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICAgIHdpbmRpbmcgKz0gYW50aW1lcmlkaWFuIF4gZM67ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaisrKSBicmVhaztcbiAgICAgICAgzrswID0gzrssIHNpbs+GMCA9IHNpbs+GLCBjb3PPhjAgPSBjb3PPhiwgcG9pbnQwID0gcG9pbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAocG9sYXJBbmdsZSA8IC3OtSB8fCBwb2xhckFuZ2xlIDwgzrUgJiYgZDNfZ2VvX2FyZWFSaW5nU3VtIDwgMCkgXiB3aW5kaW5nICYgMTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fY2xpcENpcmNsZShyYWRpdXMpIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzbWFsbFJhZGl1cyA9IGNyID4gMCwgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiDOtSwgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCA2ICogZDNfcmFkaWFucyk7XG4gICAgcmV0dXJuIGQzX2dlb19jbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbIDAsIC1yYWRpdXMgXSA6IFsgLc+ALCByYWRpdXMgLSDPgCBdKTtcbiAgICBmdW5jdGlvbiB2aXNpYmxlKM67LCDPhikge1xuICAgICAgcmV0dXJuIE1hdGguY29zKM67KSAqIE1hdGguY29zKM+GKSA+IGNyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlwTGluZShsaXN0ZW5lcikge1xuICAgICAgdmFyIHBvaW50MCwgYzAsIHYwLCB2MDAsIGNsZWFuO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2MDAgPSB2MCA9IGZhbHNlO1xuICAgICAgICAgIGNsZWFuID0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgICAgIHZhciBwb2ludDEgPSBbIM67LCDPhiBdLCBwb2ludDIsIHYgPSB2aXNpYmxlKM67LCDPhiksIGMgPSBzbWFsbFJhZGl1cyA/IHYgPyAwIDogY29kZSjOuywgz4YpIDogdiA/IGNvZGUozrsgKyAozrsgPCAwID8gz4AgOiAtz4ApLCDPhikgOiAwO1xuICAgICAgICAgIGlmICghcG9pbnQwICYmICh2MDAgPSB2MCA9IHYpKSBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpZiAodiAhPT0gdjApIHtcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBpZiAoZDNfZ2VvX3NwaGVyaWNhbEVxdWFsKHBvaW50MCwgcG9pbnQyKSB8fCBkM19nZW9fc3BoZXJpY2FsRXF1YWwocG9pbnQxLCBwb2ludDIpKSB7XG4gICAgICAgICAgICAgIHBvaW50MVswXSArPSDOtTtcbiAgICAgICAgICAgICAgcG9pbnQxWzFdICs9IM61O1xuICAgICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgICAgY2xlYW4gPSAwO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHBvaW50MlswXSwgcG9pbnQyWzFdKTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm90SGVtaXNwaGVyZSAmJiBwb2ludDAgJiYgc21hbGxSYWRpdXMgXiB2KSB7XG4gICAgICAgICAgICB2YXIgdDtcbiAgICAgICAgICAgIGlmICghKGMgJiBjMCkgJiYgKHQgPSBpbnRlcnNlY3QocG9pbnQxLCBwb2ludDAsIHRydWUpKSkge1xuICAgICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICAgIGlmIChzbWFsbFJhZGl1cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMF1bMF0sIHRbMF1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHRbMV1bMF0sIHRbMV1bMV0pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHYgJiYgKCFwb2ludDAgfHwgIWQzX2dlb19zcGhlcmljYWxFcXVhbChwb2ludDAsIHBvaW50MSkpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5wb2ludChwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh2MCkgbGlzdGVuZXIubGluZUVuZCgpO1xuICAgICAgICAgIHBvaW50MCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gY2xlYW4gfCAodjAwICYmIHYwKSA8PCAxO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoYSwgYiwgdHdvKSB7XG4gICAgICB2YXIgcGEgPSBkM19nZW9fY2FydGVzaWFuKGEpLCBwYiA9IGQzX2dlb19jYXJ0ZXNpYW4oYik7XG4gICAgICB2YXIgbjEgPSBbIDEsIDAsIDAgXSwgbjIgPSBkM19nZW9fY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSwgbjJuMiA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QobjIsIG4yKSwgbjFuMiA9IG4yWzBdLCBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcbiAgICAgIGlmICghZGV0ZXJtaW5hbnQpIHJldHVybiAhdHdvICYmIGE7XG4gICAgICB2YXIgYzEgPSBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCwgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsIG4xeG4yID0gZDNfZ2VvX2NhcnRlc2lhbkNyb3NzKG4xLCBuMiksIEEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUobjEsIGMxKSwgQiA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChBLCBCKTtcbiAgICAgIHZhciB1ID0gbjF4bjIsIHcgPSBkM19nZW9fY2FydGVzaWFuRG90KEEsIHUpLCB1dSA9IGQzX2dlb19jYXJ0ZXNpYW5Eb3QodSwgdSksIHQyID0gdyAqIHcgLSB1dSAqIChkM19nZW9fY2FydGVzaWFuRG90KEEsIEEpIC0gMSk7XG4gICAgICBpZiAodDIgPCAwKSByZXR1cm47XG4gICAgICB2YXIgdCA9IE1hdGguc3FydCh0MiksIHEgPSBkM19nZW9fY2FydGVzaWFuU2NhbGUodSwgKC13IC0gdCkgLyB1dSk7XG4gICAgICBkM19nZW9fY2FydGVzaWFuQWRkKHEsIEEpO1xuICAgICAgcSA9IGQzX2dlb19zcGhlcmljYWwocSk7XG4gICAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG4gICAgICB2YXIgzrswID0gYVswXSwgzrsxID0gYlswXSwgz4YwID0gYVsxXSwgz4YxID0gYlsxXSwgejtcbiAgICAgIGlmICjOuzEgPCDOuzApIHogPSDOuzAsIM67MCA9IM67MSwgzrsxID0gejtcbiAgICAgIHZhciDOtM67ID0gzrsxIC0gzrswLCBwb2xhciA9IGFicyjOtM67IC0gz4ApIDwgzrUsIG1lcmlkaWFuID0gcG9sYXIgfHwgzrTOuyA8IM61O1xuICAgICAgaWYgKCFwb2xhciAmJiDPhjEgPCDPhjApIHogPSDPhjAsIM+GMCA9IM+GMSwgz4YxID0gejtcbiAgICAgIGlmIChtZXJpZGlhbiA/IHBvbGFyID8gz4YwICsgz4YxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSDOuzApIDwgzrUgPyDPhjAgOiDPhjEpIDogz4YwIDw9IHFbMV0gJiYgcVsxXSA8PSDPhjEgOiDOtM67ID4gz4AgXiAozrswIDw9IHFbMF0gJiYgcVswXSA8PSDOuzEpKSB7XG4gICAgICAgIHZhciBxMSA9IGQzX2dlb19jYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgICAgZDNfZ2VvX2NhcnRlc2lhbkFkZChxMSwgQSk7XG4gICAgICAgIHJldHVybiBbIHEsIGQzX2dlb19zcGhlcmljYWwocTEpIF07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZGUozrssIM+GKSB7XG4gICAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogz4AgLSByYWRpdXMsIGNvZGUgPSAwO1xuICAgICAgaWYgKM67IDwgLXIpIGNvZGUgfD0gMTsgZWxzZSBpZiAozrsgPiByKSBjb2RlIHw9IDI7XG4gICAgICBpZiAoz4YgPCAtcikgY29kZSB8PSA0OyBlbHNlIGlmICjPhiA+IHIpIGNvZGUgfD0gODtcbiAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX2NsaXBMaW5lKHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBhID0gbGluZS5hLCBiID0gbGluZS5iLCBheCA9IGEueCwgYXkgPSBhLnksIGJ4ID0gYi54LCBieSA9IGIueSwgdDAgPSAwLCB0MSA9IDEsIGR4ID0gYnggLSBheCwgZHkgPSBieSAtIGF5LCByO1xuICAgICAgciA9IHgwIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHgxIC0gYXg7XG4gICAgICBpZiAoIWR4ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR4O1xuICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkwIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICAgICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgICAgfVxuICAgICAgciA9IHkxIC0gYXk7XG4gICAgICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gICAgICByIC89IGR5O1xuICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgICAgIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICAgICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICAgICAgfVxuICAgICAgaWYgKHQwID4gMCkgbGluZS5hID0ge1xuICAgICAgICB4OiBheCArIHQwICogZHgsXG4gICAgICAgIHk6IGF5ICsgdDAgKiBkeVxuICAgICAgfTtcbiAgICAgIGlmICh0MSA8IDEpIGxpbmUuYiA9IHtcbiAgICAgICAgeDogYXggKyB0MSAqIGR4LFxuICAgICAgICB5OiBheSArIHQxICogZHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICB9XG4gIHZhciBkM19nZW9fY2xpcEV4dGVudE1BWCA9IDFlOTtcbiAgZDMuZ2VvLmNsaXBFeHRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeDAsIHkwLCB4MSwgeTEsIHN0cmVhbSwgY2xpcCwgY2xpcEV4dGVudCA9IHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlO1xuICAgICAgICBzdHJlYW0gPSBjbGlwKG91dHB1dCk7XG4gICAgICAgIHN0cmVhbS52YWxpZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LFxuICAgICAgZXh0ZW50OiBmdW5jdGlvbihfKSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyB4MCwgeTAgXSwgWyB4MSwgeTEgXSBdO1xuICAgICAgICBjbGlwID0gZDNfZ2VvX2NsaXBFeHRlbnQoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSk7XG4gICAgICAgIGlmIChzdHJlYW0pIHN0cmVhbS52YWxpZCA9IGZhbHNlLCBzdHJlYW0gPSBudWxsO1xuICAgICAgICByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjbGlwRXh0ZW50LmV4dGVudChbIFsgMCwgMCBdLCBbIDk2MCwgNTAwIF0gXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19jbGlwRXh0ZW50KHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdGVuZXJfID0gbGlzdGVuZXIsIGJ1ZmZlckxpc3RlbmVyID0gZDNfZ2VvX2NsaXBCdWZmZXJMaXN0ZW5lcigpLCBjbGlwTGluZSA9IGQzX2dlb21fY2xpcExpbmUoeDAsIHkwLCB4MSwgeTEpLCBzZWdtZW50cywgcG9seWdvbiwgcmluZztcbiAgICAgIHZhciBjbGlwID0ge1xuICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxpc3RlbmVyID0gYnVmZmVyTGlzdGVuZXI7XG4gICAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgICBwb2x5Z29uID0gW107XG4gICAgICAgICAgY2xlYW4gPSB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyXztcbiAgICAgICAgICBzZWdtZW50cyA9IGQzLm1lcmdlKHNlZ21lbnRzKTtcbiAgICAgICAgICB2YXIgY2xpcFN0YXJ0SW5zaWRlID0gaW5zaWRlUG9seWdvbihbIHgwLCB5MSBdKSwgaW5zaWRlID0gY2xlYW4gJiYgY2xpcFN0YXJ0SW5zaWRlLCB2aXNpYmxlID0gc2VnbWVudHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChpbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICAgIGQzX2dlb19jbGlwUG9seWdvbihzZWdtZW50cywgY29tcGFyZSwgY2xpcFN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXIucG9seWdvbkVuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSByaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGluc2lkZVBvbHlnb24ocCkge1xuICAgICAgICB2YXIgd24gPSAwLCBuID0gcG9seWdvbi5sZW5ndGgsIHkgPSBwWzFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAxLCB2ID0gcG9seWdvbltpXSwgbSA9IHYubGVuZ3RoLCBhID0gdlswXSwgYjsgaiA8IG07ICsraikge1xuICAgICAgICAgICAgYiA9IHZbal07XG4gICAgICAgICAgICBpZiAoYVsxXSA8PSB5KSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdID4geSAmJiBkM19jcm9zczJkKGEsIGIsIHApID4gMCkgKyt3bjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChiWzFdIDw9IHkgJiYgZDNfY3Jvc3MyZChhLCBiLCBwKSA8IDApIC0td247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHduICE9PSAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGEgPSAwLCBhMSA9IDA7XG4gICAgICAgIGlmIChmcm9tID09IG51bGwgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSkgfHwgY29tcGFyZVBvaW50cyhmcm9tLCB0bykgPCAwIF4gZGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGEgPT09IDAgfHwgYSA9PT0gMyA/IHgwIDogeDEsIGEgPiAxID8geTEgOiB5MCk7XG4gICAgICAgICAgfSB3aGlsZSAoKGEgPSAoYSArIGRpcmVjdGlvbiArIDQpICUgNCkgIT09IGExKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaXN0ZW5lci5wb2ludCh0b1swXSwgdG9bMV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb2ludFZpc2libGUoeCwgeSkge1xuICAgICAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgaWYgKHBvaW50VmlzaWJsZSh4LCB5KSkgbGlzdGVuZXIucG9pbnQoeCwgeSk7XG4gICAgICB9XG4gICAgICB2YXIgeF9fLCB5X18sIHZfXywgeF8sIHlfLCB2XywgZmlyc3QsIGNsZWFuO1xuICAgICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBpZiAocG9seWdvbikgcG9seWdvbi5wdXNoKHJpbmcgPSBbXSk7XG4gICAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdl8gPSBmYWxzZTtcbiAgICAgICAgeF8gPSB5XyA9IE5hTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICAgIGlmIChzZWdtZW50cykge1xuICAgICAgICAgIGxpbmVQb2ludCh4X18sIHlfXyk7XG4gICAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyTGlzdGVuZXIucmVqb2luKCk7XG4gICAgICAgICAgc2VnbWVudHMucHVzaChidWZmZXJMaXN0ZW5lci5idWZmZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgICBpZiAodl8pIGxpc3RlbmVyLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVQb2ludCh4LCB5KSB7XG4gICAgICAgIHggPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgtZDNfZ2VvX2NsaXBFeHRlbnRNQVgsIE1hdGgubWluKGQzX2dlb19jbGlwRXh0ZW50TUFYLCB5KSk7XG4gICAgICAgIHZhciB2ID0gcG9pbnRWaXNpYmxlKHgsIHkpO1xuICAgICAgICBpZiAocG9seWdvbikgcmluZy5wdXNoKFsgeCwgeSBdKTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgeF9fID0geCwgeV9fID0geSwgdl9fID0gdjtcbiAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICBsaXN0ZW5lci5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodiAmJiB2XykgbGlzdGVuZXIucG9pbnQoeCwgeSk7IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGwgPSB7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICB4OiB4XyxcbiAgICAgICAgICAgICAgICB5OiB5X1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiOiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2xpcExpbmUobCkpIHtcbiAgICAgICAgICAgICAgaWYgKCF2Xykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KGwuYS54LCBsLmEueSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGlzdGVuZXIucG9pbnQobC5iLngsIGwuYi55KTtcbiAgICAgICAgICAgICAgaWYgKCF2KSBsaXN0ZW5lci5saW5lRW5kKCk7XG4gICAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGluZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIGxpc3RlbmVyLnBvaW50KHgsIHkpO1xuICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsaXA7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWJzKHBbMF0gLSB4MCkgPCDOtSA/IGRpcmVjdGlvbiA+IDAgPyAwIDogMyA6IGFicyhwWzBdIC0geDEpIDwgzrUgPyBkaXJlY3Rpb24gPiAwID8gMiA6IDEgOiBhYnMocFsxXSAtIHkwKSA8IM61ID8gZGlyZWN0aW9uID4gMCA/IDEgOiAwIDogZGlyZWN0aW9uID4gMCA/IDMgOiAyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJlUG9pbnRzKGEueCwgYi54KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGFyZVBvaW50cyhhLCBiKSB7XG4gICAgICB2YXIgY2EgPSBjb3JuZXIoYSwgMSksIGNiID0gY29ybmVyKGIsIDEpO1xuICAgICAgcmV0dXJuIGNhICE9PSBjYiA/IGNhIC0gY2IgOiBjYSA9PT0gMCA/IGJbMV0gLSBhWzFdIDogY2EgPT09IDEgPyBhWzBdIC0gYlswXSA6IGNhID09PSAyID8gYVsxXSAtIGJbMV0gOiBiWzBdIC0gYVswXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NvbmljKHByb2plY3RBdCkge1xuICAgIHZhciDPhjAgPSAwLCDPhjEgPSDPgCAvIDMsIG0gPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSwgcCA9IG0oz4YwLCDPhjEpO1xuICAgIHAucGFyYWxsZWxzID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyDPhjAgLyDPgCAqIDE4MCwgz4YxIC8gz4AgKiAxODAgXTtcbiAgICAgIHJldHVybiBtKM+GMCA9IF9bMF0gKiDPgCAvIDE4MCwgz4YxID0gX1sxXSAqIM+AIC8gMTgwKTtcbiAgICB9O1xuICAgIHJldHVybiBwO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19jb25pY0VxdWFsQXJlYSjPhjAsIM+GMSkge1xuICAgIHZhciBzaW7PhjAgPSBNYXRoLnNpbijPhjApLCBuID0gKHNpbs+GMCArIE1hdGguc2luKM+GMSkpIC8gMiwgQyA9IDEgKyBzaW7PhjAgKiAoMiAqIG4gLSBzaW7PhjApLCDPgTAgPSBNYXRoLnNxcnQoQykgLyBuO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoQyAtIDIgKiBuICogTWF0aC5zaW4oz4YpKSAvIG47XG4gICAgICByZXR1cm4gWyDPgSAqIE1hdGguc2luKM67ICo9IG4pLCDPgTAgLSDPgSAqIE1hdGguY29zKM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IM+BMCAtIHk7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHgsIM+BMF95KSAvIG4sIGQzX2FzaW4oKEMgLSAoeCAqIHggKyDPgTBfeSAqIM+BMF95KSAqIG4gKiBuKSAvICgyICogbikpIF07XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfVxuICAoZDMuZ2VvLmNvbmljRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19jb25pYyhkM19nZW9fY29uaWNFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVhbEFyZWE7XG4gIGQzLmdlby5hbGJlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgOTYsIDAgXSkuY2VudGVyKFsgLS42LCAzOC43IF0pLnBhcmFsbGVscyhbIDI5LjUsIDQ1LjUgXSkuc2NhbGUoMTA3MCk7XG4gIH07XG4gIGQzLmdlby5hbGJlcnNVc2EgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbG93ZXI0OCA9IGQzLmdlby5hbGJlcnMoKTtcbiAgICB2YXIgYWxhc2thID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU0LCAwIF0pLmNlbnRlcihbIC0yLCA1OC41IF0pLnBhcmFsbGVscyhbIDU1LCA2NSBdKTtcbiAgICB2YXIgaGF3YWlpID0gZDMuZ2VvLmNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsgMTU3LCAwIF0pLmNlbnRlcihbIC0zLCAxOS45IF0pLnBhcmFsbGVscyhbIDgsIDE4IF0pO1xuICAgIHZhciBwb2ludCwgcG9pbnRTdHJlYW0gPSB7XG4gICAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBwb2ludCA9IFsgeCwgeSBdO1xuICAgICAgfVxuICAgIH0sIGxvd2VyNDhQb2ludCwgYWxhc2thUG9pbnQsIGhhd2FpaVBvaW50O1xuICAgIGZ1bmN0aW9uIGFsYmVyc1VzYShjb29yZGluYXRlcykge1xuICAgICAgdmFyIHggPSBjb29yZGluYXRlc1swXSwgeSA9IGNvb3JkaW5hdGVzWzFdO1xuICAgICAgcG9pbnQgPSBudWxsO1xuICAgICAgKGxvd2VyNDhQb2ludCh4LCB5KSwgcG9pbnQpIHx8IChhbGFza2FQb2ludCh4LCB5KSwgcG9pbnQpIHx8IGhhd2FpaVBvaW50KHgsIHkpO1xuICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBhbGJlcnNVc2EuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB0ID0gbG93ZXI0OC50cmFuc2xhdGUoKSwgeCA9IChjb29yZGluYXRlc1swXSAtIHRbMF0pIC8gaywgeSA9IChjb29yZGluYXRlc1sxXSAtIHRbMV0pIC8gaztcbiAgICAgIHJldHVybiAoeSA+PSAuMTIgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjQyNSAmJiB4IDwgLS4yMTQgPyBhbGFza2EgOiB5ID49IC4xNjYgJiYgeSA8IC4yMzQgJiYgeCA+PSAtLjIxNCAmJiB4IDwgLS4xMTUgPyBoYXdhaWkgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICAgIH07XG4gICAgYWxiZXJzVXNhLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgdmFyIGxvd2VyNDhTdHJlYW0gPSBsb3dlcjQ4LnN0cmVhbShzdHJlYW0pLCBhbGFza2FTdHJlYW0gPSBhbGFza2Euc3RyZWFtKHN0cmVhbSksIGhhd2FpaVN0cmVhbSA9IGhhd2FpaS5zdHJlYW0oc3RyZWFtKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgbG93ZXI0OFN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICBhbGFza2FTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvaW50KHgsIHkpO1xuICAgICAgICB9LFxuICAgICAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0uc3BoZXJlKCk7XG4gICAgICAgICAgYWxhc2thU3RyZWFtLnNwaGVyZSgpO1xuICAgICAgICAgIGhhd2FpaVN0cmVhbS5zcGhlcmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBsb3dlcjQ4U3RyZWFtLnBvbHlnb25TdGFydCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICAgICAgICBoYXdhaWlTdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGxvd2VyNDhTdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIGFsYXNrYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICAgICAgaGF3YWlpU3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGFsYmVyc1VzYS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnByZWNpc2lvbigpO1xuICAgICAgbG93ZXI0OC5wcmVjaXNpb24oXyk7XG4gICAgICBhbGFza2EucHJlY2lzaW9uKF8pO1xuICAgICAgaGF3YWlpLnByZWNpc2lvbihfKTtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICBhbGJlcnNVc2Euc2NhbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnNjYWxlKCk7XG4gICAgICBsb3dlcjQ4LnNjYWxlKF8pO1xuICAgICAgYWxhc2thLnNjYWxlKF8gKiAuMzUpO1xuICAgICAgaGF3YWlpLnNjYWxlKF8pO1xuICAgICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gICAgfTtcbiAgICBhbGJlcnNVc2EudHJhbnNsYXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbG93ZXI0OC50cmFuc2xhdGUoKTtcbiAgICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcbiAgICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDgudHJhbnNsYXRlKF8pLmNsaXBFeHRlbnQoWyBbIHggLSAuNDU1ICogaywgeSAtIC4yMzggKiBrIF0sIFsgeCArIC40NTUgKiBrLCB5ICsgLjIzOCAqIGsgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgYWxhc2thUG9pbnQgPSBhbGFza2EudHJhbnNsYXRlKFsgeCAtIC4zMDcgKiBrLCB5ICsgLjIwMSAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC40MjUgKiBrICsgzrUsIHkgKyAuMTIgKiBrICsgzrUgXSwgWyB4IC0gLjIxNCAqIGsgLSDOtSwgeSArIC4yMzQgKiBrIC0gzrUgXSBdKS5zdHJlYW0ocG9pbnRTdHJlYW0pLnBvaW50O1xuICAgICAgaGF3YWlpUG9pbnQgPSBoYXdhaWkudHJhbnNsYXRlKFsgeCAtIC4yMDUgKiBrLCB5ICsgLjIxMiAqIGsgXSkuY2xpcEV4dGVudChbIFsgeCAtIC4yMTQgKiBrICsgzrUsIHkgKyAuMTY2ICogayArIM61IF0sIFsgeCAtIC4xMTUgKiBrIC0gzrUsIHkgKyAuMjM0ICogayAtIM61IF0gXSkuc3RyZWFtKHBvaW50U3RyZWFtKS5wb2ludDtcbiAgICAgIHJldHVybiBhbGJlcnNVc2E7XG4gICAgfTtcbiAgICByZXR1cm4gYWxiZXJzVXNhLnNjYWxlKDEwNzApO1xuICB9O1xuICB2YXIgZDNfZ2VvX3BhdGhBcmVhU3VtLCBkM19nZW9fcGF0aEFyZWFQb2x5Z29uLCBkM19nZW9fcGF0aEFyZWEgPSB7XG4gICAgcG9pbnQ6IGQzX25vb3AsXG4gICAgbGluZVN0YXJ0OiBkM19ub29wLFxuICAgIGxpbmVFbmQ6IGQzX25vb3AsXG4gICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gPSAwO1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYVJpbmdTdGFydDtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhBcmVhLmxpbmVTdGFydCA9IGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZDNfZ2VvX3BhdGhBcmVhLnBvaW50ID0gZDNfbm9vcDtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVN1bSArPSBhYnMoZDNfZ2VvX3BhdGhBcmVhUG9seWdvbiAvIDIpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhBcmVhUmluZ1N0YXJ0KCkge1xuICAgIHZhciB4MDAsIHkwMCwgeDAsIHkwO1xuICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYS5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIHgwMCA9IHgwID0geCwgeTAwID0geTAgPSB5O1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQXJlYVBvbHlnb24gKz0geTAgKiB4IC0geDAgKiB5O1xuICAgICAgeDAgPSB4LCB5MCA9IHk7XG4gICAgfVxuICAgIGQzX2dlb19wYXRoQXJlYS5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgdmFyIGQzX2dlb19wYXRoQm91bmRzWDAsIGQzX2dlb19wYXRoQm91bmRzWTAsIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTE7XG4gIHZhciBkM19nZW9fcGF0aEJvdW5kcyA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhCb3VuZHNQb2ludCxcbiAgICBsaW5lU3RhcnQ6IGQzX25vb3AsXG4gICAgbGluZUVuZDogZDNfbm9vcCxcbiAgICBwb2x5Z29uU3RhcnQ6IGQzX25vb3AsXG4gICAgcG9seWdvbkVuZDogZDNfbm9vcFxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJvdW5kc1BvaW50KHgsIHkpIHtcbiAgICBpZiAoeCA8IGQzX2dlb19wYXRoQm91bmRzWDApIGQzX2dlb19wYXRoQm91bmRzWDAgPSB4O1xuICAgIGlmICh4ID4gZDNfZ2VvX3BhdGhCb3VuZHNYMSkgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IHg7XG4gICAgaWYgKHkgPCBkM19nZW9fcGF0aEJvdW5kc1kwKSBkM19nZW9fcGF0aEJvdW5kc1kwID0geTtcbiAgICBpZiAoeSA+IGQzX2dlb19wYXRoQm91bmRzWTEpIGQzX2dlb19wYXRoQm91bmRzWTEgPSB5O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQnVmZmVyKCkge1xuICAgIHZhciBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKDQuNSksIGJ1ZmZlciA9IFtdO1xuICAgIHZhciBzdHJlYW0gPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludExpbmVTdGFydDtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kUG9seWdvbjtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIH0sXG4gICAgICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgICAgICBwb2ludENpcmNsZSA9IGQzX2dlb19wYXRoQnVmZmVyQ2lyY2xlKF8pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgfSxcbiAgICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGJ1ZmZlci5qb2luKFwiXCIpO1xuICAgICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiTVwiLCB4LCBcIixcIiwgeSwgcG9pbnRDaXJjbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBidWZmZXIucHVzaChcIk1cIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmUoeCwgeSkge1xuICAgICAgYnVmZmVyLnB1c2goXCJMXCIsIHgsIFwiLFwiLCB5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kUG9seWdvbigpIHtcbiAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aEJ1ZmZlckNpcmNsZShyYWRpdXMpIHtcbiAgICByZXR1cm4gXCJtMCxcIiArIHJhZGl1cyArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgLTIgKiByYWRpdXMgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIDIgKiByYWRpdXMgKyBcInpcIjtcbiAgfVxuICB2YXIgZDNfZ2VvX3BhdGhDZW50cm9pZCA9IHtcbiAgICBwb2ludDogZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50LFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIH0sXG4gICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lU3RhcnQgPSBkM19nZW9fcGF0aENlbnRyb2lkTGluZVN0YXJ0O1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZDNfZ2VvX3BhdGhDZW50cm9pZExpbmVFbmQ7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeCwgeSkge1xuICAgIGQzX2dlb19jZW50cm9pZFgwICs9IHg7XG4gICAgZDNfZ2VvX2NlbnRyb2lkWTAgKz0geTtcbiAgICArK2QzX2dlb19jZW50cm9pZFowO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRMaW5lU3RhcnQoKSB7XG4gICAgdmFyIHgwLCB5MDtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IG5leHRQb2ludDtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWRQb2ludCh4MCA9IHgsIHkwID0geSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGR4ID0geCAtIHgwLCBkeSA9IHkgLSB5MCwgeiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkM19nZW9fY2VudHJvaWRYMSArPSB6ICogKHgwICsgeCkgLyAyO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWTEgKz0geiAqICh5MCArIHkpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoxICs9IHo7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAgPSB4LCB5MCA9IHkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcGF0aENlbnRyb2lkTGluZUVuZCgpIHtcbiAgICBkM19nZW9fcGF0aENlbnRyb2lkLnBvaW50ID0gZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19wYXRoQ2VudHJvaWRSaW5nU3RhcnQoKSB7XG4gICAgdmFyIHgwMCwgeTAwLCB4MCwgeTA7XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5wb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGQzX2dlb19wYXRoQ2VudHJvaWQucG9pbnQgPSBuZXh0UG9pbnQ7XG4gICAgICBkM19nZW9fcGF0aENlbnRyb2lkUG9pbnQoeDAwID0geDAgPSB4LCB5MDAgPSB5MCA9IHkpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gbmV4dFBvaW50KHgsIHkpIHtcbiAgICAgIHZhciBkeCA9IHggLSB4MCwgZHkgPSB5IC0geTAsIHogPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDEgKz0geiAqICh4MCArIHgpIC8gMjtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkxICs9IHogKiAoeTAgKyB5KSAvIDI7XG4gICAgICBkM19nZW9fY2VudHJvaWRaMSArPSB6O1xuICAgICAgeiA9IHkwICogeCAtIHgwICogeTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFgyICs9IHogKiAoeDAgKyB4KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFkyICs9IHogKiAoeTAgKyB5KTtcbiAgICAgIGQzX2dlb19jZW50cm9pZFoyICs9IHogKiAzO1xuICAgICAgZDNfZ2VvX3BhdGhDZW50cm9pZFBvaW50KHgwID0geCwgeTAgPSB5KTtcbiAgICB9XG4gICAgZDNfZ2VvX3BhdGhDZW50cm9pZC5saW5lRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICBuZXh0UG9pbnQoeDAwLCB5MDApO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhDb250ZXh0KGNvbnRleHQpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjU7XG4gICAgdmFyIHN0cmVhbSA9IHtcbiAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZVN0YXJ0O1xuICAgICAgfSxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmRQb2x5Z29uO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50O1xuICAgICAgfSxcbiAgICAgIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgICAgIHBvaW50UmFkaXVzID0gXztcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IGQzX25vb3BcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHggKyBwb2ludFJhZGl1cywgeSk7XG4gICAgICBjb250ZXh0LmFyYyh4LCB5LCBwb2ludFJhZGl1cywgMCwgz4QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludExpbmVTdGFydCh4LCB5KSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIHN0cmVhbS5wb2ludCA9IHBvaW50TGluZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKHgsIHkpIHtcbiAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgc3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVFbmRQb2x5Z29uKCkge1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcmVzYW1wbGUocHJvamVjdCkge1xuICAgIHZhciDOtDIgPSAuNSwgY29zTWluRGlzdGFuY2UgPSBNYXRoLmNvcygzMCAqIGQzX3JhZGlhbnMpLCBtYXhEZXB0aCA9IDE2O1xuICAgIGZ1bmN0aW9uIHJlc2FtcGxlKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIChtYXhEZXB0aCA/IHJlc2FtcGxlUmVjdXJzaXZlIDogcmVzYW1wbGVOb25lKShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNhbXBsZU5vbmUoc3RyZWFtKSB7XG4gICAgICByZXR1cm4gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB4ID0gcHJvamVjdCh4LCB5KTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlUmVjdXJzaXZlKHN0cmVhbSkge1xuICAgICAgdmFyIM67MDAsIM+GMDAsIHgwMCwgeTAwLCBhMDAsIGIwMCwgYzAwLCDOuzAsIHgwLCB5MCwgYTAsIGIwLCBjMDtcbiAgICAgIHZhciByZXNhbXBsZSA9IHtcbiAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgbGluZUVuZDogbGluZUVuZCxcbiAgICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgICAgcmVzYW1wbGUubGluZVN0YXJ0ID0gcmluZ1N0YXJ0O1xuICAgICAgICB9LFxuICAgICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgICAgICAgIHJlc2FtcGxlLmxpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgICAgeDAgPSBOYU47XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gbGluZVBvaW50O1xuICAgICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsaW5lUG9pbnQozrssIM+GKSB7XG4gICAgICAgIHZhciBjID0gZDNfZ2VvX2NhcnRlc2lhbihbIM67LCDPhiBdKSwgcCA9IHByb2plY3QozrssIM+GKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgwID0gcFswXSwgeTAgPSBwWzFdLCDOuzAgPSDOuywgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHN0cmVhbS5wb2ludCh4MCwgeTApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbGluZUVuZCgpIHtcbiAgICAgICAgcmVzYW1wbGUucG9pbnQgPSBwb2ludDtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdTdGFydCgpIHtcbiAgICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICAgIHJlc2FtcGxlLnBvaW50ID0gcmluZ1BvaW50O1xuICAgICAgICByZXNhbXBsZS5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdQb2ludCjOuywgz4YpIHtcbiAgICAgICAgbGluZVBvaW50KM67MDAgPSDOuywgz4YwMCA9IM+GKSwgeDAwID0geDAsIHkwMCA9IHkwLCBhMDAgPSBhMCwgYjAwID0gYjAsIGMwMCA9IGMwO1xuICAgICAgICByZXNhbXBsZS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJpbmdFbmQoKSB7XG4gICAgICAgIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgzrswMCwgYTAwLCBiMDAsIGMwMCwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICAgIHJlc2FtcGxlLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBsaW5lRW5kKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgzrswLCBhMCwgYjAsIGMwLCB4MSwgeTEsIM67MSwgYTEsIGIxLCBjMSwgZGVwdGgsIHN0cmVhbSkge1xuICAgICAgdmFyIGR4ID0geDEgLSB4MCwgZHkgPSB5MSAtIHkwLCBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgaWYgKGQyID4gNCAqIM60MiAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhciBhID0gYTAgKyBhMSwgYiA9IGIwICsgYjEsIGMgPSBjMCArIGMxLCBtID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksIM+GMiA9IE1hdGguYXNpbihjIC89IG0pLCDOuzIgPSBhYnMoYWJzKGMpIC0gMSkgPCDOtSB8fCBhYnMozrswIC0gzrsxKSA8IM61ID8gKM67MCArIM67MSkgLyAyIDogTWF0aC5hdGFuMihiLCBhKSwgcCA9IHByb2plY3QozrsyLCDPhjIpLCB4MiA9IHBbMF0sIHkyID0gcFsxXSwgZHgyID0geDIgLSB4MCwgZHkyID0geTIgLSB5MCwgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgICBpZiAoZHogKiBkeiAvIGQyID4gzrQyIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIC41KSA+IC4zIHx8IGEwICogYTEgKyBiMCAqIGIxICsgYzAgKiBjMSA8IGNvc01pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCDOuzAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgzrsyLCBhIC89IG0sIGIgLz0gbSwgYywgZGVwdGgsIHN0cmVhbSk7XG4gICAgICAgICAgc3RyZWFtLnBvaW50KHgyLCB5Mik7XG4gICAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCDOuzIsIGEsIGIsIGMsIHgxLCB5MSwgzrsxLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXNhbXBsZS5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQozrQyKTtcbiAgICAgIG1heERlcHRoID0gKM60MiA9IF8gKiBfKSA+IDAgJiYgMTY7XG4gICAgICByZXR1cm4gcmVzYW1wbGU7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzYW1wbGU7XG4gIH1cbiAgZDMuZ2VvLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsIHByb2plY3Rpb24sIGNvbnRleHQsIHByb2plY3RTdHJlYW0sIGNvbnRleHRTdHJlYW0sIGNhY2hlU3RyZWFtO1xuICAgIGZ1bmN0aW9uIHBhdGgob2JqZWN0KSB7XG4gICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICghY2FjaGVTdHJlYW0gfHwgIWNhY2hlU3RyZWFtLnZhbGlkKSBjYWNoZVN0cmVhbSA9IHByb2plY3RTdHJlYW0oY29udGV4dFN0cmVhbSk7XG4gICAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBjYWNoZVN0cmVhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGV4dFN0cmVhbS5yZXN1bHQoKTtcbiAgICB9XG4gICAgcGF0aC5hcmVhID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBkM19nZW9fcGF0aEFyZWFTdW0gPSAwO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhBcmVhKSk7XG4gICAgICByZXR1cm4gZDNfZ2VvX3BhdGhBcmVhU3VtO1xuICAgIH07XG4gICAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX2NlbnRyb2lkWDAgPSBkM19nZW9fY2VudHJvaWRZMCA9IGQzX2dlb19jZW50cm9pZFowID0gZDNfZ2VvX2NlbnRyb2lkWDEgPSBkM19nZW9fY2VudHJvaWRZMSA9IGQzX2dlb19jZW50cm9pZFoxID0gZDNfZ2VvX2NlbnRyb2lkWDIgPSBkM19nZW9fY2VudHJvaWRZMiA9IGQzX2dlb19jZW50cm9pZFoyID0gMDtcbiAgICAgIGQzLmdlby5zdHJlYW0ob2JqZWN0LCBwcm9qZWN0U3RyZWFtKGQzX2dlb19wYXRoQ2VudHJvaWQpKTtcbiAgICAgIHJldHVybiBkM19nZW9fY2VudHJvaWRaMiA/IFsgZDNfZ2VvX2NlbnRyb2lkWDIgLyBkM19nZW9fY2VudHJvaWRaMiwgZDNfZ2VvX2NlbnRyb2lkWTIgLyBkM19nZW9fY2VudHJvaWRaMiBdIDogZDNfZ2VvX2NlbnRyb2lkWjEgPyBbIGQzX2dlb19jZW50cm9pZFgxIC8gZDNfZ2VvX2NlbnRyb2lkWjEsIGQzX2dlb19jZW50cm9pZFkxIC8gZDNfZ2VvX2NlbnRyb2lkWjEgXSA6IGQzX2dlb19jZW50cm9pZFowID8gWyBkM19nZW9fY2VudHJvaWRYMCAvIGQzX2dlb19jZW50cm9pZFowLCBkM19nZW9fY2VudHJvaWRZMCAvIGQzX2dlb19jZW50cm9pZFowIF0gOiBbIE5hTiwgTmFOIF07XG4gICAgfTtcbiAgICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgZDNfZ2VvX3BhdGhCb3VuZHNYMSA9IGQzX2dlb19wYXRoQm91bmRzWTEgPSAtKGQzX2dlb19wYXRoQm91bmRzWDAgPSBkM19nZW9fcGF0aEJvdW5kc1kwID0gSW5maW5pdHkpO1xuICAgICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIHByb2plY3RTdHJlYW0oZDNfZ2VvX3BhdGhCb3VuZHMpKTtcbiAgICAgIHJldHVybiBbIFsgZDNfZ2VvX3BhdGhCb3VuZHNYMCwgZDNfZ2VvX3BhdGhCb3VuZHNZMCBdLCBbIGQzX2dlb19wYXRoQm91bmRzWDEsIGQzX2dlb19wYXRoQm91bmRzWTEgXSBdO1xuICAgIH07XG4gICAgcGF0aC5wcm9qZWN0aW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcHJvamVjdGlvbjtcbiAgICAgIHByb2plY3RTdHJlYW0gPSAocHJvamVjdGlvbiA9IF8pID8gXy5zdHJlYW0gfHwgZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKF8pIDogZDNfaWRlbnRpdHk7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvbnRleHQ7XG4gICAgICBjb250ZXh0U3RyZWFtID0gKGNvbnRleHQgPSBfKSA9PSBudWxsID8gbmV3IGQzX2dlb19wYXRoQnVmZmVyKCkgOiBuZXcgZDNfZ2VvX3BhdGhDb250ZXh0KF8pO1xuICAgICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcGF0aC5wb2ludFJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgICAgcG9pbnRSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IChjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKCtfKSwgK18pO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKGQzLmdlby5hbGJlcnNVc2EoKSkuY29udGV4dChudWxsKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3BhdGhQcm9qZWN0U3RyZWFtKHByb2plY3QpIHtcbiAgICB2YXIgcmVzYW1wbGUgPSBkM19nZW9fcmVzYW1wbGUoZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHByb2plY3QoWyB4ICogZDNfZGVncmVlcywgeSAqIGQzX2RlZ3JlZXMgXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhyZXNhbXBsZShzdHJlYW0pKTtcbiAgICB9O1xuICB9XG4gIGQzLmdlby50cmFuc2Zvcm0gPSBmdW5jdGlvbihtZXRob2RzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmVhbTogZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pO1xuICAgICAgICBmb3IgKHZhciBrIGluIG1ldGhvZHMpIHRyYW5zZm9ybVtrXSA9IG1ldGhvZHNba107XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybShzdHJlYW0pIHtcbiAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgfVxuICBkM19nZW9fdHJhbnNmb3JtLnByb3RvdHlwZSA9IHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfSxcbiAgICBzcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0uc3BoZXJlKCk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RyZWFtLmxpbmVFbmQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgICB9LFxuICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJlYW0ucG9seWdvbkVuZCgpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zZm9ybVBvaW50KHN0cmVhbSwgcG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgc3BoZXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLnNwaGVyZSgpO1xuICAgICAgfSxcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIH0sXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICB9LFxuICAgICAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBkMy5nZW8ucHJvamVjdGlvbiA9IGQzX2dlb19wcm9qZWN0aW9uO1xuICBkMy5nZW8ucHJvamVjdGlvbk11dGF0b3IgPSBkM19nZW9fcHJvamVjdGlvbk11dGF0b3I7XG4gIGZ1bmN0aW9uIGQzX2dlb19wcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHByb2plY3Q7XG4gICAgfSkoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gICAgdmFyIHByb2plY3QsIHJvdGF0ZSwgcHJvamVjdFJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlID0gZDNfZ2VvX3Jlc2FtcGxlKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgcmV0dXJuIFsgeFswXSAqIGsgKyDOtHgsIM60eSAtIHhbMV0gKiBrIF07XG4gICAgfSksIGsgPSAxNTAsIHggPSA0ODAsIHkgPSAyNTAsIM67ID0gMCwgz4YgPSAwLCDOtM67ID0gMCwgzrTPhiA9IDAsIM60zrMgPSAwLCDOtHgsIM60eSwgcHJlY2xpcCA9IGQzX2dlb19jbGlwQW50aW1lcmlkaWFuLCBwb3N0Y2xpcCA9IGQzX2lkZW50aXR5LCBjbGlwQW5nbGUgPSBudWxsLCBjbGlwRXh0ZW50ID0gbnVsbCwgc3RyZWFtO1xuICAgIGZ1bmN0aW9uIHByb2plY3Rpb24ocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZShwb2ludFswXSAqIGQzX3JhZGlhbnMsIHBvaW50WzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gWyBwb2ludFswXSAqIGsgKyDOtHgsIM60eSAtIHBvaW50WzFdICogayBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZlcnQocG9pbnQpIHtcbiAgICAgIHBvaW50ID0gcHJvamVjdFJvdGF0ZS5pbnZlcnQoKHBvaW50WzBdIC0gzrR4KSAvIGssICjOtHkgLSBwb2ludFsxXSkgLyBrKTtcbiAgICAgIHJldHVybiBwb2ludCAmJiBbIHBvaW50WzBdICogZDNfZGVncmVlcywgcG9pbnRbMV0gKiBkM19kZWdyZWVzIF07XG4gICAgfVxuICAgIHByb2plY3Rpb24uc3RyZWFtID0gZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbSA9IGQzX2dlb19wcm9qZWN0aW9uUmFkaWFucyhwcmVjbGlwKHJvdGF0ZSwgcHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKG91dHB1dCkpKSk7XG4gICAgICBzdHJlYW0udmFsaWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24uY2xpcEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEFuZ2xlO1xuICAgICAgcHJlY2xpcCA9IF8gPT0gbnVsbCA/IChjbGlwQW5nbGUgPSBfLCBkM19nZW9fY2xpcEFudGltZXJpZGlhbikgOiBkM19nZW9fY2xpcENpcmNsZSgoY2xpcEFuZ2xlID0gK18pICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gaW52YWxpZGF0ZSgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudDtcbiAgICAgIGNsaXBFeHRlbnQgPSBfO1xuICAgICAgcG9zdGNsaXAgPSBfID8gZDNfZ2VvX2NsaXBFeHRlbnQoX1swXVswXSwgX1swXVsxXSwgX1sxXVswXSwgX1sxXVsxXSkgOiBkM19pZGVudGl0eTtcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfTtcbiAgICBwcm9qZWN0aW9uLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaztcbiAgICAgIGsgPSArXztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi50cmFuc2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgsIHkgXTtcbiAgICAgIHggPSArX1swXTtcbiAgICAgIHkgPSArX1sxXTtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM67ICogZDNfZGVncmVlcywgz4YgKiBkM19kZWdyZWVzIF07XG4gICAgICDOuyA9IF9bMF0gJSAzNjAgKiBkM19yYWRpYW5zO1xuICAgICAgz4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gICAgcHJvamVjdGlvbi5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIM60zrsgKiBkM19kZWdyZWVzLCDOtM+GICogZDNfZGVncmVlcywgzrTOsyAqIGQzX2RlZ3JlZXMgXTtcbiAgICAgIM60zrsgPSBfWzBdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60z4YgPSBfWzFdICUgMzYwICogZDNfcmFkaWFucztcbiAgICAgIM60zrMgPSBfLmxlbmd0aCA+IDIgPyBfWzJdICUgMzYwICogZDNfcmFkaWFucyA6IDA7XG4gICAgICByZXR1cm4gcmVzZXQoKTtcbiAgICB9O1xuICAgIGQzLnJlYmluZChwcm9qZWN0aW9uLCBwcm9qZWN0UmVzYW1wbGUsIFwicHJlY2lzaW9uXCIpO1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgcHJvamVjdFJvdGF0ZSA9IGQzX2dlb19jb21wb3NlKHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbijOtM67LCDOtM+GLCDOtM6zKSwgcHJvamVjdCk7XG4gICAgICB2YXIgY2VudGVyID0gcHJvamVjdCjOuywgz4YpO1xuICAgICAgzrR4ID0geCAtIGNlbnRlclswXSAqIGs7XG4gICAgICDOtHkgPSB5ICsgY2VudGVyWzFdICogaztcbiAgICAgIHJldHVybiBpbnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICBpZiAoc3RyZWFtKSBzdHJlYW0udmFsaWQgPSBmYWxzZSwgc3RyZWFtID0gbnVsbDtcbiAgICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBwcm9qZWN0aW9uLmludmVydCA9IHByb2plY3QuaW52ZXJ0ICYmIGludmVydDtcbiAgICAgIHJldHVybiByZXNldCgpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3Byb2plY3Rpb25SYWRpYW5zKHN0cmVhbSkge1xuICAgIHJldHVybiBkM19nZW9fdHJhbnNmb3JtUG9pbnQoc3RyZWFtLCBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBzdHJlYW0ucG9pbnQoeCAqIGQzX3JhZGlhbnMsIHkgKiBkM19yYWRpYW5zKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyKM67LCDPhikge1xuICAgIHJldHVybiBbIM67LCDPhiBdO1xuICB9XG4gIChkMy5nZW8uZXF1aXJlY3Rhbmd1bGFyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19lcXVpcmVjdGFuZ3VsYXIpO1xuICB9KS5yYXcgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyLmludmVydCA9IGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gIGQzLmdlby5yb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0ZSkge1xuICAgIHJvdGF0ZSA9IGQzX2dlb19yb3RhdGlvbihyb3RhdGVbMF0gJSAzNjAgKiBkM19yYWRpYW5zLCByb3RhdGVbMV0gKiBkM19yYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIGQzX3JhZGlhbnMgOiAwKTtcbiAgICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHJvdGF0ZShjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfVxuICAgIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gcm90YXRlLmludmVydChjb29yZGluYXRlc1swXSAqIGQzX3JhZGlhbnMsIGNvb3JkaW5hdGVzWzFdICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY29vcmRpbmF0ZXNbMF0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXNbMV0gKj0gZDNfZGVncmVlcywgY29vcmRpbmF0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZm9yd2FyZDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2lkZW50aXR5Um90YXRpb24ozrssIM+GKSB7XG4gICAgcmV0dXJuIFsgzrsgPiDPgCA/IM67IC0gz4QgOiDOuyA8IC3PgCA/IM67ICsgz4QgOiDOuywgz4YgXTtcbiAgfVxuICBkM19nZW9faWRlbnRpdHlSb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZXF1aXJlY3Rhbmd1bGFyO1xuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb24ozrTOuywgzrTPhiwgzrTOsykge1xuICAgIHJldHVybiDOtM67ID8gzrTPhiB8fCDOtM6zID8gZDNfZ2VvX2NvbXBvc2UoZDNfZ2VvX3JvdGF0aW9uzrsozrTOuyksIGQzX2dlb19yb3RhdGlvbs+GzrMozrTPhiwgzrTOsykpIDogZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykgOiDOtM+GIHx8IM60zrMgPyBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIDogZDNfZ2VvX2lkZW50aXR5Um90YXRpb247XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2ZvcndhcmRSb3RhdGlvbs67KM60zrspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ozrssIM+GKSB7XG4gICAgICByZXR1cm4gzrsgKz0gzrTOuywgWyDOuyA+IM+AID8gzrsgLSDPhCA6IM67IDwgLc+AID8gzrsgKyDPhCA6IM67LCDPhiBdO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX3JvdGF0aW9uzrsozrTOuykge1xuICAgIHZhciByb3RhdGlvbiA9IGQzX2dlb19mb3J3YXJkUm90YXRpb27OuyjOtM67KTtcbiAgICByb3RhdGlvbi5pbnZlcnQgPSBkM19nZW9fZm9yd2FyZFJvdGF0aW9uzrsoLc60zrspO1xuICAgIHJldHVybiByb3RhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9fcm90YXRpb27Phs6zKM60z4YsIM60zrMpIHtcbiAgICB2YXIgY29zzrTPhiA9IE1hdGguY29zKM60z4YpLCBzaW7OtM+GID0gTWF0aC5zaW4ozrTPhiksIGNvc860zrMgPSBNYXRoLmNvcyjOtM6zKSwgc2luzrTOsyA9IE1hdGguc2luKM60zrMpO1xuICAgIGZ1bmN0aW9uIHJvdGF0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM+GICsgeCAqIHNpbs60z4Y7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zIC0gayAqIHNpbs60zrMsIHggKiBjb3POtM+GIC0geiAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM6zICsgeSAqIHNpbs60zrMpIF07XG4gICAgfVxuICAgIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgdmFyIGNvc8+GID0gTWF0aC5jb3Moz4YpLCB4ID0gTWF0aC5jb3MozrspICogY29zz4YsIHkgPSBNYXRoLnNpbijOuykgKiBjb3PPhiwgeiA9IE1hdGguc2luKM+GKSwgayA9IHogKiBjb3POtM6zIC0geSAqIHNpbs60zrM7XG4gICAgICByZXR1cm4gWyBNYXRoLmF0YW4yKHkgKiBjb3POtM6zICsgeiAqIHNpbs60zrMsIHggKiBjb3POtM+GICsgayAqIHNpbs60z4YpLCBkM19hc2luKGsgKiBjb3POtM+GIC0geCAqIHNpbs60z4YpIF07XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRpb247XG4gIH1cbiAgZDMuZ2VvLmNpcmNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvcmlnaW4gPSBbIDAsIDAgXSwgYW5nbGUsIHByZWNpc2lvbiA9IDYsIGludGVycG9sYXRlO1xuICAgIGZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgICAgIHZhciBjZW50ZXIgPSB0eXBlb2Ygb3JpZ2luID09PSBcImZ1bmN0aW9uXCIgPyBvcmlnaW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IG9yaWdpbiwgcm90YXRlID0gZDNfZ2VvX3JvdGF0aW9uKC1jZW50ZXJbMF0gKiBkM19yYWRpYW5zLCAtY2VudGVyWzFdICogZDNfcmFkaWFucywgMCkuaW52ZXJ0LCByaW5nID0gW107XG4gICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCB7XG4gICAgICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgICAgICAgIHhbMF0gKj0gZDNfZGVncmVlcywgeFsxXSAqPSBkM19kZWdyZWVzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyByaW5nIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGNpcmNsZS5vcmlnaW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvcmlnaW47XG4gICAgICBvcmlnaW4gPSB4O1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIGNpcmNsZS5hbmdsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGFuZ2xlO1xuICAgICAgaW50ZXJwb2xhdGUgPSBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUoKGFuZ2xlID0gK3gpICogZDNfcmFkaWFucywgcHJlY2lzaW9uICogZDNfcmFkaWFucyk7XG4gICAgICByZXR1cm4gY2lyY2xlO1xuICAgIH07XG4gICAgY2lyY2xlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIGludGVycG9sYXRlID0gZDNfZ2VvX2NpcmNsZUludGVycG9sYXRlKGFuZ2xlICogZDNfcmFkaWFucywgKHByZWNpc2lvbiA9ICtfKSAqIGQzX3JhZGlhbnMpO1xuICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICB9O1xuICAgIHJldHVybiBjaXJjbGUuYW5nbGUoOTApO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9fY2lyY2xlSW50ZXJwb2xhdGUocmFkaXVzLCBwcmVjaXNpb24pIHtcbiAgICB2YXIgY3IgPSBNYXRoLmNvcyhyYWRpdXMpLCBzciA9IE1hdGguc2luKHJhZGl1cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZyb20sIHRvLCBkaXJlY3Rpb24sIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgc3RlcCA9IGRpcmVjdGlvbiAqIHByZWNpc2lvbjtcbiAgICAgIGlmIChmcm9tICE9IG51bGwpIHtcbiAgICAgICAgZnJvbSA9IGQzX2dlb19jaXJjbGVBbmdsZShjciwgZnJvbSk7XG4gICAgICAgIHRvID0gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCB0byk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwID8gZnJvbSA8IHRvIDogZnJvbSA+IHRvKSBmcm9tICs9IGRpcmVjdGlvbiAqIM+EO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IHJhZGl1cyArIGRpcmVjdGlvbiAqIM+EO1xuICAgICAgICB0byA9IHJhZGl1cyAtIC41ICogc3RlcDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHBvaW50LCB0ID0gZnJvbTsgZGlyZWN0aW9uID4gMCA/IHQgPiB0byA6IHQgPCB0bzsgdCAtPSBzdGVwKSB7XG4gICAgICAgIGxpc3RlbmVyLnBvaW50KChwb2ludCA9IGQzX2dlb19zcGhlcmljYWwoWyBjciwgLXNyICogTWF0aC5jb3ModCksIC1zciAqIE1hdGguc2luKHQpIF0pKVswXSwgcG9pbnRbMV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvX2NpcmNsZUFuZ2xlKGNyLCBwb2ludCkge1xuICAgIHZhciBhID0gZDNfZ2VvX2NhcnRlc2lhbihwb2ludCk7XG4gICAgYVswXSAtPSBjcjtcbiAgICBkM19nZW9fY2FydGVzaWFuTm9ybWFsaXplKGEpO1xuICAgIHZhciBhbmdsZSA9IGQzX2Fjb3MoLWFbMV0pO1xuICAgIHJldHVybiAoKC1hWzJdIDwgMCA/IC1hbmdsZSA6IGFuZ2xlKSArIDIgKiBNYXRoLlBJIC0gzrUpICUgKDIgKiBNYXRoLlBJKTtcbiAgfVxuICBkMy5nZW8uZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIM6UzrsgPSAoYlswXSAtIGFbMF0pICogZDNfcmFkaWFucywgz4YwID0gYVsxXSAqIGQzX3JhZGlhbnMsIM+GMSA9IGJbMV0gKiBkM19yYWRpYW5zLCBzaW7OlM67ID0gTWF0aC5zaW4ozpTOuyksIGNvc86UzrsgPSBNYXRoLmNvcyjOlM67KSwgc2luz4YwID0gTWF0aC5zaW4oz4YwKSwgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgc2luz4YxID0gTWF0aC5zaW4oz4YxKSwgY29zz4YxID0gTWF0aC5jb3Moz4YxKSwgdDtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihNYXRoLnNxcnQoKHQgPSBjb3PPhjEgKiBzaW7OlM67KSAqIHQgKyAodCA9IGNvc8+GMCAqIHNpbs+GMSAtIHNpbs+GMCAqIGNvc8+GMSAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GMSArIGNvc8+GMCAqIGNvc8+GMSAqIGNvc86UzrspO1xuICB9O1xuICBkMy5nZW8uZ3JhdGljdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHgxLCB4MCwgWDEsIFgwLCB5MSwgeTAsIFkxLCBZMCwgZHggPSAxMCwgZHkgPSBkeCwgRFggPSA5MCwgRFkgPSAzNjAsIHgsIHksIFgsIFksIHByZWNpc2lvbiA9IDIuNTtcbiAgICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogbGluZXMoKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXMoKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoWTAgLyBEWSkgKiBEWSwgWTEsIERZKS5tYXAoWSkpLmNvbmNhdChkMy5yYW5nZShNYXRoLmNlaWwoeDAgLyBkeCkgKiBkeCwgeDEsIGR4KS5maWx0ZXIoZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gYWJzKHggJSBEWCkgPiDOtTtcbiAgICAgIH0pLm1hcCh4KSkuY29uY2F0KGQzLnJhbmdlKE1hdGguY2VpbCh5MCAvIGR5KSAqIGR5LCB5MSwgZHkpLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBhYnMoeSAlIERZKSA+IM61O1xuICAgICAgfSkubWFwKHkpKTtcbiAgICB9XG4gICAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGluZXMoKS5tYXAoZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm91dGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogWyBYKFgwKS5jb25jYXQoWShZMSkuc2xpY2UoMSksIFgoWDEpLnJldmVyc2UoKS5zbGljZSgxKSwgWShZMCkucmV2ZXJzZSgpLnNsaWNlKDEpKSBdXG4gICAgICB9O1xuICAgIH07XG4gICAgZ3JhdGljdWxlLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vckV4dGVudCgpO1xuICAgICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChfKS5taW5vckV4dGVudChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvckV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFsgWyBYMCwgWTAgXSwgWyBYMSwgWTEgXSBdO1xuICAgICAgWDAgPSArX1swXVswXSwgWDEgPSArX1sxXVswXTtcbiAgICAgIFkwID0gK19bMF1bMV0sIFkxID0gK19bMV1bMV07XG4gICAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgICBpZiAoWTAgPiBZMSkgXyA9IFkwLCBZMCA9IFkxLCBZMSA9IF87XG4gICAgICByZXR1cm4gZ3JhdGljdWxlLnByZWNpc2lvbihwcmVjaXNpb24pO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLm1pbm9yRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBbIHgwLCB5MCBdLCBbIHgxLCB5MSBdIF07XG4gICAgICB4MCA9ICtfWzBdWzBdLCB4MSA9ICtfWzFdWzBdO1xuICAgICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICAgIGlmICh4MCA+IHgxKSBfID0geDAsIHgwID0geDEsIHgxID0gXztcbiAgICAgIGlmICh5MCA+IHkxKSBfID0geTAsIHkwID0geTEsIHkxID0gXztcbiAgICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gICAgfTtcbiAgICBncmF0aWN1bGUuc3RlcCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5taW5vclN0ZXAoKTtcbiAgICAgIHJldHVybiBncmF0aWN1bGUubWFqb3JTdGVwKF8pLm1pbm9yU3RlcChfKTtcbiAgICB9O1xuICAgIGdyYXRpY3VsZS5tYWpvclN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIERYLCBEWSBdO1xuICAgICAgRFggPSArX1swXSwgRFkgPSArX1sxXTtcbiAgICAgIHJldHVybiBncmF0aWN1bGU7XG4gICAgfTtcbiAgICBncmF0aWN1bGUubWlub3JTdGVwID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gWyBkeCwgZHkgXTtcbiAgICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgZ3JhdGljdWxlLnByZWNpc2lvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICAgIHByZWNpc2lvbiA9ICtfO1xuICAgICAgeCA9IGQzX2dlb19ncmF0aWN1bGVYKHkwLCB5MSwgOTApO1xuICAgICAgeSA9IGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgcHJlY2lzaW9uKTtcbiAgICAgIFggPSBkM19nZW9fZ3JhdGljdWxlWChZMCwgWTEsIDkwKTtcbiAgICAgIFkgPSBkM19nZW9fZ3JhdGljdWxlWShYMCwgWDEsIHByZWNpc2lvbik7XG4gICAgICByZXR1cm4gZ3JhdGljdWxlO1xuICAgIH07XG4gICAgcmV0dXJuIGdyYXRpY3VsZS5tYWpvckV4dGVudChbIFsgLTE4MCwgLTkwICsgzrUgXSwgWyAxODAsIDkwIC0gzrUgXSBdKS5taW5vckV4dGVudChbIFsgLTE4MCwgLTgwIC0gzrUgXSwgWyAxODAsIDgwICsgzrUgXSBdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvX2dyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICAgIHZhciB5ID0gZDMucmFuZ2UoeTAsIHkxIC0gzrUsIGR5KS5jb25jYXQoeTEpO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geS5tYXAoZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gWyB4LCB5IF07XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19ncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgICB2YXIgeCA9IGQzLnJhbmdlKHgwLCB4MSAtIM61LCBkeCkuY29uY2F0KHgxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHgubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIFsgeCwgeSBdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zb3VyY2UoZCkge1xuICAgIHJldHVybiBkLnNvdXJjZTtcbiAgfVxuICBmdW5jdGlvbiBkM190YXJnZXQoZCkge1xuICAgIHJldHVybiBkLnRhcmdldDtcbiAgfVxuICBkMy5nZW8uZ3JlYXRBcmMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc291cmNlID0gZDNfc291cmNlLCBzb3VyY2VfLCB0YXJnZXQgPSBkM190YXJnZXQsIHRhcmdldF87XG4gICAgZnVuY3Rpb24gZ3JlYXRBcmMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IFsgc291cmNlXyB8fCBzb3VyY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdGFyZ2V0XyB8fCB0YXJnZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSBdXG4gICAgICB9O1xuICAgIH1cbiAgICBncmVhdEFyYy5kaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzLmdlby5kaXN0YW5jZShzb3VyY2VfIHx8IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0YXJnZXRfIHx8IHRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICAgIGdyZWF0QXJjLnNvdXJjZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvdXJjZTtcbiAgICAgIHNvdXJjZSA9IF8sIHNvdXJjZV8gPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gbnVsbCA6IF87XG4gICAgICByZXR1cm4gZ3JlYXRBcmM7XG4gICAgfTtcbiAgICBncmVhdEFyYy50YXJnZXQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0YXJnZXQ7XG4gICAgICB0YXJnZXQgPSBfLCB0YXJnZXRfID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIGdyZWF0QXJjO1xuICAgIH07XG4gICAgZ3JlYXRBcmMucHJlY2lzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGdyZWF0QXJjIDogMDtcbiAgICB9O1xuICAgIHJldHVybiBncmVhdEFyYztcbiAgfTtcbiAgZDMuZ2VvLmludGVycG9sYXRlID0gZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gZDNfZ2VvX2ludGVycG9sYXRlKHNvdXJjZVswXSAqIGQzX3JhZGlhbnMsIHNvdXJjZVsxXSAqIGQzX3JhZGlhbnMsIHRhcmdldFswXSAqIGQzX3JhZGlhbnMsIHRhcmdldFsxXSAqIGQzX3JhZGlhbnMpO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9faW50ZXJwb2xhdGUoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICB2YXIgY3kwID0gTWF0aC5jb3MoeTApLCBzeTAgPSBNYXRoLnNpbih5MCksIGN5MSA9IE1hdGguY29zKHkxKSwgc3kxID0gTWF0aC5zaW4oeTEpLCBreDAgPSBjeTAgKiBNYXRoLmNvcyh4MCksIGt5MCA9IGN5MCAqIE1hdGguc2luKHgwKSwga3gxID0gY3kxICogTWF0aC5jb3MoeDEpLCBreTEgPSBjeTEgKiBNYXRoLnNpbih4MSksIGQgPSAyICogTWF0aC5hc2luKE1hdGguc3FydChkM19oYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGQzX2hhdmVyc2luKHgxIC0geDApKSksIGsgPSAxIC8gTWF0aC5zaW4oZCk7XG4gICAgdmFyIGludGVycG9sYXRlID0gZCA/IGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBCID0gTWF0aC5zaW4odCAqPSBkKSAqIGssIEEgPSBNYXRoLnNpbihkIC0gdCkgKiBrLCB4ID0gQSAqIGt4MCArIEIgKiBreDEsIHkgPSBBICoga3kwICsgQiAqIGt5MSwgeiA9IEEgKiBzeTAgKyBCICogc3kxO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih5LCB4KSAqIGQzX2RlZ3JlZXMsIE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKSAqIGQzX2RlZ3JlZXMgXTtcbiAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gWyB4MCAqIGQzX2RlZ3JlZXMsIHkwICogZDNfZGVncmVlcyBdO1xuICAgIH07XG4gICAgaW50ZXJwb2xhdGUuZGlzdGFuY2UgPSBkO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZTtcbiAgfVxuICBkMy5nZW8ubGVuZ3RoID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZDNfZ2VvX2xlbmd0aFN1bSA9IDA7XG4gICAgZDMuZ2VvLnN0cmVhbShvYmplY3QsIGQzX2dlb19sZW5ndGgpO1xuICAgIHJldHVybiBkM19nZW9fbGVuZ3RoU3VtO1xuICB9O1xuICB2YXIgZDNfZ2VvX2xlbmd0aFN1bTtcbiAgdmFyIGQzX2dlb19sZW5ndGggPSB7XG4gICAgc3BoZXJlOiBkM19ub29wLFxuICAgIHBvaW50OiBkM19ub29wLFxuICAgIGxpbmVTdGFydDogZDNfZ2VvX2xlbmd0aExpbmVTdGFydCxcbiAgICBsaW5lRW5kOiBkM19ub29wLFxuICAgIHBvbHlnb25TdGFydDogZDNfbm9vcCxcbiAgICBwb2x5Z29uRW5kOiBkM19ub29wXG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19sZW5ndGhMaW5lU3RhcnQoKSB7XG4gICAgdmFyIM67MCwgc2luz4YwLCBjb3PPhjA7XG4gICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGZ1bmN0aW9uKM67LCDPhikge1xuICAgICAgzrswID0gzrsgKiBkM19yYWRpYW5zLCBzaW7PhjAgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YwID0gTWF0aC5jb3Moz4YpO1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IG5leHRQb2ludDtcbiAgICB9O1xuICAgIGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZDNfZ2VvX2xlbmd0aC5wb2ludCA9IGQzX2dlb19sZW5ndGgubGluZUVuZCA9IGQzX25vb3A7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBuZXh0UG9pbnQozrssIM+GKSB7XG4gICAgICB2YXIgc2luz4YgPSBNYXRoLnNpbijPhiAqPSBkM19yYWRpYW5zKSwgY29zz4YgPSBNYXRoLmNvcyjPhiksIHQgPSBhYnMoKM67ICo9IGQzX3JhZGlhbnMpIC0gzrswKSwgY29zzpTOuyA9IE1hdGguY29zKHQpO1xuICAgICAgZDNfZ2VvX2xlbmd0aFN1bSArPSBNYXRoLmF0YW4yKE1hdGguc3FydCgodCA9IGNvc8+GICogTWF0aC5zaW4odCkpICogdCArICh0ID0gY29zz4YwICogc2luz4YgLSBzaW7PhjAgKiBjb3PPhiAqIGNvc86UzrspICogdCksIHNpbs+GMCAqIHNpbs+GICsgY29zz4YwICogY29zz4YgKiBjb3POlM67KTtcbiAgICAgIM67MCA9IM67LCBzaW7PhjAgPSBzaW7PhiwgY29zz4YwID0gY29zz4Y7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb19hemltdXRoYWwoc2NhbGUsIGFuZ2xlKSB7XG4gICAgZnVuY3Rpb24gYXppbXV0aGFsKM67LCDPhikge1xuICAgICAgdmFyIGNvc867ID0gTWF0aC5jb3MozrspLCBjb3PPhiA9IE1hdGguY29zKM+GKSwgayA9IHNjYWxlKGNvc867ICogY29zz4YpO1xuICAgICAgcmV0dXJuIFsgayAqIGNvc8+GICogTWF0aC5zaW4ozrspLCBrICogTWF0aC5zaW4oz4YpIF07XG4gICAgfVxuICAgIGF6aW11dGhhbC5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgz4EgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGMgPSBhbmdsZSjPgSksIHNpbmMgPSBNYXRoLnNpbihjKSwgY29zYyA9IE1hdGguY29zKGMpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4ICogc2luYywgz4EgKiBjb3NjKSwgTWF0aC5hc2luKM+BICYmIHkgKiBzaW5jIC8gz4EpIF07XG4gICAgfTtcbiAgICByZXR1cm4gYXppbXV0aGFsO1xuICB9XG4gIHZhciBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgyIC8gKDEgKyBjb3POu2Nvc8+GKSk7XG4gIH0sIGZ1bmN0aW9uKM+BKSB7XG4gICAgcmV0dXJuIDIgKiBNYXRoLmFzaW4oz4EgLyAyKTtcbiAgfSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1YWxBcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX2dlb19wcm9qZWN0aW9uKGQzX2dlb19hemltdXRoYWxFcXVhbEFyZWEpO1xuICB9KS5yYXcgPSBkM19nZW9fYXppbXV0aGFsRXF1YWxBcmVhO1xuICB2YXIgZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50ID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbihjb3POu2Nvc8+GKSB7XG4gICAgdmFyIGMgPSBNYXRoLmFjb3MoY29zzrtjb3PPhik7XG4gICAgcmV0dXJuIGMgJiYgYyAvIE1hdGguc2luKGMpO1xuICB9LCBkM19pZGVudGl0eSk7XG4gIChkMy5nZW8uYXppbXV0aGFsRXF1aWRpc3RhbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50KTtcbiAgfSkucmF3ID0gZDNfZ2VvX2F6aW11dGhhbEVxdWlkaXN0YW50O1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNDb25mb3JtYWwoz4YwLCDPhjEpIHtcbiAgICB2YXIgY29zz4YwID0gTWF0aC5jb3Moz4YwKSwgdCA9IGZ1bmN0aW9uKM+GKSB7XG4gICAgICByZXR1cm4gTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKTtcbiAgICB9LCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogTWF0aC5sb2coY29zz4YwIC8gTWF0aC5jb3Moz4YxKSkgLyBNYXRoLmxvZyh0KM+GMSkgLyB0KM+GMCkpLCBGID0gY29zz4YwICogTWF0aC5wb3codCjPhjApLCBuKSAvIG47XG4gICAgaWYgKCFuKSByZXR1cm4gZDNfZ2VvX21lcmNhdG9yO1xuICAgIGZ1bmN0aW9uIGZvcndhcmQozrssIM+GKSB7XG4gICAgICBpZiAoRiA+IDApIHtcbiAgICAgICAgaWYgKM+GIDwgLWhhbGbPgCArIM61KSDPhiA9IC1oYWxmz4AgKyDOtTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICjPhiA+IGhhbGbPgCAtIM61KSDPhiA9IGhhbGbPgCAtIM61O1xuICAgICAgfVxuICAgICAgdmFyIM+BID0gRiAvIE1hdGgucG93KHQoz4YpLCBuKTtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRiAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEYgLSB5LCDPgSA9IGQzX3NnbihuKSAqIE1hdGguc3FydCh4ICogeCArIM+BMF95ICogz4EwX3kpO1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCAyICogTWF0aC5hdGFuKE1hdGgucG93KEYgLyDPgSwgMSAvIG4pKSAtIGhhbGbPgCBdO1xuICAgIH07XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbiAgKGQzLmdlby5jb25pY0NvbmZvcm1hbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljQ29uZm9ybWFsKTtcbiAgfSkucmF3ID0gZDNfZ2VvX2NvbmljQ29uZm9ybWFsO1xuICBmdW5jdGlvbiBkM19nZW9fY29uaWNFcXVpZGlzdGFudCjPhjAsIM+GMSkge1xuICAgIHZhciBjb3PPhjAgPSBNYXRoLmNvcyjPhjApLCBuID0gz4YwID09PSDPhjEgPyBNYXRoLnNpbijPhjApIDogKGNvc8+GMCAtIE1hdGguY29zKM+GMSkpIC8gKM+GMSAtIM+GMCksIEcgPSBjb3PPhjAgLyBuICsgz4YwO1xuICAgIGlmIChhYnMobikgPCDOtSkgcmV0dXJuIGQzX2dlb19lcXVpcmVjdGFuZ3VsYXI7XG4gICAgZnVuY3Rpb24gZm9yd2FyZCjOuywgz4YpIHtcbiAgICAgIHZhciDPgSA9IEcgLSDPhjtcbiAgICAgIHJldHVybiBbIM+BICogTWF0aC5zaW4obiAqIM67KSwgRyAtIM+BICogTWF0aC5jb3MobiAqIM67KSBdO1xuICAgIH1cbiAgICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHZhciDPgTBfeSA9IEcgLSB5O1xuICAgICAgcmV0dXJuIFsgTWF0aC5hdGFuMih4LCDPgTBfeSkgLyBuLCBHIC0gZDNfc2duKG4pICogTWF0aC5zcXJ0KHggKiB4ICsgz4EwX3kgKiDPgTBfeSkgXTtcbiAgICB9O1xuICAgIHJldHVybiBmb3J3YXJkO1xuICB9XG4gIChkMy5nZW8uY29uaWNFcXVpZGlzdGFudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fY29uaWMoZDNfZ2VvX2NvbmljRXF1aWRpc3RhbnQpO1xuICB9KS5yYXcgPSBkM19nZW9fY29uaWNFcXVpZGlzdGFudDtcbiAgdmFyIGQzX2dlb19nbm9tb25pYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gY29zzrtjb3PPhjtcbiAgfSwgTWF0aC5hdGFuKTtcbiAgKGQzLmdlby5nbm9tb25pYyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19nZW9fcHJvamVjdGlvbihkM19nZW9fZ25vbW9uaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fZ25vbW9uaWM7XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyDOuywgTWF0aC5sb2coTWF0aC50YW4oz4AgLyA0ICsgz4YgLyAyKSkgXTtcbiAgfVxuICBkM19nZW9fbWVyY2F0b3IuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBbIHgsIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeSkpIC0gaGFsZs+AIF07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb19tZXJjYXRvclByb2plY3Rpb24ocHJvamVjdCkge1xuICAgIHZhciBtID0gZDNfZ2VvX3Byb2plY3Rpb24ocHJvamVjdCksIHNjYWxlID0gbS5zY2FsZSwgdHJhbnNsYXRlID0gbS50cmFuc2xhdGUsIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsIGNsaXBBdXRvO1xuICAgIG0uc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB2ID0gc2NhbGUuYXBwbHkobSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB2ID09PSBtID8gY2xpcEF1dG8gPyBtLmNsaXBFeHRlbnQobnVsbCkgOiBtIDogdjtcbiAgICB9O1xuICAgIG0udHJhbnNsYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdiA9IHRyYW5zbGF0ZS5hcHBseShtLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHYgPT09IG0gPyBjbGlwQXV0byA/IG0uY2xpcEV4dGVudChudWxsKSA6IG0gOiB2O1xuICAgIH07XG4gICAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgdmFyIHYgPSBjbGlwRXh0ZW50LmFwcGx5KG0sIGFyZ3VtZW50cyk7XG4gICAgICBpZiAodiA9PT0gbSkge1xuICAgICAgICBpZiAoY2xpcEF1dG8gPSBfID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgayA9IM+AICogc2NhbGUoKSwgdCA9IHRyYW5zbGF0ZSgpO1xuICAgICAgICAgIGNsaXBFeHRlbnQoWyBbIHRbMF0gLSBrLCB0WzFdIC0gayBdLCBbIHRbMF0gKyBrLCB0WzFdICsgayBdIF0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNsaXBBdXRvKSB7XG4gICAgICAgIHYgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbiAgICByZXR1cm4gbS5jbGlwRXh0ZW50KG51bGwpO1xuICB9XG4gIChkMy5nZW8ubWVyY2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX21lcmNhdG9yUHJvamVjdGlvbihkM19nZW9fbWVyY2F0b3IpO1xuICB9KS5yYXcgPSBkM19nZW9fbWVyY2F0b3I7XG4gIHZhciBkM19nZW9fb3J0aG9ncmFwaGljID0gZDNfZ2VvX2F6aW11dGhhbChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTtcbiAgfSwgTWF0aC5hc2luKTtcbiAgKGQzLmdlby5vcnRob2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX29ydGhvZ3JhcGhpYyk7XG4gIH0pLnJhdyA9IGQzX2dlb19vcnRob2dyYXBoaWM7XG4gIHZhciBkM19nZW9fc3RlcmVvZ3JhcGhpYyA9IGQzX2dlb19hemltdXRoYWwoZnVuY3Rpb24oY29zzrtjb3PPhikge1xuICAgIHJldHVybiAxIC8gKDEgKyBjb3POu2Nvc8+GKTtcbiAgfSwgZnVuY3Rpb24oz4EpIHtcbiAgICByZXR1cm4gMiAqIE1hdGguYXRhbijPgSk7XG4gIH0pO1xuICAoZDMuZ2VvLnN0ZXJlb2dyYXBoaWMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfZ2VvX3Byb2plY3Rpb24oZDNfZ2VvX3N0ZXJlb2dyYXBoaWMpO1xuICB9KS5yYXcgPSBkM19nZW9fc3RlcmVvZ3JhcGhpYztcbiAgZnVuY3Rpb24gZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvcijOuywgz4YpIHtcbiAgICByZXR1cm4gWyBNYXRoLmxvZyhNYXRoLnRhbijPgCAvIDQgKyDPhiAvIDIpKSwgLc67IF07XG4gIH1cbiAgZDNfZ2VvX3RyYW5zdmVyc2VNZXJjYXRvci5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsgLXksIDIgKiBNYXRoLmF0YW4oTWF0aC5leHAoeCkpIC0gaGFsZs+AIF07XG4gIH07XG4gIChkMy5nZW8udHJhbnN2ZXJzZU1lcmNhdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2plY3Rpb24gPSBkM19nZW9fbWVyY2F0b3JQcm9qZWN0aW9uKGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3IpLCBjZW50ZXIgPSBwcm9qZWN0aW9uLmNlbnRlciwgcm90YXRlID0gcHJvamVjdGlvbi5yb3RhdGU7XG4gICAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gXyA/IGNlbnRlcihbIC1fWzFdLCBfWzBdIF0pIDogKF8gPSBjZW50ZXIoKSwgWyBfWzFdLCAtX1swXSBdKTtcbiAgICB9O1xuICAgIHByb2plY3Rpb24ucm90YXRlID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIF8gPyByb3RhdGUoWyBfWzBdLCBfWzFdLCBfLmxlbmd0aCA+IDIgPyBfWzJdICsgOTAgOiA5MCBdKSA6IChfID0gcm90YXRlKCksIFxuICAgICAgWyBfWzBdLCBfWzFdLCBfWzJdIC0gOTAgXSk7XG4gICAgfTtcbiAgICByZXR1cm4gcm90YXRlKFsgMCwgMCwgOTAgXSk7XG4gIH0pLnJhdyA9IGQzX2dlb190cmFuc3ZlcnNlTWVyY2F0b3I7XG4gIGQzLmdlb20gPSB7fTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2ludFgoZCkge1xuICAgIHJldHVybiBkWzBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9pbnRZKGQpIHtcbiAgICByZXR1cm4gZFsxXTtcbiAgfVxuICBkMy5nZW9tLmh1bGwgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGh1bGwodmVydGljZXMpO1xuICAgIGZ1bmN0aW9uIGh1bGwoZGF0YSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMykgcmV0dXJuIFtdO1xuICAgICAgdmFyIGZ4ID0gZDNfZnVuY3Rvcih4KSwgZnkgPSBkM19mdW5jdG9yKHkpLCBpLCBuID0gZGF0YS5sZW5ndGgsIHBvaW50cyA9IFtdLCBmbGlwcGVkUG9pbnRzID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFsgK2Z4LmNhbGwodGhpcywgZGF0YVtpXSwgaSksICtmeS5jYWxsKHRoaXMsIGRhdGFbaV0sIGkpLCBpIF0pO1xuICAgICAgfVxuICAgICAgcG9pbnRzLnNvcnQoZDNfZ2VvbV9odWxsT3JkZXIpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgZmxpcHBlZFBvaW50cy5wdXNoKFsgcG9pbnRzW2ldWzBdLCAtcG9pbnRzW2ldWzFdIF0pO1xuICAgICAgdmFyIHVwcGVyID0gZDNfZ2VvbV9odWxsVXBwZXIocG9pbnRzKSwgbG93ZXIgPSBkM19nZW9tX2h1bGxVcHBlcihmbGlwcGVkUG9pbnRzKTtcbiAgICAgIHZhciBza2lwTGVmdCA9IGxvd2VyWzBdID09PSB1cHBlclswXSwgc2tpcFJpZ2h0ID0gbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0gPT09IHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2x5Z29uID0gW107XG4gICAgICBmb3IgKGkgPSB1cHBlci5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgcG9seWdvbi5wdXNoKGRhdGFbcG9pbnRzW3VwcGVyW2ldXVsyXV0pO1xuICAgICAgZm9yIChpID0gK3NraXBMZWZ0OyBpIDwgbG93ZXIubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIHBvbHlnb24ucHVzaChkYXRhW3BvaW50c1tsb3dlcltpXV1bMl1dKTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH1cbiAgICBodWxsLnggPSBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gXywgaHVsbCkgOiB4O1xuICAgIH07XG4gICAgaHVsbC55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IF8sIGh1bGwpIDogeTtcbiAgICB9O1xuICAgIHJldHVybiBodWxsO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX2h1bGxVcHBlcihwb2ludHMpIHtcbiAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGgsIGh1bGwgPSBbIDAsIDEgXSwgaHMgPSAyO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgaSsrKSB7XG4gICAgICB3aGlsZSAoaHMgPiAxICYmIGQzX2Nyb3NzMmQocG9pbnRzW2h1bGxbaHMgLSAyXV0sIHBvaW50c1todWxsW2hzIC0gMV1dLCBwb2ludHNbaV0pIDw9IDApIC0taHM7XG4gICAgICBodWxsW2hzKytdID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIGh1bGwuc2xpY2UoMCwgaHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21faHVsbE9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV07XG4gIH1cbiAgZDMuZ2VvbS5wb2x5Z29uID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBkM19zdWJjbGFzcyhjb29yZGluYXRlcywgZDNfZ2VvbV9wb2x5Z29uUHJvdG90eXBlKTtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXM7XG4gIH07XG4gIHZhciBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUgPSBkMy5nZW9tLnBvbHlnb24ucHJvdG90eXBlID0gW107XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5hcmVhID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCBhLCBiID0gdGhpc1tuIC0gMV0sIGFyZWEgPSAwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYXJlYSArPSBhWzFdICogYlswXSAtIGFbMF0gKiBiWzFdO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYSAqIC41O1xuICB9O1xuICBkM19nZW9tX3BvbHlnb25Qcm90b3R5cGUuY2VudHJvaWQgPSBmdW5jdGlvbihrKSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IHRoaXMubGVuZ3RoLCB4ID0gMCwgeSA9IDAsIGEsIGIgPSB0aGlzW24gLSAxXSwgYztcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIGsgPSAtMSAvICg2ICogdGhpcy5hcmVhKCkpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBhID0gYjtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgICB4ICs9IChhWzBdICsgYlswXSkgKiBjO1xuICAgICAgeSArPSAoYVsxXSArIGJbMV0pICogYztcbiAgICB9XG4gICAgcmV0dXJuIFsgeCAqIGssIHkgKiBrIF07XG4gIH07XG4gIGQzX2dlb21fcG9seWdvblByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24oc3ViamVjdCkge1xuICAgIHZhciBpbnB1dCwgY2xvc2VkID0gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKHN1YmplY3QpLCBpID0gLTEsIG4gPSB0aGlzLmxlbmd0aCAtIGQzX2dlb21fcG9seWdvbkNsb3NlZCh0aGlzKSwgaiwgbSwgYSA9IHRoaXNbbiAtIDFdLCBiLCBjLCBkO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpbnB1dCA9IHN1YmplY3Quc2xpY2UoKTtcbiAgICAgIHN1YmplY3QubGVuZ3RoID0gMDtcbiAgICAgIGIgPSB0aGlzW2ldO1xuICAgICAgYyA9IGlucHV0WyhtID0gaW5wdXQubGVuZ3RoIC0gY2xvc2VkKSAtIDFdO1xuICAgICAgaiA9IC0xO1xuICAgICAgd2hpbGUgKCsraiA8IG0pIHtcbiAgICAgICAgZCA9IGlucHV0W2pdO1xuICAgICAgICBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGQsIGEsIGIpKSB7XG4gICAgICAgICAgaWYgKCFkM19nZW9tX3BvbHlnb25JbnNpZGUoYywgYSwgYikpIHtcbiAgICAgICAgICAgIHN1YmplY3QucHVzaChkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoYywgZCwgYSwgYikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJqZWN0LnB1c2goZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZDNfZ2VvbV9wb2x5Z29uSW5zaWRlKGMsIGEsIGIpKSB7XG4gICAgICAgICAgc3ViamVjdC5wdXNoKGQzX2dlb21fcG9seWdvbkludGVyc2VjdChjLCBkLCBhLCBiKSk7XG4gICAgICAgIH1cbiAgICAgICAgYyA9IGQ7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VkKSBzdWJqZWN0LnB1c2goc3ViamVjdFswXSk7XG4gICAgICBhID0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHN1YmplY3Q7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fcG9seWdvbkluc2lkZShwLCBhLCBiKSB7XG4gICAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAocFsxXSAtIGFbMV0pIDwgKGJbMV0gLSBhWzFdKSAqIChwWzBdIC0gYVswXSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uSW50ZXJzZWN0KGMsIGQsIGEsIGIpIHtcbiAgICB2YXIgeDEgPSBjWzBdLCB4MyA9IGFbMF0sIHgyMSA9IGRbMF0gLSB4MSwgeDQzID0gYlswXSAtIHgzLCB5MSA9IGNbMV0sIHkzID0gYVsxXSwgeTIxID0gZFsxXSAtIHkxLCB5NDMgPSBiWzFdIC0geTMsIHVhID0gKHg0MyAqICh5MSAtIHkzKSAtIHk0MyAqICh4MSAtIHgzKSkgLyAoeTQzICogeDIxIC0geDQzICogeTIxKTtcbiAgICByZXR1cm4gWyB4MSArIHVhICogeDIxLCB5MSArIHVhICogeTIxIF07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9wb2x5Z29uQ2xvc2VkKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGEgPSBjb29yZGluYXRlc1swXSwgYiA9IGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAhKGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdKTtcbiAgfVxuICB2YXIgZDNfZ2VvbV92b3Jvbm9pRWRnZXMsIGQzX2dlb21fdm9yb25vaUNlbGxzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLCBkM19nZW9tX3Zvcm9ub2lCZWFjaFBvb2wgPSBbXSwgZDNfZ2VvbV92b3Jvbm9pRmlyc3RDaXJjbGUsIGQzX2dlb21fdm9yb25vaUNpcmNsZXMsIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wgPSBbXTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQmVhY2goKSB7XG4gICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKHRoaXMpO1xuICAgIHRoaXMuZWRnZSA9IHRoaXMuc2l0ZSA9IHRoaXMuY2lyY2xlID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDcmVhdGVCZWFjaChzaXRlKSB7XG4gICAgdmFyIGJlYWNoID0gZDNfZ2VvbV92b3Jvbm9pQmVhY2hQb29sLnBvcCgpIHx8IG5ldyBkM19nZW9tX3Zvcm9ub2lCZWFjaCgpO1xuICAgIGJlYWNoLnNpdGUgPSBzaXRlO1xuICAgIHJldHVybiBiZWFjaDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCkge1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShiZWFjaCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoUG9vbC5wdXNoKGJlYWNoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUoYmVhY2gpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gICAgdmFyIGNpcmNsZSA9IGJlYWNoLmNpcmNsZSwgeCA9IGNpcmNsZS54LCB5ID0gY2lyY2xlLmN5LCB2ZXJ0ZXggPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0sIHByZXZpb3VzID0gYmVhY2guUCwgbmV4dCA9IGJlYWNoLk4sIGRpc2FwcGVhcmluZyA9IFsgYmVhY2ggXTtcbiAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChiZWFjaCk7XG4gICAgdmFyIGxBcmMgPSBwcmV2aW91cztcbiAgICB3aGlsZSAobEFyYy5jaXJjbGUgJiYgYWJzKHggLSBsQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gbEFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIHByZXZpb3VzID0gbEFyYy5QO1xuICAgICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lEZXRhY2hCZWFjaChsQXJjKTtcbiAgICAgIGxBcmMgPSBwcmV2aW91cztcbiAgICB9XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIHZhciByQXJjID0gbmV4dDtcbiAgICB3aGlsZSAockFyYy5jaXJjbGUgJiYgYWJzKHggLSByQXJjLmNpcmNsZS54KSA8IM61ICYmIGFicyh5IC0gckFyYy5jaXJjbGUuY3kpIDwgzrUpIHtcbiAgICAgIG5leHQgPSByQXJjLk47XG4gICAgICBkaXNhcHBlYXJpbmcucHVzaChyQXJjKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaURldGFjaEJlYWNoKHJBcmMpO1xuICAgICAgckFyYyA9IG5leHQ7XG4gICAgfVxuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLCBpQXJjO1xuICAgIGZvciAoaUFyYyA9IDE7IGlBcmMgPCBuQXJjczsgKytpQXJjKSB7XG4gICAgICByQXJjID0gZGlzYXBwZWFyaW5nW2lBcmNdO1xuICAgICAgbEFyYyA9IGRpc2FwcGVhcmluZ1tpQXJjIC0gMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbEFyYy5zaXRlLCByQXJjLnNpdGUsIHZlcnRleCk7XG4gICAgfVxuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gICAgckFyYyA9IGRpc2FwcGVhcmluZ1tuQXJjcyAtIDFdO1xuICAgIHJBcmMuZWRnZSA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobEFyYy5zaXRlLCByQXJjLnNpdGUsIG51bGwsIHZlcnRleCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShyQXJjKTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBZGRCZWFjaChzaXRlKSB7XG4gICAgdmFyIHggPSBzaXRlLngsIGRpcmVjdHJpeCA9IHNpdGUueSwgbEFyYywgckFyYywgZHhsLCBkeHIsIG5vZGUgPSBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLl87XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGR4bCA9IGQzX2dlb21fdm9yb25vaUxlZnRCcmVha1BvaW50KG5vZGUsIGRpcmVjdHJpeCkgLSB4O1xuICAgICAgaWYgKGR4bCA+IM61KSBub2RlID0gbm9kZS5MOyBlbHNlIHtcbiAgICAgICAgZHhyID0geCAtIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgICBpZiAoZHhyID4gzrUpIHtcbiAgICAgICAgICBpZiAoIW5vZGUuUikge1xuICAgICAgICAgICAgbEFyYyA9IG5vZGU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZSA9IG5vZGUuUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZHhsID4gLc61KSB7XG4gICAgICAgICAgICBsQXJjID0gbm9kZS5QO1xuICAgICAgICAgICAgckFyYyA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtzrUpIHtcbiAgICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgICAgckFyYyA9IG5vZGUuTjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3QXJjID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlQmVhY2goc2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcbiAgICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcbiAgICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgckFyYyA9IGQzX2dlb21fdm9yb25vaUNyZWF0ZUJlYWNoKGxBcmMuc2l0ZSk7XG4gICAgICBkM19nZW9tX3Zvcm9ub2lCZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgICAgbmV3QXJjLmVkZ2UgPSByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKGxBcmMpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXJBcmMpIHtcbiAgICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZDNfZ2VvbV92b3Jvbm9pRGV0YWNoQ2lyY2xlKGxBcmMpO1xuICAgIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShyQXJjKTtcbiAgICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsIGF4ID0gbFNpdGUueCwgYXkgPSBsU2l0ZS55LCBieCA9IHNpdGUueCAtIGF4LCBieSA9IHNpdGUueSAtIGF5LCByU2l0ZSA9IHJBcmMuc2l0ZSwgY3ggPSByU2l0ZS54IC0gYXgsIGN5ID0gclNpdGUueSAtIGF5LCBkID0gMiAqIChieCAqIGN5IC0gYnkgKiBjeCksIGhiID0gYnggKiBieCArIGJ5ICogYnksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHZlcnRleCA9IHtcbiAgICAgIHg6IChjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsXG4gICAgICB5OiAoYnggKiBoYyAtIGN4ICogaGIpIC8gZCArIGF5XG4gICAgfTtcbiAgICBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKHJBcmMuZWRnZSwgbFNpdGUsIHJTaXRlLCB2ZXJ0ZXgpO1xuICAgIG5ld0FyYy5lZGdlID0gZDNfZ2VvbV92b3Jvbm9pQ3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgICByQXJjLmVkZ2UgPSBkM19nZW9tX3Zvcm9ub2lDcmVhdGVFZGdlKHNpdGUsIHJTaXRlLCBudWxsLCB2ZXJ0ZXgpO1xuICAgIGQzX2dlb21fdm9yb25vaUF0dGFjaENpcmNsZShsQXJjKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUockFyYyk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pTGVmdEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgICB2YXIgc2l0ZSA9IGFyYy5zaXRlLCByZm9jeCA9IHNpdGUueCwgcmZvY3kgPSBzaXRlLnksIHBieTIgPSByZm9jeSAtIGRpcmVjdHJpeDtcbiAgICBpZiAoIXBieTIpIHJldHVybiByZm9jeDtcbiAgICB2YXIgbEFyYyA9IGFyYy5QO1xuICAgIGlmICghbEFyYykgcmV0dXJuIC1JbmZpbml0eTtcbiAgICBzaXRlID0gbEFyYy5zaXRlO1xuICAgIHZhciBsZm9jeCA9IHNpdGUueCwgbGZvY3kgPSBzaXRlLnksIHBsYnkyID0gbGZvY3kgLSBkaXJlY3RyaXg7XG4gICAgaWYgKCFwbGJ5MikgcmV0dXJuIGxmb2N4O1xuICAgIHZhciBobCA9IGxmb2N4IC0gcmZvY3gsIGFieTIgPSAxIC8gcGJ5MiAtIDEgLyBwbGJ5MiwgYiA9IGhsIC8gcGxieTI7XG4gICAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuICAgIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJpZ2h0QnJlYWtQb2ludChhcmMsIGRpcmVjdHJpeCkge1xuICAgIHZhciByQXJjID0gYXJjLk47XG4gICAgaWYgKHJBcmMpIHJldHVybiBkM19nZW9tX3Zvcm9ub2lMZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICAgIHZhciBzaXRlID0gYXJjLnNpdGU7XG4gICAgcmV0dXJuIHNpdGUueSA9PT0gZGlyZWN0cml4ID8gc2l0ZS54IDogSW5maW5pdHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2VsbChzaXRlKSB7XG4gICAgdGhpcy5zaXRlID0gc2l0ZTtcbiAgICB0aGlzLmVkZ2VzID0gW107XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pQ2VsbC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoYWxmRWRnZXMgPSB0aGlzLmVkZ2VzLCBpSGFsZkVkZ2UgPSBoYWxmRWRnZXMubGVuZ3RoLCBlZGdlO1xuICAgIHdoaWxlIChpSGFsZkVkZ2UtLSkge1xuICAgICAgZWRnZSA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVkZ2U7XG4gICAgICBpZiAoIWVkZ2UuYiB8fCAhZWRnZS5hKSBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMSk7XG4gICAgfVxuICAgIGhhbGZFZGdlcy5zb3J0KGQzX2dlb21fdm9yb25vaUhhbGZFZGdlT3JkZXIpO1xuICAgIHJldHVybiBoYWxmRWRnZXMubGVuZ3RoO1xuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lDbG9zZUNlbGxzKGV4dGVudCkge1xuICAgIHZhciB4MCA9IGV4dGVudFswXVswXSwgeDEgPSBleHRlbnRbMV1bMF0sIHkwID0gZXh0ZW50WzBdWzFdLCB5MSA9IGV4dGVudFsxXVsxXSwgeDIsIHkyLCB4MywgeTMsIGNlbGxzID0gZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsIGlDZWxsID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBpSGFsZkVkZ2UsIGhhbGZFZGdlcywgbkhhbGZFZGdlcywgc3RhcnQsIGVuZDtcbiAgICB3aGlsZSAoaUNlbGwtLSkge1xuICAgICAgY2VsbCA9IGNlbGxzW2lDZWxsXTtcbiAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5wcmVwYXJlKCkpIGNvbnRpbnVlO1xuICAgICAgaGFsZkVkZ2VzID0gY2VsbC5lZGdlcztcbiAgICAgIG5IYWxmRWRnZXMgPSBoYWxmRWRnZXMubGVuZ3RoO1xuICAgICAgaUhhbGZFZGdlID0gMDtcbiAgICAgIHdoaWxlIChpSGFsZkVkZ2UgPCBuSGFsZkVkZ2VzKSB7XG4gICAgICAgIGVuZCA9IGhhbGZFZGdlc1tpSGFsZkVkZ2VdLmVuZCgpLCB4MyA9IGVuZC54LCB5MyA9IGVuZC55O1xuICAgICAgICBzdGFydCA9IGhhbGZFZGdlc1srK2lIYWxmRWRnZSAlIG5IYWxmRWRnZXNdLnN0YXJ0KCksIHgyID0gc3RhcnQueCwgeTIgPSBzdGFydC55O1xuICAgICAgICBpZiAoYWJzKHgzIC0geDIpID4gzrUgfHwgYWJzKHkzIC0geTIpID4gzrUpIHtcbiAgICAgICAgICBoYWxmRWRnZXMuc3BsaWNlKGlIYWxmRWRnZSwgMCwgbmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UoY2VsbC5zaXRlLCBlbmQsIGFicyh4MyAtIHgwKSA8IM61ICYmIHkxIC0geTMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgwLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDApIDwgzrUgPyB5MiA6IHkxXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkxKSA8IM61ICYmIHgxIC0geDMgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkxKSA8IM61ID8geDIgOiB4MSxcbiAgICAgICAgICAgIHk6IHkxXG4gICAgICAgICAgfSA6IGFicyh4MyAtIHgxKSA8IM61ICYmIHkzIC0geTAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogYWJzKHgyIC0geDEpIDwgzrUgPyB5MiA6IHkwXG4gICAgICAgICAgfSA6IGFicyh5MyAtIHkwKSA8IM61ICYmIHgzIC0geDAgPiDOtSA/IHtcbiAgICAgICAgICAgIHg6IGFicyh5MiAtIHkwKSA8IM61ID8geDIgOiB4MCxcbiAgICAgICAgICAgIHk6IHkwXG4gICAgICAgICAgfSA6IG51bGwpLCBjZWxsLnNpdGUsIG51bGwpKTtcbiAgICAgICAgICArK25IYWxmRWRnZXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2VPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGIuYW5nbGUgLSBhLmFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNpcmNsZSgpIHtcbiAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUodGhpcyk7XG4gICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy5hcmMgPSB0aGlzLnNpdGUgPSB0aGlzLmN5ID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lBdHRhY2hDaXJjbGUoYXJjKSB7XG4gICAgdmFyIGxBcmMgPSBhcmMuUCwgckFyYyA9IGFyYy5OO1xuICAgIGlmICghbEFyYyB8fCAhckFyYykgcmV0dXJuO1xuICAgIHZhciBsU2l0ZSA9IGxBcmMuc2l0ZSwgY1NpdGUgPSBhcmMuc2l0ZSwgclNpdGUgPSByQXJjLnNpdGU7XG4gICAgaWYgKGxTaXRlID09PSByU2l0ZSkgcmV0dXJuO1xuICAgIHZhciBieCA9IGNTaXRlLngsIGJ5ID0gY1NpdGUueSwgYXggPSBsU2l0ZS54IC0gYngsIGF5ID0gbFNpdGUueSAtIGJ5LCBjeCA9IHJTaXRlLnggLSBieCwgY3kgPSByU2l0ZS55IC0gYnk7XG4gICAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgICBpZiAoZCA+PSAtzrUyKSByZXR1cm47XG4gICAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksIGhjID0gY3ggKiBjeCArIGN5ICogY3ksIHggPSAoY3kgKiBoYSAtIGF5ICogaGMpIC8gZCwgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkLCBjeSA9IHkgKyBieTtcbiAgICB2YXIgY2lyY2xlID0gZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlUG9vbC5wb3AoKSB8fCBuZXcgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlKCk7XG4gICAgY2lyY2xlLmFyYyA9IGFyYztcbiAgICBjaXJjbGUuc2l0ZSA9IGNTaXRlO1xuICAgIGNpcmNsZS54ID0geCArIGJ4O1xuICAgIGNpcmNsZS55ID0gY3kgKyBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgY2lyY2xlLmN5ID0gY3k7XG4gICAgYXJjLmNpcmNsZSA9IGNpcmNsZTtcbiAgICB2YXIgYmVmb3JlID0gbnVsbCwgbm9kZSA9IGQzX2dlb21fdm9yb25vaUNpcmNsZXMuXztcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IGNpcmNsZS55ID09PSBub2RlLnkgJiYgY2lyY2xlLnggPD0gbm9kZS54KSB7XG4gICAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgICAgIGJlZm9yZSA9IG5vZGUuUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5vZGUuUikgbm9kZSA9IG5vZGUuUjsgZWxzZSB7XG4gICAgICAgICAgYmVmb3JlID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzLmluc2VydChiZWZvcmUsIGNpcmNsZSk7XG4gICAgaWYgKCFiZWZvcmUpIGQzX2dlb21fdm9yb25vaUZpcnN0Q2lyY2xlID0gY2lyY2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaURldGFjaENpcmNsZShhcmMpIHtcbiAgICB2YXIgY2lyY2xlID0gYXJjLmNpcmNsZTtcbiAgICBpZiAoY2lyY2xlKSB7XG4gICAgICBpZiAoIWNpcmNsZS5QKSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pQ2lyY2xlcy5yZW1vdmUoY2lyY2xlKTtcbiAgICAgIGQzX2dlb21fdm9yb25vaUNpcmNsZVBvb2wucHVzaChjaXJjbGUpO1xuICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tOb2RlKGNpcmNsZSk7XG4gICAgICBhcmMuY2lyY2xlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pQ2xpcEVkZ2VzKGV4dGVudCkge1xuICAgIHZhciBlZGdlcyA9IGQzX2dlb21fdm9yb25vaUVkZ2VzLCBjbGlwID0gZDNfZ2VvbV9jbGlwTGluZShleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXSwgZXh0ZW50WzFdWzBdLCBleHRlbnRbMV1bMV0pLCBpID0gZWRnZXMubGVuZ3RoLCBlO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGUgPSBlZGdlc1tpXTtcbiAgICAgIGlmICghZDNfZ2VvbV92b3Jvbm9pQ29ubmVjdEVkZ2UoZSwgZXh0ZW50KSB8fCAhY2xpcChlKSB8fCBhYnMoZS5hLnggLSBlLmIueCkgPCDOtSAmJiBhYnMoZS5hLnkgLSBlLmIueSkgPCDOtSkge1xuICAgICAgICBlLmEgPSBlLmIgPSBudWxsO1xuICAgICAgICBlZGdlcy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNvbm5lY3RFZGdlKGVkZ2UsIGV4dGVudCkge1xuICAgIHZhciB2YiA9IGVkZ2UuYjtcbiAgICBpZiAodmIpIHJldHVybiB0cnVlO1xuICAgIHZhciB2YSA9IGVkZ2UuYSwgeDAgPSBleHRlbnRbMF1bMF0sIHgxID0gZXh0ZW50WzFdWzBdLCB5MCA9IGV4dGVudFswXVsxXSwgeTEgPSBleHRlbnRbMV1bMV0sIGxTaXRlID0gZWRnZS5sLCByU2l0ZSA9IGVkZ2UuciwgbHggPSBsU2l0ZS54LCBseSA9IGxTaXRlLnksIHJ4ID0gclNpdGUueCwgcnkgPSByU2l0ZS55LCBmeCA9IChseCArIHJ4KSAvIDIsIGZ5ID0gKGx5ICsgcnkpIC8gMiwgZm0sIGZiO1xuICAgIGlmIChyeSA9PT0gbHkpIHtcbiAgICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XG4gICAgICBpZiAobHggPiByeCkge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MFxuICAgICAgICB9OyBlbHNlIGlmICh2YS55ID49IHkxKSByZXR1cm47XG4gICAgICAgIHZiID0ge1xuICAgICAgICAgIHg6IGZ4LFxuICAgICAgICAgIHk6IHkxXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICB4OiBmeCxcbiAgICAgICAgICB5OiB5MVxuICAgICAgICB9OyBlbHNlIGlmICh2YS55IDwgeTApIHJldHVybjtcbiAgICAgICAgdmIgPSB7XG4gICAgICAgICAgeDogZngsXG4gICAgICAgICAgeTogeTBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm0gPSAobHggLSByeCkgLyAocnkgLSBseSk7XG4gICAgICBmYiA9IGZ5IC0gZm0gKiBmeDtcbiAgICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgICBpZiAobHggPiByeCkge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPj0geTEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6ICh5MSAtIGZiKSAvIGZtLFxuICAgICAgICAgICAgeTogeTFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghdmEpIHZhID0ge1xuICAgICAgICAgICAgeDogKHkxIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MVxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnkgPCB5MCkgcmV0dXJuO1xuICAgICAgICAgIHZiID0ge1xuICAgICAgICAgICAgeDogKHkwIC0gZmIpIC8gZm0sXG4gICAgICAgICAgICB5OiB5MFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChseSA8IHJ5KSB7XG4gICAgICAgICAgaWYgKCF2YSkgdmEgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07IGVsc2UgaWYgKHZhLnggPj0geDEpIHJldHVybjtcbiAgICAgICAgICB2YiA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXZhKSB2YSA9IHtcbiAgICAgICAgICAgIHg6IHgxLFxuICAgICAgICAgICAgeTogZm0gKiB4MSArIGZiXG4gICAgICAgICAgfTsgZWxzZSBpZiAodmEueCA8IHgwKSByZXR1cm47XG4gICAgICAgICAgdmIgPSB7XG4gICAgICAgICAgICB4OiB4MCxcbiAgICAgICAgICAgIHk6IGZtICogeDAgKyBmYlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWRnZS5hID0gdmE7XG4gICAgZWRnZS5iID0gdmI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pRWRnZShsU2l0ZSwgclNpdGUpIHtcbiAgICB0aGlzLmwgPSBsU2l0ZTtcbiAgICB0aGlzLnIgPSByU2l0ZTtcbiAgICB0aGlzLmEgPSB0aGlzLmIgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUVkZ2UobFNpdGUsIHJTaXRlLCB2YSwgdmIpIHtcbiAgICB2YXIgZWRnZSA9IG5ldyBkM19nZW9tX3Zvcm9ub2lFZGdlKGxTaXRlLCByU2l0ZSk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pRWRnZXMucHVzaChlZGdlKTtcbiAgICBpZiAodmEpIGQzX2dlb21fdm9yb25vaVNldEVkZ2VFbmQoZWRnZSwgbFNpdGUsIHJTaXRlLCB2YSk7XG4gICAgaWYgKHZiKSBkM19nZW9tX3Zvcm9ub2lTZXRFZGdlRW5kKGVkZ2UsIHJTaXRlLCBsU2l0ZSwgdmIpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW2xTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIGxTaXRlLCByU2l0ZSkpO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzW3JTaXRlLmldLmVkZ2VzLnB1c2gobmV3IGQzX2dlb21fdm9yb25vaUhhbGZFZGdlKGVkZ2UsIHJTaXRlLCBsU2l0ZSkpO1xuICAgIHJldHVybiBlZGdlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaUNyZWF0ZUJvcmRlckVkZ2UobFNpdGUsIHZhLCB2Yikge1xuICAgIHZhciBlZGdlID0gbmV3IGQzX2dlb21fdm9yb25vaUVkZ2UobFNpdGUsIG51bGwpO1xuICAgIGVkZ2UuYSA9IHZhO1xuICAgIGVkZ2UuYiA9IHZiO1xuICAgIGQzX2dlb21fdm9yb25vaUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgcmV0dXJuIGVkZ2U7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pU2V0RWRnZUVuZChlZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCkge1xuICAgIGlmICghZWRnZS5hICYmICFlZGdlLmIpIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICAgIGVkZ2UubCA9IGxTaXRlO1xuICAgICAgZWRnZS5yID0gclNpdGU7XG4gICAgfSBlbHNlIGlmIChlZGdlLmwgPT09IHJTaXRlKSB7XG4gICAgICBlZGdlLmIgPSB2ZXJ0ZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UuYSA9IHZlcnRleDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UoZWRnZSwgbFNpdGUsIHJTaXRlKSB7XG4gICAgdmFyIHZhID0gZWRnZS5hLCB2YiA9IGVkZ2UuYjtcbiAgICB0aGlzLmVkZ2UgPSBlZGdlO1xuICAgIHRoaXMuc2l0ZSA9IGxTaXRlO1xuICAgIHRoaXMuYW5nbGUgPSByU2l0ZSA/IE1hdGguYXRhbjIoclNpdGUueSAtIGxTaXRlLnksIHJTaXRlLnggLSBsU2l0ZS54KSA6IGVkZ2UubCA9PT0gbFNpdGUgPyBNYXRoLmF0YW4yKHZiLnggLSB2YS54LCB2YS55IC0gdmIueSkgOiBNYXRoLmF0YW4yKHZhLnggLSB2Yi54LCB2Yi55IC0gdmEueSk7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pSGFsZkVkZ2UucHJvdG90eXBlID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmVkZ2UubCA9PT0gdGhpcy5zaXRlID8gdGhpcy5lZGdlLmEgOiB0aGlzLmVkZ2UuYjtcbiAgICB9LFxuICAgIGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlLmwgPT09IHRoaXMuc2l0ZSA/IHRoaXMuZWRnZS5iIDogdGhpcy5lZGdlLmE7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKSB7XG4gICAgdGhpcy5fID0gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja05vZGUobm9kZSkge1xuICAgIG5vZGUuVSA9IG5vZGUuQyA9IG5vZGUuTCA9IG5vZGUuUiA9IG5vZGUuUCA9IG5vZGUuTiA9IG51bGw7XG4gIH1cbiAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tUcmVlLnByb3RvdHlwZSA9IHtcbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKGFmdGVyLCBub2RlKSB7XG4gICAgICB2YXIgcGFyZW50LCBncmFuZHBhLCB1bmNsZTtcbiAgICAgIGlmIChhZnRlcikge1xuICAgICAgICBub2RlLlAgPSBhZnRlcjtcbiAgICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcbiAgICAgICAgaWYgKGFmdGVyLk4pIGFmdGVyLk4uUCA9IG5vZGU7XG4gICAgICAgIGFmdGVyLk4gPSBub2RlO1xuICAgICAgICBpZiAoYWZ0ZXIuUikge1xuICAgICAgICAgIGFmdGVyID0gYWZ0ZXIuUjtcbiAgICAgICAgICB3aGlsZSAoYWZ0ZXIuTCkgYWZ0ZXIgPSBhZnRlci5MO1xuICAgICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmdGVyLlIgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl8pIHtcbiAgICAgICAgYWZ0ZXIgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICAgIG5vZGUuUCA9IG51bGw7XG4gICAgICAgIG5vZGUuTiA9IGFmdGVyO1xuICAgICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICAgIHBhcmVudCA9IGFmdGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgICAgICAgdGhpcy5fID0gbm9kZTtcbiAgICAgICAgcGFyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUuTCA9IG5vZGUuUiA9IG51bGw7XG4gICAgICBub2RlLlUgPSBwYXJlbnQ7XG4gICAgICBub2RlLkMgPSB0cnVlO1xuICAgICAgYWZ0ZXIgPSBub2RlO1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuQykge1xuICAgICAgICBncmFuZHBhID0gcGFyZW50LlU7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICAgIHVuY2xlID0gZ3JhbmRwYS5SO1xuICAgICAgICAgIGlmICh1bmNsZSAmJiB1bmNsZS5DKSB7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IGdyYW5kcGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LlIpIHtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgICBwYXJlbnQgPSBhZnRlci5VO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIGdyYW5kcGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bmNsZSA9IGdyYW5kcGEuTDtcbiAgICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgICAgcGFyZW50LkMgPSB1bmNsZS5DID0gZmFsc2U7XG4gICAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5MKSB7XG4gICAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgIHBhcmVudCA9IGFmdGVyLlU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQuQyA9IGZhbHNlO1xuICAgICAgICAgICAgZ3JhbmRwYS5DID0gdHJ1ZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgIH1cbiAgICAgIHRoaXMuXy5DID0gZmFsc2U7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLk4pIG5vZGUuTi5QID0gbm9kZS5QO1xuICAgICAgaWYgKG5vZGUuUCkgbm9kZS5QLk4gPSBub2RlLk47XG4gICAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuVSwgc2libGluZywgbGVmdCA9IG5vZGUuTCwgcmlnaHQgPSBub2RlLlIsIG5leHQsIHJlZDtcbiAgICAgIGlmICghbGVmdCkgbmV4dCA9IHJpZ2h0OyBlbHNlIGlmICghcmlnaHQpIG5leHQgPSBsZWZ0OyBlbHNlIG5leHQgPSBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja0ZpcnN0KHJpZ2h0KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5MID09PSBub2RlKSBwYXJlbnQuTCA9IG5leHQ7IGVsc2UgcGFyZW50LlIgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICAgIHJlZCA9IG5leHQuQztcbiAgICAgICAgbmV4dC5DID0gbm9kZS5DO1xuICAgICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgICBsZWZ0LlUgPSBuZXh0O1xuICAgICAgICBpZiAobmV4dCAhPT0gcmlnaHQpIHtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XG4gICAgICAgICAgbmV4dC5VID0gbm9kZS5VO1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgICAgcGFyZW50LkwgPSBub2RlO1xuICAgICAgICAgIG5leHQuUiA9IHJpZ2h0O1xuICAgICAgICAgIHJpZ2h0LlUgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQuVSA9IHBhcmVudDtcbiAgICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgICAgbm9kZSA9IG5leHQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSkgbm9kZS5VID0gcGFyZW50O1xuICAgICAgaWYgKHJlZCkgcmV0dXJuO1xuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5DKSB7XG4gICAgICAgIG5vZGUuQyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLl8pIGJyZWFrO1xuICAgICAgICBpZiAobm9kZSA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNpYmxpbmcuTCAmJiBzaWJsaW5nLkwuQyB8fCBzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIGlmICghc2libGluZy5SIHx8ICFzaWJsaW5nLlIuQykge1xuICAgICAgICAgICAgICBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuXztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgICAgc2libGluZy5DID0gZmFsc2U7XG4gICAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzaWJsaW5nLkwgJiYgc2libGluZy5MLkMgfHwgc2libGluZy5SICYmIHNpYmxpbmcuUi5DKSB7XG4gICAgICAgICAgICBpZiAoIXNpYmxpbmcuTCB8fCAhc2libGluZy5MLkMpIHtcbiAgICAgICAgICAgICAgc2libGluZy5SLkMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHNpYmxpbmcpO1xuICAgICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50Lkw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSBwYXJlbnQuQztcbiAgICAgICAgICAgIHBhcmVudC5DID0gc2libGluZy5MLkMgPSBmYWxzZTtcbiAgICAgICAgICAgIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LlU7XG4gICAgICB9IHdoaWxlICghbm9kZS5DKTtcbiAgICAgIGlmIChub2RlKSBub2RlLkMgPSBmYWxzZTtcbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVJlZEJsYWNrUm90YXRlTGVmdCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5SLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLlIgPSBxLkw7XG4gICAgaWYgKHAuUikgcC5SLlUgPSBwO1xuICAgIHEuTCA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tSb3RhdGVSaWdodCh0cmVlLCBub2RlKSB7XG4gICAgdmFyIHAgPSBub2RlLCBxID0gbm9kZS5MLCBwYXJlbnQgPSBwLlU7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudC5MID09PSBwKSBwYXJlbnQuTCA9IHE7IGVsc2UgcGFyZW50LlIgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlLl8gPSBxO1xuICAgIH1cbiAgICBxLlUgPSBwYXJlbnQ7XG4gICAgcC5VID0gcTtcbiAgICBwLkwgPSBxLlI7XG4gICAgaWYgKHAuTCkgcC5MLlUgPSBwO1xuICAgIHEuUiA9IHA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pUmVkQmxhY2tGaXJzdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3Zvcm9ub2koc2l0ZXMsIGJib3gpIHtcbiAgICB2YXIgc2l0ZSA9IHNpdGVzLnNvcnQoZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIpLnBvcCgpLCB4MCwgeTAsIGNpcmNsZTtcbiAgICBkM19nZW9tX3Zvcm9ub2lFZGdlcyA9IFtdO1xuICAgIGQzX2dlb21fdm9yb25vaUNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gICAgZDNfZ2VvbV92b3Jvbm9pQmVhY2hlcyA9IG5ldyBkM19nZW9tX3Zvcm9ub2lSZWRCbGFja1RyZWUoKTtcbiAgICBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gbmV3IGQzX2dlb21fdm9yb25vaVJlZEJsYWNrVHJlZSgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjaXJjbGUgPSBkM19nZW9tX3Zvcm9ub2lGaXJzdENpcmNsZTtcbiAgICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGUueSA8IGNpcmNsZS55IHx8IHNpdGUueSA9PT0gY2lyY2xlLnkgJiYgc2l0ZS54IDwgY2lyY2xlLngpKSB7XG4gICAgICAgIGlmIChzaXRlLnggIT09IHgwIHx8IHNpdGUueSAhPT0geTApIHtcbiAgICAgICAgICBkM19nZW9tX3Zvcm9ub2lDZWxsc1tzaXRlLmldID0gbmV3IGQzX2dlb21fdm9yb25vaUNlbGwoc2l0ZSk7XG4gICAgICAgICAgZDNfZ2VvbV92b3Jvbm9pQWRkQmVhY2goc2l0ZSk7XG4gICAgICAgICAgeDAgPSBzaXRlLngsIHkwID0gc2l0ZS55O1xuICAgICAgICB9XG4gICAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2lyY2xlKSB7XG4gICAgICAgIGQzX2dlb21fdm9yb25vaVJlbW92ZUJlYWNoKGNpcmNsZS5hcmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiYm94KSBkM19nZW9tX3Zvcm9ub2lDbGlwRWRnZXMoYmJveCksIGQzX2dlb21fdm9yb25vaUNsb3NlQ2VsbHMoYmJveCk7XG4gICAgdmFyIGRpYWdyYW0gPSB7XG4gICAgICBjZWxsczogZDNfZ2VvbV92b3Jvbm9pQ2VsbHMsXG4gICAgICBlZGdlczogZDNfZ2VvbV92b3Jvbm9pRWRnZXNcbiAgICB9O1xuICAgIGQzX2dlb21fdm9yb25vaUJlYWNoZXMgPSBkM19nZW9tX3Zvcm9ub2lDaXJjbGVzID0gZDNfZ2VvbV92b3Jvbm9pRWRnZXMgPSBkM19nZW9tX3Zvcm9ub2lDZWxscyA9IG51bGw7XG4gICAgcmV0dXJuIGRpYWdyYW07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV92b3Jvbm9pVmVydGV4T3JkZXIoYSwgYikge1xuICAgIHJldHVybiBiLnkgLSBhLnkgfHwgYi54IC0gYS54O1xuICB9XG4gIGQzLmdlb20udm9yb25vaSA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgZnggPSB4LCBmeSA9IHksIGNsaXBFeHRlbnQgPSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50O1xuICAgIGlmIChwb2ludHMpIHJldHVybiB2b3Jvbm9pKHBvaW50cyk7XG4gICAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgICB2YXIgcG9seWdvbnMgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpLCB4MCA9IGNsaXBFeHRlbnRbMF1bMF0sIHkwID0gY2xpcEV4dGVudFswXVsxXSwgeDEgPSBjbGlwRXh0ZW50WzFdWzBdLCB5MSA9IGNsaXBFeHRlbnRbMV1bMV07XG4gICAgICBkM19nZW9tX3Zvcm9ub2koc2l0ZXMoZGF0YSksIGNsaXBFeHRlbnQpLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgICB2YXIgZWRnZXMgPSBjZWxsLmVkZ2VzLCBzaXRlID0gY2VsbC5zaXRlLCBwb2x5Z29uID0gcG9seWdvbnNbaV0gPSBlZGdlcy5sZW5ndGggPyBlZGdlcy5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciBzID0gZS5zdGFydCgpO1xuICAgICAgICAgIHJldHVybiBbIHMueCwgcy55IF07XG4gICAgICAgIH0pIDogc2l0ZS54ID49IHgwICYmIHNpdGUueCA8PSB4MSAmJiBzaXRlLnkgPj0geTAgJiYgc2l0ZS55IDw9IHkxID8gWyBbIHgwLCB5MSBdLCBbIHgxLCB5MSBdLCBbIHgxLCB5MCBdLCBbIHgwLCB5MCBdIF0gOiBbXTtcbiAgICAgICAgcG9seWdvbi5wb2ludCA9IGRhdGFbaV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwb2x5Z29ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gc2l0ZXMoZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKGZ4KGQsIGkpIC8gzrUpICogzrUsXG4gICAgICAgICAgeTogTWF0aC5yb3VuZChmeShkLCBpKSAvIM61KSAqIM61LFxuICAgICAgICAgIGk6IGlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB2b3Jvbm9pLmxpbmtzID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UubCAmJiBlZGdlLnI7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogZGF0YVtlZGdlLmwuaV0sXG4gICAgICAgICAgdGFyZ2V0OiBkYXRhW2VkZ2Uuci5pXVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICAgIGQzX2dlb21fdm9yb25vaShzaXRlcyhkYXRhKSkuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBpKSB7XG4gICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlLCBlZGdlcyA9IGNlbGwuZWRnZXMuc29ydChkM19nZW9tX3Zvcm9ub2lIYWxmRWRnZU9yZGVyKSwgaiA9IC0xLCBtID0gZWRnZXMubGVuZ3RoLCBlMCwgczAsIGUxID0gZWRnZXNbbSAtIDFdLmVkZ2UsIHMxID0gZTEubCA9PT0gc2l0ZSA/IGUxLnIgOiBlMS5sO1xuICAgICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICAgIGUwID0gZTE7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICBlMSA9IGVkZ2VzW2pdLmVkZ2U7XG4gICAgICAgICAgczEgPSBlMS5sID09PSBzaXRlID8gZTEuciA6IGUxLmw7XG4gICAgICAgICAgaWYgKGkgPCBzMC5pICYmIGkgPCBzMS5pICYmIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShzaXRlLCBzMCwgczEpIDwgMCkge1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goWyBkYXRhW2ldLCBkYXRhW3MwLmldLCBkYXRhW3MxLmldIF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJpYW5nbGVzO1xuICAgIH07XG4gICAgdm9yb25vaS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnggPSBkM19mdW5jdG9yKHggPSBfKSwgdm9yb25vaSkgOiB4O1xuICAgIH07XG4gICAgdm9yb25vaS55ID0gZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZnkgPSBkM19mdW5jdG9yKHkgPSBfKSwgdm9yb25vaSkgOiB5O1xuICAgIH07XG4gICAgdm9yb25vaS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2xpcEV4dGVudCA9PT0gZDNfZ2VvbV92b3Jvbm9pQ2xpcEV4dGVudCA/IG51bGwgOiBjbGlwRXh0ZW50O1xuICAgICAgY2xpcEV4dGVudCA9IF8gPT0gbnVsbCA/IGQzX2dlb21fdm9yb25vaUNsaXBFeHRlbnQgOiBfO1xuICAgICAgcmV0dXJuIHZvcm9ub2k7XG4gICAgfTtcbiAgICB2b3Jvbm9pLnNpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGlwRXh0ZW50ID09PSBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID8gbnVsbCA6IGNsaXBFeHRlbnQgJiYgY2xpcEV4dGVudFsxXTtcbiAgICAgIHJldHVybiB2b3Jvbm9pLmNsaXBFeHRlbnQoXyAmJiBbIFsgMCwgMCBdLCBfIF0pO1xuICAgIH07XG4gICAgcmV0dXJuIHZvcm9ub2k7XG4gIH07XG4gIHZhciBkM19nZW9tX3Zvcm9ub2lDbGlwRXh0ZW50ID0gWyBbIC0xZTYsIC0xZTYgXSwgWyAxZTYsIDFlNiBdIF07XG4gIGZ1bmN0aW9uIGQzX2dlb21fdm9yb25vaVRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gICAgcmV0dXJuIChhLnggLSBjLngpICogKGIueSAtIGEueSkgLSAoYS54IC0gYi54KSAqIChjLnkgLSBhLnkpO1xuICB9XG4gIGQzLmdlb20uZGVsYXVuYXkgPSBmdW5jdGlvbih2ZXJ0aWNlcykge1xuICAgIHJldHVybiBkMy5nZW9tLnZvcm9ub2koKS50cmlhbmdsZXModmVydGljZXMpO1xuICB9O1xuICBkMy5nZW9tLnF1YWR0cmVlID0gZnVuY3Rpb24ocG9pbnRzLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciB4ID0gZDNfZ2VvbV9wb2ludFgsIHkgPSBkM19nZW9tX3BvaW50WSwgY29tcGF0O1xuICAgIGlmIChjb21wYXQgPSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFg7XG4gICAgICB5ID0gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFk7XG4gICAgICBpZiAoY29tcGF0ID09PSAzKSB7XG4gICAgICAgIHkyID0geTE7XG4gICAgICAgIHgyID0geDE7XG4gICAgICAgIHkxID0geDEgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHF1YWR0cmVlKHBvaW50cyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHF1YWR0cmVlKGRhdGEpIHtcbiAgICAgIHZhciBkLCBmeCA9IGQzX2Z1bmN0b3IoeCksIGZ5ID0gZDNfZnVuY3Rvcih5KSwgeHMsIHlzLCBpLCBuLCB4MV8sIHkxXywgeDJfLCB5Ml87XG4gICAgICBpZiAoeDEgIT0gbnVsbCkge1xuICAgICAgICB4MV8gPSB4MSwgeTFfID0geTEsIHgyXyA9IHgyLCB5Ml8gPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgyXyA9IHkyXyA9IC0oeDFfID0geTFfID0gSW5maW5pdHkpO1xuICAgICAgICB4cyA9IFtdLCB5cyA9IFtdO1xuICAgICAgICBuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChjb21wYXQpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBkID0gZGF0YVtpXTtcbiAgICAgICAgICBpZiAoZC54IDwgeDFfKSB4MV8gPSBkLng7XG4gICAgICAgICAgaWYgKGQueSA8IHkxXykgeTFfID0gZC55O1xuICAgICAgICAgIGlmIChkLnggPiB4Ml8pIHgyXyA9IGQueDtcbiAgICAgICAgICBpZiAoZC55ID4geTJfKSB5Ml8gPSBkLnk7XG4gICAgICAgICAgeHMucHVzaChkLngpO1xuICAgICAgICAgIHlzLnB1c2goZC55KTtcbiAgICAgICAgfSBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2YXIgeF8gPSArZngoZCA9IGRhdGFbaV0sIGkpLCB5XyA9ICtmeShkLCBpKTtcbiAgICAgICAgICBpZiAoeF8gPCB4MV8pIHgxXyA9IHhfO1xuICAgICAgICAgIGlmICh5XyA8IHkxXykgeTFfID0geV87XG4gICAgICAgICAgaWYgKHhfID4geDJfKSB4Ml8gPSB4XztcbiAgICAgICAgICBpZiAoeV8gPiB5Ml8pIHkyXyA9IHlfO1xuICAgICAgICAgIHhzLnB1c2goeF8pO1xuICAgICAgICAgIHlzLnB1c2goeV8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZHggPSB4Ml8gLSB4MV8sIGR5ID0geTJfIC0geTFfO1xuICAgICAgaWYgKGR4ID4gZHkpIHkyXyA9IHkxXyArIGR4OyBlbHNlIHgyXyA9IHgxXyArIGR5O1xuICAgICAgZnVuY3Rpb24gaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIGlmIChpc05hTih4KSB8fCBpc05hTih5KSkgcmV0dXJuO1xuICAgICAgICBpZiAobi5sZWFmKSB7XG4gICAgICAgICAgdmFyIG54ID0gbi54LCBueSA9IG4ueTtcbiAgICAgICAgICBpZiAobnggIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGFicyhueCAtIHgpICsgYWJzKG55IC0geSkgPCAuMDEpIHtcbiAgICAgICAgICAgICAgaW5zZXJ0Q2hpbGQobiwgZCwgeCwgeSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5Qb2ludCA9IG4ucG9pbnQ7XG4gICAgICAgICAgICAgIG4ueCA9IG4ueSA9IG4ucG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBuUG9pbnQsIG54LCBueSwgeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4ueCA9IHgsIG4ueSA9IHksIG4ucG9pbnQgPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRDaGlsZChuLCBkLCB4LCB5LCB4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGluc2VydENoaWxkKG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICAgIHZhciB4bSA9ICh4MSArIHgyKSAqIC41LCB5bSA9ICh5MSArIHkyKSAqIC41LCByaWdodCA9IHggPj0geG0sIGJlbG93ID0geSA+PSB5bSwgaSA9IGJlbG93IDw8IDEgfCByaWdodDtcbiAgICAgICAgbi5sZWFmID0gZmFsc2U7XG4gICAgICAgIG4gPSBuLm5vZGVzW2ldIHx8IChuLm5vZGVzW2ldID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSk7XG4gICAgICAgIGlmIChyaWdodCkgeDEgPSB4bTsgZWxzZSB4MiA9IHhtO1xuICAgICAgICBpZiAoYmVsb3cpIHkxID0geW07IGVsc2UgeTIgPSB5bTtcbiAgICAgICAgaW5zZXJ0KG4sIGQsIHgsIHksIHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgIH1cbiAgICAgIHZhciByb290ID0gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKTtcbiAgICAgIHJvb3QuYWRkID0gZnVuY3Rpb24oZCkge1xuICAgICAgICBpbnNlcnQocm9vdCwgZCwgK2Z4KGQsICsraSksICtmeShkLCBpKSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LnZpc2l0ID0gZnVuY3Rpb24oZikge1xuICAgICAgICBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgcm9vdCwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgIH07XG4gICAgICByb290LmZpbmQgPSBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICByZXR1cm4gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgcG9pbnRbMF0sIHBvaW50WzFdLCB4MV8sIHkxXywgeDJfLCB5Ml8pO1xuICAgICAgfTtcbiAgICAgIGkgPSAtMTtcbiAgICAgIGlmICh4MSA9PSBudWxsKSB7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgaW5zZXJ0KHJvb3QsIGRhdGFbaV0sIHhzW2ldLCB5c1tpXSwgeDFfLCB5MV8sIHgyXywgeTJfKTtcbiAgICAgICAgfVxuICAgICAgICAtLWk7XG4gICAgICB9IGVsc2UgZGF0YS5mb3JFYWNoKHJvb3QuYWRkKTtcbiAgICAgIHhzID0geXMgPSBkYXRhID0gZCA9IG51bGw7XG4gICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcXVhZHRyZWUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSBfLCBxdWFkdHJlZSkgOiB4O1xuICAgIH07XG4gICAgcXVhZHRyZWUueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSBfLCBxdWFkdHJlZSkgOiB5O1xuICAgIH07XG4gICAgcXVhZHRyZWUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0gXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9ICtfWzBdWzBdLCB5MSA9ICtfWzBdWzFdLCB4MiA9ICtfWzFdWzBdLCBcbiAgICAgIHkyID0gK19bMV1bMV07XG4gICAgICByZXR1cm4gcXVhZHRyZWU7XG4gICAgfTtcbiAgICBxdWFkdHJlZS5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDEgPT0gbnVsbCA/IG51bGwgOiBbIHgyIC0geDEsIHkyIC0geTEgXTtcbiAgICAgIGlmIChfID09IG51bGwpIHgxID0geTEgPSB4MiA9IHkyID0gbnVsbDsgZWxzZSB4MSA9IHkxID0gMCwgeDIgPSArX1swXSwgeTIgPSArX1sxXTtcbiAgICAgIHJldHVybiBxdWFkdHJlZTtcbiAgICB9O1xuICAgIHJldHVybiBxdWFkdHJlZTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFgoZCkge1xuICAgIHJldHVybiBkLng7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUNvbXBhdFkoZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZU5vZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlYWY6IHRydWUsXG4gICAgICBub2RlczogW10sXG4gICAgICBwb2ludDogbnVsbCxcbiAgICAgIHg6IG51bGwsXG4gICAgICB5OiBudWxsXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgbm9kZSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBpZiAoIWYobm9kZSwgeDEsIHkxLCB4MiwgeTIpKSB7XG4gICAgICB2YXIgc3ggPSAoeDEgKyB4MikgKiAuNSwgc3kgPSAoeTEgKyB5MikgKiAuNSwgY2hpbGRyZW4gPSBub2RlLm5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuWzBdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bMF0sIHgxLCB5MSwgc3gsIHN5KTtcbiAgICAgIGlmIChjaGlsZHJlblsxXSkgZDNfZ2VvbV9xdWFkdHJlZVZpc2l0KGYsIGNoaWxkcmVuWzFdLCBzeCwgeTEsIHgyLCBzeSk7XG4gICAgICBpZiAoY2hpbGRyZW5bMl0pIGQzX2dlb21fcXVhZHRyZWVWaXNpdChmLCBjaGlsZHJlblsyXSwgeDEsIHN5LCBzeCwgeTIpO1xuICAgICAgaWYgKGNoaWxkcmVuWzNdKSBkM19nZW9tX3F1YWR0cmVlVmlzaXQoZiwgY2hpbGRyZW5bM10sIHN4LCBzeSwgeDIsIHkyKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfZ2VvbV9xdWFkdHJlZUZpbmQocm9vdCwgeCwgeSwgeDAsIHkwLCB4MywgeTMpIHtcbiAgICB2YXIgbWluRGlzdGFuY2UyID0gSW5maW5pdHksIGNsb3Nlc3RQb2ludDtcbiAgICAoZnVuY3Rpb24gZmluZChub2RlLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgaWYgKHgxID4geDMgfHwgeTEgPiB5MyB8fCB4MiA8IHgwIHx8IHkyIDwgeTApIHJldHVybjtcbiAgICAgIGlmIChwb2ludCA9IG5vZGUucG9pbnQpIHtcbiAgICAgICAgdmFyIHBvaW50LCBkeCA9IHggLSBub2RlLngsIGR5ID0geSAtIG5vZGUueSwgZGlzdGFuY2UyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkaXN0YW5jZTIgPCBtaW5EaXN0YW5jZTIpIHtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UyID0gZGlzdGFuY2UyKTtcbiAgICAgICAgICB4MCA9IHggLSBkaXN0YW5jZSwgeTAgPSB5IC0gZGlzdGFuY2U7XG4gICAgICAgICAgeDMgPSB4ICsgZGlzdGFuY2UsIHkzID0geSArIGRpc3RhbmNlO1xuICAgICAgICAgIGNsb3Nlc3RQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLm5vZGVzLCB4bSA9ICh4MSArIHgyKSAqIC41LCB5bSA9ICh5MSArIHkyKSAqIC41LCByaWdodCA9IHggPj0geG0sIGJlbG93ID0geSA+PSB5bTtcbiAgICAgIGZvciAodmFyIGkgPSBiZWxvdyA8PCAxIHwgcmlnaHQsIGogPSBpICsgNDsgaSA8IGo7ICsraSkge1xuICAgICAgICBpZiAobm9kZSA9IGNoaWxkcmVuW2kgJiAzXSkgc3dpdGNoIChpICYgMykge1xuICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGZpbmQobm9kZSwgeDEsIHkxLCB4bSwgeW0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZmluZChub2RlLCB4bSwgeTEsIHgyLCB5bSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBmaW5kKG5vZGUsIHgxLCB5bSwgeG0sIHkyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZpbmQobm9kZSwgeG0sIHltLCB4MiwgeTIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkocm9vdCwgeDAsIHkwLCB4MywgeTMpO1xuICAgIHJldHVybiBjbG9zZXN0UG9pbnQ7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVSZ2IgPSBkM19pbnRlcnBvbGF0ZVJnYjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVSZ2IoYSwgYikge1xuICAgIGEgPSBkMy5yZ2IoYSk7XG4gICAgYiA9IGQzLnJnYihiKTtcbiAgICB2YXIgYXIgPSBhLnIsIGFnID0gYS5nLCBhYiA9IGEuYiwgYnIgPSBiLnIgLSBhciwgYmcgPSBiLmcgLSBhZywgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIFwiI1wiICsgZDNfcmdiX2hleChNYXRoLnJvdW5kKGFyICsgYnIgKiB0KSkgKyBkM19yZ2JfaGV4KE1hdGgucm91bmQoYWcgKyBiZyAqIHQpKSArIGQzX3JnYl9oZXgoTWF0aC5yb3VuZChhYiArIGJiICogdCkpO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVPYmplY3QgPSBkM19pbnRlcnBvbGF0ZU9iamVjdDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVPYmplY3QoYSwgYikge1xuICAgIHZhciBpID0ge30sIGMgPSB7fSwgaztcbiAgICBmb3IgKGsgaW4gYSkge1xuICAgICAgaWYgKGsgaW4gYikge1xuICAgICAgICBpW2tdID0gZDNfaW50ZXJwb2xhdGUoYVtrXSwgYltrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjW2tdID0gYVtrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrIGluIGIpIHtcbiAgICAgIGlmICghKGsgaW4gYSkpIHtcbiAgICAgICAgY1trXSA9IGJba107XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKGsgaW4gaSkgY1trXSA9IGlba10odCk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG4gIGQzLmludGVycG9sYXRlTnVtYmVyID0gZDNfaW50ZXJwb2xhdGVOdW1iZXI7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlTnVtYmVyKGEsIGIpIHtcbiAgICBhID0gK2EsIGIgPSArYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG4gICAgfTtcbiAgfVxuICBkMy5pbnRlcnBvbGF0ZVN0cmluZyA9IGQzX2ludGVycG9sYXRlU3RyaW5nO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVN0cmluZyhhLCBiKSB7XG4gICAgdmFyIGJpID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQS5sYXN0SW5kZXggPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmxhc3RJbmRleCA9IDAsIGFtLCBibSwgYnMsIGkgPSAtMSwgcyA9IFtdLCBxID0gW107XG4gICAgYSA9IGEgKyBcIlwiLCBiID0gYiArIFwiXCI7XG4gICAgd2hpbGUgKChhbSA9IGQzX2ludGVycG9sYXRlX251bWJlckEuZXhlYyhhKSkgJiYgKGJtID0gZDNfaW50ZXJwb2xhdGVfbnVtYmVyQi5leGVjKGIpKSkge1xuICAgICAgaWYgKChicyA9IGJtLmluZGV4KSA+IGJpKSB7XG4gICAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgZWxzZSBzWysraV0gPSBicztcbiAgICAgIH1cbiAgICAgIGlmICgoYW0gPSBhbVswXSkgPT09IChibSA9IGJtWzBdKSkge1xuICAgICAgICBpZiAoc1tpXSkgc1tpXSArPSBibTsgZWxzZSBzWysraV0gPSBibTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNbKytpXSA9IG51bGw7XG4gICAgICAgIHEucHVzaCh7XG4gICAgICAgICAgaTogaSxcbiAgICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihhbSwgYm0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmkgPSBkM19pbnRlcnBvbGF0ZV9udW1iZXJCLmxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKGJpIDwgYi5sZW5ndGgpIHtcbiAgICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgICBpZiAoc1tpXSkgc1tpXSArPSBiczsgZWxzZSBzWysraV0gPSBicztcbiAgICB9XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgMiA/IHFbMF0gPyAoYiA9IHFbMF0ueCwgZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGIodCkgKyBcIlwiO1xuICAgIH0pIDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG87IGkgPCBiOyArK2kpIHNbKG8gPSBxW2ldKS5pXSA9IG8ueCh0KTtcbiAgICAgIHJldHVybiBzLmpvaW4oXCJcIik7XG4gICAgfSk7XG4gIH1cbiAgdmFyIGQzX2ludGVycG9sYXRlX251bWJlckEgPSAvWy0rXT8oPzpcXGQrXFwuP1xcZCp8XFwuP1xcZCspKD86W2VFXVstK10/XFxkKyk/L2csIGQzX2ludGVycG9sYXRlX251bWJlckIgPSBuZXcgUmVnRXhwKGQzX2ludGVycG9sYXRlX251bWJlckEuc291cmNlLCBcImdcIik7XG4gIGQzLmludGVycG9sYXRlID0gZDNfaW50ZXJwb2xhdGU7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlKGEsIGIpIHtcbiAgICB2YXIgaSA9IGQzLmludGVycG9sYXRvcnMubGVuZ3RoLCBmO1xuICAgIHdoaWxlICgtLWkgPj0gMCAmJiAhKGYgPSBkMy5pbnRlcnBvbGF0b3JzW2ldKGEsIGIpKSkgO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGQzLmludGVycG9sYXRvcnMgPSBbIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiBiO1xuICAgIHJldHVybiAodCA9PT0gXCJzdHJpbmdcIiA/IGQzX3JnYl9uYW1lcy5oYXMoYi50b0xvd2VyQ2FzZSgpKSB8fCAvXigjfHJnYlxcKHxoc2xcXCgpL2kudGVzdChiKSA/IGQzX2ludGVycG9sYXRlUmdiIDogZDNfaW50ZXJwb2xhdGVTdHJpbmcgOiBiIGluc3RhbmNlb2YgZDNfY29sb3IgPyBkM19pbnRlcnBvbGF0ZVJnYiA6IEFycmF5LmlzQXJyYXkoYikgPyBkM19pbnRlcnBvbGF0ZUFycmF5IDogdCA9PT0gXCJvYmplY3RcIiAmJiBpc05hTihiKSA/IGQzX2ludGVycG9sYXRlT2JqZWN0IDogZDNfaW50ZXJwb2xhdGVOdW1iZXIpKGEsIGIpO1xuICB9IF07XG4gIGQzLmludGVycG9sYXRlQXJyYXkgPSBkM19pbnRlcnBvbGF0ZUFycmF5O1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZUFycmF5KGEsIGIpIHtcbiAgICB2YXIgeCA9IFtdLCBjID0gW10sIG5hID0gYS5sZW5ndGgsIG5iID0gYi5sZW5ndGgsIG4wID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjA7ICsraSkgeC5wdXNoKGQzX2ludGVycG9sYXRlKGFbaV0sIGJbaV0pKTtcbiAgICBmb3IgKDtpIDwgbmE7ICsraSkgY1tpXSA9IGFbaV07XG4gICAgZm9yICg7aSA8IG5iOyArK2kpIGNbaV0gPSBiW2ldO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjA7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICB9XG4gIHZhciBkM19lYXNlX2RlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfaWRlbnRpdHk7XG4gIH07XG4gIHZhciBkM19lYXNlID0gZDMubWFwKHtcbiAgICBsaW5lYXI6IGQzX2Vhc2VfZGVmYXVsdCxcbiAgICBwb2x5OiBkM19lYXNlX3BvbHksXG4gICAgcXVhZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9xdWFkO1xuICAgIH0sXG4gICAgY3ViaWM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfY3ViaWM7XG4gICAgfSxcbiAgICBzaW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX2Vhc2Vfc2luO1xuICAgIH0sXG4gICAgZXhwOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19lYXNlX2V4cDtcbiAgICB9LFxuICAgIGNpcmNsZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9jaXJjbGU7XG4gICAgfSxcbiAgICBlbGFzdGljOiBkM19lYXNlX2VsYXN0aWMsXG4gICAgYmFjazogZDNfZWFzZV9iYWNrLFxuICAgIGJvdW5jZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfZWFzZV9ib3VuY2U7XG4gICAgfVxuICB9KTtcbiAgdmFyIGQzX2Vhc2VfbW9kZSA9IGQzLm1hcCh7XG4gICAgXCJpblwiOiBkM19pZGVudGl0eSxcbiAgICBvdXQ6IGQzX2Vhc2VfcmV2ZXJzZSxcbiAgICBcImluLW91dFwiOiBkM19lYXNlX3JlZmxlY3QsXG4gICAgXCJvdXQtaW5cIjogZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGQzX2Vhc2VfcmVmbGVjdChkM19lYXNlX3JldmVyc2UoZikpO1xuICAgIH1cbiAgfSk7XG4gIGQzLmVhc2UgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCItXCIpLCB0ID0gaSA+PSAwID8gbmFtZS5zbGljZSgwLCBpKSA6IG5hbWUsIG0gPSBpID49IDAgPyBuYW1lLnNsaWNlKGkgKyAxKSA6IFwiaW5cIjtcbiAgICB0ID0gZDNfZWFzZS5nZXQodCkgfHwgZDNfZWFzZV9kZWZhdWx0O1xuICAgIG0gPSBkM19lYXNlX21vZGUuZ2V0KG0pIHx8IGQzX2lkZW50aXR5O1xuICAgIHJldHVybiBkM19lYXNlX2NsYW1wKG0odC5hcHBseShudWxsLCBkM19hcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfZWFzZV9jbGFtcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0IDw9IDAgPyAwIDogdCA+PSAxID8gMSA6IGYodCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3JldmVyc2UoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gMSAtIGYoMSAtIHQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfZWFzZV9yZWZsZWN0KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIC41ICogKHQgPCAuNSA/IGYoMiAqIHQpIDogMiAtIGYoMiAtIDIgKiB0KSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX3F1YWQodCkge1xuICAgIHJldHVybiB0ICogdDtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2N1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfY3ViaWNJbk91dCh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKHQgPj0gMSkgcmV0dXJuIDE7XG4gICAgdmFyIHQyID0gdCAqIHQsIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiA0ICogKHQgPCAuNSA/IHQzIDogMyAqICh0IC0gdDIpICsgdDMgLSAuNzUpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfcG9seShlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyh0LCBlKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2Vfc2luKHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKHQgKiBoYWxmz4ApO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfZXhwKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2NpcmNsZSh0KSB7XG4gICAgcmV0dXJuIDEgLSBNYXRoLnNxcnQoMSAtIHQgKiB0KTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2VsYXN0aWMoYSwgcCkge1xuICAgIHZhciBzO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcCA9IC40NTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcyA9IHAgLyDPhCAqIE1hdGguYXNpbigxIC8gYSk7IGVsc2UgYSA9IDEsIHMgPSBwIC8gNDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIDEgKyBhICogTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogz4QgLyBwKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2Vhc2VfYmFjayhzKSB7XG4gICAgaWYgKCFzKSBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19lYXNlX2JvdW5jZSh0KSB7XG4gICAgcmV0dXJuIHQgPCAxIC8gMi43NSA/IDcuNTYyNSAqIHQgKiB0IDogdCA8IDIgLyAyLjc1ID8gNy41NjI1ICogKHQgLT0gMS41IC8gMi43NSkgKiB0ICsgLjc1IDogdCA8IDIuNSAvIDIuNzUgPyA3LjU2MjUgKiAodCAtPSAyLjI1IC8gMi43NSkgKiB0ICsgLjkzNzUgOiA3LjU2MjUgKiAodCAtPSAyLjYyNSAvIDIuNzUpICogdCArIC45ODQzNzU7XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVIY2wgPSBkM19pbnRlcnBvbGF0ZUhjbDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVIY2woYSwgYikge1xuICAgIGEgPSBkMy5oY2woYSk7XG4gICAgYiA9IGQzLmhjbChiKTtcbiAgICB2YXIgYWggPSBhLmgsIGFjID0gYS5jLCBhbCA9IGEubCwgYmggPSBiLmggLSBhaCwgYmMgPSBiLmMgLSBhYywgYmwgPSBiLmwgLSBhbDtcbiAgICBpZiAoaXNOYU4oYmMpKSBiYyA9IDAsIGFjID0gaXNOYU4oYWMpID8gYi5jIDogYWM7XG4gICAgaWYgKGlzTmFOKGJoKSkgYmggPSAwLCBhaCA9IGlzTmFOKGFoKSA/IGIuaCA6IGFoOyBlbHNlIGlmIChiaCA+IDE4MCkgYmggLT0gMzYwOyBlbHNlIGlmIChiaCA8IC0xODApIGJoICs9IDM2MDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2hjbF9sYWIoYWggKyBiaCAqIHQsIGFjICsgYmMgKiB0LCBhbCArIGJsICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVIc2wgPSBkM19pbnRlcnBvbGF0ZUhzbDtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVIc2woYSwgYikge1xuICAgIGEgPSBkMy5oc2woYSk7XG4gICAgYiA9IGQzLmhzbChiKTtcbiAgICB2YXIgYWggPSBhLmgsIGFzID0gYS5zLCBhbCA9IGEubCwgYmggPSBiLmggLSBhaCwgYnMgPSBiLnMgLSBhcywgYmwgPSBiLmwgLSBhbDtcbiAgICBpZiAoaXNOYU4oYnMpKSBicyA9IDAsIGFzID0gaXNOYU4oYXMpID8gYi5zIDogYXM7XG4gICAgaWYgKGlzTmFOKGJoKSkgYmggPSAwLCBhaCA9IGlzTmFOKGFoKSA/IGIuaCA6IGFoOyBlbHNlIGlmIChiaCA+IDE4MCkgYmggLT0gMzYwOyBlbHNlIGlmIChiaCA8IC0xODApIGJoICs9IDM2MDtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2hzbF9yZ2IoYWggKyBiaCAqIHQsIGFzICsgYnMgKiB0LCBhbCArIGJsICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVMYWIgPSBkM19pbnRlcnBvbGF0ZUxhYjtcbiAgZnVuY3Rpb24gZDNfaW50ZXJwb2xhdGVMYWIoYSwgYikge1xuICAgIGEgPSBkMy5sYWIoYSk7XG4gICAgYiA9IGQzLmxhYihiKTtcbiAgICB2YXIgYWwgPSBhLmwsIGFhID0gYS5hLCBhYiA9IGEuYiwgYmwgPSBiLmwgLSBhbCwgYmEgPSBiLmEgLSBhYSwgYmIgPSBiLmIgLSBhYjtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIGQzX2xhYl9yZ2IoYWwgKyBibCAqIHQsIGFhICsgYmEgKiB0LCBhYiArIGJiICogdCkgKyBcIlwiO1xuICAgIH07XG4gIH1cbiAgZDMuaW50ZXJwb2xhdGVSb3VuZCA9IGQzX2ludGVycG9sYXRlUm91bmQ7XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUm91bmQoYSwgYikge1xuICAgIGIgLT0gYTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSArIGIgKiB0KTtcbiAgICB9O1xuICB9XG4gIGQzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBnID0gZDNfZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzLm5zLnByZWZpeC5zdmcsIFwiZ1wiKTtcbiAgICByZXR1cm4gKGQzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgaWYgKHN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIGcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0cmluZyk7XG4gICAgICAgIHZhciB0ID0gZy50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBkM190cmFuc2Zvcm0odCA/IHQubWF0cml4IDogZDNfdHJhbnNmb3JtSWRlbnRpdHkpO1xuICAgIH0pKHN0cmluZyk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zZm9ybShtKSB7XG4gICAgdmFyIHIwID0gWyBtLmEsIG0uYiBdLCByMSA9IFsgbS5jLCBtLmQgXSwga3ggPSBkM190cmFuc2Zvcm1Ob3JtYWxpemUocjApLCBreiA9IGQzX3RyYW5zZm9ybURvdChyMCwgcjEpLCBreSA9IGQzX3RyYW5zZm9ybU5vcm1hbGl6ZShkM190cmFuc2Zvcm1Db21iaW5lKHIxLCByMCwgLWt6KSkgfHwgMDtcbiAgICBpZiAocjBbMF0gKiByMVsxXSA8IHIxWzBdICogcjBbMV0pIHtcbiAgICAgIHIwWzBdICo9IC0xO1xuICAgICAgcjBbMV0gKj0gLTE7XG4gICAgICBreCAqPSAtMTtcbiAgICAgIGt6ICo9IC0xO1xuICAgIH1cbiAgICB0aGlzLnJvdGF0ZSA9IChreCA/IE1hdGguYXRhbjIocjBbMV0sIHIwWzBdKSA6IE1hdGguYXRhbjIoLXIxWzBdLCByMVsxXSkpICogZDNfZGVncmVlcztcbiAgICB0aGlzLnRyYW5zbGF0ZSA9IFsgbS5lLCBtLmYgXTtcbiAgICB0aGlzLnNjYWxlID0gWyBreCwga3kgXTtcbiAgICB0aGlzLnNrZXcgPSBreSA/IE1hdGguYXRhbjIoa3osIGt5KSAqIGQzX2RlZ3JlZXMgOiAwO1xuICB9XG4gIGQzX3RyYW5zZm9ybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB0aGlzLnRyYW5zbGF0ZSArIFwiKXJvdGF0ZShcIiArIHRoaXMucm90YXRlICsgXCIpc2tld1goXCIgKyB0aGlzLnNrZXcgKyBcIilzY2FsZShcIiArIHRoaXMuc2NhbGUgKyBcIilcIjtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtRG90KGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbiAgfVxuICBmdW5jdGlvbiBkM190cmFuc2Zvcm1Ob3JtYWxpemUoYSkge1xuICAgIHZhciBrID0gTWF0aC5zcXJ0KGQzX3RyYW5zZm9ybURvdChhLCBhKSk7XG4gICAgaWYgKGspIHtcbiAgICAgIGFbMF0gLz0gaztcbiAgICAgIGFbMV0gLz0gaztcbiAgICB9XG4gICAgcmV0dXJuIGs7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNmb3JtQ29tYmluZShhLCBiLCBrKSB7XG4gICAgYVswXSArPSBrICogYlswXTtcbiAgICBhWzFdICs9IGsgKiBiWzFdO1xuICAgIHJldHVybiBhO1xuICB9XG4gIHZhciBkM190cmFuc2Zvcm1JZGVudGl0eSA9IHtcbiAgICBhOiAxLFxuICAgIGI6IDAsXG4gICAgYzogMCxcbiAgICBkOiAxLFxuICAgIGU6IDAsXG4gICAgZjogMFxuICB9O1xuICBkMy5pbnRlcnBvbGF0ZVRyYW5zZm9ybSA9IGQzX2ludGVycG9sYXRlVHJhbnNmb3JtO1xuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoID8gcy5wb3AoKSArIFwiLFwiIDogXCJcIjtcbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zbGF0ZSh0YSwgdGIsIHMsIHEpIHtcbiAgICBpZiAodGFbMF0gIT09IHRiWzBdIHx8IHRhWzFdICE9PSB0YlsxXSkge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBpIC0gNCxcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIodGFbMF0sIHRiWzBdKVxuICAgICAgfSwge1xuICAgICAgICBpOiBpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIodGFbMV0sIHRiWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0YlswXSB8fCB0YlsxXSkge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgdGIgKyBcIilcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2ludGVycG9sYXRlUm90YXRlKHJhLCByYiwgcywgcSkge1xuICAgIGlmIChyYSAhPT0gcmIpIHtcbiAgICAgIGlmIChyYSAtIHJiID4gMTgwKSByYiArPSAzNjA7IGVsc2UgaWYgKHJiIC0gcmEgPiAxODApIHJhICs9IDM2MDtcbiAgICAgIHEucHVzaCh7XG4gICAgICAgIGk6IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBcIilcIikgLSAyLFxuICAgICAgICB4OiBkM19pbnRlcnBvbGF0ZU51bWJlcihyYSwgcmIpXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJiKSB7XG4gICAgICBzLnB1c2goZDNfaW50ZXJwb2xhdGVUcmFuc2Zvcm1Qb3AocykgKyBcInJvdGF0ZShcIiArIHJiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVNrZXcod2EsIHdiLCBzLCBxKSB7XG4gICAgaWYgKHdhICE9PSB3Yikge1xuICAgICAgcS5wdXNoKHtcbiAgICAgICAgaTogcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJza2V3WChcIiwgbnVsbCwgXCIpXCIpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIod2EsIHdiKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh3Yikge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJza2V3WChcIiArIHdiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVNjYWxlKGthLCBrYiwgcywgcSkge1xuICAgIGlmIChrYVswXSAhPT0ga2JbMF0gfHwga2FbMV0gIT09IGtiWzFdKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybVBvcChzKSArIFwic2NhbGUoXCIsIG51bGwsIFwiLFwiLCBudWxsLCBcIilcIik7XG4gICAgICBxLnB1c2goe1xuICAgICAgICBpOiBpIC0gNCxcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoa2FbMF0sIGtiWzBdKVxuICAgICAgfSwge1xuICAgICAgICBpOiBpIC0gMixcbiAgICAgICAgeDogZDNfaW50ZXJwb2xhdGVOdW1iZXIoa2FbMV0sIGtiWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChrYlswXSAhPT0gMSB8fCBrYlsxXSAhPT0gMSkge1xuICAgICAgcy5wdXNoKGQzX2ludGVycG9sYXRlVHJhbnNmb3JtUG9wKHMpICsgXCJzY2FsZShcIiArIGtiICsgXCIpXCIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkM19pbnRlcnBvbGF0ZVRyYW5zZm9ybShhLCBiKSB7XG4gICAgdmFyIHMgPSBbXSwgcSA9IFtdO1xuICAgIGEgPSBkMy50cmFuc2Zvcm0oYSksIGIgPSBkMy50cmFuc2Zvcm0oYik7XG4gICAgZDNfaW50ZXJwb2xhdGVUcmFuc2xhdGUoYS50cmFuc2xhdGUsIGIudHJhbnNsYXRlLCBzLCBxKTtcbiAgICBkM19pbnRlcnBvbGF0ZVJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIGQzX2ludGVycG9sYXRlU2tldyhhLnNrZXcsIGIuc2tldywgcywgcSk7XG4gICAgZDNfaW50ZXJwb2xhdGVTY2FsZShhLnNjYWxlLCBiLnNjYWxlLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZDNfdW5pbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gICAgYiA9IChiIC09IGEgPSArYSkgfHwgMSAvIGI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAoeCAtIGEpIC8gYjtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3VuaW50ZXJwb2xhdGVDbGFtcChhLCBiKSB7XG4gICAgYiA9IChiIC09IGEgPSArYSkgfHwgMSAvIGI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoeCAtIGEpIC8gYikpO1xuICAgIH07XG4gIH1cbiAgZDMubGF5b3V0ID0ge307XG4gIGQzLmxheW91dC5idW5kbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obGlua3MpIHtcbiAgICAgIHZhciBwYXRocyA9IFtdLCBpID0gLTEsIG4gPSBsaW5rcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoKytpIDwgbikgcGF0aHMucHVzaChkM19sYXlvdXRfYnVuZGxlUGF0aChsaW5rc1tpXSkpO1xuICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVQYXRoKGxpbmspIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5rLnNvdXJjZSwgZW5kID0gbGluay50YXJnZXQsIGxjYSA9IGQzX2xheW91dF9idW5kbGVMZWFzdENvbW1vbkFuY2VzdG9yKHN0YXJ0LCBlbmQpLCBwb2ludHMgPSBbIHN0YXJ0IF07XG4gICAgd2hpbGUgKHN0YXJ0ICE9PSBsY2EpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgICAgcG9pbnRzLnB1c2goc3RhcnQpO1xuICAgIH1cbiAgICB2YXIgayA9IHBvaW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKGVuZCAhPT0gbGNhKSB7XG4gICAgICBwb2ludHMuc3BsaWNlKGssIDAsIGVuZCk7XG4gICAgICBlbmQgPSBlbmQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMobm9kZSkge1xuICAgIHZhciBhbmNlc3RvcnMgPSBbXSwgcGFyZW50ID0gbm9kZS5wYXJlbnQ7XG4gICAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBhbmNlc3RvcnMucHVzaChub2RlKTtcbiAgICByZXR1cm4gYW5jZXN0b3JzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9idW5kbGVMZWFzdENvbW1vbkFuY2VzdG9yKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGE7XG4gICAgdmFyIGFOb2RlcyA9IGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMoYSksIGJOb2RlcyA9IGQzX2xheW91dF9idW5kbGVBbmNlc3RvcnMoYiksIGFOb2RlID0gYU5vZGVzLnBvcCgpLCBiTm9kZSA9IGJOb2Rlcy5wb3AoKSwgc2hhcmVkTm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKGFOb2RlID09PSBiTm9kZSkge1xuICAgICAgc2hhcmVkTm9kZSA9IGFOb2RlO1xuICAgICAgYU5vZGUgPSBhTm9kZXMucG9wKCk7XG4gICAgICBiTm9kZSA9IGJOb2Rlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXJlZE5vZGU7XG4gIH1cbiAgZDMubGF5b3V0LmNob3JkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNob3JkID0ge30sIGNob3JkcywgZ3JvdXBzLCBtYXRyaXgsIG4sIHBhZGRpbmcgPSAwLCBzb3J0R3JvdXBzLCBzb3J0U3ViZ3JvdXBzLCBzb3J0Q2hvcmRzO1xuICAgIGZ1bmN0aW9uIHJlbGF5b3V0KCkge1xuICAgICAgdmFyIHN1Ymdyb3VwcyA9IHt9LCBncm91cFN1bXMgPSBbXSwgZ3JvdXBJbmRleCA9IGQzLnJhbmdlKG4pLCBzdWJncm91cEluZGV4ID0gW10sIGssIHgsIHgwLCBpLCBqO1xuICAgICAgY2hvcmRzID0gW107XG4gICAgICBncm91cHMgPSBbXTtcbiAgICAgIGsgPSAwLCBpID0gLTE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICB4ID0gMCwgaiA9IC0xO1xuICAgICAgICB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICAgIHggKz0gbWF0cml4W2ldW2pdO1xuICAgICAgICB9XG4gICAgICAgIGdyb3VwU3Vtcy5wdXNoKHgpO1xuICAgICAgICBzdWJncm91cEluZGV4LnB1c2goZDMucmFuZ2UobikpO1xuICAgICAgICBrICs9IHg7XG4gICAgICB9XG4gICAgICBpZiAoc29ydEdyb3Vwcykge1xuICAgICAgICBncm91cEluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIHJldHVybiBzb3J0R3JvdXBzKGdyb3VwU3Vtc1thXSwgZ3JvdXBTdW1zW2JdKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc29ydFN1Ymdyb3Vwcykge1xuICAgICAgICBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICAgIGQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gc29ydFN1Ymdyb3VwcyhtYXRyaXhbaV1bYV0sIG1hdHJpeFtpXVtiXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgayA9ICjPhCAtIHBhZGRpbmcgKiBuKSAvIGs7XG4gICAgICB4ID0gMCwgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgeDAgPSB4LCBqID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgICAgdmFyIGRpID0gZ3JvdXBJbmRleFtpXSwgZGogPSBzdWJncm91cEluZGV4W2RpXVtqXSwgdiA9IG1hdHJpeFtkaV1bZGpdLCBhMCA9IHgsIGExID0geCArPSB2ICogaztcbiAgICAgICAgICBzdWJncm91cHNbZGkgKyBcIi1cIiArIGRqXSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICAgIHN1YmluZGV4OiBkaixcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IGEwLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICAgICAgdmFsdWU6IHZcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGdyb3Vwc1tkaV0gPSB7XG4gICAgICAgICAgaW5kZXg6IGRpLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IHgwLFxuICAgICAgICAgIGVuZEFuZ2xlOiB4LFxuICAgICAgICAgIHZhbHVlOiBncm91cFN1bXNbZGldXG4gICAgICAgIH07XG4gICAgICAgIHggKz0gcGFkZGluZztcbiAgICAgIH1cbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGogPSBpIC0gMTtcbiAgICAgICAgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gc3ViZ3JvdXBzW2kgKyBcIi1cIiArIGpdLCB0YXJnZXQgPSBzdWJncm91cHNbaiArIFwiLVwiICsgaV07XG4gICAgICAgICAgaWYgKHNvdXJjZS52YWx1ZSB8fCB0YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIGNob3Jkcy5wdXNoKHNvdXJjZS52YWx1ZSA8IHRhcmdldC52YWx1ZSA/IHtcbiAgICAgICAgICAgICAgc291cmNlOiB0YXJnZXQsXG4gICAgICAgICAgICAgIHRhcmdldDogc291cmNlXG4gICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNvcnRDaG9yZHMpIHJlc29ydCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNvcnQoKSB7XG4gICAgICBjaG9yZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBzb3J0Q2hvcmRzKChhLnNvdXJjZS52YWx1ZSArIGEudGFyZ2V0LnZhbHVlKSAvIDIsIChiLnNvdXJjZS52YWx1ZSArIGIudGFyZ2V0LnZhbHVlKSAvIDIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNob3JkLm1hdHJpeCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1hdHJpeDtcbiAgICAgIG4gPSAobWF0cml4ID0geCkgJiYgbWF0cml4Lmxlbmd0aDtcbiAgICAgIGNob3JkcyA9IGdyb3VwcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5wYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkZGluZztcbiAgICAgIHBhZGRpbmcgPSB4O1xuICAgICAgY2hvcmRzID0gZ3JvdXBzID0gbnVsbDtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnNvcnRHcm91cHMgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0R3JvdXBzO1xuICAgICAgc29ydEdyb3VwcyA9IHg7XG4gICAgICBjaG9yZHMgPSBncm91cHMgPSBudWxsO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnRTdWJncm91cHM7XG4gICAgICBzb3J0U3ViZ3JvdXBzID0geDtcbiAgICAgIGNob3JkcyA9IG51bGw7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zb3J0Q2hvcmRzID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc29ydENob3JkcztcbiAgICAgIHNvcnRDaG9yZHMgPSB4O1xuICAgICAgaWYgKGNob3JkcykgcmVzb3J0KCk7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5jaG9yZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghY2hvcmRzKSByZWxheW91dCgpO1xuICAgICAgcmV0dXJuIGNob3JkcztcbiAgICB9O1xuICAgIGNob3JkLmdyb3VwcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFncm91cHMpIHJlbGF5b3V0KCk7XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH07XG4gICAgcmV0dXJuIGNob3JkO1xuICB9O1xuICBkMy5sYXlvdXQuZm9yY2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZm9yY2UgPSB7fSwgZXZlbnQgPSBkMy5kaXNwYXRjaChcInN0YXJ0XCIsIFwidGlja1wiLCBcImVuZFwiKSwgdGltZXIsIHNpemUgPSBbIDEsIDEgXSwgZHJhZywgYWxwaGEsIGZyaWN0aW9uID0gLjksIGxpbmtEaXN0YW5jZSA9IGQzX2xheW91dF9mb3JjZUxpbmtEaXN0YW5jZSwgbGlua1N0cmVuZ3RoID0gZDNfbGF5b3V0X2ZvcmNlTGlua1N0cmVuZ3RoLCBjaGFyZ2UgPSAtMzAsIGNoYXJnZURpc3RhbmNlMiA9IGQzX2xheW91dF9mb3JjZUNoYXJnZURpc3RhbmNlMiwgZ3Jhdml0eSA9IC4xLCB0aGV0YTIgPSAuNjQsIG5vZGVzID0gW10sIGxpbmtzID0gW10sIGRpc3RhbmNlcywgc3RyZW5ndGhzLCBjaGFyZ2VzO1xuICAgIGZ1bmN0aW9uIHJlcHVsc2Uobm9kZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHF1YWQsIHgxLCBfLCB4Mikge1xuICAgICAgICBpZiAocXVhZC5wb2ludCAhPT0gbm9kZSkge1xuICAgICAgICAgIHZhciBkeCA9IHF1YWQuY3ggLSBub2RlLngsIGR5ID0gcXVhZC5jeSAtIG5vZGUueSwgZHcgPSB4MiAtIHgxLCBkbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICAgIGlmIChkdyAqIGR3IC8gdGhldGEyIDwgZG4pIHtcbiAgICAgICAgICAgIGlmIChkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgICB2YXIgayA9IHF1YWQuY2hhcmdlIC8gZG47XG4gICAgICAgICAgICAgIG5vZGUucHggLT0gZHggKiBrO1xuICAgICAgICAgICAgICBub2RlLnB5IC09IGR5ICogaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocXVhZC5wb2ludCAmJiBkbiAmJiBkbiA8IGNoYXJnZURpc3RhbmNlMikge1xuICAgICAgICAgICAgdmFyIGsgPSBxdWFkLnBvaW50Q2hhcmdlIC8gZG47XG4gICAgICAgICAgICBub2RlLnB4IC09IGR4ICogaztcbiAgICAgICAgICAgIG5vZGUucHkgLT0gZHkgKiBrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXF1YWQuY2hhcmdlO1xuICAgICAgfTtcbiAgICB9XG4gICAgZm9yY2UudGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKChhbHBoYSAqPSAuOTkpIDwgLjAwNSkge1xuICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgIGV2ZW50LmVuZCh7XG4gICAgICAgICAgdHlwZTogXCJlbmRcIixcbiAgICAgICAgICBhbHBoYTogYWxwaGEgPSAwXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBuID0gbm9kZXMubGVuZ3RoLCBtID0gbGlua3MubGVuZ3RoLCBxLCBpLCBvLCBzLCB0LCBsLCBrLCB4LCB5O1xuICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkge1xuICAgICAgICBvID0gbGlua3NbaV07XG4gICAgICAgIHMgPSBvLnNvdXJjZTtcbiAgICAgICAgdCA9IG8udGFyZ2V0O1xuICAgICAgICB4ID0gdC54IC0gcy54O1xuICAgICAgICB5ID0gdC55IC0gcy55O1xuICAgICAgICBpZiAobCA9IHggKiB4ICsgeSAqIHkpIHtcbiAgICAgICAgICBsID0gYWxwaGEgKiBzdHJlbmd0aHNbaV0gKiAoKGwgPSBNYXRoLnNxcnQobCkpIC0gZGlzdGFuY2VzW2ldKSAvIGw7XG4gICAgICAgICAgeCAqPSBsO1xuICAgICAgICAgIHkgKj0gbDtcbiAgICAgICAgICB0LnggLT0geCAqIChrID0gcy53ZWlnaHQgKyB0LndlaWdodCA/IHMud2VpZ2h0IC8gKHMud2VpZ2h0ICsgdC53ZWlnaHQpIDogLjUpO1xuICAgICAgICAgIHQueSAtPSB5ICogaztcbiAgICAgICAgICBzLnggKz0geCAqIChrID0gMSAtIGspO1xuICAgICAgICAgIHMueSArPSB5ICogaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGsgPSBhbHBoYSAqIGdyYXZpdHkpIHtcbiAgICAgICAgeCA9IHNpemVbMF0gLyAyO1xuICAgICAgICB5ID0gc2l6ZVsxXSAvIDI7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgaWYgKGspIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICAgIG8ueCArPSAoeCAtIG8ueCkgKiBrO1xuICAgICAgICAgIG8ueSArPSAoeSAtIG8ueSkgKiBrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhcmdlKSB7XG4gICAgICAgIGQzX2xheW91dF9mb3JjZUFjY3VtdWxhdGUocSA9IGQzLmdlb20ucXVhZHRyZWUobm9kZXMpLCBhbHBoYSwgY2hhcmdlcyk7XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBpZiAoIShvID0gbm9kZXNbaV0pLmZpeGVkKSB7XG4gICAgICAgICAgICBxLnZpc2l0KHJlcHVsc2UobykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSA9IC0xO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgbyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoby5maXhlZCkge1xuICAgICAgICAgIG8ueCA9IG8ucHg7XG4gICAgICAgICAgby55ID0gby5weTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvLnggLT0gKG8ucHggLSAoby5weCA9IG8ueCkpICogZnJpY3Rpb247XG4gICAgICAgICAgby55IC09IChvLnB5IC0gKG8ucHkgPSBvLnkpKSAqIGZyaWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudC50aWNrKHtcbiAgICAgICAgdHlwZTogXCJ0aWNrXCIsXG4gICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3JjZS5ub2RlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVzO1xuICAgICAgbm9kZXMgPSB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UubGlua3MgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rcztcbiAgICAgIGxpbmtzID0geDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5saW5rRGlzdGFuY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5rRGlzdGFuY2U7XG4gICAgICBsaW5rRGlzdGFuY2UgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuZGlzdGFuY2UgPSBmb3JjZS5saW5rRGlzdGFuY2U7XG4gICAgZm9yY2UubGlua1N0cmVuZ3RoID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGlua1N0cmVuZ3RoO1xuICAgICAgbGlua1N0cmVuZ3RoID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmZyaWN0aW9uID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZnJpY3Rpb247XG4gICAgICBmcmljdGlvbiA9ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuY2hhcmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY2hhcmdlO1xuICAgICAgY2hhcmdlID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiAreDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmNoYXJnZURpc3RhbmNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gTWF0aC5zcXJ0KGNoYXJnZURpc3RhbmNlMik7XG4gICAgICBjaGFyZ2VEaXN0YW5jZTIgPSB4ICogeDtcbiAgICAgIHJldHVybiBmb3JjZTtcbiAgICB9O1xuICAgIGZvcmNlLmdyYXZpdHkgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmF2aXR5O1xuICAgICAgZ3Jhdml0eSA9ICt4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UudGhldGEgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBNYXRoLnNxcnQodGhldGEyKTtcbiAgICAgIHRoZXRhMiA9IHggKiB4O1xuICAgICAgcmV0dXJuIGZvcmNlO1xuICAgIH07XG4gICAgZm9yY2UuYWxwaGEgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBhbHBoYTtcbiAgICAgIHggPSAreDtcbiAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgICBhbHBoYSA9IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZXIuYyA9IG51bGwsIHRpbWVyLnQgPSBOYU4sIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICBldmVudC5lbmQoe1xuICAgICAgICAgICAgdHlwZTogXCJlbmRcIixcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYSA9IDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4ID4gMCkge1xuICAgICAgICBldmVudC5zdGFydCh7XG4gICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSA9IHhcbiAgICAgICAgfSk7XG4gICAgICAgIHRpbWVyID0gZDNfdGltZXIoZm9yY2UudGljayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yY2U7XG4gICAgfTtcbiAgICBmb3JjZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG0gPSBsaW5rcy5sZW5ndGgsIHcgPSBzaXplWzBdLCBoID0gc2l6ZVsxXSwgbmVpZ2hib3JzLCBvO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICAobyA9IG5vZGVzW2ldKS5pbmRleCA9IGk7XG4gICAgICAgIG8ud2VpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgbyA9IGxpbmtzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIG8uc291cmNlID09IFwibnVtYmVyXCIpIG8uc291cmNlID0gbm9kZXNbby5zb3VyY2VdO1xuICAgICAgICBpZiAodHlwZW9mIG8udGFyZ2V0ID09IFwibnVtYmVyXCIpIG8udGFyZ2V0ID0gbm9kZXNbby50YXJnZXRdO1xuICAgICAgICArK28uc291cmNlLndlaWdodDtcbiAgICAgICAgKytvLnRhcmdldC53ZWlnaHQ7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG8gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKGlzTmFOKG8ueCkpIG8ueCA9IHBvc2l0aW9uKFwieFwiLCB3KTtcbiAgICAgICAgaWYgKGlzTmFOKG8ueSkpIG8ueSA9IHBvc2l0aW9uKFwieVwiLCBoKTtcbiAgICAgICAgaWYgKGlzTmFOKG8ucHgpKSBvLnB4ID0gby54O1xuICAgICAgICBpZiAoaXNOYU4oby5weSkpIG8ucHkgPSBvLnk7XG4gICAgICB9XG4gICAgICBkaXN0YW5jZXMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgbGlua0Rpc3RhbmNlID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIGRpc3RhbmNlc1tpXSA9ICtsaW5rRGlzdGFuY2UuY2FsbCh0aGlzLCBsaW5rc1tpXSwgaSk7IGVsc2UgZm9yIChpID0gMDsgaSA8IG07ICsraSkgZGlzdGFuY2VzW2ldID0gbGlua0Rpc3RhbmNlO1xuICAgICAgc3RyZW5ndGhzID0gW107XG4gICAgICBpZiAodHlwZW9mIGxpbmtTdHJlbmd0aCA9PT0gXCJmdW5jdGlvblwiKSBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSBzdHJlbmd0aHNbaV0gPSArbGlua1N0cmVuZ3RoLmNhbGwodGhpcywgbGlua3NbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHN0cmVuZ3Roc1tpXSA9IGxpbmtTdHJlbmd0aDtcbiAgICAgIGNoYXJnZXMgPSBbXTtcbiAgICAgIGlmICh0eXBlb2YgY2hhcmdlID09PSBcImZ1bmN0aW9uXCIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoYXJnZXNbaV0gPSArY2hhcmdlLmNhbGwodGhpcywgbm9kZXNbaV0sIGkpOyBlbHNlIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoYXJnZXNbaV0gPSBjaGFyZ2U7XG4gICAgICBmdW5jdGlvbiBwb3NpdGlvbihkaW1lbnNpb24sIHNpemUpIHtcbiAgICAgICAgaWYgKCFuZWlnaGJvcnMpIHtcbiAgICAgICAgICBuZWlnaGJvcnMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgbmVpZ2hib3JzW2pdID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgICAgIHZhciBvID0gbGlua3Nbal07XG4gICAgICAgICAgICBuZWlnaGJvcnNbby5zb3VyY2UuaW5kZXhdLnB1c2goby50YXJnZXQpO1xuICAgICAgICAgICAgbmVpZ2hib3JzW28udGFyZ2V0LmluZGV4XS5wdXNoKG8uc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBuZWlnaGJvcnNbaV0sIGogPSAtMSwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoLCB4O1xuICAgICAgICB3aGlsZSAoKytqIDwgbCkgaWYgKCFpc05hTih4ID0gY2FuZGlkYXRlc1tqXVtkaW1lbnNpb25dKSkgcmV0dXJuIHg7XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JjZS5yZXN1bWUoKTtcbiAgICB9O1xuICAgIGZvcmNlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcmNlLmFscGhhKC4xKTtcbiAgICB9O1xuICAgIGZvcmNlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JjZS5hbHBoYSgwKTtcbiAgICB9O1xuICAgIGZvcmNlLmRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghZHJhZykgZHJhZyA9IGQzLmJlaGF2aW9yLmRyYWcoKS5vcmlnaW4oZDNfaWRlbnRpdHkpLm9uKFwiZHJhZ3N0YXJ0LmZvcmNlXCIsIGQzX2xheW91dF9mb3JjZURyYWdzdGFydCkub24oXCJkcmFnLmZvcmNlXCIsIGRyYWdtb3ZlKS5vbihcImRyYWdlbmQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlRHJhZ2VuZCk7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkcmFnO1xuICAgICAgdGhpcy5vbihcIm1vdXNlb3Zlci5mb3JjZVwiLCBkM19sYXlvdXRfZm9yY2VNb3VzZW92ZXIpLm9uKFwibW91c2VvdXQuZm9yY2VcIiwgZDNfbGF5b3V0X2ZvcmNlTW91c2VvdXQpLmNhbGwoZHJhZyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBkcmFnbW92ZShkKSB7XG4gICAgICBkLnB4ID0gZDMuZXZlbnQueCwgZC5weSA9IGQzLmV2ZW50Lnk7XG4gICAgICBmb3JjZS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGQzLnJlYmluZChmb3JjZSwgZXZlbnQsIFwib25cIik7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZURyYWdzdGFydChkKSB7XG4gICAgZC5maXhlZCB8PSAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9mb3JjZURyYWdlbmQoZCkge1xuICAgIGQuZml4ZWQgJj0gfjY7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2ZvcmNlTW91c2VvdmVyKGQpIHtcbiAgICBkLmZpeGVkIHw9IDQ7XG4gICAgZC5weCA9IGQueCwgZC5weSA9IGQueTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VNb3VzZW91dChkKSB7XG4gICAgZC5maXhlZCAmPSB+NDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfZm9yY2VBY2N1bXVsYXRlKHF1YWQsIGFscGhhLCBjaGFyZ2VzKSB7XG4gICAgdmFyIGN4ID0gMCwgY3kgPSAwO1xuICAgIHF1YWQuY2hhcmdlID0gMDtcbiAgICBpZiAoIXF1YWQubGVhZikge1xuICAgICAgdmFyIG5vZGVzID0gcXVhZC5ub2RlcywgbiA9IG5vZGVzLmxlbmd0aCwgaSA9IC0xLCBjO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgYyA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoYyA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgZDNfbGF5b3V0X2ZvcmNlQWNjdW11bGF0ZShjLCBhbHBoYSwgY2hhcmdlcyk7XG4gICAgICAgIHF1YWQuY2hhcmdlICs9IGMuY2hhcmdlO1xuICAgICAgICBjeCArPSBjLmNoYXJnZSAqIGMuY3g7XG4gICAgICAgIGN5ICs9IGMuY2hhcmdlICogYy5jeTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHF1YWQucG9pbnQpIHtcbiAgICAgIGlmICghcXVhZC5sZWFmKSB7XG4gICAgICAgIHF1YWQucG9pbnQueCArPSBNYXRoLnJhbmRvbSgpIC0gLjU7XG4gICAgICAgIHF1YWQucG9pbnQueSArPSBNYXRoLnJhbmRvbSgpIC0gLjU7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGFscGhhICogY2hhcmdlc1txdWFkLnBvaW50LmluZGV4XTtcbiAgICAgIHF1YWQuY2hhcmdlICs9IHF1YWQucG9pbnRDaGFyZ2UgPSBrO1xuICAgICAgY3ggKz0gayAqIHF1YWQucG9pbnQueDtcbiAgICAgIGN5ICs9IGsgKiBxdWFkLnBvaW50Lnk7XG4gICAgfVxuICAgIHF1YWQuY3ggPSBjeCAvIHF1YWQuY2hhcmdlO1xuICAgIHF1YWQuY3kgPSBjeSAvIHF1YWQuY2hhcmdlO1xuICB9XG4gIHZhciBkM19sYXlvdXRfZm9yY2VMaW5rRGlzdGFuY2UgPSAyMCwgZDNfbGF5b3V0X2ZvcmNlTGlua1N0cmVuZ3RoID0gMSwgZDNfbGF5b3V0X2ZvcmNlQ2hhcmdlRGlzdGFuY2UyID0gSW5maW5pdHk7XG4gIGQzLmxheW91dC5oaWVyYXJjaHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc29ydCA9IGQzX2xheW91dF9oaWVyYXJjaHlTb3J0LCBjaGlsZHJlbiA9IGQzX2xheW91dF9oaWVyYXJjaHlDaGlsZHJlbiwgdmFsdWUgPSBkM19sYXlvdXRfaGllcmFyY2h5VmFsdWU7XG4gICAgZnVuY3Rpb24gaGllcmFyY2h5KHJvb3QpIHtcbiAgICAgIHZhciBzdGFjayA9IFsgcm9vdCBdLCBub2RlcyA9IFtdLCBub2RlO1xuICAgICAgcm9vdC5kZXB0aCA9IDA7XG4gICAgICB3aGlsZSAoKG5vZGUgPSBzdGFjay5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICBpZiAoKGNoaWxkcyA9IGNoaWxkcmVuLmNhbGwoaGllcmFyY2h5LCBub2RlLCBub2RlLmRlcHRoKSkgJiYgKG4gPSBjaGlsZHMubGVuZ3RoKSkge1xuICAgICAgICAgIHZhciBuLCBjaGlsZHMsIGNoaWxkO1xuICAgICAgICAgIHdoaWxlICgtLW4gPj0gMCkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChjaGlsZCA9IGNoaWxkc1tuXSk7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgY2hpbGQuZGVwdGggPSBub2RlLmRlcHRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlKSBub2RlLnZhbHVlID0gMDtcbiAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZSkgbm9kZS52YWx1ZSA9ICt2YWx1ZS5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkgfHwgMDtcbiAgICAgICAgICBkZWxldGUgbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgY2hpbGRzLCBwYXJlbnQ7XG4gICAgICAgIGlmIChzb3J0ICYmIChjaGlsZHMgPSBub2RlLmNoaWxkcmVuKSkgY2hpbGRzLnNvcnQoc29ydCk7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAocGFyZW50ID0gbm9kZS5wYXJlbnQpKSBwYXJlbnQudmFsdWUgKz0gbm9kZS52YWx1ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBoaWVyYXJjaHkuc29ydCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNvcnQ7XG4gICAgICBzb3J0ID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkuY2hpbGRyZW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjaGlsZHJlbjtcbiAgICAgIGNoaWxkcmVuID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkudmFsdWUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICAgIHZhbHVlID0geDtcbiAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfTtcbiAgICBoaWVyYXJjaHkucmV2YWx1ZSA9IGZ1bmN0aW9uKHJvb3QpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSBub2RlLnZhbHVlID0gMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICB2YXIgcGFyZW50O1xuICAgICAgICAgIGlmICghbm9kZS5jaGlsZHJlbikgbm9kZS52YWx1ZSA9ICt2YWx1ZS5jYWxsKGhpZXJhcmNoeSwgbm9kZSwgbm9kZS5kZXB0aCkgfHwgMDtcbiAgICAgICAgICBpZiAocGFyZW50ID0gbm9kZS5wYXJlbnQpIHBhcmVudC52YWx1ZSArPSBub2RlLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByb290O1xuICAgIH07XG4gICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChvYmplY3QsIGhpZXJhcmNoeSkge1xuICAgIGQzLnJlYmluZChvYmplY3QsIGhpZXJhcmNoeSwgXCJzb3J0XCIsIFwiY2hpbGRyZW5cIiwgXCJ2YWx1ZVwiKTtcbiAgICBvYmplY3Qubm9kZXMgPSBvYmplY3Q7XG4gICAgb2JqZWN0LmxpbmtzID0gZDNfbGF5b3V0X2hpZXJhcmNoeUxpbmtzO1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5vZGVzID0gWyBub2RlIF07XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMucG9wKCkpICE9IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgaWYgKChjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW4pICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbiwgY2hpbGRyZW47XG4gICAgICAgIHdoaWxlICgtLW4gPj0gMCkgbm9kZXMucHVzaChjaGlsZHJlbltuXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG5vZGVzID0gWyBub2RlIF0sIG5vZGVzMiA9IFtdO1xuICAgIHdoaWxlICgobm9kZSA9IG5vZGVzLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBub2RlczIucHVzaChub2RlKTtcbiAgICAgIGlmICgoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbiwgY2hpbGRyZW47XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSBub2Rlcy5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKChub2RlID0gbm9kZXMyLnBvcCgpKSAhPSBudWxsKSB7XG4gICAgICBjYWxsYmFjayhub2RlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeUNoaWxkcmVuKGQpIHtcbiAgICByZXR1cm4gZC5jaGlsZHJlbjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGllcmFyY2h5VmFsdWUoZCkge1xuICAgIHJldHVybiBkLnZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaWVyYXJjaHlTb3J0KGEsIGIpIHtcbiAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2hpZXJhcmNoeUxpbmtzKG5vZGVzKSB7XG4gICAgcmV0dXJuIGQzLm1lcmdlKG5vZGVzLm1hcChmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgIHJldHVybiAocGFyZW50LmNoaWxkcmVuIHx8IFtdKS5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzb3VyY2U6IHBhcmVudCxcbiAgICAgICAgICB0YXJnZXQ6IGNoaWxkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgZDMubGF5b3V0LnBhcnRpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCksIHNpemUgPSBbIDEsIDEgXTtcbiAgICBmdW5jdGlvbiBwb3NpdGlvbihub2RlLCB4LCBkeCwgZHkpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBub2RlLnggPSB4O1xuICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIGR5O1xuICAgICAgbm9kZS5keCA9IGR4O1xuICAgICAgbm9kZS5keSA9IGR5O1xuICAgICAgaWYgKGNoaWxkcmVuICYmIChuID0gY2hpbGRyZW4ubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuLCBjLCBkO1xuICAgICAgICBkeCA9IG5vZGUudmFsdWUgPyBkeCAvIG5vZGUudmFsdWUgOiAwO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICAgIHBvc2l0aW9uKGMgPSBjaGlsZHJlbltpXSwgeCwgZCA9IGMudmFsdWUgKiBkeCwgZHkpO1xuICAgICAgICAgIHggKz0gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZXB0aChub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLCBkID0gMDtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbjtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIGQgPSBNYXRoLm1heChkLCBkZXB0aChjaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDEgKyBkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJ0aXRpb24oZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSk7XG4gICAgICBwb3NpdGlvbihub2Rlc1swXSwgMCwgc2l6ZVswXSwgc2l6ZVsxXSAvIGRlcHRoKG5vZGVzWzBdKSk7XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHBhcnRpdGlvbi5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSB4O1xuICAgICAgcmV0dXJuIHBhcnRpdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHBhcnRpdGlvbiwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZDMubGF5b3V0LnBpZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IE51bWJlciwgc29ydCA9IGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSwgc3RhcnRBbmdsZSA9IDAsIGVuZEFuZ2xlID0gz4QsIHBhZEFuZ2xlID0gMDtcbiAgICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgICAgdmFyIG4gPSBkYXRhLmxlbmd0aCwgdmFsdWVzID0gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gK3ZhbHVlLmNhbGwocGllLCBkLCBpKTtcbiAgICAgIH0pLCBhID0gKyh0eXBlb2Ygc3RhcnRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogc3RhcnRBbmdsZSksIGRhID0gKHR5cGVvZiBlbmRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gZW5kQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGVuZEFuZ2xlKSAtIGEsIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCArKHR5cGVvZiBwYWRBbmdsZSA9PT0gXCJmdW5jdGlvblwiID8gcGFkQW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHBhZEFuZ2xlKSksIHBhID0gcCAqIChkYSA8IDAgPyAtMSA6IDEpLCBzdW0gPSBkMy5zdW0odmFsdWVzKSwgayA9IHN1bSA/IChkYSAtIG4gKiBwYSkgLyBzdW0gOiAwLCBpbmRleCA9IGQzLnJhbmdlKG4pLCBhcmNzID0gW10sIHY7XG4gICAgICBpZiAoc29ydCAhPSBudWxsKSBpbmRleC5zb3J0KHNvcnQgPT09IGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSA/IGZ1bmN0aW9uKGksIGopIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlc1tqXSAtIHZhbHVlc1tpXTtcbiAgICAgIH0gOiBmdW5jdGlvbihpLCBqKSB7XG4gICAgICAgIHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pO1xuICAgICAgfSk7XG4gICAgICBpbmRleC5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgYXJjc1tpXSA9IHtcbiAgICAgICAgICBkYXRhOiBkYXRhW2ldLFxuICAgICAgICAgIHZhbHVlOiB2ID0gdmFsdWVzW2ldLFxuICAgICAgICAgIHN0YXJ0QW5nbGU6IGEsXG4gICAgICAgICAgZW5kQW5nbGU6IGEgKz0gdiAqIGsgKyBwYSxcbiAgICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9XG4gICAgcGllLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdmFsdWU7XG4gICAgICB2YWx1ZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnNvcnQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3J0O1xuICAgICAgc29ydCA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcGllLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkQW5nbGU7XG4gICAgICBwYWRBbmdsZSA9IF87XG4gICAgICByZXR1cm4gcGllO1xuICAgIH07XG4gICAgcmV0dXJuIHBpZTtcbiAgfTtcbiAgdmFyIGQzX2xheW91dF9waWVTb3J0QnlWYWx1ZSA9IHt9O1xuICBkMy5sYXlvdXQuc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVzID0gZDNfaWRlbnRpdHksIG9yZGVyID0gZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0LCBvZmZzZXQgPSBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvLCBvdXQgPSBkM19sYXlvdXRfc3RhY2tPdXQsIHggPSBkM19sYXlvdXRfc3RhY2tYLCB5ID0gZDNfbGF5b3V0X3N0YWNrWTtcbiAgICBmdW5jdGlvbiBzdGFjayhkYXRhLCBpbmRleCkge1xuICAgICAgaWYgKCEobiA9IGRhdGEubGVuZ3RoKSkgcmV0dXJuIGRhdGE7XG4gICAgICB2YXIgc2VyaWVzID0gZGF0YS5tYXAoZnVuY3Rpb24oZCwgaSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLmNhbGwoc3RhY2ssIGQsIGkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnRzID0gc2VyaWVzLm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgICAgcmV0dXJuIFsgeC5jYWxsKHN0YWNrLCB2LCBpKSwgeS5jYWxsKHN0YWNrLCB2LCBpKSBdO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG9yZGVycyA9IG9yZGVyLmNhbGwoc3RhY2ssIHBvaW50cywgaW5kZXgpO1xuICAgICAgc2VyaWVzID0gZDMucGVybXV0ZShzZXJpZXMsIG9yZGVycyk7XG4gICAgICBwb2ludHMgPSBkMy5wZXJtdXRlKHBvaW50cywgb3JkZXJzKTtcbiAgICAgIHZhciBvZmZzZXRzID0gb2Zmc2V0LmNhbGwoc3RhY2ssIHBvaW50cywgaW5kZXgpO1xuICAgICAgdmFyIG0gPSBzZXJpZXNbMF0ubGVuZ3RoLCBuLCBpLCBqLCBvO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBvdXQuY2FsbChzdGFjaywgc2VyaWVzWzBdW2pdLCBvID0gb2Zmc2V0c1tqXSwgcG9pbnRzWzBdW2pdWzFdKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIG91dC5jYWxsKHN0YWNrLCBzZXJpZXNbaV1bal0sIG8gKz0gcG9pbnRzW2kgLSAxXVtqXVsxXSwgcG9pbnRzW2ldW2pdWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHN0YWNrLnZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcztcbiAgICAgIHZhbHVlcyA9IHg7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vcmRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yZGVyO1xuICAgICAgb3JkZXIgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGQzX2xheW91dF9zdGFja09yZGVycy5nZXQoeCkgfHwgZDNfbGF5b3V0X3N0YWNrT3JkZXJEZWZhdWx0O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBkM19sYXlvdXRfc3RhY2tPZmZzZXRzLmdldCh4KSB8fCBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvO1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgc3RhY2sueCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHg7XG4gICAgICB4ID0gejtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9O1xuICAgIHN0YWNrLnkgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IHo7XG4gICAgICByZXR1cm4gc3RhY2s7XG4gICAgfTtcbiAgICBzdGFjay5vdXQgPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXQ7XG4gICAgICBvdXQgPSB6O1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH07XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tYKGQpIHtcbiAgICByZXR1cm4gZC54O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1koZCkge1xuICAgIHJldHVybiBkLnk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrT3V0KGQsIHkwLCB5KSB7XG4gICAgZC55MCA9IHkwO1xuICAgIGQueSA9IHk7XG4gIH1cbiAgdmFyIGQzX2xheW91dF9zdGFja09yZGVycyA9IGQzLm1hcCh7XG4gICAgXCJpbnNpZGUtb3V0XCI6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBuID0gZGF0YS5sZW5ndGgsIGksIGosIG1heCA9IGRhdGEubWFwKGQzX2xheW91dF9zdGFja01heEluZGV4KSwgc3VtcyA9IGRhdGEubWFwKGQzX2xheW91dF9zdGFja1JlZHVjZVN1bSksIGluZGV4ID0gZDMucmFuZ2Uobikuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBtYXhbYV0gLSBtYXhbYl07XG4gICAgICB9KSwgdG9wID0gMCwgYm90dG9tID0gMCwgdG9wcyA9IFtdLCBib3R0b21zID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGogPSBpbmRleFtpXTtcbiAgICAgICAgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgICAgIHRvcCArPSBzdW1zW2pdO1xuICAgICAgICAgIHRvcHMucHVzaChqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgICAgICBib3R0b21zLnB1c2goaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBib3R0b21zLnJldmVyc2UoKS5jb25jYXQodG9wcyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoZGF0YS5sZW5ndGgpLnJldmVyc2UoKTtcbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBkM19sYXlvdXRfc3RhY2tPcmRlckRlZmF1bHRcbiAgfSk7XG4gIHZhciBkM19sYXlvdXRfc3RhY2tPZmZzZXRzID0gZDMubWFwKHtcbiAgICBzaWxob3VldHRlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBtID0gZGF0YVswXS5sZW5ndGgsIHN1bXMgPSBbXSwgbWF4ID0gMCwgaSwgaiwgbywgeTAgPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IDA7IGkgPCBuOyBpKyspIG8gKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgaWYgKG8gPiBtYXgpIG1heCA9IG87XG4gICAgICAgIHN1bXMucHVzaChvKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgeTBbal0gPSAobWF4IC0gc3Vtc1tqXSkgLyAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgd2lnZ2xlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCB4ID0gZGF0YVswXSwgbSA9IHgubGVuZ3RoLCBpLCBqLCBrLCBzMSwgczIsIHMzLCBkeCwgbywgbzAsIHkwID0gW107XG4gICAgICB5MFswXSA9IG8gPSBvMCA9IDA7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZvciAoaSA9IDAsIHMxID0gMDsgaSA8IG47ICsraSkgczEgKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgZm9yIChpID0gMCwgczIgPSAwLCBkeCA9IHhbal1bMF0gLSB4W2ogLSAxXVswXTsgaSA8IG47ICsraSkge1xuICAgICAgICAgIGZvciAoayA9IDAsIHMzID0gKGRhdGFbaV1bal1bMV0gLSBkYXRhW2ldW2ogLSAxXVsxXSkgLyAoMiAqIGR4KTsgayA8IGk7ICsraykge1xuICAgICAgICAgICAgczMgKz0gKGRhdGFba11bal1bMV0gLSBkYXRhW2tdW2ogLSAxXVsxXSkgLyBkeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgczIgKz0gczMgKiBkYXRhW2ldW2pdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHkwW2pdID0gbyAtPSBzMSA/IHMyIC8gczEgKiBkeCA6IDA7XG4gICAgICAgIGlmIChvIDwgbzApIG8wID0gbztcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdIC09IG8wO1xuICAgICAgcmV0dXJuIHkwO1xuICAgIH0sXG4gICAgZXhwYW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbiA9IGRhdGEubGVuZ3RoLCBtID0gZGF0YVswXS5sZW5ndGgsIGsgPSAxIC8gbiwgaSwgaiwgbywgeTAgPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgICAgZm9yIChpID0gMCwgbyA9IDA7IGkgPCBuOyBpKyspIG8gKz0gZGF0YVtpXVtqXVsxXTtcbiAgICAgICAgaWYgKG8pIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIGRhdGFbaV1bal1bMV0gLz0gbzsgZWxzZSBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkYXRhW2ldW2pdWzFdID0gaztcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHkwW2pdID0gMDtcbiAgICAgIHJldHVybiB5MDtcbiAgICB9LFxuICAgIHplcm86IGQzX2xheW91dF9zdGFja09mZnNldFplcm9cbiAgfSk7XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja09yZGVyRGVmYXVsdChkYXRhKSB7XG4gICAgcmV0dXJuIGQzLnJhbmdlKGRhdGEubGVuZ3RoKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfc3RhY2tPZmZzZXRaZXJvKGRhdGEpIHtcbiAgICB2YXIgaiA9IC0xLCBtID0gZGF0YVswXS5sZW5ndGgsIHkwID0gW107XG4gICAgd2hpbGUgKCsraiA8IG0pIHkwW2pdID0gMDtcbiAgICByZXR1cm4geTA7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrTWF4SW5kZXgoYXJyYXkpIHtcbiAgICB2YXIgaSA9IDEsIGogPSAwLCB2ID0gYXJyYXlbMF1bMV0sIGssIG4gPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICg7aSA8IG47ICsraSkge1xuICAgICAgaWYgKChrID0gYXJyYXlbaV1bMV0pID4gdikge1xuICAgICAgICBqID0gaTtcbiAgICAgICAgdiA9IGs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBqO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9zdGFja1JlZHVjZVN1bShkKSB7XG4gICAgcmV0dXJuIGQucmVkdWNlKGQzX2xheW91dF9zdGFja1N1bSwgMCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3N0YWNrU3VtKHAsIGQpIHtcbiAgICByZXR1cm4gcCArIGRbMV07XG4gIH1cbiAgZDMubGF5b3V0Lmhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcmVxdWVuY3kgPSB0cnVlLCB2YWx1ZXIgPSBOdW1iZXIsIHJhbmdlciA9IGQzX2xheW91dF9oaXN0b2dyYW1SYW5nZSwgYmlubmVyID0gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpblN0dXJnZXM7XG4gICAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEsIGkpIHtcbiAgICAgIHZhciBiaW5zID0gW10sIHZhbHVlcyA9IGRhdGEubWFwKHZhbHVlciwgdGhpcyksIHJhbmdlID0gcmFuZ2VyLmNhbGwodGhpcywgdmFsdWVzLCBpKSwgdGhyZXNob2xkcyA9IGJpbm5lci5jYWxsKHRoaXMsIHJhbmdlLCB2YWx1ZXMsIGkpLCBiaW4sIGkgPSAtMSwgbiA9IHZhbHVlcy5sZW5ndGgsIG0gPSB0aHJlc2hvbGRzLmxlbmd0aCAtIDEsIGsgPSBmcmVxdWVuY3kgPyAxIDogMSAvIG4sIHg7XG4gICAgICB3aGlsZSAoKytpIDwgbSkge1xuICAgICAgICBiaW4gPSBiaW5zW2ldID0gW107XG4gICAgICAgIGJpbi5keCA9IHRocmVzaG9sZHNbaSArIDFdIC0gKGJpbi54ID0gdGhyZXNob2xkc1tpXSk7XG4gICAgICAgIGJpbi55ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChtID4gMCkge1xuICAgICAgICBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgeCA9IHZhbHVlc1tpXTtcbiAgICAgICAgICBpZiAoeCA+PSByYW5nZVswXSAmJiB4IDw9IHJhbmdlWzFdKSB7XG4gICAgICAgICAgICBiaW4gPSBiaW5zW2QzLmJpc2VjdCh0aHJlc2hvbGRzLCB4LCAxLCBtKSAtIDFdO1xuICAgICAgICAgICAgYmluLnkgKz0gaztcbiAgICAgICAgICAgIGJpbi5wdXNoKGRhdGFbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJpbnM7XG4gICAgfVxuICAgIGhpc3RvZ3JhbS52YWx1ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcjtcbiAgICAgIHZhbHVlciA9IHg7XG4gICAgICByZXR1cm4gaGlzdG9ncmFtO1xuICAgIH07XG4gICAgaGlzdG9ncmFtLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2VyO1xuICAgICAgcmFuZ2VyID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0uYmlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJpbm5lcjtcbiAgICAgIGJpbm5lciA9IHR5cGVvZiB4ID09PSBcIm51bWJlclwiID8gZnVuY3Rpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGQzX2xheW91dF9oaXN0b2dyYW1CaW5GaXhlZChyYW5nZSwgeCk7XG4gICAgICB9IDogZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBoaXN0b2dyYW07XG4gICAgfTtcbiAgICBoaXN0b2dyYW0uZnJlcXVlbmN5ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZnJlcXVlbmN5O1xuICAgICAgZnJlcXVlbmN5ID0gISF4O1xuICAgICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgICB9O1xuICAgIHJldHVybiBoaXN0b2dyYW07XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1CaW5TdHVyZ2VzKHJhbmdlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpc3RvZ3JhbUJpbkZpeGVkKHJhbmdlLCBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMiArIDEpKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfaGlzdG9ncmFtQmluRml4ZWQocmFuZ2UsIG4pIHtcbiAgICB2YXIgeCA9IC0xLCBiID0gK3JhbmdlWzBdLCBtID0gKHJhbmdlWzFdIC0gYikgLyBuLCBmID0gW107XG4gICAgd2hpbGUgKCsreCA8PSBuKSBmW3hdID0gbSAqIHggKyBiO1xuICAgIHJldHVybiBmO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9oaXN0b2dyYW1SYW5nZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gWyBkMy5taW4odmFsdWVzKSwgZDMubWF4KHZhbHVlcykgXTtcbiAgfVxuICBkMy5sYXlvdXQucGFjayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChkM19sYXlvdXRfcGFja1NvcnQpLCBwYWRkaW5nID0gMCwgc2l6ZSA9IFsgMSwgMSBdLCByYWRpdXM7XG4gICAgZnVuY3Rpb24gcGFjayhkLCBpKSB7XG4gICAgICB2YXIgbm9kZXMgPSBoaWVyYXJjaHkuY2FsbCh0aGlzLCBkLCBpKSwgcm9vdCA9IG5vZGVzWzBdLCB3ID0gc2l6ZVswXSwgaCA9IHNpemVbMV0sIHIgPSByYWRpdXMgPT0gbnVsbCA/IE1hdGguc3FydCA6IHR5cGVvZiByYWRpdXMgPT09IFwiZnVuY3Rpb25cIiA/IHJhZGl1cyA6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmFkaXVzO1xuICAgICAgfTtcbiAgICAgIHJvb3QueCA9IHJvb3QueSA9IDA7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgIGQuciA9ICtyKGQudmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBkM19sYXlvdXRfcGFja1NpYmxpbmdzKTtcbiAgICAgIGlmIChwYWRkaW5nKSB7XG4gICAgICAgIHZhciBkciA9IHBhZGRpbmcgKiAocmFkaXVzID8gMSA6IE1hdGgubWF4KDIgKiByb290LnIgLyB3LCAyICogcm9vdC5yIC8gaCkpIC8gMjtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdCwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGQuciArPSBkcjtcbiAgICAgICAgfSk7XG4gICAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGQzX2xheW91dF9wYWNrU2libGluZ3MpO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgZC5yIC09IGRyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGQzX2xheW91dF9wYWNrVHJhbnNmb3JtKHJvb3QsIHcgLyAyLCBoIC8gMiwgcmFkaXVzID8gMSA6IDEgLyBNYXRoLm1heCgyICogcm9vdC5yIC8gdywgMiAqIHJvb3QuciAvIGgpKTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgcGFjay5zaXplID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICAgIHNpemUgPSBfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICBwYWNrLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhZGl1cztcbiAgICAgIHJhZGl1cyA9IF8gPT0gbnVsbCB8fCB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6ICtfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICBwYWNrLnBhZGRpbmcgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwYWRkaW5nO1xuICAgICAgcGFkZGluZyA9ICtfO1xuICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZChwYWNrLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NvcnQoYSwgYikge1xuICAgIHJldHVybiBhLnZhbHVlIC0gYi52YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0luc2VydChhLCBiKSB7XG4gICAgdmFyIGMgPSBhLl9wYWNrX25leHQ7XG4gICAgYS5fcGFja19uZXh0ID0gYjtcbiAgICBiLl9wYWNrX3ByZXYgPSBhO1xuICAgIGIuX3BhY2tfbmV4dCA9IGM7XG4gICAgYy5fcGFja19wcmV2ID0gYjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1NwbGljZShhLCBiKSB7XG4gICAgYS5fcGFja19uZXh0ID0gYjtcbiAgICBiLl9wYWNrX3ByZXYgPSBhO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgdmFyIGR4ID0gYi54IC0gYS54LCBkeSA9IGIueSAtIGEueSwgZHIgPSBhLnIgKyBiLnI7XG4gICAgcmV0dXJuIC45OTkgKiBkciAqIGRyID4gZHggKiBkeCArIGR5ICogZHk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tTaWJsaW5ncyhub2RlKSB7XG4gICAgaWYgKCEobm9kZXMgPSBub2RlLmNoaWxkcmVuKSB8fCAhKG4gPSBub2Rlcy5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIG5vZGVzLCB4TWluID0gSW5maW5pdHksIHhNYXggPSAtSW5maW5pdHksIHlNaW4gPSBJbmZpbml0eSwgeU1heCA9IC1JbmZpbml0eSwgYSwgYiwgYywgaSwgaiwgaywgbjtcbiAgICBmdW5jdGlvbiBib3VuZChub2RlKSB7XG4gICAgICB4TWluID0gTWF0aC5taW4obm9kZS54IC0gbm9kZS5yLCB4TWluKTtcbiAgICAgIHhNYXggPSBNYXRoLm1heChub2RlLnggKyBub2RlLnIsIHhNYXgpO1xuICAgICAgeU1pbiA9IE1hdGgubWluKG5vZGUueSAtIG5vZGUuciwgeU1pbik7XG4gICAgICB5TWF4ID0gTWF0aC5tYXgobm9kZS55ICsgbm9kZS5yLCB5TWF4KTtcbiAgICB9XG4gICAgbm9kZXMuZm9yRWFjaChkM19sYXlvdXRfcGFja0xpbmspO1xuICAgIGEgPSBub2Rlc1swXTtcbiAgICBhLnggPSAtYS5yO1xuICAgIGEueSA9IDA7XG4gICAgYm91bmQoYSk7XG4gICAgaWYgKG4gPiAxKSB7XG4gICAgICBiID0gbm9kZXNbMV07XG4gICAgICBiLnggPSBiLnI7XG4gICAgICBiLnkgPSAwO1xuICAgICAgYm91bmQoYik7XG4gICAgICBpZiAobiA+IDIpIHtcbiAgICAgICAgYyA9IG5vZGVzWzJdO1xuICAgICAgICBkM19sYXlvdXRfcGFja1BsYWNlKGEsIGIsIGMpO1xuICAgICAgICBib3VuZChjKTtcbiAgICAgICAgZDNfbGF5b3V0X3BhY2tJbnNlcnQoYSwgYyk7XG4gICAgICAgIGEuX3BhY2tfcHJldiA9IGM7XG4gICAgICAgIGQzX2xheW91dF9wYWNrSW5zZXJ0KGMsIGIpO1xuICAgICAgICBiID0gYS5fcGFja19uZXh0O1xuICAgICAgICBmb3IgKGkgPSAzOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgZDNfbGF5b3V0X3BhY2tQbGFjZShhLCBiLCBjID0gbm9kZXNbaV0pO1xuICAgICAgICAgIHZhciBpc2VjdCA9IDAsIHMxID0gMSwgczIgPSAxO1xuICAgICAgICAgIGZvciAoaiA9IGIuX3BhY2tfbmV4dDsgaiAhPT0gYjsgaiA9IGouX3BhY2tfbmV4dCwgczErKykge1xuICAgICAgICAgICAgaWYgKGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhqLCBjKSkge1xuICAgICAgICAgICAgICBpc2VjdCA9IDE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNlY3QgPT0gMSkge1xuICAgICAgICAgICAgZm9yIChrID0gYS5fcGFja19wcmV2OyBrICE9PSBqLl9wYWNrX3ByZXY7IGsgPSBrLl9wYWNrX3ByZXYsIHMyKyspIHtcbiAgICAgICAgICAgICAgaWYgKGQzX2xheW91dF9wYWNrSW50ZXJzZWN0cyhrLCBjKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc2VjdCkge1xuICAgICAgICAgICAgaWYgKHMxIDwgczIgfHwgczEgPT0gczIgJiYgYi5yIDwgYS5yKSBkM19sYXlvdXRfcGFja1NwbGljZShhLCBiID0gaik7IGVsc2UgZDNfbGF5b3V0X3BhY2tTcGxpY2UoYSA9IGssIGIpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkM19sYXlvdXRfcGFja0luc2VydChhLCBjKTtcbiAgICAgICAgICAgIGIgPSBjO1xuICAgICAgICAgICAgYm91bmQoYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjeCA9ICh4TWluICsgeE1heCkgLyAyLCBjeSA9ICh5TWluICsgeU1heCkgLyAyLCBjciA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgYyA9IG5vZGVzW2ldO1xuICAgICAgYy54IC09IGN4O1xuICAgICAgYy55IC09IGN5O1xuICAgICAgY3IgPSBNYXRoLm1heChjciwgYy5yICsgTWF0aC5zcXJ0KGMueCAqIGMueCArIGMueSAqIGMueSkpO1xuICAgIH1cbiAgICBub2RlLnIgPSBjcjtcbiAgICBub2Rlcy5mb3JFYWNoKGQzX2xheW91dF9wYWNrVW5saW5rKTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja0xpbmsobm9kZSkge1xuICAgIG5vZGUuX3BhY2tfbmV4dCA9IG5vZGUuX3BhY2tfcHJldiA9IG5vZGU7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3BhY2tVbmxpbmsobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlLl9wYWNrX25leHQ7XG4gICAgZGVsZXRlIG5vZGUuX3BhY2tfcHJldjtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShub2RlLCB4LCB5LCBrKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBub2RlLnggPSB4ICs9IGsgKiBub2RlLng7XG4gICAgbm9kZS55ID0geSArPSBrICogbm9kZS55O1xuICAgIG5vZGUuciAqPSBrO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBkM19sYXlvdXRfcGFja1RyYW5zZm9ybShjaGlsZHJlbltpXSwgeCwgeSwgayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF9wYWNrUGxhY2UoYSwgYiwgYykge1xuICAgIHZhciBkYiA9IGEuciArIGMuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICAgIGlmIChkYiAmJiAoZHggfHwgZHkpKSB7XG4gICAgICB2YXIgZGEgPSBiLnIgKyBjLnIsIGRjID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBkYSAqPSBkYTtcbiAgICAgIGRiICo9IGRiO1xuICAgICAgdmFyIHggPSAuNSArIChkYiAtIGRhKSAvICgyICogZGMpLCB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIDIgKiBkYSAqIChkYiArIGRjKSAtIChkYiAtPSBkYykgKiBkYiAtIGRhICogZGEpKSAvICgyICogZGMpO1xuICAgICAgYy54ID0gYS54ICsgeCAqIGR4ICsgeSAqIGR5O1xuICAgICAgYy55ID0gYS55ICsgeCAqIGR5IC0geSAqIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjLnggPSBhLnggKyBkYjtcbiAgICAgIGMueSA9IGEueTtcbiAgICB9XG4gIH1cbiAgZDMubGF5b3V0LnRyZWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gZDMubGF5b3V0LmhpZXJhcmNoeSgpLnNvcnQobnVsbCkudmFsdWUobnVsbCksIHNlcGFyYXRpb24gPSBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24sIHNpemUgPSBbIDEsIDEgXSwgbm9kZVNpemUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHRyZWUoZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QwID0gbm9kZXNbMF0sIHJvb3QxID0gd3JhcFRyZWUocm9vdDApO1xuICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QWZ0ZXIocm9vdDEsIGZpcnN0V2FsayksIHJvb3QxLnBhcmVudC5tID0gLXJvb3QxLno7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDEsIHNlY29uZFdhbGspO1xuICAgICAgaWYgKG5vZGVTaXplKSBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIHNpemVOb2RlKTsgZWxzZSB7XG4gICAgICAgIHZhciBsZWZ0ID0gcm9vdDAsIHJpZ2h0ID0gcm9vdDAsIGJvdHRvbSA9IHJvb3QwO1xuICAgICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRCZWZvcmUocm9vdDAsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgICBpZiAobm9kZS54ID4gcmlnaHQueCkgcmlnaHQgPSBub2RlO1xuICAgICAgICAgIGlmIChub2RlLmRlcHRoID4gYm90dG9tLmRlcHRoKSBib3R0b20gPSBub2RlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHR4ID0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyIC0gbGVmdC54LCBreCA9IHNpemVbMF0gLyAocmlnaHQueCArIHNlcGFyYXRpb24ocmlnaHQsIGxlZnQpIC8gMiArIHR4KSwga3kgPSBzaXplWzFdIC8gKGJvdHRvbS5kZXB0aCB8fCAxKTtcbiAgICAgICAgZDNfbGF5b3V0X2hpZXJhcmNoeVZpc2l0QmVmb3JlKHJvb3QwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBreTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXBUcmVlKHJvb3QwKSB7XG4gICAgICB2YXIgcm9vdDEgPSB7XG4gICAgICAgIEE6IG51bGwsXG4gICAgICAgIGNoaWxkcmVuOiBbIHJvb3QwIF1cbiAgICAgIH0sIHF1ZXVlID0gWyByb290MSBdLCBub2RlMTtcbiAgICAgIHdoaWxlICgobm9kZTEgPSBxdWV1ZS5wb3AoKSkgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBjaGlsZHJlbiA9IG5vZGUxLmNoaWxkcmVuLCBjaGlsZCwgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKChjaGlsZHJlbltpXSA9IGNoaWxkID0ge1xuICAgICAgICAgICAgXzogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICBwYXJlbnQ6IG5vZGUxLFxuICAgICAgICAgICAgY2hpbGRyZW46IChjaGlsZCA9IGNoaWxkcmVuW2ldLmNoaWxkcmVuKSAmJiBjaGlsZC5zbGljZSgpIHx8IFtdLFxuICAgICAgICAgICAgQTogbnVsbCxcbiAgICAgICAgICAgIGE6IG51bGwsXG4gICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgbTogMCxcbiAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgdDogbnVsbCxcbiAgICAgICAgICAgIGk6IGlcbiAgICAgICAgICB9KS5hID0gY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcm9vdDEuY2hpbGRyZW5bMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpcnN0V2Fsayh2KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLCBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLCB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBkM19sYXlvdXRfdHJlZVNoaWZ0KHYpO1xuICAgICAgICB2YXIgbWlkcG9pbnQgPSAoY2hpbGRyZW5bMF0ueiArIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnopIC8gMjtcbiAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICAgICAgICB2Lm0gPSB2LnogLSBtaWRwb2ludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2LnogPSBtaWRwb2ludDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICAgIHYueiA9IHcueiArIHNlcGFyYXRpb24odi5fLCB3Ll8pO1xuICAgICAgfVxuICAgICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Vjb25kV2Fsayh2KSB7XG4gICAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgICB2Lm0gKz0gdi5wYXJlbnQubTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgICBpZiAodykge1xuICAgICAgICB2YXIgdmlwID0gdiwgdm9wID0gdiwgdmltID0gdywgdm9tID0gdmlwLnBhcmVudC5jaGlsZHJlblswXSwgc2lwID0gdmlwLm0sIHNvcCA9IHZvcC5tLCBzaW0gPSB2aW0ubSwgc29tID0gdm9tLm0sIHNoaWZ0O1xuICAgICAgICB3aGlsZSAodmltID0gZDNfbGF5b3V0X3RyZWVSaWdodCh2aW0pLCB2aXAgPSBkM19sYXlvdXRfdHJlZUxlZnQodmlwKSwgdmltICYmIHZpcCkge1xuICAgICAgICAgIHZvbSA9IGQzX2xheW91dF90cmVlTGVmdCh2b20pO1xuICAgICAgICAgIHZvcCA9IGQzX2xheW91dF90cmVlUmlnaHQodm9wKTtcbiAgICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgICAgc2hpZnQgPSB2aW0ueiArIHNpbSAtIHZpcC56IC0gc2lwICsgc2VwYXJhdGlvbih2aW0uXywgdmlwLl8pO1xuICAgICAgICAgIGlmIChzaGlmdCA+IDApIHtcbiAgICAgICAgICAgIGQzX2xheW91dF90cmVlTW92ZShkM19sYXlvdXRfdHJlZUFuY2VzdG9yKHZpbSwgdiwgYW5jZXN0b3IpLCB2LCBzaGlmdCk7XG4gICAgICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNpbSArPSB2aW0ubTtcbiAgICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgICAgc29tICs9IHZvbS5tO1xuICAgICAgICAgIHNvcCArPSB2b3AubTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmltICYmICFkM19sYXlvdXRfdHJlZVJpZ2h0KHZvcCkpIHtcbiAgICAgICAgICB2b3AudCA9IHZpbTtcbiAgICAgICAgICB2b3AubSArPSBzaW0gLSBzb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpcCAmJiAhZDNfbGF5b3V0X3RyZWVMZWZ0KHZvbSkpIHtcbiAgICAgICAgICB2b20udCA9IHZpcDtcbiAgICAgICAgICB2b20ubSArPSBzaXAgLSBzb207XG4gICAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpemVOb2RlKG5vZGUpIHtcbiAgICAgIG5vZGUueCAqPSBzaXplWzBdO1xuICAgICAgbm9kZS55ID0gbm9kZS5kZXB0aCAqIHNpemVbMV07XG4gICAgfVxuICAgIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNlcGFyYXRpb247XG4gICAgICBzZXBhcmF0aW9uID0geDtcbiAgICAgIHJldHVybiB0cmVlO1xuICAgIH07XG4gICAgdHJlZS5zaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBudWxsIDogc2l6ZTtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsID8gc2l6ZU5vZGUgOiBudWxsO1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICB0cmVlLm5vZGVTaXplID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbm9kZVNpemUgPyBzaXplIDogbnVsbDtcbiAgICAgIG5vZGVTaXplID0gKHNpemUgPSB4KSA9PSBudWxsID8gbnVsbCA6IHNpemVOb2RlO1xuICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfTtcbiAgICByZXR1cm4gZDNfbGF5b3V0X2hpZXJhcmNoeVJlYmluZCh0cmVlLCBoaWVyYXJjaHkpO1xuICB9O1xuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVNlcGFyYXRpb24oYSwgYikge1xuICAgIHJldHVybiBhLnBhcmVudCA9PSBiLnBhcmVudCA/IDEgOiAyO1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlTGVmdCh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbjtcbiAgICByZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID8gY2hpbGRyZW5bMF0gOiB2LnQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X3RyZWVSaWdodCh2KSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdi5jaGlsZHJlbiwgbjtcbiAgICByZXR1cm4gKG4gPSBjaGlsZHJlbi5sZW5ndGgpID8gY2hpbGRyZW5bbiAtIDFdIDogdi50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlTW92ZSh3bSwgd3AsIHNoaWZ0KSB7XG4gICAgdmFyIGNoYW5nZSA9IHNoaWZ0IC8gKHdwLmkgLSB3bS5pKTtcbiAgICB3cC5jIC09IGNoYW5nZTtcbiAgICB3cC5zICs9IHNoaWZ0O1xuICAgIHdtLmMgKz0gY2hhbmdlO1xuICAgIHdwLnogKz0gc2hpZnQ7XG4gICAgd3AubSArPSBzaGlmdDtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfdHJlZVNoaWZ0KHYpIHtcbiAgICB2YXIgc2hpZnQgPSAwLCBjaGFuZ2UgPSAwLCBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sIGkgPSBjaGlsZHJlbi5sZW5ndGgsIHc7XG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICB3ID0gY2hpbGRyZW5baV07XG4gICAgICB3LnogKz0gc2hpZnQ7XG4gICAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgICBzaGlmdCArPSB3LnMgKyAoY2hhbmdlICs9IHcuYyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlQW5jZXN0b3IodmltLCB2LCBhbmNlc3Rvcikge1xuICAgIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3RvcjtcbiAgfVxuICBkMy5sYXlvdXQuY2x1c3RlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaWVyYXJjaHkgPSBkMy5sYXlvdXQuaGllcmFyY2h5KCkuc29ydChudWxsKS52YWx1ZShudWxsKSwgc2VwYXJhdGlvbiA9IGQzX2xheW91dF90cmVlU2VwYXJhdGlvbiwgc2l6ZSA9IFsgMSwgMSBdLCBub2RlU2l6ZSA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGNsdXN0ZXIoZCwgaSkge1xuICAgICAgdmFyIG5vZGVzID0gaGllcmFyY2h5LmNhbGwodGhpcywgZCwgaSksIHJvb3QgPSBub2Rlc1swXSwgcHJldmlvdXNOb2RlLCB4ID0gMDtcbiAgICAgIGQzX2xheW91dF9oaWVyYXJjaHlWaXNpdEFmdGVyKHJvb3QsIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUueCA9IGQzX2xheW91dF9jbHVzdGVyWChjaGlsZHJlbik7XG4gICAgICAgICAgbm9kZS55ID0gZDNfbGF5b3V0X2NsdXN0ZXJZKGNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnggPSBwcmV2aW91c05vZGUgPyB4ICs9IHNlcGFyYXRpb24obm9kZSwgcHJldmlvdXNOb2RlKSA6IDA7XG4gICAgICAgICAgbm9kZS55ID0gMDtcbiAgICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBsZWZ0ID0gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KHJvb3QpLCByaWdodCA9IGQzX2xheW91dF9jbHVzdGVyUmlnaHQocm9vdCksIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLCB4MSA9IHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDI7XG4gICAgICBkM19sYXlvdXRfaGllcmFyY2h5VmlzaXRBZnRlcihyb290LCBub2RlU2l6ZSA/IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHJvb3QueCkgKiBzaXplWzBdO1xuICAgICAgICBub2RlLnkgPSAocm9vdC55IC0gbm9kZS55KSAqIHNpemVbMV07XG4gICAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLnggPSAobm9kZS54IC0geDApIC8gKHgxIC0geDApICogc2l6ZVswXTtcbiAgICAgICAgbm9kZS55ID0gKDEgLSAocm9vdC55ID8gbm9kZS55IC8gcm9vdC55IDogMSkpICogc2l6ZVsxXTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBjbHVzdGVyLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzZXBhcmF0aW9uO1xuICAgICAgc2VwYXJhdGlvbiA9IHg7XG4gICAgICByZXR1cm4gY2x1c3RlcjtcbiAgICB9O1xuICAgIGNsdXN0ZXIuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gbnVsbCA6IHNpemU7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgPT0gbnVsbDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgY2x1c3Rlci5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG5vZGVTaXplID8gc2l6ZSA6IG51bGw7XG4gICAgICBub2RlU2l6ZSA9IChzaXplID0geCkgIT0gbnVsbDtcbiAgICAgIHJldHVybiBjbHVzdGVyO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX2xheW91dF9oaWVyYXJjaHlSZWJpbmQoY2x1c3RlciwgaGllcmFyY2h5KTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJZKGNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIDEgKyBkMy5tYXgoY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICByZXR1cm4gY2hpbGQueTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclgoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uKHgsIGNoaWxkKSB7XG4gICAgICByZXR1cm4geCArIGNoaWxkLng7XG4gICAgfSwgMCkgLyBjaGlsZHJlbi5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gZDNfbGF5b3V0X2NsdXN0ZXJMZWZ0KG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGggPyBkM19sYXlvdXRfY2x1c3RlckxlZnQoY2hpbGRyZW5bMF0pIDogbm9kZTtcbiAgfVxuICBmdW5jdGlvbiBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KG5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLCBuO1xuICAgIHJldHVybiBjaGlsZHJlbiAmJiAobiA9IGNoaWxkcmVuLmxlbmd0aCkgPyBkM19sYXlvdXRfY2x1c3RlclJpZ2h0KGNoaWxkcmVuW24gLSAxXSkgOiBub2RlO1xuICB9XG4gIGQzLmxheW91dC50cmVlbWFwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhpZXJhcmNoeSA9IGQzLmxheW91dC5oaWVyYXJjaHkoKSwgcm91bmQgPSBNYXRoLnJvdW5kLCBzaXplID0gWyAxLCAxIF0sIHBhZGRpbmcgPSBudWxsLCBwYWQgPSBkM19sYXlvdXRfdHJlZW1hcFBhZE51bGwsIHN0aWNreSA9IGZhbHNlLCBzdGlja2llcywgbW9kZSA9IFwic3F1YXJpZnlcIiwgcmF0aW8gPSAuNSAqICgxICsgTWF0aC5zcXJ0KDUpKTtcbiAgICBmdW5jdGlvbiBzY2FsZShjaGlsZHJlbiwgaykge1xuICAgICAgdmFyIGkgPSAtMSwgbiA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQsIGFyZWE7XG4gICAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgICBhcmVhID0gKGNoaWxkID0gY2hpbGRyZW5baV0pLnZhbHVlICogKGsgPCAwID8gMCA6IGspO1xuICAgICAgICBjaGlsZC5hcmVhID0gaXNOYU4oYXJlYSkgfHwgYXJlYSA8PSAwID8gMCA6IGFyZWE7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNxdWFyaWZ5KG5vZGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHZhciByZWN0ID0gcGFkKG5vZGUpLCByb3cgPSBbXSwgcmVtYWluaW5nID0gY2hpbGRyZW4uc2xpY2UoKSwgY2hpbGQsIGJlc3QgPSBJbmZpbml0eSwgc2NvcmUsIHUgPSBtb2RlID09PSBcInNsaWNlXCIgPyByZWN0LmR4IDogbW9kZSA9PT0gXCJkaWNlXCIgPyByZWN0LmR5IDogbW9kZSA9PT0gXCJzbGljZS1kaWNlXCIgPyBub2RlLmRlcHRoICYgMSA/IHJlY3QuZHkgOiByZWN0LmR4IDogTWF0aC5taW4ocmVjdC5keCwgcmVjdC5keSksIG47XG4gICAgICAgIHNjYWxlKHJlbWFpbmluZywgcmVjdC5keCAqIHJlY3QuZHkgLyBub2RlLnZhbHVlKTtcbiAgICAgICAgcm93LmFyZWEgPSAwO1xuICAgICAgICB3aGlsZSAoKG4gPSByZW1haW5pbmcubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICByb3cucHVzaChjaGlsZCA9IHJlbWFpbmluZ1tuIC0gMV0pO1xuICAgICAgICAgIHJvdy5hcmVhICs9IGNoaWxkLmFyZWE7XG4gICAgICAgICAgaWYgKG1vZGUgIT09IFwic3F1YXJpZnlcIiB8fCAoc2NvcmUgPSB3b3JzdChyb3csIHUpKSA8PSBiZXN0KSB7XG4gICAgICAgICAgICByZW1haW5pbmcucG9wKCk7XG4gICAgICAgICAgICBiZXN0ID0gc2NvcmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdy5hcmVhIC09IHJvdy5wb3AoKS5hcmVhO1xuICAgICAgICAgICAgcG9zaXRpb24ocm93LCB1LCByZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICB1ID0gTWF0aC5taW4ocmVjdC5keCwgcmVjdC5keSk7XG4gICAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICAgICAgYmVzdCA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocm93Lmxlbmd0aCkge1xuICAgICAgICAgIHBvc2l0aW9uKHJvdywgdSwgcmVjdCwgdHJ1ZSk7XG4gICAgICAgICAgcm93Lmxlbmd0aCA9IHJvdy5hcmVhID0gMDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHNxdWFyaWZ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RpY2tpZnkobm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBwYWQobm9kZSksIHJlbWFpbmluZyA9IGNoaWxkcmVuLnNsaWNlKCksIGNoaWxkLCByb3cgPSBbXTtcbiAgICAgICAgc2NhbGUocmVtYWluaW5nLCByZWN0LmR4ICogcmVjdC5keSAvIG5vZGUudmFsdWUpO1xuICAgICAgICByb3cuYXJlYSA9IDA7XG4gICAgICAgIHdoaWxlIChjaGlsZCA9IHJlbWFpbmluZy5wb3AoKSkge1xuICAgICAgICAgIHJvdy5wdXNoKGNoaWxkKTtcbiAgICAgICAgICByb3cuYXJlYSArPSBjaGlsZC5hcmVhO1xuICAgICAgICAgIGlmIChjaGlsZC56ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uKHJvdywgY2hpbGQueiA/IHJlY3QuZHggOiByZWN0LmR5LCByZWN0LCAhcmVtYWluaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICByb3cubGVuZ3RoID0gcm93LmFyZWEgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHN0aWNraWZ5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gd29yc3Qocm93LCB1KSB7XG4gICAgICB2YXIgcyA9IHJvdy5hcmVhLCByLCBybWF4ID0gMCwgcm1pbiA9IEluZmluaXR5LCBpID0gLTEsIG4gPSByb3cubGVuZ3RoO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgaWYgKCEociA9IHJvd1tpXS5hcmVhKSkgY29udGludWU7XG4gICAgICAgIGlmIChyIDwgcm1pbikgcm1pbiA9IHI7XG4gICAgICAgIGlmIChyID4gcm1heCkgcm1heCA9IHI7XG4gICAgICB9XG4gICAgICBzICo9IHM7XG4gICAgICB1ICo9IHU7XG4gICAgICByZXR1cm4gcyA/IE1hdGgubWF4KHUgKiBybWF4ICogcmF0aW8gLyBzLCBzIC8gKHUgKiBybWluICogcmF0aW8pKSA6IEluZmluaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3NpdGlvbihyb3csIHUsIHJlY3QsIGZsdXNoKSB7XG4gICAgICB2YXIgaSA9IC0xLCBuID0gcm93Lmxlbmd0aCwgeCA9IHJlY3QueCwgeSA9IHJlY3QueSwgdiA9IHUgPyByb3VuZChyb3cuYXJlYSAvIHUpIDogMCwgbztcbiAgICAgIGlmICh1ID09IHJlY3QuZHgpIHtcbiAgICAgICAgaWYgKGZsdXNoIHx8IHYgPiByZWN0LmR5KSB2ID0gcmVjdC5keTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgICAgICBvID0gcm93W2ldO1xuICAgICAgICAgIG8ueCA9IHg7XG4gICAgICAgICAgby55ID0geTtcbiAgICAgICAgICBvLmR5ID0gdjtcbiAgICAgICAgICB4ICs9IG8uZHggPSBNYXRoLm1pbihyZWN0LnggKyByZWN0LmR4IC0geCwgdiA/IHJvdW5kKG8uYXJlYSAvIHYpIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgby56ID0gdHJ1ZTtcbiAgICAgICAgby5keCArPSByZWN0LnggKyByZWN0LmR4IC0geDtcbiAgICAgICAgcmVjdC55ICs9IHY7XG4gICAgICAgIHJlY3QuZHkgLT0gdjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbHVzaCB8fCB2ID4gcmVjdC5keCkgdiA9IHJlY3QuZHg7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgbyA9IHJvd1tpXTtcbiAgICAgICAgICBvLnggPSB4O1xuICAgICAgICAgIG8ueSA9IHk7XG4gICAgICAgICAgby5keCA9IHY7XG4gICAgICAgICAgeSArPSBvLmR5ID0gTWF0aC5taW4ocmVjdC55ICsgcmVjdC5keSAtIHksIHYgPyByb3VuZChvLmFyZWEgLyB2KSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIG8ueiA9IGZhbHNlO1xuICAgICAgICBvLmR5ICs9IHJlY3QueSArIHJlY3QuZHkgLSB5O1xuICAgICAgICByZWN0LnggKz0gdjtcbiAgICAgICAgcmVjdC5keCAtPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0cmVlbWFwKGQpIHtcbiAgICAgIHZhciBub2RlcyA9IHN0aWNraWVzIHx8IGhpZXJhcmNoeShkKSwgcm9vdCA9IG5vZGVzWzBdO1xuICAgICAgcm9vdC54ID0gcm9vdC55ID0gMDtcbiAgICAgIGlmIChyb290LnZhbHVlKSByb290LmR4ID0gc2l6ZVswXSwgcm9vdC5keSA9IHNpemVbMV07IGVsc2Ugcm9vdC5keCA9IHJvb3QuZHkgPSAwO1xuICAgICAgaWYgKHN0aWNraWVzKSBoaWVyYXJjaHkucmV2YWx1ZShyb290KTtcbiAgICAgIHNjYWxlKFsgcm9vdCBdLCByb290LmR4ICogcm9vdC5keSAvIHJvb3QudmFsdWUpO1xuICAgICAgKHN0aWNraWVzID8gc3RpY2tpZnkgOiBzcXVhcmlmeSkocm9vdCk7XG4gICAgICBpZiAoc3RpY2t5KSBzdGlja2llcyA9IG5vZGVzO1xuICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICB0cmVlbWFwLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzaXplO1xuICAgICAgc2l6ZSA9IHg7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZGRpbmc7XG4gICAgICBmdW5jdGlvbiBwYWRGdW5jdGlvbihub2RlKSB7XG4gICAgICAgIHZhciBwID0geC5jYWxsKHRyZWVtYXAsIG5vZGUsIG5vZGUuZGVwdGgpO1xuICAgICAgICByZXR1cm4gcCA9PSBudWxsID8gZDNfbGF5b3V0X3RyZWVtYXBQYWROdWxsKG5vZGUpIDogZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgdHlwZW9mIHAgPT09IFwibnVtYmVyXCIgPyBbIHAsIHAsIHAsIHAgXSA6IHApO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFkQ29uc3RhbnQobm9kZSkge1xuICAgICAgICByZXR1cm4gZDNfbGF5b3V0X3RyZWVtYXBQYWQobm9kZSwgeCk7XG4gICAgICB9XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHBhZCA9IChwYWRkaW5nID0geCkgPT0gbnVsbCA/IGQzX2xheW91dF90cmVlbWFwUGFkTnVsbCA6ICh0eXBlID0gdHlwZW9mIHgpID09PSBcImZ1bmN0aW9uXCIgPyBwYWRGdW5jdGlvbiA6IHR5cGUgPT09IFwibnVtYmVyXCIgPyAoeCA9IFsgeCwgeCwgeCwgeCBdLCBcbiAgICAgIHBhZENvbnN0YW50KSA6IHBhZENvbnN0YW50O1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcm91bmQgIT0gTnVtYmVyO1xuICAgICAgcm91bmQgPSB4ID8gTWF0aC5yb3VuZCA6IE51bWJlcjtcbiAgICAgIHJldHVybiB0cmVlbWFwO1xuICAgIH07XG4gICAgdHJlZW1hcC5zdGlja3kgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGlja3k7XG4gICAgICBzdGlja3kgPSB4O1xuICAgICAgc3RpY2tpZXMgPSBudWxsO1xuICAgICAgcmV0dXJuIHRyZWVtYXA7XG4gICAgfTtcbiAgICB0cmVlbWFwLnJhdGlvID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmF0aW87XG4gICAgICByYXRpbyA9IHg7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHRyZWVtYXAubW9kZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1vZGU7XG4gICAgICBtb2RlID0geCArIFwiXCI7XG4gICAgICByZXR1cm4gdHJlZW1hcDtcbiAgICB9O1xuICAgIHJldHVybiBkM19sYXlvdXRfaGllcmFyY2h5UmViaW5kKHRyZWVtYXAsIGhpZXJhcmNoeSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlbWFwUGFkTnVsbChub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IG5vZGUueCxcbiAgICAgIHk6IG5vZGUueSxcbiAgICAgIGR4OiBub2RlLmR4LFxuICAgICAgZHk6IG5vZGUuZHlcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX2xheW91dF90cmVlbWFwUGFkKG5vZGUsIHBhZGRpbmcpIHtcbiAgICB2YXIgeCA9IG5vZGUueCArIHBhZGRpbmdbM10sIHkgPSBub2RlLnkgKyBwYWRkaW5nWzBdLCBkeCA9IG5vZGUuZHggLSBwYWRkaW5nWzFdIC0gcGFkZGluZ1szXSwgZHkgPSBub2RlLmR5IC0gcGFkZGluZ1swXSAtIHBhZGRpbmdbMl07XG4gICAgaWYgKGR4IDwgMCkge1xuICAgICAgeCArPSBkeCAvIDI7XG4gICAgICBkeCA9IDA7XG4gICAgfVxuICAgIGlmIChkeSA8IDApIHtcbiAgICAgIHkgKz0gZHkgLyAyO1xuICAgICAgZHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHlcbiAgICB9O1xuICB9XG4gIGQzLnJhbmRvbSA9IHtcbiAgICBub3JtYWw6IGZ1bmN0aW9uKMK1LCDPgykge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKG4gPCAyKSDPgyA9IDE7XG4gICAgICBpZiAobiA8IDEpIMK1ID0gMDtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHgsIHksIHI7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB4ID0gTWF0aC5yYW5kb20oKSAqIDIgLSAxO1xuICAgICAgICAgIHkgPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgIH0gd2hpbGUgKCFyIHx8IHIgPiAxKTtcbiAgICAgICAgcmV0dXJuIMK1ICsgz4MgKiB4ICogTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocikgLyByKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBsb2dOb3JtYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmRvbSA9IGQzLnJhbmRvbS5ub3JtYWwuYXBwbHkoZDMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmV4cChyYW5kb20oKSk7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYmF0ZXM6IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHZhciByYW5kb20gPSBkMy5yYW5kb20uaXJ3aW5IYWxsKG0pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tKCkgLyBtO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGlyd2luSGFsbDogZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBzID0gMCwgaiA9IDA7IGogPCBtOyBqKyspIHMgKz0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgZDMuc2NhbGUgPSB7fTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSB7XG4gICAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gc3RhcnQgPCBzdG9wID8gWyBzdGFydCwgc3RvcCBdIDogWyBzdG9wLCBzdGFydCBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlUmFuZ2Uoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUucmFuZ2VFeHRlbnQgPyBzY2FsZS5yYW5nZUV4dGVudCgpIDogZDNfc2NhbGVFeHRlbnQoc2NhbGUucmFuZ2UoKSk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfYmlsaW5lYXIoZG9tYWluLCByYW5nZSwgdW5pbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUpIHtcbiAgICB2YXIgdSA9IHVuaW50ZXJwb2xhdGUoZG9tYWluWzBdLCBkb21haW5bMV0pLCBpID0gaW50ZXJwb2xhdGUocmFuZ2VbMF0sIHJhbmdlWzFdKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGkodSh4KSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9uaWNlKGRvbWFpbiwgbmljZSkge1xuICAgIHZhciBpMCA9IDAsIGkxID0gZG9tYWluLmxlbmd0aCAtIDEsIHgwID0gZG9tYWluW2kwXSwgeDEgPSBkb21haW5baTFdLCBkeDtcbiAgICBpZiAoeDEgPCB4MCkge1xuICAgICAgZHggPSBpMCwgaTAgPSBpMSwgaTEgPSBkeDtcbiAgICAgIGR4ID0geDAsIHgwID0geDEsIHgxID0gZHg7XG4gICAgfVxuICAgIGRvbWFpbltpMF0gPSBuaWNlLmZsb29yKHgwKTtcbiAgICBkb21haW5baTFdID0gbmljZS5jZWlsKHgxKTtcbiAgICByZXR1cm4gZG9tYWluO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX25pY2VTdGVwKHN0ZXApIHtcbiAgICByZXR1cm4gc3RlcCA/IHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHggLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHggLyBzdGVwKSAqIHN0ZXA7XG4gICAgICB9XG4gICAgfSA6IGQzX3NjYWxlX25pY2VJZGVudGl0eTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbmljZUlkZW50aXR5ID0ge1xuICAgIGZsb29yOiBkM19pZGVudGl0eSxcbiAgICBjZWlsOiBkM19pZGVudGl0eVxuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9wb2x5bGluZWFyKGRvbWFpbiwgcmFuZ2UsIHVuaW50ZXJwb2xhdGUsIGludGVycG9sYXRlKSB7XG4gICAgdmFyIHUgPSBbXSwgaSA9IFtdLCBqID0gMCwgayA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlLmxlbmd0aCkgLSAxO1xuICAgIGlmIChkb21haW5ba10gPCBkb21haW5bMF0pIHtcbiAgICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlID0gcmFuZ2Uuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHdoaWxlICgrK2ogPD0gaykge1xuICAgICAgdS5wdXNoKHVuaW50ZXJwb2xhdGUoZG9tYWluW2ogLSAxXSwgZG9tYWluW2pdKSk7XG4gICAgICBpLnB1c2goaW50ZXJwb2xhdGUocmFuZ2VbaiAtIDFdLCByYW5nZVtqXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIGogPSBkMy5iaXNlY3QoZG9tYWluLCB4LCAxLCBrKSAtIDE7XG4gICAgICByZXR1cm4gaVtqXSh1W2pdKHgpKTtcbiAgICB9O1xuICB9XG4gIGQzLnNjYWxlLmxpbmVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXIoWyAwLCAxIF0sIFsgMCwgMSBdLCBkM19pbnRlcnBvbGF0ZSwgZmFsc2UpO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXIoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUsIGNsYW1wKSB7XG4gICAgdmFyIG91dHB1dCwgaW5wdXQ7XG4gICAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICAgIHZhciBsaW5lYXIgPSBNYXRoLm1pbihkb21haW4ubGVuZ3RoLCByYW5nZS5sZW5ndGgpID4gMiA/IGQzX3NjYWxlX3BvbHlsaW5lYXIgOiBkM19zY2FsZV9iaWxpbmVhciwgdW5pbnRlcnBvbGF0ZSA9IGNsYW1wID8gZDNfdW5pbnRlcnBvbGF0ZUNsYW1wIDogZDNfdW5pbnRlcnBvbGF0ZU51bWJlcjtcbiAgICAgIG91dHB1dCA9IGxpbmVhcihkb21haW4sIHJhbmdlLCB1bmludGVycG9sYXRlLCBpbnRlcnBvbGF0ZSk7XG4gICAgICBpbnB1dCA9IGxpbmVhcihyYW5nZSwgZG9tYWluLCB1bmludGVycG9sYXRlLCBkM19pbnRlcnBvbGF0ZSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBvdXRwdXQoeCk7XG4gICAgfVxuICAgIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBpbnB1dCh5KTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IHgubWFwKE51bWJlcik7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYW5nZTtcbiAgICAgIHJhbmdlID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZVJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHNjYWxlLnJhbmdlKHgpLmludGVycG9sYXRlKGQzX2ludGVycG9sYXRlUm91bmQpO1xuICAgIH07XG4gICAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjbGFtcDtcbiAgICAgIGNsYW1wID0geDtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlO1xuICAgICAgaW50ZXJwb2xhdGUgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24obSkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSk7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24obSwgZm9ybWF0KSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbGluZWFyVGlja0Zvcm1hdChkb21haW4sIG0sIGZvcm1hdCk7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24obSkge1xuICAgICAgZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXIoZG9tYWluLCByYW5nZSwgaW50ZXJwb2xhdGUsIGNsYW1wKTtcbiAgICB9O1xuICAgIHJldHVybiByZXNjYWxlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyUmViaW5kKHNjYWxlLCBsaW5lYXIpIHtcbiAgICByZXR1cm4gZDMucmViaW5kKHNjYWxlLCBsaW5lYXIsIFwicmFuZ2VcIiwgXCJyYW5nZVJvdW5kXCIsIFwiaW50ZXJwb2xhdGVcIiwgXCJjbGFtcFwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJOaWNlKGRvbWFpbiwgbSkge1xuICAgIGQzX3NjYWxlX25pY2UoZG9tYWluLCBkM19zY2FsZV9uaWNlU3RlcChkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKVsyXSkpO1xuICAgIGQzX3NjYWxlX25pY2UoZG9tYWluLCBkM19zY2FsZV9uaWNlU3RlcChkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKVsyXSkpO1xuICAgIHJldHVybiBkb21haW47XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkge1xuICAgIGlmIChtID09IG51bGwpIG0gPSAxMDtcbiAgICB2YXIgZXh0ZW50ID0gZDNfc2NhbGVFeHRlbnQoZG9tYWluKSwgc3BhbiA9IGV4dGVudFsxXSAtIGV4dGVudFswXSwgc3RlcCA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHNwYW4gLyBtKSAvIE1hdGguTE4xMCkpLCBlcnIgPSBtIC8gc3BhbiAqIHN0ZXA7XG4gICAgaWYgKGVyciA8PSAuMTUpIHN0ZXAgKj0gMTA7IGVsc2UgaWYgKGVyciA8PSAuMzUpIHN0ZXAgKj0gNTsgZWxzZSBpZiAoZXJyIDw9IC43NSkgc3RlcCAqPSAyO1xuICAgIGV4dGVudFswXSA9IE1hdGguY2VpbChleHRlbnRbMF0gLyBzdGVwKSAqIHN0ZXA7XG4gICAgZXh0ZW50WzFdID0gTWF0aC5mbG9vcihleHRlbnRbMV0gLyBzdGVwKSAqIHN0ZXAgKyBzdGVwICogLjU7XG4gICAgZXh0ZW50WzJdID0gc3RlcDtcbiAgICByZXR1cm4gZXh0ZW50O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tzKGRvbWFpbiwgbSkge1xuICAgIHJldHVybiBkMy5yYW5nZS5hcHBseShkMywgZDNfc2NhbGVfbGluZWFyVGlja1JhbmdlKGRvbWFpbiwgbSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpIHtcbiAgICB2YXIgcmFuZ2UgPSBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZG9tYWluLCBtKTtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSBkM19mb3JtYXRfcmUuZXhlYyhmb3JtYXQpO1xuICAgICAgbWF0Y2guc2hpZnQoKTtcbiAgICAgIGlmIChtYXRjaFs4XSA9PT0gXCJzXCIpIHtcbiAgICAgICAgdmFyIHByZWZpeCA9IGQzLmZvcm1hdFByZWZpeChNYXRoLm1heChhYnMocmFuZ2VbMF0pLCBhYnMocmFuZ2VbMV0pKSk7XG4gICAgICAgIGlmICghbWF0Y2hbN10pIG1hdGNoWzddID0gXCIuXCIgKyBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24ocHJlZml4LnNjYWxlKHJhbmdlWzJdKSk7XG4gICAgICAgIG1hdGNoWzhdID0gXCJmXCI7XG4gICAgICAgIGZvcm1hdCA9IGQzLmZvcm1hdChtYXRjaC5qb2luKFwiXCIpKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gZm9ybWF0KHByZWZpeC5zY2FsZShkKSkgKyBwcmVmaXguc3ltYm9sO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaFs3XSkgbWF0Y2hbN10gPSBcIi5cIiArIGQzX3NjYWxlX2xpbmVhckZvcm1hdFByZWNpc2lvbihtYXRjaFs4XSwgcmFuZ2UpO1xuICAgICAgZm9ybWF0ID0gbWF0Y2guam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9ybWF0ID0gXCIsLlwiICsgZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKHJhbmdlWzJdKSArIFwiZlwiO1xuICAgIH1cbiAgICByZXR1cm4gZDMuZm9ybWF0KGZvcm1hdCk7XG4gIH1cbiAgdmFyIGQzX3NjYWxlX2xpbmVhckZvcm1hdFNpZ25pZmljYW50ID0ge1xuICAgIHM6IDEsXG4gICAgZzogMSxcbiAgICBwOiAxLFxuICAgIHI6IDEsXG4gICAgZTogMVxuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJQcmVjaXNpb24odmFsdWUpIHtcbiAgICByZXR1cm4gLU1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjEwICsgLjAxKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zY2FsZV9saW5lYXJGb3JtYXRQcmVjaXNpb24odHlwZSwgcmFuZ2UpIHtcbiAgICB2YXIgcCA9IGQzX3NjYWxlX2xpbmVhclByZWNpc2lvbihyYW5nZVsyXSk7XG4gICAgcmV0dXJuIHR5cGUgaW4gZDNfc2NhbGVfbGluZWFyRm9ybWF0U2lnbmlmaWNhbnQgPyBNYXRoLmFicyhwIC0gZDNfc2NhbGVfbGluZWFyUHJlY2lzaW9uKE1hdGgubWF4KGFicyhyYW5nZVswXSksIGFicyhyYW5nZVsxXSkpKSkgKyArKHR5cGUgIT09IFwiZVwiKSA6IHAgLSAodHlwZSA9PT0gXCIlXCIpICogMjtcbiAgfVxuICBkMy5zY2FsZS5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihbIDAsIDEgXSksIDEwLCB0cnVlLCBbIDEsIDEwIF0pO1xuICB9O1xuICBmdW5jdGlvbiBkM19zY2FsZV9sb2cobGluZWFyLCBiYXNlLCBwb3NpdGl2ZSwgZG9tYWluKSB7XG4gICAgZnVuY3Rpb24gbG9nKHgpIHtcbiAgICAgIHJldHVybiAocG9zaXRpdmUgPyBNYXRoLmxvZyh4IDwgMCA/IDAgOiB4KSA6IC1NYXRoLmxvZyh4ID4gMCA/IDAgOiAteCkpIC8gTWF0aC5sb2coYmFzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvdyh4KSB7XG4gICAgICByZXR1cm4gcG9zaXRpdmUgPyBNYXRoLnBvdyhiYXNlLCB4KSA6IC1NYXRoLnBvdyhiYXNlLCAteCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICAgIHJldHVybiBsaW5lYXIobG9nKHgpKTtcbiAgICB9XG4gICAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBvdyhsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIHBvc2l0aXZlID0geFswXSA+PSAwO1xuICAgICAgbGluZWFyLmRvbWFpbigoZG9tYWluID0geC5tYXAoTnVtYmVyKSkubWFwKGxvZykpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuYmFzZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGJhc2U7XG4gICAgICBiYXNlID0gK187XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAobG9nKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmljZWQgPSBkM19zY2FsZV9uaWNlKGRvbWFpbi5tYXAobG9nKSwgcG9zaXRpdmUgPyBNYXRoIDogZDNfc2NhbGVfbG9nTmljZU5lZ2F0aXZlKTtcbiAgICAgIGxpbmVhci5kb21haW4obmljZWQpO1xuICAgICAgZG9tYWluID0gbmljZWQubWFwKHBvdyk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KGRvbWFpbiksIHRpY2tzID0gW10sIHUgPSBleHRlbnRbMF0sIHYgPSBleHRlbnRbMV0sIGkgPSBNYXRoLmZsb29yKGxvZyh1KSksIGogPSBNYXRoLmNlaWwobG9nKHYpKSwgbiA9IGJhc2UgJSAxID8gMiA6IGJhc2U7XG4gICAgICBpZiAoaXNGaW5pdGUoaiAtIGkpKSB7XG4gICAgICAgIGlmIChwb3NpdGl2ZSkge1xuICAgICAgICAgIGZvciAoO2kgPCBqOyBpKyspIGZvciAodmFyIGsgPSAxOyBrIDwgbjsgaysrKSB0aWNrcy5wdXNoKHBvdyhpKSAqIGspO1xuICAgICAgICAgIHRpY2tzLnB1c2gocG93KGkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrcy5wdXNoKHBvdyhpKSk7XG4gICAgICAgICAgZm9yICg7aSsrIDwgajsgKSBmb3IgKHZhciBrID0gbiAtIDE7IGsgPiAwOyBrLS0pIHRpY2tzLnB1c2gocG93KGkpICogayk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgdGlja3NbaV0gPCB1OyBpKyspIHt9XG4gICAgICAgIGZvciAoaiA9IHRpY2tzLmxlbmd0aDsgdGlja3NbaiAtIDFdID4gdjsgai0tKSB7fVxuICAgICAgICB0aWNrcyA9IHRpY2tzLnNsaWNlKGksIGopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpY2tzO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG4sIGZvcm1hdCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZDNfc2NhbGVfbG9nRm9ybWF0O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBmb3JtYXQgPSBkM19zY2FsZV9sb2dGb3JtYXQ7IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT09IFwiZnVuY3Rpb25cIikgZm9ybWF0ID0gZDMuZm9ybWF0KGZvcm1hdCk7XG4gICAgICB2YXIgayA9IE1hdGgubWF4KDEsIGJhc2UgKiBuIC8gc2NhbGUudGlja3MoKS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGkgPSBkIC8gcG93KE1hdGgucm91bmQobG9nKGQpKSk7XG4gICAgICAgIGlmIChpICogYmFzZSA8IGJhc2UgLSAuNSkgaSAqPSBiYXNlO1xuICAgICAgICByZXR1cm4gaSA8PSBrID8gZm9ybWF0KGQpIDogXCJcIjtcbiAgICAgIH07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfbG9nKGxpbmVhci5jb3B5KCksIGJhc2UsIHBvc2l0aXZlLCBkb21haW4pO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICB2YXIgZDNfc2NhbGVfbG9nRm9ybWF0ID0gZDMuZm9ybWF0KFwiLjBlXCIpLCBkM19zY2FsZV9sb2dOaWNlTmVnYXRpdmUgPSB7XG4gICAgZmxvb3I6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5jZWlsKC14KTtcbiAgICB9LFxuICAgIGNlaWw6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiAtTWF0aC5mbG9vcigteCk7XG4gICAgfVxuICB9O1xuICBkMy5zY2FsZS5wb3cgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcG93KGQzLnNjYWxlLmxpbmVhcigpLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3BvdyhsaW5lYXIsIGV4cG9uZW50LCBkb21haW4pIHtcbiAgICB2YXIgcG93cCA9IGQzX3NjYWxlX3Bvd1BvdyhleHBvbmVudCksIHBvd2IgPSBkM19zY2FsZV9wb3dQb3coMSAvIGV4cG9uZW50KTtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHBvd3AoeCkpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcG93YihsaW5lYXIuaW52ZXJ0KHgpKTtcbiAgICB9O1xuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGxpbmVhci5kb21haW4oKGRvbWFpbiA9IHgubWFwKE51bWJlcikpLm1hcChwb3dwKSk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgc2NhbGUudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgc2NhbGUubmljZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBzY2FsZS5kb21haW4oZDNfc2NhbGVfbGluZWFyTmljZShkb21haW4sIG0pKTtcbiAgICB9O1xuICAgIHNjYWxlLmV4cG9uZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZXhwb25lbnQ7XG4gICAgICBwb3dwID0gZDNfc2NhbGVfcG93UG93KGV4cG9uZW50ID0geCk7XG4gICAgICBwb3diID0gZDNfc2NhbGVfcG93UG93KDEgLyBleHBvbmVudCk7XG4gICAgICBsaW5lYXIuZG9tYWluKGRvbWFpbi5tYXAocG93cCkpO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3BvdyhsaW5lYXIuY29weSgpLCBleHBvbmVudCwgZG9tYWluKTtcbiAgICB9O1xuICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJSZWJpbmQoc2NhbGUsIGxpbmVhcik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc2NhbGVfcG93UG93KGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggPCAwID8gLU1hdGgucG93KC14LCBlKSA6IE1hdGgucG93KHgsIGUpO1xuICAgIH07XG4gIH1cbiAgZDMuc2NhbGUuc3FydCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkMy5zY2FsZS5wb3coKS5leHBvbmVudCguNSk7XG4gIH07XG4gIGQzLnNjYWxlLm9yZGluYWwgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfb3JkaW5hbChbXSwge1xuICAgICAgdDogXCJyYW5nZVwiLFxuICAgICAgYTogWyBbXSBdXG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpIHtcbiAgICB2YXIgaW5kZXgsIHJhbmdlLCByYW5nZUJhbmQ7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlWygoaW5kZXguZ2V0KHgpIHx8IChyYW5nZXIudCA9PT0gXCJyYW5nZVwiID8gaW5kZXguc2V0KHgsIGRvbWFpbi5wdXNoKHgpKSA6IE5hTikpIC0gMSkgJSByYW5nZS5sZW5ndGhdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwcyhzdGFydCwgc3RlcCkge1xuICAgICAgcmV0dXJuIGQzLnJhbmdlKGRvbWFpbi5sZW5ndGgpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBzdGFydCArIHN0ZXAgKiBpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbjtcbiAgICAgIGRvbWFpbiA9IFtdO1xuICAgICAgaW5kZXggPSBuZXcgZDNfTWFwKCk7XG4gICAgICB2YXIgaSA9IC0xLCBuID0geC5sZW5ndGgsIHhpO1xuICAgICAgd2hpbGUgKCsraSA8IG4pIGlmICghaW5kZXguaGFzKHhpID0geFtpXSkpIGluZGV4LnNldCh4aSwgZG9tYWluLnB1c2goeGkpKTtcbiAgICAgIHJldHVybiBzY2FsZVtyYW5nZXIudF0uYXBwbHkoc2NhbGUsIHJhbmdlci5hKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUG9pbnRzID0gZnVuY3Rpb24oeCwgcGFkZGluZykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSBwYWRkaW5nID0gMDtcbiAgICAgIHZhciBzdGFydCA9IHhbMF0sIHN0b3AgPSB4WzFdLCBzdGVwID0gZG9tYWluLmxlbmd0aCA8IDIgPyAoc3RhcnQgPSAoc3RhcnQgKyBzdG9wKSAvIDIsIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBwYWRkaW5nIC8gMiwgc3RlcCk7XG4gICAgICByYW5nZUJhbmQgPSAwO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlUm91bmRQb2ludHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgdmFyIHN0YXJ0ID0geFswXSwgc3RvcCA9IHhbMV0sIHN0ZXAgPSBkb21haW4ubGVuZ3RoIDwgMiA/IChzdGFydCA9IHN0b3AgPSBNYXRoLnJvdW5kKChzdGFydCArIHN0b3ApIC8gMiksIFxuICAgICAgMCkgOiAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gMSArIHBhZGRpbmcpIHwgMDtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKHN0ZXAgKiBwYWRkaW5nIC8gMiArIChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIDEgKyBwYWRkaW5nKSAqIHN0ZXApIC8gMiksIHN0ZXApO1xuICAgICAgcmFuZ2VCYW5kID0gMDtcbiAgICAgIHJhbmdlciA9IHtcbiAgICAgICAgdDogXCJyYW5nZVJvdW5kUG9pbnRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZHMgPSBmdW5jdGlvbih4LCBwYWRkaW5nLCBvdXRlclBhZGRpbmcpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcGFkZGluZyA9IDA7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIG91dGVyUGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICB2YXIgcmV2ZXJzZSA9IHhbMV0gPCB4WzBdLCBzdGFydCA9IHhbcmV2ZXJzZSAtIDBdLCBzdG9wID0geFsxIC0gcmV2ZXJzZV0sIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpO1xuICAgICAgcmFuZ2UgPSBzdGVwcyhzdGFydCArIHN0ZXAgKiBvdXRlclBhZGRpbmcsIHN0ZXApO1xuICAgICAgaWYgKHJldmVyc2UpIHJhbmdlLnJldmVyc2UoKTtcbiAgICAgIHJhbmdlQmFuZCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmcpO1xuICAgICAgcmFuZ2VyID0ge1xuICAgICAgICB0OiBcInJhbmdlQmFuZHNcIixcbiAgICAgICAgYTogYXJndW1lbnRzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzID0gZnVuY3Rpb24oeCwgcGFkZGluZywgb3V0ZXJQYWRkaW5nKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHBhZGRpbmcgPSAwO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBvdXRlclBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgdmFyIHJldmVyc2UgPSB4WzFdIDwgeFswXSwgc3RhcnQgPSB4W3JldmVyc2UgLSAwXSwgc3RvcCA9IHhbMSAtIHJldmVyc2VdLCBzdGVwID0gTWF0aC5mbG9vcigoc3RvcCAtIHN0YXJ0KSAvIChkb21haW4ubGVuZ3RoIC0gcGFkZGluZyArIDIgKiBvdXRlclBhZGRpbmcpKTtcbiAgICAgIHJhbmdlID0gc3RlcHMoc3RhcnQgKyBNYXRoLnJvdW5kKChzdG9wIC0gc3RhcnQgLSAoZG9tYWluLmxlbmd0aCAtIHBhZGRpbmcpICogc3RlcCkgLyAyKSwgc3RlcCk7XG4gICAgICBpZiAocmV2ZXJzZSkgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgcmFuZ2VCYW5kID0gTWF0aC5yb3VuZChzdGVwICogKDEgLSBwYWRkaW5nKSk7XG4gICAgICByYW5nZXIgPSB7XG4gICAgICAgIHQ6IFwicmFuZ2VSb3VuZEJhbmRzXCIsXG4gICAgICAgIGE6IGFyZ3VtZW50c1xuICAgICAgfTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlQmFuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmdlQmFuZDtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlRXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVFeHRlbnQocmFuZ2VyLmFbMF0pO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX29yZGluYWwoZG9tYWluLCByYW5nZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICB9XG4gIGQzLnNjYWxlLmNhdGVnb3J5MTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MTApO1xuICB9O1xuICBkMy5zY2FsZS5jYXRlZ29yeTIwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBiKTtcbiAgfTtcbiAgZDMuc2NhbGUuY2F0ZWdvcnkyMGMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBjKTtcbiAgfTtcbiAgdmFyIGQzX2NhdGVnb3J5MTAgPSBbIDIwNjIyNjAsIDE2NzQ0MjA2LCAyOTI0NTg4LCAxNDAzNDcyOCwgOTcyNTg4NSwgOTE5NzEzMSwgMTQ5MDczMzAsIDgzNTU3MTEsIDEyMzY5MTg2LCAxNTU2MTc1IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwID0gWyAyMDYyMjYwLCAxMTQ1NDQ0MCwgMTY3NDQyMDYsIDE2NzU5NjcyLCAyOTI0NTg4LCAxMDAxODY5OCwgMTQwMzQ3MjgsIDE2NzUwNzQyLCA5NzI1ODg1LCAxMjk1NTg2MSwgOTE5NzEzMSwgMTI4ODUxNDAsIDE0OTA3MzMwLCAxNjIzNDE5NCwgODM1NTcxMSwgMTMwOTI4MDcsIDEyMzY5MTg2LCAxNDQwODU4OSwgMTU1NjE3NSwgMTA0MTA3MjUgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgdmFyIGQzX2NhdGVnb3J5MjBiID0gWyAzNzUwNzc3LCA1Mzk1NjE5LCA3MDQwNzE5LCAxMDI2NDI4NiwgNjUxOTA5NywgOTIxNjU5NCwgMTE5MTUxMTUsIDEzNTU2NjM2LCA5MjAyOTkzLCAxMjQyNjgwOSwgMTUxODY1MTQsIDE1MTkwOTMyLCA4NjY2MTY5LCAxMTM1NjQ5MCwgMTQwNDk2NDMsIDE1MTc3MzcyLCA4MDc3NjgzLCAxMDgzNDMyNCwgMTM1Mjg1MDksIDE0NTg5NjU0IF0ubWFwKGQzX3JnYlN0cmluZyk7XG4gIHZhciBkM19jYXRlZ29yeTIwYyA9IFsgMzI0NDczMywgNzA1NzExMCwgMTA0MDY2MjUsIDEzMDMyNDMxLCAxNTA5NTA1MywgMTY2MTY3NjQsIDE2NjI1MjU5LCAxNjYzNDAxOCwgMzI1MzA3NiwgNzY1MjQ3MCwgMTA2MDcwMDMsIDEzMTAxNTA0LCA3Njk1MjgxLCAxMDM5NDMxMiwgMTIzNjkzNzIsIDE0MzQyODkxLCA2NTEzNTA3LCA5ODY4OTUwLCAxMjQzNDg3NywgMTQyNzcwODEgXS5tYXAoZDNfcmdiU3RyaW5nKTtcbiAgZDMuc2NhbGUucXVhbnRpbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpbGUoW10sIFtdKTtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc2NhbGVfcXVhbnRpbGUoZG9tYWluLCByYW5nZSkge1xuICAgIHZhciB0aHJlc2hvbGRzO1xuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICB2YXIgayA9IDAsIHEgPSByYW5nZS5sZW5ndGg7XG4gICAgICB0aHJlc2hvbGRzID0gW107XG4gICAgICB3aGlsZSAoKytrIDwgcSkgdGhyZXNob2xkc1trIC0gMV0gPSBkMy5xdWFudGlsZShkb21haW4sIGsgLyBxKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKCFpc05hTih4ID0gK3gpKSByZXR1cm4gcmFuZ2VbZDMuYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0geC5tYXAoZDNfbnVtYmVyKS5maWx0ZXIoZDNfbnVtZXJpYykuc29ydChkM19hc2NlbmRpbmcpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IHg7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH07XG4gICAgc2NhbGUucXVhbnRpbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhyZXNob2xkcztcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgcmV0dXJuIHkgPCAwID8gWyBOYU4sIE5hTiBdIDogWyB5ID4gMCA/IHRocmVzaG9sZHNbeSAtIDFdIDogZG9tYWluWzBdLCB5IDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW3ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3F1YW50aWxlKGRvbWFpbiwgcmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfVxuICBkMy5zY2FsZS5xdWFudGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9xdWFudGl6ZSgwLCAxLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3F1YW50aXplKHgwLCB4MSwgcmFuZ2UpIHtcbiAgICB2YXIga3gsIGk7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKGksIE1hdGguZmxvb3Ioa3ggKiAoeCAtIHgwKSkpKV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgICBreCA9IHJhbmdlLmxlbmd0aCAvICh4MSAtIHgwKTtcbiAgICAgIGkgPSByYW5nZS5sZW5ndGggLSAxO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH1cbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbIHgwLCB4MSBdO1xuICAgICAgeDAgPSAreFswXTtcbiAgICAgIHgxID0gK3hbeC5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfTtcbiAgICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHJhbmdlO1xuICAgICAgcmFuZ2UgPSB4O1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9O1xuICAgIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICAgIHkgPSByYW5nZS5pbmRleE9mKHkpO1xuICAgICAgeSA9IHkgPCAwID8gTmFOIDogeSAvIGt4ICsgeDA7XG4gICAgICByZXR1cm4gWyB5LCB5ICsgMSAvIGt4IF07XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfc2NhbGVfcXVhbnRpemUoeDAsIHgxLCByYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9XG4gIGQzLnNjYWxlLnRocmVzaG9sZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV90aHJlc2hvbGQoWyAuNSBdLCBbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKSB7XG4gICAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlW2QzLmJpc2VjdChkb21haW4sIHgpXTtcbiAgICB9XG4gICAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluO1xuICAgICAgZG9tYWluID0gXztcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9O1xuICAgIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcmFuZ2U7XG4gICAgICByYW5nZSA9IF87XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBzY2FsZS5pbnZlcnRFeHRlbnQgPSBmdW5jdGlvbih5KSB7XG4gICAgICB5ID0gcmFuZ2UuaW5kZXhPZih5KTtcbiAgICAgIHJldHVybiBbIGRvbWFpblt5IC0gMV0sIGRvbWFpblt5XSBdO1xuICAgIH07XG4gICAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX3RocmVzaG9sZChkb21haW4sIHJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuICBkMy5zY2FsZS5pZGVudGl0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zY2FsZV9pZGVudGl0eShbIDAsIDEgXSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbikge1xuICAgIGZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgICAgIHJldHVybiAreDtcbiAgICB9XG4gICAgaWRlbnRpdHkuaW52ZXJ0ID0gaWRlbnRpdHk7XG4gICAgaWRlbnRpdHkuZG9tYWluID0gaWRlbnRpdHkucmFuZ2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkb21haW47XG4gICAgICBkb21haW4gPSB4Lm1hcChpZGVudGl0eSk7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfTtcbiAgICBpZGVudGl0eS50aWNrcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgIHJldHVybiBkM19zY2FsZV9saW5lYXJUaWNrcyhkb21haW4sIG0pO1xuICAgIH07XG4gICAgaWRlbnRpdHkudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKG0sIGZvcm1hdCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclRpY2tGb3JtYXQoZG9tYWluLCBtLCBmb3JtYXQpO1xuICAgIH07XG4gICAgaWRlbnRpdHkuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGQzX3NjYWxlX2lkZW50aXR5KGRvbWFpbik7XG4gICAgfTtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgZDMuc3ZnID0ge307XG4gIGZ1bmN0aW9uIGQzX3plcm8oKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZDMuc3ZnLmFyYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbm5lclJhZGl1cyA9IGQzX3N2Z19hcmNJbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgPSBkM19zdmdfYXJjT3V0ZXJSYWRpdXMsIGNvcm5lclJhZGl1cyA9IGQzX3plcm8sIHBhZFJhZGl1cyA9IGQzX3N2Z19hcmNBdXRvLCBzdGFydEFuZ2xlID0gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gZDNfc3ZnX2FyY0VuZEFuZ2xlLCBwYWRBbmdsZSA9IGQzX3N2Z19hcmNQYWRBbmdsZTtcbiAgICBmdW5jdGlvbiBhcmMoKSB7XG4gICAgICB2YXIgcjAgPSBNYXRoLm1heCgwLCAraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSksIHIxID0gTWF0aC5tYXgoMCwgK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpLCBhMCA9IHN0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSAtIGhhbGbPgCwgYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZs+ALCBkYSA9IE1hdGguYWJzKGExIC0gYTApLCBjdyA9IGEwID4gYTEgPyAwIDogMTtcbiAgICAgIGlmIChyMSA8IHIwKSByYyA9IHIxLCByMSA9IHIwLCByMCA9IHJjO1xuICAgICAgaWYgKGRhID49IM+EzrUpIHJldHVybiBjaXJjbGVTZWdtZW50KHIxLCBjdykgKyAocjAgPyBjaXJjbGVTZWdtZW50KHIwLCAxIC0gY3cpIDogXCJcIikgKyBcIlpcIjtcbiAgICAgIHZhciByYywgY3IsIHJwLCBhcCwgcDAgPSAwLCBwMSA9IDAsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgcGF0aCA9IFtdO1xuICAgICAgaWYgKGFwID0gKCtwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IDApIC8gMikge1xuICAgICAgICBycCA9IHBhZFJhZGl1cyA9PT0gZDNfc3ZnX2FyY0F1dG8gPyBNYXRoLnNxcnQocjAgKiByMCArIHIxICogcjEpIDogK3BhZFJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIWN3KSBwMSAqPSAtMTtcbiAgICAgICAgaWYgKHIxKSBwMSA9IGQzX2FzaW4ocnAgLyByMSAqIE1hdGguc2luKGFwKSk7XG4gICAgICAgIGlmIChyMCkgcDAgPSBkM19hc2luKHJwIC8gcjAgKiBNYXRoLnNpbihhcCkpO1xuICAgICAgfVxuICAgICAgaWYgKHIxKSB7XG4gICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhhMCArIHAxKTtcbiAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGEwICsgcDEpO1xuICAgICAgICB4MSA9IHIxICogTWF0aC5jb3MoYTEgLSBwMSk7XG4gICAgICAgIHkxID0gcjEgKiBNYXRoLnNpbihhMSAtIHAxKTtcbiAgICAgICAgdmFyIGwxID0gTWF0aC5hYnMoYTEgLSBhMCAtIDIgKiBwMSkgPD0gz4AgPyAwIDogMTtcbiAgICAgICAgaWYgKHAxICYmIGQzX3N2Z19hcmNTd2VlcCh4MCwgeTAsIHgxLCB5MSkgPT09IGN3IF4gbDEpIHtcbiAgICAgICAgICB2YXIgaDEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgwID0gcjEgKiBNYXRoLmNvcyhoMSk7XG4gICAgICAgICAgeTAgPSByMSAqIE1hdGguc2luKGgxKTtcbiAgICAgICAgICB4MSA9IHkxID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDAgPSB5MCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocjApIHtcbiAgICAgICAgeDIgPSByMCAqIE1hdGguY29zKGExIC0gcDApO1xuICAgICAgICB5MiA9IHIwICogTWF0aC5zaW4oYTEgLSBwMCk7XG4gICAgICAgIHgzID0gcjAgKiBNYXRoLmNvcyhhMCArIHAwKTtcbiAgICAgICAgeTMgPSByMCAqIE1hdGguc2luKGEwICsgcDApO1xuICAgICAgICB2YXIgbDAgPSBNYXRoLmFicyhhMCAtIGExICsgMiAqIHAwKSA8PSDPgCA/IDAgOiAxO1xuICAgICAgICBpZiAocDAgJiYgZDNfc3ZnX2FyY1N3ZWVwKHgyLCB5MiwgeDMsIHkzKSA9PT0gMSAtIGN3IF4gbDApIHtcbiAgICAgICAgICB2YXIgaDAgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgICAgIHgyID0gcjAgKiBNYXRoLmNvcyhoMCk7XG4gICAgICAgICAgeTIgPSByMCAqIE1hdGguc2luKGgwKTtcbiAgICAgICAgICB4MyA9IHkzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB5MiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoZGEgPiDOtSAmJiAocmMgPSBNYXRoLm1pbihNYXRoLmFicyhyMSAtIHIwKSAvIDIsICtjb3JuZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSkpID4gLjAwMSkge1xuICAgICAgICBjciA9IHIwIDwgcjEgXiBjdyA/IDAgOiAxO1xuICAgICAgICB2YXIgcmMxID0gcmMsIHJjMCA9IHJjO1xuICAgICAgICBpZiAoZGEgPCDPgCkge1xuICAgICAgICAgIHZhciBvYyA9IHgzID09IG51bGwgPyBbIHgyLCB5MiBdIDogeDEgPT0gbnVsbCA/IFsgeDAsIHkwIF0gOiBkM19nZW9tX3BvbHlnb25JbnRlcnNlY3QoWyB4MCwgeTAgXSwgWyB4MywgeTMgXSwgWyB4MSwgeTEgXSwgWyB4MiwgeTIgXSksIGF4ID0geDAgLSBvY1swXSwgYXkgPSB5MCAtIG9jWzFdLCBieCA9IHgxIC0gb2NbMF0sIGJ5ID0geTEgLSBvY1sxXSwga2MgPSAxIC8gTWF0aC5zaW4oTWF0aC5hY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoTWF0aC5zcXJ0KGF4ICogYXggKyBheSAqIGF5KSAqIE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSkpKSAvIDIpLCBsYyA9IE1hdGguc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gTWF0aC5taW4ocmMsIChyMCAtIGxjKSAvIChrYyAtIDEpKTtcbiAgICAgICAgICByYzEgPSBNYXRoLm1pbihyYywgKHIxIC0gbGMpIC8gKGtjICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4MSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHQzMCA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyh4MyA9PSBudWxsID8gWyB4MiwgeTIgXSA6IFsgeDMsIHkzIF0sIFsgeDAsIHkwIF0sIHIxLCByYzEsIGN3KSwgdDEyID0gZDNfc3ZnX2FyY0Nvcm5lclRhbmdlbnRzKFsgeDEsIHkxIF0sIFsgeDIsIHkyIF0sIHIxLCByYzEsIGN3KTtcbiAgICAgICAgICBpZiAocmMgPT09IHJjMSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB0MzBbMF0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MzBbMV0sIFwiQVwiLCByMSwgXCIsXCIsIHIxLCBcIiAwIFwiLCAxIC0gY3cgXiBkM19zdmdfYXJjU3dlZXAodDMwWzFdWzBdLCB0MzBbMV1bMV0sIHQxMlsxXVswXSwgdDEyWzFdWzFdKSwgXCIsXCIsIGN3LCBcIiBcIiwgdDEyWzFdLCBcIkFcIiwgcmMxLCBcIixcIiwgcmMxLCBcIiAwIDAsXCIsIGNyLCBcIiBcIiwgdDEyWzBdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKFwiTVwiLCB0MzBbMF0sIFwiQVwiLCByYzEsIFwiLFwiLCByYzEsIFwiIDAgMSxcIiwgY3IsIFwiIFwiLCB0MTJbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoLnB1c2goXCJNXCIsIHgwLCBcIixcIiwgeTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4MyAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIHQwMyA9IGQzX3N2Z19hcmNDb3JuZXJUYW5nZW50cyhbIHgwLCB5MCBdLCBbIHgzLCB5MyBdLCByMCwgLXJjMCwgY3cpLCB0MjEgPSBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMoWyB4MiwgeTIgXSwgeDEgPT0gbnVsbCA/IFsgeDAsIHkwIF0gOiBbIHgxLCB5MSBdLCByMCwgLXJjMCwgY3cpO1xuICAgICAgICAgIGlmIChyYyA9PT0gcmMwKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHQyMVswXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQyMVsxXSwgXCJBXCIsIHIwLCBcIixcIiwgcjAsIFwiIDAgXCIsIGN3IF4gZDNfc3ZnX2FyY1N3ZWVwKHQyMVsxXVswXSwgdDIxWzFdWzFdLCB0MDNbMV1bMF0sIHQwM1sxXVsxXSksIFwiLFwiLCAxIC0gY3csIFwiIFwiLCB0MDNbMV0sIFwiQVwiLCByYzAsIFwiLFwiLCByYzAsIFwiIDAgMCxcIiwgY3IsIFwiIFwiLCB0MDNbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goXCJMXCIsIHQyMVswXSwgXCJBXCIsIHJjMCwgXCIsXCIsIHJjMCwgXCIgMCAwLFwiLCBjciwgXCIgXCIsIHQwM1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucHVzaChcIkxcIiwgeDIsIFwiLFwiLCB5Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGgucHVzaChcIk1cIiwgeDAsIFwiLFwiLCB5MCk7XG4gICAgICAgIGlmICh4MSAhPSBudWxsKSBwYXRoLnB1c2goXCJBXCIsIHIxLCBcIixcIiwgcjEsIFwiIDAgXCIsIGwxLCBcIixcIiwgY3csIFwiIFwiLCB4MSwgXCIsXCIsIHkxKTtcbiAgICAgICAgcGF0aC5wdXNoKFwiTFwiLCB4MiwgXCIsXCIsIHkyKTtcbiAgICAgICAgaWYgKHgzICE9IG51bGwpIHBhdGgucHVzaChcIkFcIiwgcjAsIFwiLFwiLCByMCwgXCIgMCBcIiwgbDAsIFwiLFwiLCAxIC0gY3csIFwiIFwiLCB4MywgXCIsXCIsIHkzKTtcbiAgICAgIH1cbiAgICAgIHBhdGgucHVzaChcIlpcIik7XG4gICAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaXJjbGVTZWdtZW50KHIxLCBjdykge1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyByMSArIFwiQVwiICsgcjEgKyBcIixcIiArIHIxICsgXCIgMCAxLFwiICsgY3cgKyBcIiAwLFwiICsgLXIxICsgXCJBXCIgKyByMSArIFwiLFwiICsgcjEgKyBcIiAwIDEsXCIgKyBjdyArIFwiIDAsXCIgKyByMTtcbiAgICB9XG4gICAgYXJjLmlubmVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gaW5uZXJSYWRpdXM7XG4gICAgICBpbm5lclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLm91dGVyUmFkaXVzID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3V0ZXJSYWRpdXM7XG4gICAgICBvdXRlclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNvcm5lclJhZGl1cztcbiAgICAgIGNvcm5lclJhZGl1cyA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnBhZFJhZGl1cyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBhZFJhZGl1cztcbiAgICAgIHBhZFJhZGl1cyA9IHYgPT0gZDNfc3ZnX2FyY0F1dG8gPyBkM19zdmdfYXJjQXV0byA6IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdGFydEFuZ2xlO1xuICAgICAgc3RhcnRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmVuZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZW5kQW5nbGU7XG4gICAgICBlbmRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gcGFkQW5nbGU7XG4gICAgICBwYWRBbmdsZSA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gYXJjO1xuICAgIH07XG4gICAgYXJjLmNlbnRyb2lkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBoYWxmz4A7XG4gICAgICByZXR1cm4gWyBNYXRoLmNvcyhhKSAqIHIsIE1hdGguc2luKGEpICogciBdO1xuICAgIH07XG4gICAgcmV0dXJuIGFyYztcbiAgfTtcbiAgdmFyIGQzX3N2Z19hcmNBdXRvID0gXCJhdXRvXCI7XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNJbm5lclJhZGl1cyhkKSB7XG4gICAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2FyY091dGVyUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5vdXRlclJhZGl1cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjU3RhcnRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQuc3RhcnRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjRW5kQW5nbGUoZCkge1xuICAgIHJldHVybiBkLmVuZEFuZ2xlO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19hcmNQYWRBbmdsZShkKSB7XG4gICAgcmV0dXJuIGQgJiYgZC5wYWRBbmdsZTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjU3dlZXAoeDAsIHkwLCB4MSwgeTEpIHtcbiAgICByZXR1cm4gKHgwIC0geDEpICogeTAgLSAoeTAgLSB5MSkgKiB4MCA+IDAgPyAwIDogMTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJjQ29ybmVyVGFuZ2VudHMocDAsIHAxLCByMSwgcmMsIGN3KSB7XG4gICAgdmFyIHgwMSA9IHAwWzBdIC0gcDFbMF0sIHkwMSA9IHAwWzFdIC0gcDFbMV0sIGxvID0gKGN3ID8gcmMgOiAtcmMpIC8gTWF0aC5zcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksIG94ID0gbG8gKiB5MDEsIG95ID0gLWxvICogeDAxLCB4MSA9IHAwWzBdICsgb3gsIHkxID0gcDBbMV0gKyBveSwgeDIgPSBwMVswXSArIG94LCB5MiA9IHAxWzFdICsgb3ksIHgzID0gKHgxICsgeDIpIC8gMiwgeTMgPSAoeTEgKyB5MikgLyAyLCBkeCA9IHgyIC0geDEsIGR5ID0geTIgLSB5MSwgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSwgciA9IHIxIC0gcmMsIEQgPSB4MSAqIHkyIC0geDIgKiB5MSwgZCA9IChkeSA8IDAgPyAtMSA6IDEpICogTWF0aC5zcXJ0KE1hdGgubWF4KDAsIHIgKiByICogZDIgLSBEICogRCkpLCBjeDAgPSAoRCAqIGR5IC0gZHggKiBkKSAvIGQyLCBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMiwgY3gxID0gKEQgKiBkeSArIGR4ICogZCkgLyBkMiwgY3kxID0gKC1EICogZHggKyBkeSAqIGQpIC8gZDIsIGR4MCA9IGN4MCAtIHgzLCBkeTAgPSBjeTAgLSB5MywgZHgxID0gY3gxIC0geDMsIGR5MSA9IGN5MSAtIHkzO1xuICAgIGlmIChkeDAgKiBkeDAgKyBkeTAgKiBkeTAgPiBkeDEgKiBkeDEgKyBkeTEgKiBkeTEpIGN4MCA9IGN4MSwgY3kwID0gY3kxO1xuICAgIHJldHVybiBbIFsgY3gwIC0gb3gsIGN5MCAtIG95IF0sIFsgY3gwICogcjEgLyByLCBjeTAgKiByMSAvIHIgXSBdO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lKHByb2plY3Rpb24pIHtcbiAgICB2YXIgeCA9IGQzX2dlb21fcG9pbnRYLCB5ID0gZDNfZ2VvbV9wb2ludFksIGRlZmluZWQgPSBkM190cnVlLCBpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lTGluZWFyLCBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlLmtleSwgdGVuc2lvbiA9IC43O1xuICAgIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHBvaW50cyA9IFtdLCBpID0gLTEsIG4gPSBkYXRhLmxlbmd0aCwgZCwgZnggPSBkM19mdW5jdG9yKHgpLCBmeSA9IGQzX2Z1bmN0b3IoeSk7XG4gICAgICBmdW5jdGlvbiBzZWdtZW50KCkge1xuICAgICAgICBzZWdtZW50cy5wdXNoKFwiTVwiLCBpbnRlcnBvbGF0ZShwcm9qZWN0aW9uKHBvaW50cyksIHRlbnNpb24pKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkZWZpbmVkLmNhbGwodGhpcywgZCA9IGRhdGFbaV0sIGkpKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goWyArZnguY2FsbCh0aGlzLCBkLCBpKSwgK2Z5LmNhbGwodGhpcywgZCwgaSkgXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHNlZ21lbnQoKTtcbiAgICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHNlZ21lbnQoKTtcbiAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50cy5qb2luKFwiXCIpIDogbnVsbDtcbiAgICB9XG4gICAgbGluZS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDtcbiAgICAgIHggPSBfO1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5O1xuICAgICAgeSA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIGxpbmUuZGVmaW5lZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRlZmluZWQ7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH07XG4gICAgbGluZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGludGVycG9sYXRlS2V5O1xuICAgICAgaWYgKHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIpIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUgPSBfOyBlbHNlIGludGVycG9sYXRlS2V5ID0gKGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVJbnRlcnBvbGF0b3JzLmdldChfKSB8fCBkM19zdmdfbGluZUxpbmVhcikua2V5O1xuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcbiAgICBsaW5lLnRlbnNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0ZW5zaW9uO1xuICAgICAgdGVuc2lvbiA9IF87XG4gICAgICByZXR1cm4gbGluZTtcbiAgICB9O1xuICAgIHJldHVybiBsaW5lO1xuICB9XG4gIGQzLnN2Zy5saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3N2Z19saW5lKGQzX2lkZW50aXR5KTtcbiAgfTtcbiAgdmFyIGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycyA9IGQzLm1hcCh7XG4gICAgbGluZWFyOiBkM19zdmdfbGluZUxpbmVhcixcbiAgICBcImxpbmVhci1jbG9zZWRcIjogZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQsXG4gICAgc3RlcDogZDNfc3ZnX2xpbmVTdGVwLFxuICAgIFwic3RlcC1iZWZvcmVcIjogZDNfc3ZnX2xpbmVTdGVwQmVmb3JlLFxuICAgIFwic3RlcC1hZnRlclwiOiBkM19zdmdfbGluZVN0ZXBBZnRlcixcbiAgICBiYXNpczogZDNfc3ZnX2xpbmVCYXNpcyxcbiAgICBcImJhc2lzLW9wZW5cIjogZDNfc3ZnX2xpbmVCYXNpc09wZW4sXG4gICAgXCJiYXNpcy1jbG9zZWRcIjogZDNfc3ZnX2xpbmVCYXNpc0Nsb3NlZCxcbiAgICBidW5kbGU6IGQzX3N2Z19saW5lQnVuZGxlLFxuICAgIGNhcmRpbmFsOiBkM19zdmdfbGluZUNhcmRpbmFsLFxuICAgIFwiY2FyZGluYWwtb3BlblwiOiBkM19zdmdfbGluZUNhcmRpbmFsT3BlbixcbiAgICBcImNhcmRpbmFsLWNsb3NlZFwiOiBkM19zdmdfbGluZUNhcmRpbmFsQ2xvc2VkLFxuICAgIG1vbm90b25lOiBkM19zdmdfbGluZU1vbm90b25lXG4gIH0pO1xuICBkM19zdmdfbGluZUludGVycG9sYXRvcnMuZm9yRWFjaChmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFsdWUua2V5ID0ga2V5O1xuICAgIHZhbHVlLmNsb3NlZCA9IC8tY2xvc2VkJC8udGVzdChrZXkpO1xuICB9KTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPiAxID8gcG9pbnRzLmpvaW4oXCJMXCIpIDogcG9pbnRzICsgXCJaXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVMaW5lYXJDbG9zZWQocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5qb2luKFwiTFwiKSArIFwiWlwiO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcChwb2ludHMpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBwb2ludHMubGVuZ3RoLCBwID0gcG9pbnRzWzBdLCBwYXRoID0gWyBwWzBdLCBcIixcIiwgcFsxXSBdO1xuICAgIHdoaWxlICgrK2kgPCBuKSBwYXRoLnB1c2goXCJIXCIsIChwWzBdICsgKHAgPSBwb2ludHNbaV0pWzBdKSAvIDIsIFwiVlwiLCBwWzFdKTtcbiAgICBpZiAobiA+IDEpIHBhdGgucHVzaChcIkhcIiwgcFswXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZVN0ZXBCZWZvcmUocG9pbnRzKSB7XG4gICAgdmFyIGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aCwgcCA9IHBvaW50c1swXSwgcGF0aCA9IFsgcFswXSwgXCIsXCIsIHBbMV0gXTtcbiAgICB3aGlsZSAoKytpIDwgbikgcGF0aC5wdXNoKFwiVlwiLCAocCA9IHBvaW50c1tpXSlbMV0sIFwiSFwiLCBwWzBdKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU3RlcEFmdGVyKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgbiA9IHBvaW50cy5sZW5ndGgsIHAgPSBwb2ludHNbMF0sIHBhdGggPSBbIHBbMF0sIFwiLFwiLCBwWzFdIF07XG4gICAgd2hpbGUgKCsraSA8IG4pIHBhdGgucHVzaChcIkhcIiwgKHAgPSBwb2ludHNbaV0pWzBdLCBcIlZcIiwgcFsxXSk7XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsT3Blbihwb2ludHMsIHRlbnNpb24pIHtcbiAgICByZXR1cm4gcG9pbnRzLmxlbmd0aCA8IDQgPyBkM19zdmdfbGluZUxpbmVhcihwb2ludHMpIDogcG9pbnRzWzFdICsgZDNfc3ZnX2xpbmVIZXJtaXRlKHBvaW50cy5zbGljZSgxLCAtMSksIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsQ2xvc2VkKHBvaW50cywgdGVuc2lvbikge1xuICAgIHJldHVybiBwb2ludHMubGVuZ3RoIDwgMyA/IGQzX3N2Z19saW5lTGluZWFyQ2xvc2VkKHBvaW50cykgOiBwb2ludHNbMF0gKyBkM19zdmdfbGluZUhlcm1pdGUoKHBvaW50cy5wdXNoKHBvaW50c1swXSksIFxuICAgIHBvaW50cyksIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhbIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gXS5jb25jYXQocG9pbnRzLCBbIHBvaW50c1sxXSBdKSwgdGVuc2lvbikpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQ2FyZGluYWwocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIGQzX3N2Z19saW5lQ2FyZGluYWxUYW5nZW50cyhwb2ludHMsIHRlbnNpb24pKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUhlcm1pdGUocG9pbnRzLCB0YW5nZW50cykge1xuICAgIGlmICh0YW5nZW50cy5sZW5ndGggPCAxIHx8IHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoICYmIHBvaW50cy5sZW5ndGggIT0gdGFuZ2VudHMubGVuZ3RoICsgMikge1xuICAgICAgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgfVxuICAgIHZhciBxdWFkID0gcG9pbnRzLmxlbmd0aCAhPSB0YW5nZW50cy5sZW5ndGgsIHBhdGggPSBcIlwiLCBwMCA9IHBvaW50c1swXSwgcCA9IHBvaW50c1sxXSwgdDAgPSB0YW5nZW50c1swXSwgdCA9IHQwLCBwaSA9IDE7XG4gICAgaWYgKHF1YWQpIHtcbiAgICAgIHBhdGggKz0gXCJRXCIgKyAocFswXSAtIHQwWzBdICogMiAvIDMpICsgXCIsXCIgKyAocFsxXSAtIHQwWzFdICogMiAvIDMpICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgcDAgPSBwb2ludHNbMV07XG4gICAgICBwaSA9IDI7XG4gICAgfVxuICAgIGlmICh0YW5nZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICB0ID0gdGFuZ2VudHNbMV07XG4gICAgICBwID0gcG9pbnRzW3BpXTtcbiAgICAgIHBpKys7XG4gICAgICBwYXRoICs9IFwiQ1wiICsgKHAwWzBdICsgdDBbMF0pICsgXCIsXCIgKyAocDBbMV0gKyB0MFsxXSkgKyBcIixcIiArIChwWzBdIC0gdFswXSkgKyBcIixcIiArIChwWzFdIC0gdFsxXSkgKyBcIixcIiArIHBbMF0gKyBcIixcIiArIHBbMV07XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRhbmdlbnRzLmxlbmd0aDsgaSsrLCBwaSsrKSB7XG4gICAgICAgIHAgPSBwb2ludHNbcGldO1xuICAgICAgICB0ID0gdGFuZ2VudHNbaV07XG4gICAgICAgIHBhdGggKz0gXCJTXCIgKyAocFswXSAtIHRbMF0pICsgXCIsXCIgKyAocFsxXSAtIHRbMV0pICsgXCIsXCIgKyBwWzBdICsgXCIsXCIgKyBwWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocXVhZCkge1xuICAgICAgdmFyIGxwID0gcG9pbnRzW3BpXTtcbiAgICAgIHBhdGggKz0gXCJRXCIgKyAocFswXSArIHRbMF0gKiAyIC8gMykgKyBcIixcIiArIChwWzFdICsgdFsxXSAqIDIgLyAzKSArIFwiLFwiICsgbHBbMF0gKyBcIixcIiArIGxwWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUNhcmRpbmFsVGFuZ2VudHMocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgdmFyIHRhbmdlbnRzID0gW10sIGEgPSAoMSAtIHRlbnNpb24pIC8gMiwgcDAsIHAxID0gcG9pbnRzWzBdLCBwMiA9IHBvaW50c1sxXSwgaSA9IDEsIG4gPSBwb2ludHMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwMCA9IHAxO1xuICAgICAgcDEgPSBwMjtcbiAgICAgIHAyID0gcG9pbnRzW2ldO1xuICAgICAgdGFuZ2VudHMucHVzaChbIGEgKiAocDJbMF0gLSBwMFswXSksIGEgKiAocDJbMV0gLSBwMFsxXSkgXSk7XG4gICAgfVxuICAgIHJldHVybiB0YW5nZW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzKHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgdmFyIGkgPSAxLCBuID0gcG9pbnRzLmxlbmd0aCwgcGkgPSBwb2ludHNbMF0sIHgwID0gcGlbMF0sIHkwID0gcGlbMV0sIHB4ID0gWyB4MCwgeDAsIHgwLCAocGkgPSBwb2ludHNbMV0pWzBdIF0sIHB5ID0gWyB5MCwgeTAsIHkwLCBwaVsxXSBdLCBwYXRoID0gWyB4MCwgXCIsXCIsIHkwLCBcIkxcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCBweCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSBdO1xuICAgIHBvaW50cy5wdXNoKHBvaW50c1tuIC0gMV0pO1xuICAgIHdoaWxlICgrK2kgPD0gbikge1xuICAgICAgcGkgPSBwb2ludHNbaV07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHBvaW50cy5wb3AoKTtcbiAgICBwYXRoLnB1c2goXCJMXCIsIHBpKTtcbiAgICByZXR1cm4gcGF0aC5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lQmFzaXNPcGVuKHBvaW50cykge1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgNCkgcmV0dXJuIGQzX3N2Z19saW5lTGluZWFyKHBvaW50cyk7XG4gICAgdmFyIHBhdGggPSBbXSwgaSA9IC0xLCBuID0gcG9pbnRzLmxlbmd0aCwgcGksIHB4ID0gWyAwIF0sIHB5ID0gWyAwIF07XG4gICAgd2hpbGUgKCsraSA8IDMpIHtcbiAgICAgIHBpID0gcG9pbnRzW2ldO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICB9XG4gICAgcGF0aC5wdXNoKGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHgpICsgXCIsXCIgKyBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB5KSk7XG4gICAgLS1pO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwaSA9IHBvaW50c1tpXTtcbiAgICAgIHB4LnNoaWZ0KCk7XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnNoaWZ0KCk7XG4gICAgICBweS5wdXNoKHBpWzFdKTtcbiAgICAgIGQzX3N2Z19saW5lQmFzaXNCZXppZXIocGF0aCwgcHgsIHB5KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGguam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUJhc2lzQ2xvc2VkKHBvaW50cykge1xuICAgIHZhciBwYXRoLCBpID0gLTEsIG4gPSBwb2ludHMubGVuZ3RoLCBtID0gbiArIDQsIHBpLCBweCA9IFtdLCBweSA9IFtdO1xuICAgIHdoaWxlICgrK2kgPCA0KSB7XG4gICAgICBwaSA9IHBvaW50c1tpICUgbl07XG4gICAgICBweC5wdXNoKHBpWzBdKTtcbiAgICAgIHB5LnB1c2gocGlbMV0pO1xuICAgIH1cbiAgICBwYXRoID0gWyBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMsIHB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgcHkpIF07XG4gICAgLS1pO1xuICAgIHdoaWxlICgrK2kgPCBtKSB7XG4gICAgICBwaSA9IHBvaW50c1tpICUgbl07XG4gICAgICBweC5zaGlmdCgpO1xuICAgICAgcHgucHVzaChwaVswXSk7XG4gICAgICBweS5zaGlmdCgpO1xuICAgICAgcHkucHVzaChwaVsxXSk7XG4gICAgICBkM19zdmdfbGluZUJhc2lzQmV6aWVyKHBhdGgsIHB4LCBweSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCdW5kbGUocG9pbnRzLCB0ZW5zaW9uKSB7XG4gICAgdmFyIG4gPSBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobikge1xuICAgICAgdmFyIHgwID0gcG9pbnRzWzBdWzBdLCB5MCA9IHBvaW50c1swXVsxXSwgZHggPSBwb2ludHNbbl1bMF0gLSB4MCwgZHkgPSBwb2ludHNbbl1bMV0gLSB5MCwgaSA9IC0xLCBwLCB0O1xuICAgICAgd2hpbGUgKCsraSA8PSBuKSB7XG4gICAgICAgIHAgPSBwb2ludHNbaV07XG4gICAgICAgIHQgPSBpIC8gbjtcbiAgICAgICAgcFswXSA9IHRlbnNpb24gKiBwWzBdICsgKDEgLSB0ZW5zaW9uKSAqICh4MCArIHQgKiBkeCk7XG4gICAgICAgIHBbMV0gPSB0ZW5zaW9uICogcFsxXSArICgxIC0gdGVuc2lvbikgKiAoeTAgKyB0ICogZHkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfc3ZnX2xpbmVCYXNpcyhwb2ludHMpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lRG90NChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xuICB9XG4gIHZhciBkM19zdmdfbGluZUJhc2lzQmV6aWVyMSA9IFsgMCwgMiAvIDMsIDEgLyAzLCAwIF0sIGQzX3N2Z19saW5lQmFzaXNCZXppZXIyID0gWyAwLCAxIC8gMywgMiAvIDMsIDAgXSwgZDNfc3ZnX2xpbmVCYXNpc0JlemllcjMgPSBbIDAsIDEgLyA2LCAyIC8gMywgMSAvIDYgXTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2xpbmVCYXNpc0JlemllcihwYXRoLCB4LCB5KSB7XG4gICAgcGF0aC5wdXNoKFwiQ1wiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjEsIHgpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIxLCB5KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMiwgeCksIFwiLFwiLCBkM19zdmdfbGluZURvdDQoZDNfc3ZnX2xpbmVCYXNpc0JlemllcjIsIHkpLCBcIixcIiwgZDNfc3ZnX2xpbmVEb3Q0KGQzX3N2Z19saW5lQmFzaXNCZXppZXIzLCB4KSwgXCIsXCIsIGQzX3N2Z19saW5lRG90NChkM19zdmdfbGluZUJhc2lzQmV6aWVyMywgeSkpO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lU2xvcGUocDAsIHAxKSB7XG4gICAgcmV0dXJuIChwMVsxXSAtIHAwWzFdKSAvIChwMVswXSAtIHAwWzBdKTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZUZpbml0ZURpZmZlcmVuY2VzKHBvaW50cykge1xuICAgIHZhciBpID0gMCwgaiA9IHBvaW50cy5sZW5ndGggLSAxLCBtID0gW10sIHAwID0gcG9pbnRzWzBdLCBwMSA9IHBvaW50c1sxXSwgZCA9IG1bMF0gPSBkM19zdmdfbGluZVNsb3BlKHAwLCBwMSk7XG4gICAgd2hpbGUgKCsraSA8IGopIHtcbiAgICAgIG1baV0gPSAoZCArIChkID0gZDNfc3ZnX2xpbmVTbG9wZShwMCA9IHAxLCBwMSA9IHBvaW50c1tpICsgMV0pKSkgLyAyO1xuICAgIH1cbiAgICBtW2ldID0gZDtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfbGluZU1vbm90b25lVGFuZ2VudHMocG9pbnRzKSB7XG4gICAgdmFyIHRhbmdlbnRzID0gW10sIGQsIGEsIGIsIHMsIG0gPSBkM19zdmdfbGluZUZpbml0ZURpZmZlcmVuY2VzKHBvaW50cyksIGkgPSAtMSwgaiA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIHdoaWxlICgrK2kgPCBqKSB7XG4gICAgICBkID0gZDNfc3ZnX2xpbmVTbG9wZShwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgaWYgKGFicyhkKSA8IM61KSB7XG4gICAgICAgIG1baV0gPSBtW2kgKyAxXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gbVtpXSAvIGQ7XG4gICAgICAgIGIgPSBtW2kgKyAxXSAvIGQ7XG4gICAgICAgIHMgPSBhICogYSArIGIgKiBiO1xuICAgICAgICBpZiAocyA+IDkpIHtcbiAgICAgICAgICBzID0gZCAqIDMgLyBNYXRoLnNxcnQocyk7XG4gICAgICAgICAgbVtpXSA9IHMgKiBhO1xuICAgICAgICAgIG1baSArIDFdID0gcyAqIGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IC0xO1xuICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgcyA9IChwb2ludHNbTWF0aC5taW4oaiwgaSArIDEpXVswXSAtIHBvaW50c1tNYXRoLm1heCgwLCBpIC0gMSldWzBdKSAvICg2ICogKDEgKyBtW2ldICogbVtpXSkpO1xuICAgICAgdGFuZ2VudHMucHVzaChbIHMgfHwgMCwgbVtpXSAqIHMgfHwgMCBdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhbmdlbnRzO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19saW5lTW9ub3RvbmUocG9pbnRzKSB7XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPCAzID8gZDNfc3ZnX2xpbmVMaW5lYXIocG9pbnRzKSA6IHBvaW50c1swXSArIGQzX3N2Z19saW5lSGVybWl0ZShwb2ludHMsIGQzX3N2Z19saW5lTW9ub3RvbmVUYW5nZW50cyhwb2ludHMpKTtcbiAgfVxuICBkMy5zdmcubGluZS5yYWRpYWwgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGluZSA9IGQzX3N2Z19saW5lKGQzX3N2Z19saW5lUmFkaWFsKTtcbiAgICBsaW5lLnJhZGl1cyA9IGxpbmUueCwgZGVsZXRlIGxpbmUueDtcbiAgICBsaW5lLmFuZ2xlID0gbGluZS55LCBkZWxldGUgbGluZS55O1xuICAgIHJldHVybiBsaW5lO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfbGluZVJhZGlhbChwb2ludHMpIHtcbiAgICB2YXIgcG9pbnQsIGkgPSAtMSwgbiA9IHBvaW50cy5sZW5ndGgsIHIsIGE7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgciA9IHBvaW50WzBdO1xuICAgICAgYSA9IHBvaW50WzFdIC0gaGFsZs+AO1xuICAgICAgcG9pbnRbMF0gPSByICogTWF0aC5jb3MoYSk7XG4gICAgICBwb2ludFsxXSA9IHIgKiBNYXRoLnNpbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICBmdW5jdGlvbiBkM19zdmdfYXJlYShwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHgwID0gZDNfZ2VvbV9wb2ludFgsIHgxID0gZDNfZ2VvbV9wb2ludFgsIHkwID0gMCwgeTEgPSBkM19nZW9tX3BvaW50WSwgZGVmaW5lZCA9IGQzX3RydWUsIGludGVycG9sYXRlID0gZDNfc3ZnX2xpbmVMaW5lYXIsIGludGVycG9sYXRlS2V5ID0gaW50ZXJwb2xhdGUua2V5LCBpbnRlcnBvbGF0ZVJldmVyc2UgPSBpbnRlcnBvbGF0ZSwgTCA9IFwiTFwiLCB0ZW5zaW9uID0gLjc7XG4gICAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgICB2YXIgc2VnbWVudHMgPSBbXSwgcG9pbnRzMCA9IFtdLCBwb2ludHMxID0gW10sIGkgPSAtMSwgbiA9IGRhdGEubGVuZ3RoLCBkLCBmeDAgPSBkM19mdW5jdG9yKHgwKSwgZnkwID0gZDNfZnVuY3Rvcih5MCksIGZ4MSA9IHgwID09PSB4MSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH0gOiBkM19mdW5jdG9yKHgxKSwgZnkxID0geTAgPT09IHkxID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfSA6IGQzX2Z1bmN0b3IoeTEpLCB4LCB5O1xuICAgICAgZnVuY3Rpb24gc2VnbWVudCgpIHtcbiAgICAgICAgc2VnbWVudHMucHVzaChcIk1cIiwgaW50ZXJwb2xhdGUocHJvamVjdGlvbihwb2ludHMxKSwgdGVuc2lvbiksIEwsIGludGVycG9sYXRlUmV2ZXJzZShwcm9qZWN0aW9uKHBvaW50czAucmV2ZXJzZSgpKSwgdGVuc2lvbiksIFwiWlwiKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChkZWZpbmVkLmNhbGwodGhpcywgZCA9IGRhdGFbaV0sIGkpKSB7XG4gICAgICAgICAgcG9pbnRzMC5wdXNoKFsgeCA9ICtmeDAuY2FsbCh0aGlzLCBkLCBpKSwgeSA9ICtmeTAuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgICBwb2ludHMxLnB1c2goWyArZngxLmNhbGwodGhpcywgZCwgaSksICtmeTEuY2FsbCh0aGlzLCBkLCBpKSBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludHMwLmxlbmd0aCkge1xuICAgICAgICAgIHNlZ21lbnQoKTtcbiAgICAgICAgICBwb2ludHMwID0gW107XG4gICAgICAgICAgcG9pbnRzMSA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9pbnRzMC5sZW5ndGgpIHNlZ21lbnQoKTtcbiAgICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50cy5qb2luKFwiXCIpIDogbnVsbDtcbiAgICB9XG4gICAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MCA9IHgxID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS54MCA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHgwO1xuICAgICAgeDAgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLngxID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4geDE7XG4gICAgICB4MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTAgPSB5MSA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB5MDtcbiAgICAgIHkwID0gXztcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS55MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHkxO1xuICAgICAgeTEgPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICBhcmVhLmRlZmluZWQgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkZWZpbmVkO1xuICAgICAgZGVmaW5lZCA9IF87XG4gICAgICByZXR1cm4gYXJlYTtcbiAgICB9O1xuICAgIGFyZWEuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbnRlcnBvbGF0ZUtleTtcbiAgICAgIGlmICh0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiKSBpbnRlcnBvbGF0ZUtleSA9IGludGVycG9sYXRlID0gXzsgZWxzZSBpbnRlcnBvbGF0ZUtleSA9IChpbnRlcnBvbGF0ZSA9IGQzX3N2Z19saW5lSW50ZXJwb2xhdG9ycy5nZXQoXykgfHwgZDNfc3ZnX2xpbmVMaW5lYXIpLmtleTtcbiAgICAgIGludGVycG9sYXRlUmV2ZXJzZSA9IGludGVycG9sYXRlLnJldmVyc2UgfHwgaW50ZXJwb2xhdGU7XG4gICAgICBMID0gaW50ZXJwb2xhdGUuY2xvc2VkID8gXCJNXCIgOiBcIkxcIjtcbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH07XG4gICAgYXJlYS50ZW5zaW9uID0gZnVuY3Rpb24oXykge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGVuc2lvbjtcbiAgICAgIHRlbnNpb24gPSBfO1xuICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfTtcbiAgICByZXR1cm4gYXJlYTtcbiAgfVxuICBkM19zdmdfbGluZVN0ZXBCZWZvcmUucmV2ZXJzZSA9IGQzX3N2Z19saW5lU3RlcEFmdGVyO1xuICBkM19zdmdfbGluZVN0ZXBBZnRlci5yZXZlcnNlID0gZDNfc3ZnX2xpbmVTdGVwQmVmb3JlO1xuICBkMy5zdmcuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkM19zdmdfYXJlYShkM19pZGVudGl0eSk7XG4gIH07XG4gIGQzLnN2Zy5hcmVhLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmVhID0gZDNfc3ZnX2FyZWEoZDNfc3ZnX2xpbmVSYWRpYWwpO1xuICAgIGFyZWEucmFkaXVzID0gYXJlYS54LCBkZWxldGUgYXJlYS54O1xuICAgIGFyZWEuaW5uZXJSYWRpdXMgPSBhcmVhLngwLCBkZWxldGUgYXJlYS54MDtcbiAgICBhcmVhLm91dGVyUmFkaXVzID0gYXJlYS54MSwgZGVsZXRlIGFyZWEueDE7XG4gICAgYXJlYS5hbmdsZSA9IGFyZWEueSwgZGVsZXRlIGFyZWEueTtcbiAgICBhcmVhLnN0YXJ0QW5nbGUgPSBhcmVhLnkwLCBkZWxldGUgYXJlYS55MDtcbiAgICBhcmVhLmVuZEFuZ2xlID0gYXJlYS55MSwgZGVsZXRlIGFyZWEueTE7XG4gICAgcmV0dXJuIGFyZWE7XG4gIH07XG4gIGQzLnN2Zy5jaG9yZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzb3VyY2UgPSBkM19zb3VyY2UsIHRhcmdldCA9IGQzX3RhcmdldCwgcmFkaXVzID0gZDNfc3ZnX2Nob3JkUmFkaXVzLCBzdGFydEFuZ2xlID0gZDNfc3ZnX2FyY1N0YXJ0QW5nbGUsIGVuZEFuZ2xlID0gZDNfc3ZnX2FyY0VuZEFuZ2xlO1xuICAgIGZ1bmN0aW9uIGNob3JkKGQsIGkpIHtcbiAgICAgIHZhciBzID0gc3ViZ3JvdXAodGhpcywgc291cmNlLCBkLCBpKSwgdCA9IHN1Ymdyb3VwKHRoaXMsIHRhcmdldCwgZCwgaSk7XG4gICAgICByZXR1cm4gXCJNXCIgKyBzLnAwICsgYXJjKHMuciwgcy5wMSwgcy5hMSAtIHMuYTApICsgKGVxdWFscyhzLCB0KSA/IGN1cnZlKHMuciwgcy5wMSwgcy5yLCBzLnAwKSA6IGN1cnZlKHMuciwgcy5wMSwgdC5yLCB0LnAwKSArIGFyYyh0LnIsIHQucDEsIHQuYTEgLSB0LmEwKSArIGN1cnZlKHQuciwgdC5wMSwgcy5yLCBzLnAwKSkgKyBcIlpcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3ViZ3JvdXAoc2VsZiwgZiwgZCwgaSkge1xuICAgICAgdmFyIHN1Ymdyb3VwID0gZi5jYWxsKHNlbGYsIGQsIGkpLCByID0gcmFkaXVzLmNhbGwoc2VsZiwgc3ViZ3JvdXAsIGkpLCBhMCA9IHN0YXJ0QW5nbGUuY2FsbChzZWxmLCBzdWJncm91cCwgaSkgLSBoYWxmz4AsIGExID0gZW5kQW5nbGUuY2FsbChzZWxmLCBzdWJncm91cCwgaSkgLSBoYWxmz4A7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiByLFxuICAgICAgICBhMDogYTAsXG4gICAgICAgIGExOiBhMSxcbiAgICAgICAgcDA6IFsgciAqIE1hdGguY29zKGEwKSwgciAqIE1hdGguc2luKGEwKSBdLFxuICAgICAgICBwMTogWyByICogTWF0aC5jb3MoYTEpLCByICogTWF0aC5zaW4oYTEpIF1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gICAgICByZXR1cm4gYS5hMCA9PSBiLmEwICYmIGEuYTEgPT0gYi5hMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJjKHIsIHAsIGEpIHtcbiAgICAgIHJldHVybiBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIFwiICsgKyhhID4gz4ApICsgXCIsMSBcIiArIHA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGN1cnZlKHIwLCBwMCwgcjEsIHAxKSB7XG4gICAgICByZXR1cm4gXCJRIDAsMCBcIiArIHAxO1xuICAgIH1cbiAgICBjaG9yZC5yYWRpdXMgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiByYWRpdXM7XG4gICAgICByYWRpdXMgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuc291cmNlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc291cmNlO1xuICAgICAgc291cmNlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIGNob3JkLnRhcmdldCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRhcmdldDtcbiAgICAgIHRhcmdldCA9IGQzX2Z1bmN0b3Iodik7XG4gICAgICByZXR1cm4gY2hvcmQ7XG4gICAgfTtcbiAgICBjaG9yZC5zdGFydEFuZ2xlID0gZnVuY3Rpb24odikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSBkM19mdW5jdG9yKHYpO1xuICAgICAgcmV0dXJuIGNob3JkO1xuICAgIH07XG4gICAgY2hvcmQuZW5kQW5nbGUgPSBmdW5jdGlvbih2KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gZDNfZnVuY3Rvcih2KTtcbiAgICAgIHJldHVybiBjaG9yZDtcbiAgICB9O1xuICAgIHJldHVybiBjaG9yZDtcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2Nob3JkUmFkaXVzKGQpIHtcbiAgICByZXR1cm4gZC5yYWRpdXM7XG4gIH1cbiAgZDMuc3ZnLmRpYWdvbmFsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IGQzX3NvdXJjZSwgdGFyZ2V0ID0gZDNfdGFyZ2V0LCBwcm9qZWN0aW9uID0gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbjtcbiAgICBmdW5jdGlvbiBkaWFnb25hbChkLCBpKSB7XG4gICAgICB2YXIgcDAgPSBzb3VyY2UuY2FsbCh0aGlzLCBkLCBpKSwgcDMgPSB0YXJnZXQuY2FsbCh0aGlzLCBkLCBpKSwgbSA9IChwMC55ICsgcDMueSkgLyAyLCBwID0gWyBwMCwge1xuICAgICAgICB4OiBwMC54LFxuICAgICAgICB5OiBtXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHAzLngsXG4gICAgICAgIHk6IG1cbiAgICAgIH0sIHAzIF07XG4gICAgICBwID0gcC5tYXAocHJvamVjdGlvbik7XG4gICAgICByZXR1cm4gXCJNXCIgKyBwWzBdICsgXCJDXCIgKyBwWzFdICsgXCIgXCIgKyBwWzJdICsgXCIgXCIgKyBwWzNdO1xuICAgIH1cbiAgICBkaWFnb25hbC5zb3VyY2UgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzb3VyY2U7XG4gICAgICBzb3VyY2UgPSBkM19mdW5jdG9yKHgpO1xuICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgIH07XG4gICAgZGlhZ29uYWwudGFyZ2V0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGFyZ2V0O1xuICAgICAgdGFyZ2V0ID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBkaWFnb25hbDtcbiAgICB9O1xuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBwcm9qZWN0aW9uO1xuICAgICAgcHJvamVjdGlvbiA9IHg7XG4gICAgICByZXR1cm4gZGlhZ29uYWw7XG4gICAgfTtcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19kaWFnb25hbFByb2plY3Rpb24oZCkge1xuICAgIHJldHVybiBbIGQueCwgZC55IF07XG4gIH1cbiAgZDMuc3ZnLmRpYWdvbmFsLnJhZGlhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaWFnb25hbCA9IGQzLnN2Zy5kaWFnb25hbCgpLCBwcm9qZWN0aW9uID0gZDNfc3ZnX2RpYWdvbmFsUHJvamVjdGlvbiwgcHJvamVjdGlvbl8gPSBkaWFnb25hbC5wcm9qZWN0aW9uO1xuICAgIGRpYWdvbmFsLnByb2plY3Rpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHByb2plY3Rpb25fKGQzX3N2Z19kaWFnb25hbFJhZGlhbFByb2plY3Rpb24ocHJvamVjdGlvbiA9IHgpKSA6IHByb2plY3Rpb247XG4gICAgfTtcbiAgICByZXR1cm4gZGlhZ29uYWw7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3N2Z19kaWFnb25hbFJhZGlhbFByb2plY3Rpb24ocHJvamVjdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkID0gcHJvamVjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCByID0gZFswXSwgYSA9IGRbMV0gLSBoYWxmz4A7XG4gICAgICByZXR1cm4gWyByICogTWF0aC5jb3MoYSksIHIgKiBNYXRoLnNpbihhKSBdO1xuICAgIH07XG4gIH1cbiAgZDMuc3ZnLnN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlID0gZDNfc3ZnX3N5bWJvbFR5cGUsIHNpemUgPSBkM19zdmdfc3ltYm9sU2l6ZTtcbiAgICBmdW5jdGlvbiBzeW1ib2woZCwgaSkge1xuICAgICAgcmV0dXJuIChkM19zdmdfc3ltYm9scy5nZXQodHlwZS5jYWxsKHRoaXMsIGQsIGkpKSB8fCBkM19zdmdfc3ltYm9sQ2lyY2xlKShzaXplLmNhbGwodGhpcywgZCwgaSkpO1xuICAgIH1cbiAgICBzeW1ib2wudHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHR5cGU7XG4gICAgICB0eXBlID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNpemU7XG4gICAgICBzaXplID0gZDNfZnVuY3Rvcih4KTtcbiAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgfTtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9O1xuICBmdW5jdGlvbiBkM19zdmdfc3ltYm9sU2l6ZSgpIHtcbiAgICByZXR1cm4gNjQ7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiY2lyY2xlXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfc3ZnX3N5bWJvbENpcmNsZShzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIM+AKTtcbiAgICByZXR1cm4gXCJNMCxcIiArIHIgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMSAwLFwiICsgLXIgKyBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiAwIDEsMSAwLFwiICsgciArIFwiWlwiO1xuICB9XG4gIHZhciBkM19zdmdfc3ltYm9scyA9IGQzLm1hcCh7XG4gICAgY2lyY2xlOiBkM19zdmdfc3ltYm9sQ2lyY2xlLFxuICAgIGNyb3NzOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgcmV0dXJuIFwiTVwiICsgLTMgKiByICsgXCIsXCIgKyAtciArIFwiSFwiICsgLXIgKyBcIlZcIiArIC0zICogciArIFwiSFwiICsgciArIFwiVlwiICsgLXIgKyBcIkhcIiArIDMgKiByICsgXCJWXCIgKyByICsgXCJIXCIgKyByICsgXCJWXCIgKyAzICogciArIFwiSFwiICsgLXIgKyBcIlZcIiArIHIgKyBcIkhcIiArIC0zICogciArIFwiWlwiO1xuICAgIH0sXG4gICAgZGlhbW9uZDogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIGQzX3N2Z19zeW1ib2xUYW4zMCkpLCByeCA9IHJ5ICogZDNfc3ZnX3N5bWJvbFRhbjMwO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyAtcnkgKyBcIkxcIiArIHJ4ICsgXCIsMFwiICsgXCIgMCxcIiArIHJ5ICsgXCIgXCIgKyAtcnggKyBcIiwwXCIgKyBcIlpcIjtcbiAgICB9LFxuICAgIHNxdWFyZTogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgcmV0dXJuIFwiTVwiICsgLXIgKyBcIixcIiArIC1yICsgXCJMXCIgKyByICsgXCIsXCIgKyAtciArIFwiIFwiICsgciArIFwiLFwiICsgciArIFwiIFwiICsgLXIgKyBcIixcIiArIHIgKyBcIlpcIjtcbiAgICB9LFxuICAgIFwidHJpYW5nbGUtZG93blwiOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICB2YXIgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIGQzX3N2Z19zeW1ib2xTcXJ0MyksIHJ5ID0gcnggKiBkM19zdmdfc3ltYm9sU3FydDMgLyAyO1xuICAgICAgcmV0dXJuIFwiTTAsXCIgKyByeSArIFwiTFwiICsgcnggKyBcIixcIiArIC1yeSArIFwiIFwiICsgLXJ4ICsgXCIsXCIgKyAtcnkgKyBcIlpcIjtcbiAgICB9LFxuICAgIFwidHJpYW5nbGUtdXBcIjogZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBkM19zdmdfc3ltYm9sU3FydDMpLCByeSA9IHJ4ICogZDNfc3ZnX3N5bWJvbFNxcnQzIC8gMjtcbiAgICAgIHJldHVybiBcIk0wLFwiICsgLXJ5ICsgXCJMXCIgKyByeCArIFwiLFwiICsgcnkgKyBcIiBcIiArIC1yeCArIFwiLFwiICsgcnkgKyBcIlpcIjtcbiAgICB9XG4gIH0pO1xuICBkMy5zdmcuc3ltYm9sVHlwZXMgPSBkM19zdmdfc3ltYm9scy5rZXlzKCk7XG4gIHZhciBkM19zdmdfc3ltYm9sU3FydDMgPSBNYXRoLnNxcnQoMyksIGQzX3N2Z19zeW1ib2xUYW4zMCA9IE1hdGgudGFuKDMwICogZDNfcmFkaWFucyk7XG4gIGQzX3NlbGVjdGlvblByb3RvdHlwZS50cmFuc2l0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpZCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgfHwgKytkM190cmFuc2l0aW9uSWQsIG5zID0gZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBub2RlLCB0cmFuc2l0aW9uID0gZDNfdHJhbnNpdGlvbkluaGVyaXQgfHwge1xuICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgIGVhc2U6IGQzX2Vhc2VfY3ViaWNJbk91dCxcbiAgICAgIGRlbGF5OiAwLFxuICAgICAgZHVyYXRpb246IDI1MFxuICAgIH07XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAtMSwgbiA9IGdyb3VwLmxlbmd0aDsgKytpIDwgbjsgKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGQzX3RyYW5zaXRpb25Ob2RlKG5vZGUsIGksIG5zLCBpZCwgdHJhbnNpdGlvbik7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkKTtcbiAgfTtcbiAgZDNfc2VsZWN0aW9uUHJvdG90eXBlLmludGVycnVwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKG5hbWUgPT0gbnVsbCA/IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHQgOiBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMoZDNfdHJhbnNpdGlvbk5hbWVzcGFjZShuYW1lKSkpO1xuICB9O1xuICB2YXIgZDNfc2VsZWN0aW9uX2ludGVycnVwdCA9IGQzX3NlbGVjdGlvbl9pbnRlcnJ1cHROUyhkM190cmFuc2l0aW9uTmFtZXNwYWNlKCkpO1xuICBmdW5jdGlvbiBkM19zZWxlY3Rpb25faW50ZXJydXB0TlMobnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbG9jaywgYWN0aXZlSWQsIGFjdGl2ZTtcbiAgICAgIGlmICgobG9jayA9IHRoaXNbbnNdKSAmJiAoYWN0aXZlID0gbG9ja1thY3RpdmVJZCA9IGxvY2suYWN0aXZlXSkpIHtcbiAgICAgICAgYWN0aXZlLnRpbWVyLmMgPSBudWxsO1xuICAgICAgICBhY3RpdmUudGltZXIudCA9IE5hTjtcbiAgICAgICAgaWYgKC0tbG9jay5jb3VudCkgZGVsZXRlIGxvY2tbYWN0aXZlSWRdOyBlbHNlIGRlbGV0ZSB0aGlzW25zXTtcbiAgICAgICAgbG9jay5hY3RpdmUgKz0gLjU7XG4gICAgICAgIGFjdGl2ZS5ldmVudCAmJiBhY3RpdmUuZXZlbnQuaW50ZXJydXB0LmNhbGwodGhpcywgdGhpcy5fX2RhdGFfXywgYWN0aXZlLmluZGV4KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb24oZ3JvdXBzLCBucywgaWQpIHtcbiAgICBkM19zdWJjbGFzcyhncm91cHMsIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUpO1xuICAgIGdyb3Vwcy5uYW1lc3BhY2UgPSBucztcbiAgICBncm91cHMuaWQgPSBpZDtcbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG4gIHZhciBkM190cmFuc2l0aW9uUHJvdG90eXBlID0gW10sIGQzX3RyYW5zaXRpb25JZCA9IDAsIGQzX3RyYW5zaXRpb25Jbmhlcml0SWQsIGQzX3RyYW5zaXRpb25Jbmhlcml0O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmNhbGwgPSBkM19zZWxlY3Rpb25Qcm90b3R5cGUuY2FsbDtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5lbXB0eSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5lbXB0eTtcbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5ub2RlID0gZDNfc2VsZWN0aW9uUHJvdG90eXBlLm5vZGU7XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc2l6ZSA9IGQzX3NlbGVjdGlvblByb3RvdHlwZS5zaXplO1xuICBkMy50cmFuc2l0aW9uID0gZnVuY3Rpb24oc2VsZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24udHJhbnNpdGlvbiA/IGQzX3RyYW5zaXRpb25Jbmhlcml0SWQgPyBzZWxlY3Rpb24udHJhbnNpdGlvbihuYW1lKSA6IHNlbGVjdGlvbiA6IGQzLnNlbGVjdGlvbigpLnRyYW5zaXRpb24oc2VsZWN0aW9uKTtcbiAgfTtcbiAgZDMudHJhbnNpdGlvbi5wcm90b3R5cGUgPSBkM190cmFuc2l0aW9uUHJvdG90eXBlO1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2RlLCBub2RlO1xuICAgIHNlbGVjdG9yID0gZDNfc2VsZWN0aW9uX3NlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBmb3IgKHZhciBqID0gLTEsIG0gPSB0aGlzLmxlbmd0aDsgKytqIDwgbTsgKSB7XG4gICAgICBzdWJncm91cHMucHVzaChzdWJncm91cCA9IFtdKTtcbiAgICAgIGZvciAodmFyIGdyb3VwID0gdGhpc1tqXSwgaSA9IC0xLCBuID0gZ3JvdXAubGVuZ3RoOyArK2kgPCBuOyApIHtcbiAgICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0b3IuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpIHtcbiAgICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICAgIGQzX3RyYW5zaXRpb25Ob2RlKHN1Ym5vZGUsIGksIG5zLCBpZCwgbm9kZVtuc11baWRdKTtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1Ymdyb3VwLnB1c2gobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb24oc3ViZ3JvdXBzLCBucywgaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnNlbGVjdEFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgdmFyIGlkID0gdGhpcy5pZCwgbnMgPSB0aGlzLm5hbWVzcGFjZSwgc3ViZ3JvdXBzID0gW10sIHN1Ymdyb3VwLCBzdWJub2Rlcywgbm9kZSwgc3Vibm9kZSwgdHJhbnNpdGlvbjtcbiAgICBzZWxlY3RvciA9IGQzX3NlbGVjdGlvbl9zZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBtID0gdGhpcy5sZW5ndGg7ICsraiA8IG07ICkge1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gLTEsIG4gPSBncm91cC5sZW5ndGg7ICsraSA8IG47ICkge1xuICAgICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgICBzdWJub2RlcyA9IHNlbGVjdG9yLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICAgICAgZm9yICh2YXIgayA9IC0xLCBvID0gc3Vibm9kZXMubGVuZ3RoOyArK2sgPCBvOyApIHtcbiAgICAgICAgICAgIGlmIChzdWJub2RlID0gc3Vibm9kZXNba10pIGQzX3RyYW5zaXRpb25Ob2RlKHN1Ym5vZGUsIGssIG5zLCBpZCwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICBzdWJncm91cC5wdXNoKHN1Ym5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbihzdWJncm91cHMsIG5zLCBpZCk7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gICAgdmFyIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGU7XG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgIT09IFwiZnVuY3Rpb25cIikgZmlsdGVyID0gZDNfc2VsZWN0aW9uX2ZpbHRlcihmaWx0ZXIpO1xuICAgIGZvciAodmFyIGogPSAwLCBtID0gdGhpcy5sZW5ndGg7IGogPCBtOyBqKyspIHtcbiAgICAgIHN1Ymdyb3Vwcy5wdXNoKHN1Ymdyb3VwID0gW10pO1xuICAgICAgZm9yICh2YXIgZ3JvdXAgPSB0aGlzW2pdLCBpID0gMCwgbiA9IGdyb3VwLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoKG5vZGUgPSBncm91cFtpXSkgJiYgZmlsdGVyLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaikpIHtcbiAgICAgICAgICBzdWJncm91cC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5uYW1lc3BhY2UsIHRoaXMuaWQpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnR3ZWVuID0gZnVuY3Rpb24obmFtZSwgdHdlZW4pIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0udHdlZW4uZ2V0KG5hbWUpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCB0d2VlbiA9PSBudWxsID8gZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnJlbW92ZShuYW1lKTtcbiAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLnR3ZWVuLnNldChuYW1lLCB0d2Vlbik7XG4gICAgfSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25fdHdlZW4oZ3JvdXBzLCBuYW1lLCB2YWx1ZSwgdHdlZW4pIHtcbiAgICB2YXIgaWQgPSBncm91cHMuaWQsIG5zID0gZ3JvdXBzLm5hbWVzcGFjZTtcbiAgICByZXR1cm4gZDNfc2VsZWN0aW9uX2VhY2goZ3JvdXBzLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGZ1bmN0aW9uKG5vZGUsIGksIGopIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdHdlZW4odmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSkpO1xuICAgIH0gOiAodmFsdWUgPSB0d2Vlbih2YWx1ZSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGVbbnNdW2lkXS50d2Vlbi5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH0pKTtcbiAgfVxuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lTlMsIHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBmb3IgKHZhbHVlIGluIG5hbWVOUykgdGhpcy5hdHRyKHZhbHVlLCBuYW1lTlNbdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgaW50ZXJwb2xhdGUgPSBuYW1lTlMgPT0gXCJ0cmFuc2Zvcm1cIiA/IGQzX2ludGVycG9sYXRlVHJhbnNmb3JtIDogZDNfaW50ZXJwb2xhdGUsIG5hbWUgPSBkMy5ucy5xdWFsaWZ5KG5hbWVOUyk7XG4gICAgZnVuY3Rpb24gYXR0ck51bGwoKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0ck51bGxOUygpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dHJUd2VlbihiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gYXR0ck51bGwgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSwgaTtcbiAgICAgICAgcmV0dXJuIGEgIT09IGIgJiYgKGkgPSBpbnRlcnBvbGF0ZShhLCBiKSwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIGkodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW5OUyhiKSB7XG4gICAgICByZXR1cm4gYiA9PSBudWxsID8gYXR0ck51bGxOUyA6IChiICs9IFwiXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMuZ2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCksIGk7XG4gICAgICAgIHJldHVybiBhICE9PSBiICYmIChpID0gaW50ZXJwb2xhdGUoYSwgYiksIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZU5TKG5hbWUuc3BhY2UsIG5hbWUubG9jYWwsIGkodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZDNfdHJhbnNpdGlvbl90d2Vlbih0aGlzLCBcImF0dHIuXCIgKyBuYW1lTlMsIHZhbHVlLCBuYW1lLmxvY2FsID8gYXR0clR3ZWVuTlMgOiBhdHRyVHdlZW4pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmF0dHJUd2VlbiA9IGZ1bmN0aW9uKG5hbWVOUywgdHdlZW4pIHtcbiAgICB2YXIgbmFtZSA9IGQzLm5zLnF1YWxpZnkobmFtZU5TKTtcbiAgICBmdW5jdGlvbiBhdHRyVHdlZW4oZCwgaSkge1xuICAgICAgdmFyIGYgPSB0d2Vlbi5jYWxsKHRoaXMsIGQsIGksIHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUobmFtZSwgZih0KSk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhdHRyVHdlZW5OUyhkLCBpKSB7XG4gICAgICB2YXIgZiA9IHR3ZWVuLmNhbGwodGhpcywgZCwgaSwgdGhpcy5nZXRBdHRyaWJ1dGVOUyhuYW1lLnNwYWNlLCBuYW1lLmxvY2FsKSk7XG4gICAgICByZXR1cm4gZiAmJiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlTlMobmFtZS5zcGFjZSwgbmFtZS5sb2NhbCwgZih0KSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50d2VlbihcImF0dHIuXCIgKyBuYW1lTlMsIG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKG4gPCAzKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKG4gPCAyKSB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAocHJpb3JpdHkgaW4gbmFtZSkgdGhpcy5zdHlsZShwcmlvcml0eSwgbmFtZVtwcmlvcml0eV0sIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBwcmlvcml0eSA9IFwiXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlTnVsbCgpIHtcbiAgICAgIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0eWxlU3RyaW5nKGIpIHtcbiAgICAgIHJldHVybiBiID09IG51bGwgPyBzdHlsZU51bGwgOiAoYiArPSBcIlwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSBkM193aW5kb3codGhpcykuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpLCBpO1xuICAgICAgICByZXR1cm4gYSAhPT0gYiAmJiAoaSA9IGQzX2ludGVycG9sYXRlKGEsIGIpLCBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBpKHQpLCBwcmlvcml0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uX3R3ZWVuKHRoaXMsIFwic3R5bGUuXCIgKyBuYW1lLCB2YWx1ZSwgc3R5bGVTdHJpbmcpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnN0eWxlVHdlZW4gPSBmdW5jdGlvbihuYW1lLCB0d2VlbiwgcHJpb3JpdHkpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHByaW9yaXR5ID0gXCJcIjtcbiAgICBmdW5jdGlvbiBzdHlsZVR3ZWVuKGQsIGkpIHtcbiAgICAgIHZhciBmID0gdHdlZW4uY2FsbCh0aGlzLCBkLCBpLCBkM193aW5kb3codGhpcykuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgICAgIHJldHVybiBmICYmIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBmKHQpLCBwcmlvcml0eSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50d2VlbihcInN0eWxlLlwiICsgbmFtZSwgc3R5bGVUd2Vlbik7XG4gIH07XG4gIGQzX3RyYW5zaXRpb25Qcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGQzX3RyYW5zaXRpb25fdHdlZW4odGhpcywgXCJ0ZXh0XCIsIHZhbHVlLCBkM190cmFuc2l0aW9uX3RleHQpO1xuICB9O1xuICBmdW5jdGlvbiBkM190cmFuc2l0aW9uX3RleHQoYikge1xuICAgIGlmIChiID09IG51bGwpIGIgPSBcIlwiO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBiO1xuICAgIH07XG4gIH1cbiAgZDNfdHJhbnNpdGlvblByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnMgPSB0aGlzLm5hbWVzcGFjZTtcbiAgICByZXR1cm4gdGhpcy5lYWNoKFwiZW5kLnRyYW5zaXRpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIGlmICh0aGlzW25zXS5jb3VudCA8IDIgJiYgKHAgPSB0aGlzLnBhcmVudE5vZGUpKSBwLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH0pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVhc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSByZXR1cm4gdGhpcy5ub2RlKClbbnNdW2lkXS5lYXNlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdmFsdWUgPSBkMy5lYXNlLmFwcGx5KGQzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlW25zXVtpZF0uZWFzZSA9IHZhbHVlO1xuICAgIH0pO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZGVsYXk7XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLmRlbGF5ID0gK3ZhbHVlLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgaik7XG4gICAgfSA6ICh2YWx1ZSA9ICt2YWx1ZSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmRlbGF5ID0gdmFsdWU7XG4gICAgfSkpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLmlkLCBucyA9IHRoaXMubmFtZXNwYWNlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXMubm9kZSgpW25zXVtpZF0uZHVyYXRpb247XG4gICAgcmV0dXJuIGQzX3NlbGVjdGlvbl9lYWNoKHRoaXMsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZnVuY3Rpb24obm9kZSwgaSwgaikge1xuICAgICAgbm9kZVtuc11baWRdLmR1cmF0aW9uID0gTWF0aC5tYXgoMSwgdmFsdWUuY2FsbChub2RlLCBub2RlLl9fZGF0YV9fLCBpLCBqKSk7XG4gICAgfSA6ICh2YWx1ZSA9IE1hdGgubWF4KDEsIHZhbHVlKSwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZVtuc11baWRdLmR1cmF0aW9uID0gdmFsdWU7XG4gICAgfSkpO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBpZCA9IHRoaXMuaWQsIG5zID0gdGhpcy5uYW1lc3BhY2U7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB2YXIgaW5oZXJpdCA9IGQzX3RyYW5zaXRpb25Jbmhlcml0LCBpbmhlcml0SWQgPSBkM190cmFuc2l0aW9uSW5oZXJpdElkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA9IGlkO1xuICAgICAgICBkM19zZWxlY3Rpb25fZWFjaCh0aGlzLCBmdW5jdGlvbihub2RlLCBpLCBqKSB7XG4gICAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXQgPSBub2RlW25zXVtpZF07XG4gICAgICAgICAgdHlwZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGopO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGQzX3RyYW5zaXRpb25Jbmhlcml0ID0gaW5oZXJpdDtcbiAgICAgICAgZDNfdHJhbnNpdGlvbkluaGVyaXRJZCA9IGluaGVyaXRJZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZDNfc2VsZWN0aW9uX2VhY2godGhpcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IG5vZGVbbnNdW2lkXTtcbiAgICAgICAgKHRyYW5zaXRpb24uZXZlbnQgfHwgKHRyYW5zaXRpb24uZXZlbnQgPSBkMy5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiaW50ZXJydXB0XCIpKSkub24odHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBkM190cmFuc2l0aW9uUHJvdG90eXBlLnRyYW5zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWQwID0gdGhpcy5pZCwgaWQxID0gKytkM190cmFuc2l0aW9uSWQsIG5zID0gdGhpcy5uYW1lc3BhY2UsIHN1Ymdyb3VwcyA9IFtdLCBzdWJncm91cCwgZ3JvdXAsIG5vZGUsIHRyYW5zaXRpb247XG4gICAgZm9yICh2YXIgaiA9IDAsIG0gPSB0aGlzLmxlbmd0aDsgaiA8IG07IGorKykge1xuICAgICAgc3ViZ3JvdXBzLnB1c2goc3ViZ3JvdXAgPSBbXSk7XG4gICAgICBmb3IgKHZhciBncm91cCA9IHRoaXNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgICB0cmFuc2l0aW9uID0gbm9kZVtuc11baWQwXTtcbiAgICAgICAgICBkM190cmFuc2l0aW9uTm9kZShub2RlLCBpLCBucywgaWQxLCB7XG4gICAgICAgICAgICB0aW1lOiB0cmFuc2l0aW9uLnRpbWUsXG4gICAgICAgICAgICBlYXNlOiB0cmFuc2l0aW9uLmVhc2UsXG4gICAgICAgICAgICBkZWxheTogdHJhbnNpdGlvbi5kZWxheSArIHRyYW5zaXRpb24uZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvbjogdHJhbnNpdGlvbi5kdXJhdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkM190cmFuc2l0aW9uKHN1Ymdyb3VwcywgbnMsIGlkMSk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX3RyYW5zaXRpb25OYW1lc3BhY2UobmFtZSkge1xuICAgIHJldHVybiBuYW1lID09IG51bGwgPyBcIl9fdHJhbnNpdGlvbl9fXCIgOiBcIl9fdHJhbnNpdGlvbl9cIiArIG5hbWUgKyBcIl9fXCI7XG4gIH1cbiAgZnVuY3Rpb24gZDNfdHJhbnNpdGlvbk5vZGUobm9kZSwgaSwgbnMsIGlkLCBpbmhlcml0KSB7XG4gICAgdmFyIGxvY2sgPSBub2RlW25zXSB8fCAobm9kZVtuc10gPSB7XG4gICAgICBhY3RpdmU6IDAsXG4gICAgICBjb3VudDogMFxuICAgIH0pLCB0cmFuc2l0aW9uID0gbG9ja1tpZF0sIHRpbWUsIHRpbWVyLCBkdXJhdGlvbiwgZWFzZSwgdHdlZW5zO1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICAgIHZhciBkZWxheSA9IHRyYW5zaXRpb24uZGVsYXk7XG4gICAgICB0aW1lci50ID0gZGVsYXkgKyB0aW1lO1xuICAgICAgaWYgKGRlbGF5IDw9IGVsYXBzZWQpIHJldHVybiBzdGFydChlbGFwc2VkIC0gZGVsYXkpO1xuICAgICAgdGltZXIuYyA9IHN0YXJ0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydChlbGFwc2VkKSB7XG4gICAgICB2YXIgYWN0aXZlSWQgPSBsb2NrLmFjdGl2ZSwgYWN0aXZlID0gbG9ja1thY3RpdmVJZF07XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZS50aW1lci5jID0gbnVsbDtcbiAgICAgICAgYWN0aXZlLnRpbWVyLnQgPSBOYU47XG4gICAgICAgIC0tbG9jay5jb3VudDtcbiAgICAgICAgZGVsZXRlIGxvY2tbYWN0aXZlSWRdO1xuICAgICAgICBhY3RpdmUuZXZlbnQgJiYgYWN0aXZlLmV2ZW50LmludGVycnVwdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGFjdGl2ZS5pbmRleCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjYW5jZWxJZCBpbiBsb2NrKSB7XG4gICAgICAgIGlmICgrY2FuY2VsSWQgPCBpZCkge1xuICAgICAgICAgIHZhciBjYW5jZWwgPSBsb2NrW2NhbmNlbElkXTtcbiAgICAgICAgICBjYW5jZWwudGltZXIuYyA9IG51bGw7XG4gICAgICAgICAgY2FuY2VsLnRpbWVyLnQgPSBOYU47XG4gICAgICAgICAgLS1sb2NrLmNvdW50O1xuICAgICAgICAgIGRlbGV0ZSBsb2NrW2NhbmNlbElkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGltZXIuYyA9IHRpY2s7XG4gICAgICBkM190aW1lcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRpbWVyLmMgJiYgdGljayhlbGFwc2VkIHx8IDEpKSB7XG4gICAgICAgICAgdGltZXIuYyA9IG51bGw7XG4gICAgICAgICAgdGltZXIudCA9IE5hTjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0sIDAsIHRpbWUpO1xuICAgICAgbG9jay5hY3RpdmUgPSBpZDtcbiAgICAgIHRyYW5zaXRpb24uZXZlbnQgJiYgdHJhbnNpdGlvbi5ldmVudC5zdGFydC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpO1xuICAgICAgdHdlZW5zID0gW107XG4gICAgICB0cmFuc2l0aW9uLnR3ZWVuLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPSB2YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGkpKSB7XG4gICAgICAgICAgdHdlZW5zLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVhc2UgPSB0cmFuc2l0aW9uLmVhc2U7XG4gICAgICBkdXJhdGlvbiA9IHRyYW5zaXRpb24uZHVyYXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgICAgdmFyIHQgPSBlbGFwc2VkIC8gZHVyYXRpb24sIGUgPSBlYXNlKHQpLCBuID0gdHdlZW5zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgICB0d2VlbnNbLS1uXS5jYWxsKG5vZGUsIGUpO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICB0cmFuc2l0aW9uLmV2ZW50ICYmIHRyYW5zaXRpb24uZXZlbnQuZW5kLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSk7XG4gICAgICAgIGlmICgtLWxvY2suY291bnQpIGRlbGV0ZSBsb2NrW2lkXTsgZWxzZSBkZWxldGUgbm9kZVtuc107XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyYW5zaXRpb24pIHtcbiAgICAgIHRpbWUgPSBpbmhlcml0LnRpbWU7XG4gICAgICB0aW1lciA9IGQzX3RpbWVyKHNjaGVkdWxlLCAwLCB0aW1lKTtcbiAgICAgIHRyYW5zaXRpb24gPSBsb2NrW2lkXSA9IHtcbiAgICAgICAgdHdlZW46IG5ldyBkM19NYXAoKSxcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdGltZXI6IHRpbWVyLFxuICAgICAgICBkZWxheTogaW5oZXJpdC5kZWxheSxcbiAgICAgICAgZHVyYXRpb246IGluaGVyaXQuZHVyYXRpb24sXG4gICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZSxcbiAgICAgICAgaW5kZXg6IGlcbiAgICAgIH07XG4gICAgICBpbmhlcml0ID0gbnVsbDtcbiAgICAgICsrbG9jay5jb3VudDtcbiAgICB9XG4gIH1cbiAgZDMuc3ZnLmF4aXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKSwgb3JpZW50ID0gZDNfc3ZnX2F4aXNEZWZhdWx0T3JpZW50LCBpbm5lclRpY2tTaXplID0gNiwgb3V0ZXJUaWNrU2l6ZSA9IDYsIHRpY2tQYWRkaW5nID0gMywgdGlja0FyZ3VtZW50c18gPSBbIDEwIF0sIHRpY2tWYWx1ZXMgPSBudWxsLCB0aWNrRm9ybWF0XztcbiAgICBmdW5jdGlvbiBheGlzKGcpIHtcbiAgICAgIGcuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGcgPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIHZhciBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZSwgc2NhbGUxID0gdGhpcy5fX2NoYXJ0X18gPSBzY2FsZS5jb3B5KCk7XG4gICAgICAgIHZhciB0aWNrcyA9IHRpY2tWYWx1ZXMgPT0gbnVsbCA/IHNjYWxlMS50aWNrcyA/IHNjYWxlMS50aWNrcy5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IHNjYWxlMS5kb21haW4oKSA6IHRpY2tWYWx1ZXMsIHRpY2tGb3JtYXQgPSB0aWNrRm9ybWF0XyA9PSBudWxsID8gc2NhbGUxLnRpY2tGb3JtYXQgPyBzY2FsZTEudGlja0Zvcm1hdC5hcHBseShzY2FsZTEsIHRpY2tBcmd1bWVudHNfKSA6IGQzX2lkZW50aXR5IDogdGlja0Zvcm1hdF8sIHRpY2sgPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpLmRhdGEodGlja3MsIHNjYWxlMSksIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKS5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpLnN0eWxlKFwib3BhY2l0eVwiLCDOtSksIHRpY2tFeGl0ID0gZDMudHJhbnNpdGlvbih0aWNrLmV4aXQoKSkuc3R5bGUoXCJvcGFjaXR5XCIsIM61KS5yZW1vdmUoKSwgdGlja1VwZGF0ZSA9IGQzLnRyYW5zaXRpb24odGljay5vcmRlcigpKS5zdHlsZShcIm9wYWNpdHlcIiwgMSksIHRpY2tTcGFjaW5nID0gTWF0aC5tYXgoaW5uZXJUaWNrU2l6ZSwgMCkgKyB0aWNrUGFkZGluZywgdGlja1RyYW5zZm9ybTtcbiAgICAgICAgdmFyIHJhbmdlID0gZDNfc2NhbGVSYW5nZShzY2FsZTEpLCBwYXRoID0gZy5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoWyAwIF0pLCBwYXRoVXBkYXRlID0gKHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKSwgXG4gICAgICAgIGQzLnRyYW5zaXRpb24ocGF0aCkpO1xuICAgICAgICB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcbiAgICAgICAgdGlja0VudGVyLmFwcGVuZChcInRleHRcIik7XG4gICAgICAgIHZhciBsaW5lRW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKSwgbGluZVVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwibGluZVwiKSwgdGV4dCA9IHRpY2suc2VsZWN0KFwidGV4dFwiKS50ZXh0KHRpY2tGb3JtYXQpLCB0ZXh0RW50ZXIgPSB0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKSwgdGV4dFVwZGF0ZSA9IHRpY2tVcGRhdGUuc2VsZWN0KFwidGV4dFwiKSwgc2lnbiA9IG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwibGVmdFwiID8gLTEgOiAxLCB4MSwgeDIsIHkxLCB5MjtcbiAgICAgICAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNYLCB4MSA9IFwieFwiLCB5MSA9IFwieVwiLCB4MiA9IFwieDJcIiwgeTIgPSBcInkyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgc2lnbiA8IDAgPyBcIjBlbVwiIDogXCIuNzFlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICAgIHBhdGhVcGRhdGUuYXR0cihcImRcIiwgXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUgKyBcIlYwSFwiICsgcmFuZ2VbMV0gKyBcIlZcIiArIHNpZ24gKiBvdXRlclRpY2tTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aWNrVHJhbnNmb3JtID0gZDNfc3ZnX2F4aXNZLCB4MSA9IFwieVwiLCB5MSA9IFwieFwiLCB4MiA9IFwieTJcIiwgeTIgPSBcIngyXCI7XG4gICAgICAgICAgdGV4dC5hdHRyKFwiZHlcIiwgXCIuMzJlbVwiKS5zdHlsZShcInRleHQtYW5jaG9yXCIsIHNpZ24gPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIik7XG4gICAgICAgICAgcGF0aFVwZGF0ZS5hdHRyKFwiZFwiLCBcIk1cIiArIHNpZ24gKiBvdXRlclRpY2tTaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2lnbiAqIG91dGVyVGlja1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVFbnRlci5hdHRyKHkyLCBzaWduICogaW5uZXJUaWNrU2l6ZSk7XG4gICAgICAgIHRleHRFbnRlci5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBsaW5lVXBkYXRlLmF0dHIoeDIsIDApLmF0dHIoeTIsIHNpZ24gKiBpbm5lclRpY2tTaXplKTtcbiAgICAgICAgdGV4dFVwZGF0ZS5hdHRyKHgxLCAwKS5hdHRyKHkxLCBzaWduICogdGlja1NwYWNpbmcpO1xuICAgICAgICBpZiAoc2NhbGUxLnJhbmdlQmFuZCkge1xuICAgICAgICAgIHZhciB4ID0gc2NhbGUxLCBkeCA9IHgucmFuZ2VCYW5kKCkgLyAyO1xuICAgICAgICAgIHNjYWxlMCA9IHNjYWxlMSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHJldHVybiB4KGQpICsgZHg7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzY2FsZTAucmFuZ2VCYW5kKSB7XG4gICAgICAgICAgc2NhbGUwID0gc2NhbGUxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpY2tFeGl0LmNhbGwodGlja1RyYW5zZm9ybSwgc2NhbGUxLCBzY2FsZTApO1xuICAgICAgICB9XG4gICAgICAgIHRpY2tFbnRlci5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMCwgc2NhbGUxKTtcbiAgICAgICAgdGlja1VwZGF0ZS5jYWxsKHRpY2tUcmFuc2Zvcm0sIHNjYWxlMSwgc2NhbGUxKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBheGlzLnNjYWxlID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgICBzY2FsZSA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgICAgb3JpZW50ID0geCBpbiBkM19zdmdfYXhpc09yaWVudHMgPyB4ICsgXCJcIiA6IGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50c187XG4gICAgICB0aWNrQXJndW1lbnRzXyA9IGQzX2FycmF5KGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tWYWx1ZXM7XG4gICAgICB0aWNrVmFsdWVzID0geDtcbiAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG4gICAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0Zvcm1hdF87XG4gICAgICB0aWNrRm9ybWF0XyA9IHg7XG4gICAgICByZXR1cm4gYXhpcztcbiAgICB9O1xuICAgIGF4aXMudGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIW4pIHJldHVybiBpbm5lclRpY2tTaXplO1xuICAgICAgaW5uZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgb3V0ZXJUaWNrU2l6ZSA9ICthcmd1bWVudHNbbiAtIDFdO1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLmlubmVyVGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBpbm5lclRpY2tTaXplO1xuICAgICAgaW5uZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLm91dGVyVGlja1NpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvdXRlclRpY2tTaXplO1xuICAgICAgb3V0ZXJUaWNrU2l6ZSA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgICB0aWNrUGFkZGluZyA9ICt4O1xuICAgICAgcmV0dXJuIGF4aXM7XG4gICAgfTtcbiAgICBheGlzLnRpY2tTdWJkaXZpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoICYmIGF4aXM7XG4gICAgfTtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgdmFyIGQzX3N2Z19heGlzRGVmYXVsdE9yaWVudCA9IFwiYm90dG9tXCIsIGQzX3N2Z19heGlzT3JpZW50cyA9IHtcbiAgICB0b3A6IDEsXG4gICAgcmlnaHQ6IDEsXG4gICAgYm90dG9tOiAxLFxuICAgIGxlZnQ6IDFcbiAgfTtcbiAgZnVuY3Rpb24gZDNfc3ZnX2F4aXNYKHNlbGVjdGlvbiwgeDAsIHgxKSB7XG4gICAgc2VsZWN0aW9uLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xuICAgICAgdmFyIHYwID0geDAoZCk7XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyAoaXNGaW5pdGUodjApID8gdjAgOiB4MShkKSkgKyBcIiwwKVwiO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGQzX3N2Z19heGlzWShzZWxlY3Rpb24sIHkwLCB5MSkge1xuICAgIHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciB2MCA9IHkwKGQpO1xuICAgICAgcmV0dXJuIFwidHJhbnNsYXRlKDAsXCIgKyAoaXNGaW5pdGUodjApID8gdjAgOiB5MShkKSkgKyBcIilcIjtcbiAgICB9KTtcbiAgfVxuICBkMy5zdmcuYnJ1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZXZlbnQgPSBkM19ldmVudERpc3BhdGNoKGJydXNoLCBcImJydXNoc3RhcnRcIiwgXCJicnVzaFwiLCBcImJydXNoZW5kXCIpLCB4ID0gbnVsbCwgeSA9IG51bGwsIHhFeHRlbnQgPSBbIDAsIDAgXSwgeUV4dGVudCA9IFsgMCwgMCBdLCB4RXh0ZW50RG9tYWluLCB5RXh0ZW50RG9tYWluLCB4Q2xhbXAgPSB0cnVlLCB5Q2xhbXAgPSB0cnVlLCByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1swXTtcbiAgICBmdW5jdGlvbiBicnVzaChnKSB7XG4gICAgICBnLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gZDMuc2VsZWN0KHRoaXMpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIikuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpLm9uKFwibW91c2Vkb3duLmJydXNoXCIsIGJydXNoc3RhcnQpLm9uKFwidG91Y2hzdGFydC5icnVzaFwiLCBicnVzaHN0YXJ0KTtcbiAgICAgICAgdmFyIGJhY2tncm91bmQgPSBnLnNlbGVjdEFsbChcIi5iYWNrZ3JvdW5kXCIpLmRhdGEoWyAwIF0pO1xuICAgICAgICBiYWNrZ3JvdW5kLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJiYWNrZ3JvdW5kXCIpLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKS5zdHlsZShcImN1cnNvclwiLCBcImNyb3NzaGFpclwiKTtcbiAgICAgICAgZy5zZWxlY3RBbGwoXCIuZXh0ZW50XCIpLmRhdGEoWyAwIF0pLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJleHRlbnRcIikuc3R5bGUoXCJjdXJzb3JcIiwgXCJtb3ZlXCIpO1xuICAgICAgICB2YXIgcmVzaXplID0gZy5zZWxlY3RBbGwoXCIucmVzaXplXCIpLmRhdGEocmVzaXplcywgZDNfaWRlbnRpdHkpO1xuICAgICAgICByZXNpemUuZXhpdCgpLnJlbW92ZSgpO1xuICAgICAgICByZXNpemUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgcmV0dXJuIFwicmVzaXplIFwiICsgZDtcbiAgICAgICAgfSkuc3R5bGUoXCJjdXJzb3JcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiBkM19zdmdfYnJ1c2hDdXJzb3JbZF07XG4gICAgICAgIH0pLmFwcGVuZChcInJlY3RcIikuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAvW2V3XSQvLnRlc3QoZCkgPyAtMyA6IG51bGw7XG4gICAgICAgIH0pLmF0dHIoXCJ5XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICByZXR1cm4gL15bbnNdLy50ZXN0KGQpID8gLTMgOiBudWxsO1xuICAgICAgICB9KS5hdHRyKFwid2lkdGhcIiwgNikuYXR0cihcImhlaWdodFwiLCA2KS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XG4gICAgICAgIHJlc2l6ZS5zdHlsZShcImRpc3BsYXlcIiwgYnJ1c2guZW1wdHkoKSA/IFwibm9uZVwiIDogbnVsbCk7XG4gICAgICAgIHZhciBnVXBkYXRlID0gZDMudHJhbnNpdGlvbihnKSwgYmFja2dyb3VuZFVwZGF0ZSA9IGQzLnRyYW5zaXRpb24oYmFja2dyb3VuZCksIHJhbmdlO1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIHJhbmdlID0gZDNfc2NhbGVSYW5nZSh4KTtcbiAgICAgICAgICBiYWNrZ3JvdW5kVXBkYXRlLmF0dHIoXCJ4XCIsIHJhbmdlWzBdKS5hdHRyKFwid2lkdGhcIiwgcmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gICAgICAgICAgcmVkcmF3WChnVXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSkge1xuICAgICAgICAgIHJhbmdlID0gZDNfc2NhbGVSYW5nZSh5KTtcbiAgICAgICAgICBiYWNrZ3JvdW5kVXBkYXRlLmF0dHIoXCJ5XCIsIHJhbmdlWzBdKS5hdHRyKFwiaGVpZ2h0XCIsIHJhbmdlWzFdIC0gcmFuZ2VbMF0pO1xuICAgICAgICAgIHJlZHJhd1koZ1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVkcmF3KGdVcGRhdGUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJydXNoLmV2ZW50ID0gZnVuY3Rpb24oZykge1xuICAgICAgZy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZXZlbnRfID0gZXZlbnQub2YodGhpcywgYXJndW1lbnRzKSwgZXh0ZW50MSA9IHtcbiAgICAgICAgICB4OiB4RXh0ZW50LFxuICAgICAgICAgIHk6IHlFeHRlbnQsXG4gICAgICAgICAgaTogeEV4dGVudERvbWFpbixcbiAgICAgICAgICBqOiB5RXh0ZW50RG9tYWluXG4gICAgICAgIH0sIGV4dGVudDAgPSB0aGlzLl9fY2hhcnRfXyB8fCBleHRlbnQxO1xuICAgICAgICB0aGlzLl9fY2hhcnRfXyA9IGV4dGVudDE7XG4gICAgICAgIGlmIChkM190cmFuc2l0aW9uSW5oZXJpdElkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnRyYW5zaXRpb24oKS5lYWNoKFwic3RhcnQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0gZXh0ZW50MC5pO1xuICAgICAgICAgICAgeUV4dGVudERvbWFpbiA9IGV4dGVudDAuajtcbiAgICAgICAgICAgIHhFeHRlbnQgPSBleHRlbnQwLng7XG4gICAgICAgICAgICB5RXh0ZW50ID0gZXh0ZW50MC55O1xuICAgICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJicnVzaHN0YXJ0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLnR3ZWVuKFwiYnJ1c2g6YnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSBkM19pbnRlcnBvbGF0ZUFycmF5KHhFeHRlbnQsIGV4dGVudDEueCksIHlpID0gZDNfaW50ZXJwb2xhdGVBcnJheSh5RXh0ZW50LCBleHRlbnQxLnkpO1xuICAgICAgICAgICAgeEV4dGVudERvbWFpbiA9IHlFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICAgICAgeEV4dGVudCA9IGV4dGVudDEueCA9IHhpKHQpO1xuICAgICAgICAgICAgICB5RXh0ZW50ID0gZXh0ZW50MS55ID0geWkodCk7XG4gICAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwicmVzaXplXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pLmVhY2goXCJlbmQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB4RXh0ZW50RG9tYWluID0gZXh0ZW50MS5pO1xuICAgICAgICAgICAgeUV4dGVudERvbWFpbiA9IGV4dGVudDEuajtcbiAgICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hcIixcbiAgICAgICAgICAgICAgbW9kZTogXCJyZXNpemVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50Xyh7XG4gICAgICAgICAgICB0eXBlOiBcImJydXNoXCIsXG4gICAgICAgICAgICBtb2RlOiBcInJlc2l6ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICAgIHR5cGU6IFwiYnJ1c2hlbmRcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlZHJhdyhnKSB7XG4gICAgICBnLnNlbGVjdEFsbChcIi5yZXNpemVcIikuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIiArIHhFeHRlbnRbKy9lJC8udGVzdChkKV0gKyBcIixcIiArIHlFeHRlbnRbKy9ecy8udGVzdChkKV0gKyBcIilcIjtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWRyYXdYKGcpIHtcbiAgICAgIGcuc2VsZWN0KFwiLmV4dGVudFwiKS5hdHRyKFwieFwiLCB4RXh0ZW50WzBdKTtcbiAgICAgIGcuc2VsZWN0QWxsKFwiLmV4dGVudCwubj5yZWN0LC5zPnJlY3RcIikuYXR0cihcIndpZHRoXCIsIHhFeHRlbnRbMV0gLSB4RXh0ZW50WzBdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVkcmF3WShnKSB7XG4gICAgICBnLnNlbGVjdChcIi5leHRlbnRcIikuYXR0cihcInlcIiwgeUV4dGVudFswXSk7XG4gICAgICBnLnNlbGVjdEFsbChcIi5leHRlbnQsLmU+cmVjdCwudz5yZWN0XCIpLmF0dHIoXCJoZWlnaHRcIiwgeUV4dGVudFsxXSAtIHlFeHRlbnRbMF0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBicnVzaHN0YXJ0KCkge1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMsIGV2ZW50VGFyZ2V0ID0gZDMuc2VsZWN0KGQzLmV2ZW50LnRhcmdldCksIGV2ZW50XyA9IGV2ZW50Lm9mKHRhcmdldCwgYXJndW1lbnRzKSwgZyA9IGQzLnNlbGVjdCh0YXJnZXQpLCByZXNpemluZyA9IGV2ZW50VGFyZ2V0LmRhdHVtKCksIHJlc2l6aW5nWCA9ICEvXihufHMpJC8udGVzdChyZXNpemluZykgJiYgeCwgcmVzaXppbmdZID0gIS9eKGV8dykkLy50ZXN0KHJlc2l6aW5nKSAmJiB5LCBkcmFnZ2luZyA9IGV2ZW50VGFyZ2V0LmNsYXNzZWQoXCJleHRlbnRcIiksIGRyYWdSZXN0b3JlID0gZDNfZXZlbnRfZHJhZ1N1cHByZXNzKHRhcmdldCksIGNlbnRlciwgb3JpZ2luID0gZDMubW91c2UodGFyZ2V0KSwgb2Zmc2V0O1xuICAgICAgdmFyIHcgPSBkMy5zZWxlY3QoZDNfd2luZG93KHRhcmdldCkpLm9uKFwia2V5ZG93bi5icnVzaFwiLCBrZXlkb3duKS5vbihcImtleXVwLmJydXNoXCIsIGtleXVwKTtcbiAgICAgIGlmIChkMy5ldmVudC5jaGFuZ2VkVG91Y2hlcykge1xuICAgICAgICB3Lm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBicnVzaGVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3Lm9uKFwibW91c2Vtb3ZlLmJydXNoXCIsIGJydXNobW92ZSkub24oXCJtb3VzZXVwLmJydXNoXCIsIGJydXNoZW5kKTtcbiAgICAgIH1cbiAgICAgIGcuaW50ZXJydXB0KCkuc2VsZWN0QWxsKFwiKlwiKS5pbnRlcnJ1cHQoKTtcbiAgICAgIGlmIChkcmFnZ2luZykge1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50WzBdIC0gb3JpZ2luWzBdO1xuICAgICAgICBvcmlnaW5bMV0gPSB5RXh0ZW50WzBdIC0gb3JpZ2luWzFdO1xuICAgICAgfSBlbHNlIGlmIChyZXNpemluZykge1xuICAgICAgICB2YXIgZXggPSArL3ckLy50ZXN0KHJlc2l6aW5nKSwgZXkgPSArL15uLy50ZXN0KHJlc2l6aW5nKTtcbiAgICAgICAgb2Zmc2V0ID0gWyB4RXh0ZW50WzEgLSBleF0gLSBvcmlnaW5bMF0sIHlFeHRlbnRbMSAtIGV5XSAtIG9yaWdpblsxXSBdO1xuICAgICAgICBvcmlnaW5bMF0gPSB4RXh0ZW50W2V4XTtcbiAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFtleV07XG4gICAgICB9IGVsc2UgaWYgKGQzLmV2ZW50LmFsdEtleSkgY2VudGVyID0gb3JpZ2luLnNsaWNlKCk7XG4gICAgICBnLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpLnNlbGVjdEFsbChcIi5yZXNpemVcIikuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xuICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBldmVudFRhcmdldC5zdHlsZShcImN1cnNvclwiKSk7XG4gICAgICBldmVudF8oe1xuICAgICAgICB0eXBlOiBcImJydXNoc3RhcnRcIlxuICAgICAgfSk7XG4gICAgICBicnVzaG1vdmUoKTtcbiAgICAgIGZ1bmN0aW9uIGtleWRvd24oKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgY2VudGVyID0gbnVsbDtcbiAgICAgICAgICAgIG9yaWdpblswXSAtPSB4RXh0ZW50WzFdO1xuICAgICAgICAgICAgb3JpZ2luWzFdIC09IHlFeHRlbnRbMV07XG4gICAgICAgICAgICBkcmFnZ2luZyA9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGQzX2V2ZW50UHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga2V5dXAoKSB7XG4gICAgICAgIGlmIChkMy5ldmVudC5rZXlDb2RlID09IDMyICYmIGRyYWdnaW5nID09IDIpIHtcbiAgICAgICAgICBvcmlnaW5bMF0gKz0geEV4dGVudFsxXTtcbiAgICAgICAgICBvcmlnaW5bMV0gKz0geUV4dGVudFsxXTtcbiAgICAgICAgICBkcmFnZ2luZyA9IDA7XG4gICAgICAgICAgZDNfZXZlbnRQcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaG1vdmUoKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGQzLm1vdXNlKHRhcmdldCksIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGlmIChvZmZzZXQpIHtcbiAgICAgICAgICBwb2ludFswXSArPSBvZmZzZXRbMF07XG4gICAgICAgICAgcG9pbnRbMV0gKz0gb2Zmc2V0WzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZHJhZ2dpbmcpIHtcbiAgICAgICAgICBpZiAoZDMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICBpZiAoIWNlbnRlcikgY2VudGVyID0gWyAoeEV4dGVudFswXSArIHhFeHRlbnRbMV0pIC8gMiwgKHlFeHRlbnRbMF0gKyB5RXh0ZW50WzFdKSAvIDIgXTtcbiAgICAgICAgICAgIG9yaWdpblswXSA9IHhFeHRlbnRbKyhwb2ludFswXSA8IGNlbnRlclswXSldO1xuICAgICAgICAgICAgb3JpZ2luWzFdID0geUV4dGVudFsrKHBvaW50WzFdIDwgY2VudGVyWzFdKV07XG4gICAgICAgICAgfSBlbHNlIGNlbnRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2l6aW5nWCAmJiBtb3ZlMShwb2ludCwgeCwgMCkpIHtcbiAgICAgICAgICByZWRyYXdYKGcpO1xuICAgICAgICAgIG1vdmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzaXppbmdZICYmIG1vdmUxKHBvaW50LCB5LCAxKSkge1xuICAgICAgICAgIHJlZHJhd1koZyk7XG4gICAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb3ZlZCkge1xuICAgICAgICAgIHJlZHJhdyhnKTtcbiAgICAgICAgICBldmVudF8oe1xuICAgICAgICAgICAgdHlwZTogXCJicnVzaFwiLFxuICAgICAgICAgICAgbW9kZTogZHJhZ2dpbmcgPyBcIm1vdmVcIiA6IFwicmVzaXplXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbW92ZTEocG9pbnQsIHNjYWxlLCBpKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGQzX3NjYWxlUmFuZ2Uoc2NhbGUpLCByMCA9IHJhbmdlWzBdLCByMSA9IHJhbmdlWzFdLCBwb3NpdGlvbiA9IG9yaWdpbltpXSwgZXh0ZW50ID0gaSA/IHlFeHRlbnQgOiB4RXh0ZW50LCBzaXplID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCBtaW4sIG1heDtcbiAgICAgICAgaWYgKGRyYWdnaW5nKSB7XG4gICAgICAgICAgcjAgLT0gcG9zaXRpb247XG4gICAgICAgICAgcjEgLT0gc2l6ZSArIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IChpID8geUNsYW1wIDogeENsYW1wKSA/IE1hdGgubWF4KHIwLCBNYXRoLm1pbihyMSwgcG9pbnRbaV0pKSA6IHBvaW50W2ldO1xuICAgICAgICBpZiAoZHJhZ2dpbmcpIHtcbiAgICAgICAgICBtYXggPSAobWluICs9IHBvc2l0aW9uKSArIHNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNlbnRlcikgcG9zaXRpb24gPSBNYXRoLm1heChyMCwgTWF0aC5taW4ocjEsIDIgKiBjZW50ZXJbaV0gLSBtaW4pKTtcbiAgICAgICAgICBpZiAocG9zaXRpb24gPCBtaW4pIHtcbiAgICAgICAgICAgIG1heCA9IG1pbjtcbiAgICAgICAgICAgIG1pbiA9IHBvc2l0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXggPSBwb3NpdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVudFswXSAhPSBtaW4gfHwgZXh0ZW50WzFdICE9IG1heCkge1xuICAgICAgICAgIGlmIChpKSB5RXh0ZW50RG9tYWluID0gbnVsbDsgZWxzZSB4RXh0ZW50RG9tYWluID0gbnVsbDtcbiAgICAgICAgICBleHRlbnRbMF0gPSBtaW47XG4gICAgICAgICAgZXh0ZW50WzFdID0gbWF4O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBicnVzaGVuZCgpIHtcbiAgICAgICAgYnJ1c2htb3ZlKCk7XG4gICAgICAgIGcuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKS5zZWxlY3RBbGwoXCIucmVzaXplXCIpLnN0eWxlKFwiZGlzcGxheVwiLCBicnVzaC5lbXB0eSgpID8gXCJub25lXCIgOiBudWxsKTtcbiAgICAgICAgZDMuc2VsZWN0KFwiYm9keVwiKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcbiAgICAgICAgdy5vbihcIm1vdXNlbW92ZS5icnVzaFwiLCBudWxsKS5vbihcIm1vdXNldXAuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaG1vdmUuYnJ1c2hcIiwgbnVsbCkub24oXCJ0b3VjaGVuZC5icnVzaFwiLCBudWxsKS5vbihcImtleWRvd24uYnJ1c2hcIiwgbnVsbCkub24oXCJrZXl1cC5icnVzaFwiLCBudWxsKTtcbiAgICAgICAgZHJhZ1Jlc3RvcmUoKTtcbiAgICAgICAgZXZlbnRfKHtcbiAgICAgICAgICB0eXBlOiBcImJydXNoZW5kXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJydXNoLnggPSBmdW5jdGlvbih6KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB4O1xuICAgICAgeCA9IHo7XG4gICAgICByZXNpemVzID0gZDNfc3ZnX2JydXNoUmVzaXplc1sheCA8PCAxIHwgIXldO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2gueSA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHk7XG4gICAgICB5ID0gejtcbiAgICAgIHJlc2l6ZXMgPSBkM19zdmdfYnJ1c2hSZXNpemVzWyF4IDw8IDEgfCAheV07XG4gICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfTtcbiAgICBicnVzaC5jbGFtcCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHggJiYgeSA/IFsgeENsYW1wLCB5Q2xhbXAgXSA6IHggPyB4Q2xhbXAgOiB5ID8geUNsYW1wIDogbnVsbDtcbiAgICAgIGlmICh4ICYmIHkpIHhDbGFtcCA9ICEhelswXSwgeUNsYW1wID0gISF6WzFdOyBlbHNlIGlmICh4KSB4Q2xhbXAgPSAhIXo7IGVsc2UgaWYgKHkpIHlDbGFtcCA9ICEhejtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9O1xuICAgIGJydXNoLmV4dGVudCA9IGZ1bmN0aW9uKHopIHtcbiAgICAgIHZhciB4MCwgeDEsIHkwLCB5MSwgdDtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgIGlmICh4RXh0ZW50RG9tYWluKSB7XG4gICAgICAgICAgICB4MCA9IHhFeHRlbnREb21haW5bMF0sIHgxID0geEV4dGVudERvbWFpblsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeDAgPSB4RXh0ZW50WzBdLCB4MSA9IHhFeHRlbnRbMV07XG4gICAgICAgICAgICBpZiAoeC5pbnZlcnQpIHgwID0geC5pbnZlcnQoeDApLCB4MSA9IHguaW52ZXJ0KHgxKTtcbiAgICAgICAgICAgIGlmICh4MSA8IHgwKSB0ID0geDAsIHgwID0geDEsIHgxID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICBpZiAoeUV4dGVudERvbWFpbikge1xuICAgICAgICAgICAgeTAgPSB5RXh0ZW50RG9tYWluWzBdLCB5MSA9IHlFeHRlbnREb21haW5bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkwID0geUV4dGVudFswXSwgeTEgPSB5RXh0ZW50WzFdO1xuICAgICAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkuaW52ZXJ0KHkwKSwgeTEgPSB5LmludmVydCh5MSk7XG4gICAgICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4ICYmIHkgPyBbIFsgeDAsIHkwIF0sIFsgeDEsIHkxIF0gXSA6IHggPyBbIHgwLCB4MSBdIDogeSAmJiBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHgpIHtcbiAgICAgICAgeDAgPSB6WzBdLCB4MSA9IHpbMV07XG4gICAgICAgIGlmICh5KSB4MCA9IHgwWzBdLCB4MSA9IHgxWzBdO1xuICAgICAgICB4RXh0ZW50RG9tYWluID0gWyB4MCwgeDEgXTtcbiAgICAgICAgaWYgKHguaW52ZXJ0KSB4MCA9IHgoeDApLCB4MSA9IHgoeDEpO1xuICAgICAgICBpZiAoeDEgPCB4MCkgdCA9IHgwLCB4MCA9IHgxLCB4MSA9IHQ7XG4gICAgICAgIGlmICh4MCAhPSB4RXh0ZW50WzBdIHx8IHgxICE9IHhFeHRlbnRbMV0pIHhFeHRlbnQgPSBbIHgwLCB4MSBdO1xuICAgICAgfVxuICAgICAgaWYgKHkpIHtcbiAgICAgICAgeTAgPSB6WzBdLCB5MSA9IHpbMV07XG4gICAgICAgIGlmICh4KSB5MCA9IHkwWzFdLCB5MSA9IHkxWzFdO1xuICAgICAgICB5RXh0ZW50RG9tYWluID0gWyB5MCwgeTEgXTtcbiAgICAgICAgaWYgKHkuaW52ZXJ0KSB5MCA9IHkoeTApLCB5MSA9IHkoeTEpO1xuICAgICAgICBpZiAoeTEgPCB5MCkgdCA9IHkwLCB5MCA9IHkxLCB5MSA9IHQ7XG4gICAgICAgIGlmICh5MCAhPSB5RXh0ZW50WzBdIHx8IHkxICE9IHlFeHRlbnRbMV0pIHlFeHRlbnQgPSBbIHkwLCB5MSBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghYnJ1c2guZW1wdHkoKSkge1xuICAgICAgICB4RXh0ZW50ID0gWyAwLCAwIF0sIHlFeHRlbnQgPSBbIDAsIDAgXTtcbiAgICAgICAgeEV4dGVudERvbWFpbiA9IHlFeHRlbnREb21haW4gPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH07XG4gICAgYnJ1c2guZW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXggJiYgeEV4dGVudFswXSA9PSB4RXh0ZW50WzFdIHx8ICEheSAmJiB5RXh0ZW50WzBdID09IHlFeHRlbnRbMV07XG4gICAgfTtcbiAgICByZXR1cm4gZDMucmViaW5kKGJydXNoLCBldmVudCwgXCJvblwiKTtcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaEN1cnNvciA9IHtcbiAgICBuOiBcIm5zLXJlc2l6ZVwiLFxuICAgIGU6IFwiZXctcmVzaXplXCIsXG4gICAgczogXCJucy1yZXNpemVcIixcbiAgICB3OiBcImV3LXJlc2l6ZVwiLFxuICAgIG53OiBcIm53c2UtcmVzaXplXCIsXG4gICAgbmU6IFwibmVzdy1yZXNpemVcIixcbiAgICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICAgIHN3OiBcIm5lc3ctcmVzaXplXCJcbiAgfTtcbiAgdmFyIGQzX3N2Z19icnVzaFJlc2l6ZXMgPSBbIFsgXCJuXCIsIFwiZVwiLCBcInNcIiwgXCJ3XCIsIFwibndcIiwgXCJuZVwiLCBcInNlXCIsIFwic3dcIiBdLCBbIFwiZVwiLCBcIndcIiBdLCBbIFwiblwiLCBcInNcIiBdLCBbXSBdO1xuICB2YXIgZDNfdGltZV9mb3JtYXQgPSBkM190aW1lLmZvcm1hdCA9IGQzX2xvY2FsZV9lblVTLnRpbWVGb3JtYXQ7XG4gIHZhciBkM190aW1lX2Zvcm1hdFV0YyA9IGQzX3RpbWVfZm9ybWF0LnV0YztcbiAgdmFyIGQzX3RpbWVfZm9ybWF0SXNvID0gZDNfdGltZV9mb3JtYXRVdGMoXCIlWS0lbS0lZFQlSDolTTolUy4lTFpcIik7XG4gIGQzX3RpbWVfZm9ybWF0LmlzbyA9IERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nICYmICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKSA/IGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlIDogZDNfdGltZV9mb3JtYXRJc287XG4gIGZ1bmN0aW9uIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xuICB9XG4gIGQzX3RpbWVfZm9ybWF0SXNvTmF0aXZlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShzdHJpbmcpO1xuICAgIHJldHVybiBpc05hTihkYXRlKSA/IG51bGwgOiBkYXRlO1xuICB9O1xuICBkM190aW1lX2Zvcm1hdElzb05hdGl2ZS50b1N0cmluZyA9IGQzX3RpbWVfZm9ybWF0SXNvLnRvU3RyaW5nO1xuICBkM190aW1lLnNlY29uZCA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyAxZTMpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMWUzKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldFNlY29uZHMoKTtcbiAgfSk7XG4gIGQzX3RpbWUuc2Vjb25kcyA9IGQzX3RpbWUuc2Vjb25kLnJhbmdlO1xuICBkM190aW1lLnNlY29uZHMudXRjID0gZDNfdGltZS5zZWNvbmQudXRjLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZSA9IGQzX3RpbWVfaW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBuZXcgZDNfZGF0ZShNYXRoLmZsb29yKGRhdGUgLyA2ZTQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogNmU0KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgfSk7XG4gIGQzX3RpbWUubWludXRlcyA9IGQzX3RpbWUubWludXRlLnJhbmdlO1xuICBkM190aW1lLm1pbnV0ZXMudXRjID0gZDNfdGltZS5taW51dGUudXRjLnJhbmdlO1xuICBkM190aW1lLmhvdXIgPSBkM190aW1lX2ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgdGltZXpvbmUgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MDtcbiAgICByZXR1cm4gbmV3IGQzX2RhdGUoKE1hdGguZmxvb3IoZGF0ZSAvIDM2ZTUgLSB0aW1lem9uZSkgKyB0aW1lem9uZSkgKiAzNmU1KTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgTWF0aC5mbG9vcihvZmZzZXQpICogMzZlNSk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xuICB9KTtcbiAgZDNfdGltZS5ob3VycyA9IGQzX3RpbWUuaG91ci5yYW5nZTtcbiAgZDNfdGltZS5ob3Vycy51dGMgPSBkM190aW1lLmhvdXIudXRjLnJhbmdlO1xuICBkM190aW1lLm1vbnRoID0gZDNfdGltZV9pbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZSA9IGQzX3RpbWUuZGF5KGRhdGUpO1xuICAgIGRhdGUuc2V0RGF0ZSgxKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgb2Zmc2V0KSB7XG4gICAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBvZmZzZXQpO1xuICB9LCBmdW5jdGlvbihkYXRlKSB7XG4gICAgcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcbiAgfSk7XG4gIGQzX3RpbWUubW9udGhzID0gZDNfdGltZS5tb250aC5yYW5nZTtcbiAgZDNfdGltZS5tb250aHMudXRjID0gZDNfdGltZS5tb250aC51dGMucmFuZ2U7XG4gIGZ1bmN0aW9uIGQzX3RpbWVfc2NhbGUobGluZWFyLCBtZXRob2RzLCBmb3JtYXQpIHtcbiAgICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgICByZXR1cm4gbGluZWFyKHgpO1xuICAgIH1cbiAgICBzY2FsZS5pbnZlcnQgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZURhdGUobGluZWFyLmludmVydCh4KSk7XG4gICAgfTtcbiAgICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbih4KSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsaW5lYXIuZG9tYWluKCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICAgIGxpbmVhci5kb21haW4oeCk7XG4gICAgICByZXR1cm4gc2NhbGU7XG4gICAgfTtcbiAgICBmdW5jdGlvbiB0aWNrTWV0aG9kKGV4dGVudCwgY291bnQpIHtcbiAgICAgIHZhciBzcGFuID0gZXh0ZW50WzFdIC0gZXh0ZW50WzBdLCB0YXJnZXQgPSBzcGFuIC8gY291bnQsIGkgPSBkMy5iaXNlY3QoZDNfdGltZV9zY2FsZVN0ZXBzLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuIGkgPT0gZDNfdGltZV9zY2FsZVN0ZXBzLmxlbmd0aCA/IFsgbWV0aG9kcy55ZWFyLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiBkIC8gMzE1MzZlNjtcbiAgICAgIH0pLCBjb3VudClbMl0gXSA6ICFpID8gWyBkM190aW1lX3NjYWxlTWlsbGlzZWNvbmRzLCBkM19zY2FsZV9saW5lYXJUaWNrUmFuZ2UoZXh0ZW50LCBjb3VudClbMl0gXSA6IG1ldGhvZHNbdGFyZ2V0IC8gZDNfdGltZV9zY2FsZVN0ZXBzW2kgLSAxXSA8IGQzX3RpbWVfc2NhbGVTdGVwc1tpXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgfVxuICAgIHNjYWxlLm5pY2UgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLCBleHRlbnQgPSBkM19zY2FsZUV4dGVudChkb21haW4pLCBtZXRob2QgPSBpbnRlcnZhbCA9PSBudWxsID8gdGlja01ldGhvZChleHRlbnQsIDEwKSA6IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiAmJiB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpO1xuICAgICAgaWYgKG1ldGhvZCkgaW50ZXJ2YWwgPSBtZXRob2RbMF0sIHNraXAgPSBtZXRob2RbMV07XG4gICAgICBmdW5jdGlvbiBza2lwcGVkKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkYXRlKSAmJiAhaW50ZXJ2YWwucmFuZ2UoZGF0ZSwgZDNfdGltZV9zY2FsZURhdGUoK2RhdGUgKyAxKSwgc2tpcCkubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYWxlLmRvbWFpbihkM19zY2FsZV9uaWNlKGRvbWFpbiwgc2tpcCA+IDEgPyB7XG4gICAgICAgIGZsb29yOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgd2hpbGUgKHNraXBwZWQoZGF0ZSA9IGludGVydmFsLmZsb29yKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKGRhdGUgLSAxKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2VpbDogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHdoaWxlIChza2lwcGVkKGRhdGUgPSBpbnRlcnZhbC5jZWlsKGRhdGUpKSkgZGF0ZSA9IGQzX3RpbWVfc2NhbGVEYXRlKCtkYXRlICsgMSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gOiBpbnRlcnZhbCkpO1xuICAgIH07XG4gICAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihpbnRlcnZhbCwgc2tpcCkge1xuICAgICAgdmFyIGV4dGVudCA9IGQzX3NjYWxlRXh0ZW50KHNjYWxlLmRvbWFpbigpKSwgbWV0aG9kID0gaW50ZXJ2YWwgPT0gbnVsbCA/IHRpY2tNZXRob2QoZXh0ZW50LCAxMCkgOiB0eXBlb2YgaW50ZXJ2YWwgPT09IFwibnVtYmVyXCIgPyB0aWNrTWV0aG9kKGV4dGVudCwgaW50ZXJ2YWwpIDogIWludGVydmFsLnJhbmdlICYmIFsge1xuICAgICAgICByYW5nZTogaW50ZXJ2YWxcbiAgICAgIH0sIHNraXAgXTtcbiAgICAgIGlmIChtZXRob2QpIGludGVydmFsID0gbWV0aG9kWzBdLCBza2lwID0gbWV0aG9kWzFdO1xuICAgICAgcmV0dXJuIGludGVydmFsLnJhbmdlKGV4dGVudFswXSwgZDNfdGltZV9zY2FsZURhdGUoK2V4dGVudFsxXSArIDEpLCBza2lwIDwgMSA/IDEgOiBza2lwKTtcbiAgICB9O1xuICAgIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfTtcbiAgICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZDNfdGltZV9zY2FsZShsaW5lYXIuY29weSgpLCBtZXRob2RzLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIGQzX3NjYWxlX2xpbmVhclJlYmluZChzY2FsZSwgbGluZWFyKTtcbiAgfVxuICBmdW5jdGlvbiBkM190aW1lX3NjYWxlRGF0ZSh0KSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHQpO1xuICB9XG4gIHZhciBkM190aW1lX3NjYWxlU3RlcHMgPSBbIDFlMywgNWUzLCAxNWUzLCAzZTQsIDZlNCwgM2U1LCA5ZTUsIDE4ZTUsIDM2ZTUsIDEwOGU1LCAyMTZlNSwgNDMyZTUsIDg2NGU1LCAxNzI4ZTUsIDYwNDhlNSwgMjU5MmU2LCA3Nzc2ZTYsIDMxNTM2ZTYgXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbE1ldGhvZHMgPSBbIFsgZDNfdGltZS5zZWNvbmQsIDEgXSwgWyBkM190aW1lLnNlY29uZCwgNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAxNSBdLCBbIGQzX3RpbWUuc2Vjb25kLCAzMCBdLCBbIGQzX3RpbWUubWludXRlLCAxIF0sIFsgZDNfdGltZS5taW51dGUsIDUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMTUgXSwgWyBkM190aW1lLm1pbnV0ZSwgMzAgXSwgWyBkM190aW1lLmhvdXIsIDEgXSwgWyBkM190aW1lLmhvdXIsIDMgXSwgWyBkM190aW1lLmhvdXIsIDYgXSwgWyBkM190aW1lLmhvdXIsIDEyIF0sIFsgZDNfdGltZS5kYXksIDEgXSwgWyBkM190aW1lLmRheSwgMiBdLCBbIGQzX3RpbWUud2VlaywgMSBdLCBbIGQzX3RpbWUubW9udGgsIDEgXSwgWyBkM190aW1lLm1vbnRoLCAzIF0sIFsgZDNfdGltZS55ZWFyLCAxIF0gXTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVMb2NhbEZvcm1hdCA9IGQzX3RpbWVfZm9ybWF0Lm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0U2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0SG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldERheSgpICYmIGQuZ2V0RGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXREYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldE1vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVNaWxsaXNlY29uZHMgPSB7XG4gICAgcmFuZ2U6IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgICByZXR1cm4gZDMucmFuZ2UoTWF0aC5jZWlsKHN0YXJ0IC8gc3RlcCkgKiBzdGVwLCArc3RvcCwgc3RlcCkubWFwKGQzX3RpbWVfc2NhbGVEYXRlKTtcbiAgICB9LFxuICAgIGZsb29yOiBkM19pZGVudGl0eSxcbiAgICBjZWlsOiBkM19pZGVudGl0eVxuICB9O1xuICBkM190aW1lX3NjYWxlTG9jYWxNZXRob2RzLnllYXIgPSBkM190aW1lLnllYXI7XG4gIGQzX3RpbWUuc2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZDNfdGltZV9zY2FsZShkMy5zY2FsZS5saW5lYXIoKSwgZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcywgZDNfdGltZV9zY2FsZUxvY2FsRm9ybWF0KTtcbiAgfTtcbiAgdmFyIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzID0gZDNfdGltZV9zY2FsZUxvY2FsTWV0aG9kcy5tYXAoZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBbIG1bMF0udXRjLCBtWzFdIF07XG4gIH0pO1xuICB2YXIgZDNfdGltZV9zY2FsZVV0Y0Zvcm1hdCA9IGQzX3RpbWVfZm9ybWF0VXRjLm11bHRpKFsgWyBcIi4lTFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIH0gXSwgWyBcIjolU1wiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDU2Vjb25kcygpO1xuICB9IF0sIFsgXCIlSTolTVwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDTWludXRlcygpO1xuICB9IF0sIFsgXCIlSSAlcFwiLCBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIGQuZ2V0VVRDSG91cnMoKTtcbiAgfSBdLCBbIFwiJWEgJWRcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ0RheSgpICYmIGQuZ2V0VVRDRGF0ZSgpICE9IDE7XG4gIH0gXSwgWyBcIiViICVkXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gZC5nZXRVVENEYXRlKCkgIT0gMTtcbiAgfSBdLCBbIFwiJUJcIiwgZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gIH0gXSwgWyBcIiVZXCIsIGQzX3RydWUgXSBdKTtcbiAgZDNfdGltZV9zY2FsZVV0Y01ldGhvZHMueWVhciA9IGQzX3RpbWUueWVhci51dGM7XG4gIGQzX3RpbWUuc2NhbGUudXRjID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGQzX3RpbWVfc2NhbGUoZDMuc2NhbGUubGluZWFyKCksIGQzX3RpbWVfc2NhbGVVdGNNZXRob2RzLCBkM190aW1lX3NjYWxlVXRjRm9ybWF0KTtcbiAgfTtcbiAgZDMudGV4dCA9IGQzX3hoclR5cGUoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfSk7XG4gIGQzLmpzb24gPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGQzX3hocih1cmwsIFwiYXBwbGljYXRpb24vanNvblwiLCBkM19qc29uLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2pzb24ocmVxdWVzdCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy5odG1sID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBkM194aHIodXJsLCBcInRleHQvaHRtbFwiLCBkM19odG1sLCBjYWxsYmFjayk7XG4gIH07XG4gIGZ1bmN0aW9uIGQzX2h0bWwocmVxdWVzdCkge1xuICAgIHZhciByYW5nZSA9IGQzX2RvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZShkM19kb2N1bWVudC5ib2R5KTtcbiAgICByZXR1cm4gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgfVxuICBkMy54bWwgPSBkM194aHJUeXBlKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVhNTDtcbiAgfSk7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkgdGhpcy5kMyA9IGQzLCBkZWZpbmUoZDMpOyBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGQzOyBlbHNlIHRoaXMuZDMgPSBkMztcbn0oKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9kMy9kMy5qc1xuLy8gbW9kdWxlIGlkID0gMTY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnQ29tcG9uZW50cy9zeW5hcHNlLXVpL3N5bmFwc2UtdWkuc2Nzcyc7XG5pbXBvcnQgKiBhcyBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuaW1wb3J0ICdmaXJlYmFzZS9hdXRoJztcblxuLy8gPC0tIHNpZ24gb3V0IG1vZHVsZVxudmFyIGF1dGggPSBmaXJlYmFzZS5hdXRoKCk7XG52YXIgc3luVUlMb2dvdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc3luLXVpLWxvZ291dCcpO1xuXG5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlZChmaXJlYmFzZVVzZXIgPT4ge1xuICAgIGlmIChmaXJlYmFzZVVzZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2xvZ2dlZC1pbicpO1xuXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24gPSAnLi9sb2dpbi5odG1sJztcbiAgICB9XG59KTtcblxuc3luVUlMb2dvdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICBhdXRoLnNpZ25PdXQoKTtcbn0pXG5cbi8vIC0tPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2NvbXBvbmVudHMvc3luYXBzZS11aS9zeW5hcHNlLXVpLmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3N5bmFwc2UtdWkvc3luYXBzZS11aS5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICdDb21wb25lbnRzL3N5bmFwc2Utc3luYy9zeW5hcHNlLXN5bmMuc2Nzcyc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvY29tcG9uZW50cy9zeW5hcHNlLXN5bmMvc3luYXBzZS1zeW5jLmpzIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL3N5bmFwc2Utc3luYy9zeW5hcHNlLXN5bmMuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=